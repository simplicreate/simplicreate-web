{"version":3,"file":"invert.cjs","names":["purry"],"sources":["../src/invert.ts"],"sourcesContent":["import type { Simplify } from \"type-fest\";\nimport { purry } from \"./purry\";\nimport type { ToString } from \"./internal/types/ToString\";\n\ntype Inverted<T extends object> = Simplify<{\n  -readonly [K in keyof T as K extends number | string\n    ? Required<T>[K] extends PropertyKey\n      ? Required<T>[K]\n      : never\n    : never]: ToString<K>;\n}>;\n\n/**\n * Returns an object whose keys and values are swapped. If the object contains duplicate values,\n * subsequent values will overwrite previous values.\n *\n * @param object - The object.\n * @signature\n *    invert(object)\n * @example\n *    invert({ a: \"d\", b: \"e\", c: \"f\" }) // => { d: \"a\", e: \"b\", f: \"c\" }\n * @dataFirst\n * @category Object\n */\nexport function invert<T extends object>(object: T): Inverted<T>;\n\n/**\n * Returns an object whose keys and values are swapped. If the object contains duplicate values,\n * subsequent values will overwrite previous values.\n *\n * @signature\n *    invert()(object)\n * @example\n *    pipe({ a: \"d\", b: \"e\", c: \"f\" }, invert()); // => { d: \"a\", e: \"b\", f: \"c\" }\n * @dataLast\n * @category Object\n */\nexport function invert<T extends object>(): (object: T) => Inverted<T>;\n\nexport function invert(...args: readonly unknown[]): unknown {\n  return purry(invertImplementation, args);\n}\n\nfunction invertImplementation(\n  data: Readonly<Record<PropertyKey, PropertyKey>>,\n): Record<PropertyKey, PropertyKey> {\n  const result: Record<PropertyKey, PropertyKey> = {};\n\n  for (const [key, value] of Object.entries(data)) {\n    result[value] = key;\n  }\n\n  return result;\n}\n"],"mappings":"kGAuCA,SAAgB,EAAO,GAAG,EAAmC,CAC3D,OAAOA,EAAAA,MAAM,EAAsB,EAAK,CAG1C,SAAS,EACP,EACkC,CAClC,IAAM,EAA2C,EAAE,CAEnD,IAAK,GAAM,CAAC,EAAK,KAAU,OAAO,QAAQ,EAAK,CAC7C,EAAO,GAAS,EAGlB,OAAO"}