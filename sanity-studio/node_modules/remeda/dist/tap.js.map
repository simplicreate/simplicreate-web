{"version":3,"file":"tap.js","names":[],"sources":["../src/tap.ts"],"sourcesContent":["import { purry } from \"./purry\";\n\n/**\n * Calls the given function with the given value, then returns the given value.\n * The return value of the provided function is ignored.\n *\n * This allows \"tapping into\" a function sequence in a pipe, to perform side\n * effects on intermediate results.\n *\n * @param value - The value to pass into the function.\n * @param fn - The function to call.\n * @signature\n *    tap(value, fn)\n * @example\n *    tap(\"foo\", console.log) // => \"foo\"\n * @dataFirst\n * @category Other\n */\nexport function tap<T>(value: T, fn: (value: T) => void): T;\n\n/**\n * Calls the given function with the given value, then returns the given value.\n * The return value of the provided function is ignored.\n *\n * This allows \"tapping into\" a function sequence in a pipe, to perform side\n * effects on intermediate results.\n *\n * @param fn - The function to call.\n * @signature\n *    tap(fn)(value)\n * @example\n *    pipe(\n *      [-5, -1, 2, 3],\n *      filter(n => n > 0),\n *      tap(console.log), // prints [2, 3]\n *      map(n => n * 2)\n *    ) // => [4, 6]\n * @dataLast\n * @category Other\n */\nexport function tap<\n  T,\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters -- TODO: This is solvable by inlining F and wrapping the T parameter with `NoInfer` (e.g. `(value: NoInfer<T>) => unknown`); to prevent typescript from inferring it as `unknown`. This is only available in TS 5.4, which is above what we currently support (5.1).\n  F extends (value: T) => unknown,\n>(fn: F): (value: T) => T;\n\nexport function tap(...args: readonly unknown[]): unknown {\n  return purry(tapImplementation, args);\n}\n\nfunction tapImplementation<T>(value: T, fn: (value: T) => void): T {\n  fn(value);\n  return value;\n}\n"],"mappings":"mCA8CA,SAAgB,EAAI,GAAG,EAAmC,CACxD,OAAO,EAAM,EAAmB,EAAK,CAGvC,SAAS,EAAqB,EAAU,EAA2B,CAEjE,OADA,EAAG,EAAM,CACF"}