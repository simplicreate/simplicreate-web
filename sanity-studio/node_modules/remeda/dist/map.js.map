{"version":3,"file":"map.js","names":[],"sources":["../src/map.ts"],"sourcesContent":["import type { IterableContainer } from \"./internal/types/IterableContainer\";\nimport type { LazyEvaluator } from \"./internal/types/LazyEvaluator\";\nimport type { Mapped } from \"./internal/types/Mapped\";\nimport { purry } from \"./purry\";\n\n/**\n * Creates a new array populated with the results of calling a provided function\n * on every element in the calling array. Equivalent to `Array.prototype.map`.\n *\n * @param data - The array to map.\n * @param callbackfn - A function to execute for each element in the array. Its\n * return value is added as a single element in the new array.\n * @returns A new array with each element being the result of the callback\n * function.\n * @signature\n *    map(data, callbackfn)\n * @example\n *    map([1, 2, 3], multiply(2)); // => [2, 4, 6]\n *    map([0, 0], add(1)); // => [1, 1]\n *    map([0, 0], (value, index) => value + index); // => [0, 1]\n * @dataFirst\n * @lazy\n * @category Array\n */\nexport function map<T extends IterableContainer, U>(\n  data: T,\n  callbackfn: (value: T[number], index: number, data: T) => U,\n): Mapped<T, U>;\n\n/**\n * Creates a new array populated with the results of calling a provided function\n * on every element in the calling array. Equivalent to `Array.prototype.map`.\n *\n * @param callbackfn - A function to execute for each element in the array. Its\n * return value is added as a single element in the new array.\n * @returns A new array with each element being the result of the callback\n * function.\n * @signature\n *    map(callbackfn)(data)\n * @example\n *    pipe([1, 2, 3], map(multiply(2))); // => [2, 4, 6]\n *    pipe([0, 0], map(add(1))); // => [1, 1]\n *    pipe([0, 0], map((value, index) => value + index)); // => [0, 1]\n * @dataLast\n * @lazy\n * @category Array\n */\nexport function map<T extends IterableContainer, U>(\n  callbackfn: (value: T[number], index: number, data: T) => U,\n): (data: T) => Mapped<T, U>;\n\nexport function map(...args: readonly unknown[]): unknown {\n  return purry(mapImplementation, args, lazyImplementation);\n}\n\nconst mapImplementation = <T, U>(\n  data: readonly T[],\n  callbackfn: (value: T, index: number, data: readonly T[]) => U,\n): U[] => data.map(callbackfn);\n\nconst lazyImplementation =\n  <T, U>(\n    callbackfn: (value: T, index: number, data: readonly T[]) => U,\n  ): LazyEvaluator<T, U> =>\n  (value, index, data) => ({\n    done: false,\n    hasNext: true,\n    next: callbackfn(value, index, data),\n  });\n"],"mappings":"mCAmDA,SAAgB,EAAI,GAAG,EAAmC,CACxD,OAAO,EAAM,EAAmB,EAAM,EAAmB,CAG3D,MAAM,GACJ,EACA,IACQ,EAAK,IAAI,EAAW,CAExB,EAEF,IAED,EAAO,EAAO,KAAU,CACvB,KAAM,GACN,QAAS,GACT,KAAM,EAAW,EAAO,EAAO,EAAK,CACrC"}