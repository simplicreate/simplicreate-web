{"version":3,"file":"nthBy.cjs","names":["purryOrderRulesWithArgument","quickSelect"],"sources":["../src/nthBy.ts"],"sourcesContent":["import {\n  purryOrderRulesWithArgument,\n  type OrderRule,\n} from \"./internal/purryOrderRules\";\nimport { quickSelect } from \"./internal/quickSelect\";\nimport type { CompareFunction } from \"./internal/types/CompareFunction\";\nimport type { IterableContainer } from \"./internal/types/IterableContainer\";\nimport type { NonEmptyArray } from \"./internal/types/NonEmptyArray\";\n\n/**\n * Retrieves the element that would be at the given index if the array were sorted according to specified rules. This function uses the *QuickSelect* algorithm running at an average complexity of *O(n)*. Semantically it is equivalent to `sortBy(data, ...rules).at(index)` which would run at *O(nlogn)*.\n *\n * See also `firstBy` which provides an even more efficient algorithm and a stricter return type, but only for `index === 0`. See `takeFirstBy` to get all the elements up to and including `index`.\n *\n * @param data - The input array.\n * @param index - The zero-based index for selecting the element in the sorted order. Negative indices count backwards from the end.\n * @param rules - A variadic array of order rules defining the sorting criteria. Each order rule is a projection function that extracts a comparable value from the data. Sorting is based on these extracted values using the native `<` and `>` operators. Earlier rules take precedence over later ones. Use the syntax `[projection, \"desc\"]` for descending order.\n * @returns The element at the specified index in the sorted order, or `undefined` if the index is out of bounds.\n * @signature\n *   nthBy(data, index, ...rules);\n * @example\n *   nthBy([2,1,4,5,3,], 2, identity()); // => 3\n * @dataFirst\n * @category Array\n */\nexport function nthBy<T extends IterableContainer>(\n  data: T,\n  index: number,\n  ...rules: Readonly<NonEmptyArray<OrderRule<T[number]>>>\n): T[number] | undefined;\n\n/**\n * Retrieves the element that would be at the given index if the array were sorted according to specified rules. This function uses the *QuickSelect* algorithm running at an average complexity of *O(n)*. Semantically it is equivalent to `sortBy(data, ...rules)[index]` which would run at *O(nlogn)*.\n *\n * See also `firstBy` which provides an even more efficient algorithm and a stricter return type, but only for `index === 0`. See `takeFirstBy` to get all the elements up to and including `index`.\n *\n * @param index - The zero-based index for selecting the element in the sorted order. Negative indices count backwards from the end.\n * @param rules - A variadic array of order rules defining the sorting criteria. Each order rule is a projection function that extracts a comparable value from the data. Sorting is based on these extracted values using the native `<` and `>` operators. Earlier rules take precedence over later ones. Use the syntax `[projection, \"desc\"]` for descending order.\n * @returns The element at the specified index in the sorted order, or `undefined` if the index is out of bounds.\n * @signature\n *   nthBy(index, ...rules)(data);\n * @example\n *   pipe([2,1,4,5,3,], nthBy(2, identity())); // => 3\n * @dataLast\n * @category Array\n */\nexport function nthBy<T extends IterableContainer>(\n  index: number,\n  ...rules: Readonly<NonEmptyArray<OrderRule<T[number]>>>\n): (data: T) => T[number] | undefined;\n\nexport function nthBy(...args: readonly unknown[]): unknown {\n  return purryOrderRulesWithArgument(nthByImplementation, args);\n}\n\nconst nthByImplementation = <T>(\n  data: readonly T[],\n  compareFn: CompareFunction<T>,\n  index: number,\n): T | undefined =>\n  quickSelect(\n    data,\n    // Allow negative indices gracefully\n    index >= 0 ? index : data.length + index,\n    compareFn,\n  );\n"],"mappings":"6JAmDA,SAAgB,EAAM,GAAG,EAAmC,CAC1D,OAAOA,EAAAA,EAA4B,EAAqB,EAAK,CAG/D,MAAM,GACJ,EACA,EACA,IAEAC,EAAAA,EACE,EAEA,GAAS,EAAI,EAAQ,EAAK,OAAS,EACnC,EACD"}