{"version":3,"file":"index.js","sources":["../src/input-rule.ts","../src/input-rule-match-location.ts","../src/plugin.input-rule.tsx","../src/text-transform-rule.ts"],"sourcesContent":["import type {BlockPath, PortableTextBlock} from '@portabletext/editor'\nimport type {\n  BehaviorActionSet,\n  BehaviorGuard,\n} from '@portabletext/editor/behaviors'\nimport type {InputRuleMatchLocation} from './input-rule-match-location'\n\n/**\n * Match found in the text after the insertion\n * @alpha\n */\nexport type InputRuleMatch = InputRuleMatchLocation & {\n  groupMatches: Array<InputRuleMatchLocation>\n}\n\n/**\n * @alpha\n */\nexport type InputRuleEvent = {\n  type: 'custom.input rule'\n  /**\n   * Matches found by the input rule\n   */\n  matches: Array<InputRuleMatch>\n  /**\n   * The text before the insertion\n   */\n  textBefore: string\n  /**\n   * The text is destined to be inserted\n   */\n  textInserted: string\n  /**\n   * The block where the insertion takes place\n   */\n  focusBlock: {\n    path: BlockPath\n    node: PortableTextBlock\n  }\n}\n\n/**\n * @alpha\n */\nexport type InputRuleGuard<TGuardResponse = true> = BehaviorGuard<\n  InputRuleEvent,\n  TGuardResponse\n>\n\n/**\n * @alpha\n */\nexport type InputRule<TGuardResponse = true> = {\n  on: RegExp\n  guard?: InputRuleGuard<TGuardResponse>\n  actions: Array<BehaviorActionSet<InputRuleEvent, TGuardResponse>>\n}\n\n/**\n * @alpha\n */\nexport function defineInputRule<TGuardResponse = true>(\n  config: InputRule<TGuardResponse>,\n): InputRule<TGuardResponse> {\n  return config\n}\n","import type {\n  BlockOffset,\n  BlockPath,\n  EditorSelection,\n  EditorSnapshot,\n} from '@portabletext/editor'\nimport {\n  getNextInlineObjects,\n  getPreviousInlineObjects,\n} from '@portabletext/editor/selectors'\nimport {blockOffsetToSpanSelectionPoint} from '@portabletext/editor/utils'\n\nexport type InputRuleMatchLocation = {\n  /**\n   * The matched text\n   */\n  text: string\n  /**\n   * Estimated selection of where in the original text the match is located.\n   * The selection is estimated since the match is found in the text after\n   * insertion.\n   */\n  selection: NonNullable<EditorSelection>\n  /**\n   * Block offsets of the match in the text after the insertion\n   */\n  targetOffsets: {\n    anchor: BlockOffset\n    focus: BlockOffset\n    backward: boolean\n  }\n}\n\nexport function getInputRuleMatchLocation({\n  match,\n  adjustIndexBy,\n  snapshot,\n  focusBlock,\n  originalTextBefore,\n}: {\n  match: [string, number, number]\n  adjustIndexBy: number\n  snapshot: EditorSnapshot\n  focusBlock: {\n    path: BlockPath\n  }\n  originalTextBefore: string\n}): InputRuleMatchLocation | undefined {\n  const [text, start, end] = match\n  const adjustedIndex = start + adjustIndexBy\n\n  const targetOffsets = {\n    anchor: {\n      path: focusBlock.path,\n      offset: adjustedIndex,\n    },\n    focus: {\n      path: focusBlock.path,\n      offset: adjustedIndex + end - start,\n    },\n    backward: false,\n  }\n  const normalizedOffsets = {\n    anchor: {\n      path: focusBlock.path,\n      offset: Math.min(targetOffsets.anchor.offset, originalTextBefore.length),\n    },\n    focus: {\n      path: focusBlock.path,\n      offset: Math.min(targetOffsets.focus.offset, originalTextBefore.length),\n    },\n    backward: false,\n  }\n\n  const anchorBackwards = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: normalizedOffsets.anchor,\n    direction: 'backward',\n  })\n  const focusForwards = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: normalizedOffsets.focus,\n    direction: 'forward',\n  })\n\n  if (!anchorBackwards || !focusForwards) {\n    return undefined\n  }\n\n  const selection = {\n    anchor: anchorBackwards,\n    focus: focusForwards,\n  }\n\n  const inlineObjectsAfterMatch = getNextInlineObjects({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: selection.anchor,\n        focus: selection.anchor,\n      },\n    },\n  })\n  const inlineObjectsBefore = getPreviousInlineObjects(snapshot)\n\n  if (\n    inlineObjectsAfterMatch.some((inlineObjectAfter) =>\n      inlineObjectsBefore.some(\n        (inlineObjectBefore) =>\n          inlineObjectAfter.node._key === inlineObjectBefore.node._key,\n      ),\n    )\n  ) {\n    return undefined\n  }\n\n  return {\n    text,\n    selection,\n    targetOffsets,\n  }\n}\n","import {\n  useEditor,\n  type BlockOffset,\n  type Editor,\n  type EditorSelection,\n} from '@portabletext/editor'\nimport {\n  defineBehavior,\n  effect,\n  forward,\n  raise,\n  type BehaviorAction,\n} from '@portabletext/editor/behaviors'\nimport {\n  getBlockOffsets,\n  getBlockTextBefore,\n  getFocusBlock,\n} from '@portabletext/editor/selectors'\nimport {\n  isEqualSelections,\n  isSelectionCollapsed,\n} from '@portabletext/editor/utils'\nimport {useActorRef} from '@xstate/react'\nimport {\n  fromCallback,\n  setup,\n  type AnyEventObject,\n  type CallbackLogicFunction,\n} from 'xstate'\nimport type {InputRule, InputRuleMatch} from './input-rule'\nimport {getInputRuleMatchLocation} from './input-rule-match-location'\n\n/**\n * @alpha\n */\nexport function defineInputRuleBehavior(config: {\n  rules: Array<InputRule<any>>\n  onApply?: ({\n    endOffsets,\n    endSelection,\n  }: {\n    endOffsets: {start: BlockOffset; end: BlockOffset} | undefined\n    endSelection: EditorSelection\n  }) => void\n}) {\n  return defineBehavior({\n    on: 'insert.text',\n    guard: ({snapshot, event, dom}) => {\n      if (\n        !snapshot.context.selection ||\n        !isSelectionCollapsed(snapshot.context.selection)\n      ) {\n        return false\n      }\n\n      const focusBlock = getFocusBlock(snapshot)\n\n      if (!focusBlock) {\n        return false\n      }\n\n      const originalTextBefore = getBlockTextBefore(snapshot)\n      let textBefore = originalTextBefore\n      const originalNewText = textBefore + event.text\n      let newText = originalNewText\n\n      const foundMatches: Array<InputRuleMatch['groupMatches'][number]> = []\n      const foundActions: Array<BehaviorAction> = []\n\n      for (const rule of config.rules) {\n        const matcher = new RegExp(rule.on.source, 'gd')\n\n        while (true) {\n          // Find matches in the text after the insertion\n          const ruleMatches = [...newText.matchAll(matcher)].flatMap(\n            (regExpMatch) => {\n              if (regExpMatch.indices === undefined) {\n                return []\n              }\n\n              const match = regExpMatch.indices.at(0)\n\n              if (!match) {\n                return []\n              }\n\n              const matchLocation = getInputRuleMatchLocation({\n                match: [regExpMatch.at(0) ?? '', ...match],\n                adjustIndexBy: originalNewText.length - newText.length,\n                snapshot,\n                focusBlock,\n                originalTextBefore,\n              })\n\n              if (!matchLocation) {\n                return []\n              }\n\n              const existsInTextBefore =\n                matchLocation.targetOffsets.focus.offset <=\n                originalTextBefore.length\n\n              // Ignore if this match occurs in the text before the insertion\n              if (existsInTextBefore) {\n                return []\n              }\n\n              const alreadyFound = foundMatches.some(\n                (foundMatch) =>\n                  foundMatch.targetOffsets.anchor.offset ===\n                  matchLocation.targetOffsets.anchor.offset,\n              )\n\n              // Ignore if this match has already been found\n              if (alreadyFound) {\n                return []\n              }\n\n              const groupMatches =\n                regExpMatch.indices.length > 1\n                  ? regExpMatch.indices\n                      .slice(1)\n                      .filter((indices) => indices !== undefined)\n                  : []\n\n              const ruleMatch = {\n                text: matchLocation.text,\n                selection: matchLocation.selection,\n                targetOffsets: matchLocation.targetOffsets,\n                groupMatches: groupMatches.flatMap((match, index) => {\n                  const text = regExpMatch.at(index + 1) ?? ''\n                  const groupMatchLocation = getInputRuleMatchLocation({\n                    match: [text, ...match],\n                    adjustIndexBy: originalNewText.length - newText.length,\n                    snapshot,\n                    focusBlock,\n                    originalTextBefore,\n                  })\n\n                  if (!groupMatchLocation) {\n                    return []\n                  }\n\n                  return groupMatchLocation\n                }),\n              }\n\n              return [ruleMatch]\n            },\n          )\n\n          if (ruleMatches.length > 0) {\n            const guardResult =\n              rule.guard?.({\n                snapshot,\n                event: {\n                  type: 'custom.input rule',\n                  matches: ruleMatches,\n                  focusBlock,\n                  textBefore: originalTextBefore,\n                  textInserted: event.text,\n                },\n                dom,\n              }) ?? true\n\n            if (!guardResult) {\n              break\n            }\n\n            const actionSets = rule.actions.map((action) =>\n              action(\n                {\n                  snapshot,\n                  event: {\n                    type: 'custom.input rule',\n                    matches: ruleMatches,\n                    focusBlock,\n                    textBefore: originalTextBefore,\n                    textInserted: event.text,\n                  },\n                  dom,\n                },\n                guardResult,\n              ),\n            )\n\n            for (const actionSet of actionSets) {\n              for (const action of actionSet) {\n                foundActions.push(action)\n              }\n            }\n\n            const matches = ruleMatches.flatMap((match) =>\n              match.groupMatches.length === 0 ? [match] : match.groupMatches,\n            )\n\n            for (const match of matches) {\n              // Remember each match and adjust `textBefore` and `newText` so\n              // no subsequent matches can overlap with this one\n              foundMatches.push(match)\n              textBefore = newText.slice(\n                0,\n                match.targetOffsets.focus.offset ?? 0,\n              )\n              newText = originalNewText.slice(\n                match.targetOffsets.focus.offset ?? 0,\n              )\n            }\n          } else {\n            // If no match was found, break out of the loop to try the next\n            // rule\n            break\n          }\n        }\n      }\n\n      if (foundActions.length === 0) {\n        return false\n      }\n\n      return {actions: foundActions}\n    },\n    actions: [\n      ({event}) => [forward(event)],\n      (_, {actions}) => actions,\n      ({snapshot}) => [\n        effect(() => {\n          const blockOffsets = getBlockOffsets(snapshot)\n\n          config.onApply?.({\n            endOffsets: blockOffsets,\n            endSelection: snapshot.context.selection,\n          })\n        }),\n      ],\n    ],\n  })\n}\n\ntype InputRulePluginProps = {\n  rules: Array<InputRule<any>>\n}\n\n/**\n * Turn an array of `InputRule`s into a Behavior that can be used to apply the\n * rules to the editor.\n *\n * The plugin handles undo/redo out of the box including smart undo with\n * Backspace.\n *\n * @example\n * ```tsx\n * <InputRulePlugin rules={smartQuotesRules} />\n * ```\n *\n * @alpha\n */\nexport function InputRulePlugin(props: InputRulePluginProps) {\n  const editor = useEditor()\n\n  useActorRef(inputRuleMachine, {\n    input: {editor, rules: props.rules},\n  })\n\n  return null\n}\n\ntype InputRuleMachineEvent =\n  | {\n      type: 'input rule raised'\n      endOffsets: {start: BlockOffset; end: BlockOffset} | undefined\n      endSelection: EditorSelection\n    }\n  | {type: 'history.undo raised'}\n  | {\n      type: 'selection changed'\n      blockOffsets: {start: BlockOffset; end: BlockOffset} | undefined\n      selection: EditorSelection\n    }\n\nconst inputRuleListenerCallback: CallbackLogicFunction<\n  AnyEventObject,\n  InputRuleMachineEvent,\n  {\n    editor: Editor\n    rules: Array<InputRule>\n  }\n> = ({input, sendBack}) => {\n  const unregister = input.editor.registerBehavior({\n    behavior: defineInputRuleBehavior({\n      rules: input.rules,\n      onApply: ({endOffsets, endSelection}) => {\n        sendBack({type: 'input rule raised', endOffsets, endSelection})\n      },\n    }),\n  })\n\n  return () => {\n    unregister()\n  }\n}\n\nconst deleteBackwardListenerCallback: CallbackLogicFunction<\n  AnyEventObject,\n  InputRuleMachineEvent,\n  {editor: Editor}\n> = ({input, sendBack}) => {\n  return input.editor.registerBehavior({\n    behavior: defineBehavior({\n      on: 'delete.backward',\n      actions: [\n        () => [\n          raise({type: 'history.undo'}),\n          effect(() => {\n            sendBack({type: 'history.undo raised'})\n          }),\n        ],\n      ],\n    }),\n  })\n}\n\nconst selectionListenerCallback: CallbackLogicFunction<\n  AnyEventObject,\n  InputRuleMachineEvent,\n  {editor: Editor}\n> = ({sendBack, input}) => {\n  // Listen for the emitted 'selection' event which fires after ANY cursor\n  // movement (typing, clicking, pasting, etc.) - not just explicit 'select'\n  // behavior events.\n  const subscription = input.editor.on('selection', (event) => {\n    const blockOffsets = getBlockOffsets({\n      ...input.editor.getSnapshot(),\n      context: {\n        ...input.editor.getSnapshot().context,\n        selection: event.selection,\n      },\n    })\n\n    sendBack({\n      type: 'selection changed',\n      blockOffsets,\n      selection: event.selection,\n    })\n  })\n\n  return () => subscription.unsubscribe()\n}\n\nconst inputRuleSetup = setup({\n  types: {\n    context: {} as {\n      editor: Editor\n      rules: Array<InputRule>\n      endOffsets: {start: BlockOffset; end: BlockOffset} | undefined\n      endSelection: EditorSelection\n    },\n    input: {} as {\n      editor: Editor\n      rules: Array<InputRule>\n    },\n    events: {} as InputRuleMachineEvent,\n  },\n  actors: {\n    'delete.backward listener': fromCallback(deleteBackwardListenerCallback),\n    'input rule listener': fromCallback(inputRuleListenerCallback),\n    'selection listener': fromCallback(selectionListenerCallback),\n  },\n  guards: {\n    'selection changed': ({context, event}) => {\n      if (event.type !== 'selection changed') {\n        return false\n      }\n\n      // When block offsets are available for both the end state and the\n      // current selection, compare them. Block offsets normalize away\n      // span-level differences (e.g. cursor at the same position but in a\n      // different span after normalization).\n      if (event.blockOffsets && context.endOffsets) {\n        const startChanged =\n          context.endOffsets.start.path[0]._key !==\n            event.blockOffsets.start.path[0]._key ||\n          context.endOffsets.start.offset !== event.blockOffsets.start.offset\n        const endChanged =\n          context.endOffsets.end.path[0]._key !==\n            event.blockOffsets.end.path[0]._key ||\n          context.endOffsets.end.offset !== event.blockOffsets.end.offset\n\n        return startChanged || endChanged\n      }\n\n      // Block offsets can't be computed when the cursor is on an inline\n      // object (e.g. after a stock ticker rule inserts one). Fall back to\n      // comparing the raw selections.\n      return !isEqualSelections(context.endSelection, event.selection)\n    },\n  },\n})\n\nconst assignEndState = inputRuleSetup.assign({\n  endOffsets: ({context, event}) =>\n    event.type === 'input rule raised' ? event.endOffsets : context.endOffsets,\n  endSelection: ({context, event}) =>\n    event.type === 'input rule raised'\n      ? event.endSelection\n      : context.endSelection,\n})\n\nconst inputRuleMachine = inputRuleSetup.createMachine({\n  id: 'input rule',\n  context: ({input}) => ({\n    editor: input.editor,\n    rules: input.rules,\n    endOffsets: undefined,\n    endSelection: null,\n  }),\n  initial: 'idle',\n  invoke: {\n    src: 'input rule listener',\n    input: ({context}) => ({\n      editor: context.editor,\n      rules: context.rules,\n    }),\n  },\n  on: {\n    'input rule raised': {\n      target: '.input rule applied',\n      actions: assignEndState,\n    },\n  },\n  states: {\n    'idle': {},\n    'input rule applied': {\n      invoke: [\n        {\n          src: 'delete.backward listener',\n          input: ({context}) => ({editor: context.editor}),\n        },\n        {\n          src: 'selection listener',\n          input: ({context}) => ({editor: context.editor}),\n        },\n      ],\n      on: {\n        'selection changed': {\n          target: 'idle',\n          guard: 'selection changed',\n        },\n        'history.undo raised': {\n          target: 'idle',\n        },\n      },\n    },\n  },\n})\n","import {raise, type BehaviorAction} from '@portabletext/editor/behaviors'\nimport {getMarkState} from '@portabletext/editor/selectors'\nimport type {InputRule, InputRuleGuard} from './input-rule'\nimport type {InputRuleMatchLocation} from './input-rule-match-location'\n\n/**\n * @alpha\n */\nexport type TextTransformRule<TGuardResponse = true> = {\n  on: RegExp\n  guard?: InputRuleGuard<TGuardResponse>\n  transform: (\n    {location}: {location: InputRuleMatchLocation},\n    guardResponse: TGuardResponse,\n  ) => string\n}\n\n/**\n * Define an `InputRule` specifically designed to transform matched text into\n * some other text.\n *\n * @example\n * ```tsx\n * const transformRule = defineTextTransformRule({\n *   on: /--/,\n *   transform: () => 'â€”',\n * })\n * ```\n *\n * @alpha\n */\nexport function defineTextTransformRule<TGuardResponse = true>(\n  config: TextTransformRule<TGuardResponse>,\n): InputRule<TGuardResponse> {\n  return {\n    on: config.on,\n    guard: config.guard ?? (() => true as TGuardResponse),\n    actions: [\n      ({snapshot, event}, guardResponse) => {\n        const locations = event.matches.flatMap((match) =>\n          match.groupMatches.length === 0 ? [match] : match.groupMatches,\n        )\n        const newText = event.textBefore + event.textInserted\n\n        let textLengthDelta = 0\n        const actions: Array<BehaviorAction> = []\n\n        for (const location of locations.reverse()) {\n          const text = config.transform({location}, guardResponse)\n\n          textLengthDelta =\n            textLengthDelta -\n            (text.length -\n              (location.targetOffsets.focus.offset -\n                location.targetOffsets.anchor.offset))\n\n          actions.push(raise({type: 'select', at: location.targetOffsets}))\n          actions.push(raise({type: 'delete', at: location.targetOffsets}))\n          actions.push(\n            raise({\n              type: 'insert.child',\n              child: {\n                _type: snapshot.context.schema.span.name,\n                text,\n                marks:\n                  getMarkState({\n                    ...snapshot,\n                    context: {\n                      ...snapshot.context,\n                      selection: {\n                        anchor: location.selection.anchor,\n                        focus: {\n                          path: location.selection.focus.path,\n                          offset: Math.min(\n                            location.selection.focus.offset,\n                            event.textBefore.length,\n                          ),\n                        },\n                      },\n                    },\n                  })?.marks ?? [],\n              },\n            }),\n          )\n        }\n\n        const endCaretPosition = {\n          path: event.focusBlock.path,\n          offset: newText.length - textLengthDelta,\n        }\n\n        return [\n          ...actions,\n          raise({\n            type: 'select',\n            at: {\n              anchor: endCaretPosition,\n              focus: endCaretPosition,\n            },\n          }),\n        ]\n      },\n    ],\n  }\n}\n"],"names":["defineInputRule","config","getInputRuleMatchLocation","match","adjustIndexBy","snapshot","focusBlock","originalTextBefore","text","start","end","adjustedIndex","targetOffsets","anchor","path","offset","focus","backward","normalizedOffsets","Math","min","length","anchorBackwards","blockOffsetToSpanSelectionPoint","context","blockOffset","direction","focusForwards","selection","inlineObjectsAfterMatch","getNextInlineObjects","inlineObjectsBefore","getPreviousInlineObjects","some","inlineObjectAfter","inlineObjectBefore","node","_key","defineInputRuleBehavior","defineBehavior","on","guard","event","dom","isSelectionCollapsed","getFocusBlock","getBlockTextBefore","textBefore","originalNewText","newText","foundMatches","foundActions","rule","rules","matcher","RegExp","source","ruleMatches","matchAll","flatMap","regExpMatch","indices","undefined","at","matchLocation","foundMatch","groupMatches","slice","filter","index","guardResult","type","matches","textInserted","actionSets","actions","map","action","actionSet","push","forward","_","effect","blockOffsets","getBlockOffsets","onApply","endOffsets","endSelection","InputRulePlugin","props","$","_c","editor","useEditor","t0","input","useActorRef","inputRuleMachine","inputRuleListenerCallback","sendBack","unregister","registerBehavior","behavior","deleteBackwardListenerCallback","raise","selectionListenerCallback","subscription","getSnapshot","unsubscribe","inputRuleSetup","setup","types","events","actors","fromCallback","guards","selection changed","startChanged","endChanged","isEqualSelections","assignEndState","assign","createMachine","id","initial","invoke","src","target","states","defineTextTransformRule","guardResponse","locations","textLengthDelta","location","reverse","transform","child","_type","schema","span","name","marks","getMarkState","endCaretPosition"],"mappings":"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"}