{"version":3,"file":"selector.is-selecting-entire-blocks.js","sources":["../../src/types/paths.ts","../../src/utils/util.is-selection-expanded.ts","../../src/selectors/selector.get-focus-block.ts","../../src/selectors/selector.get-focus-text-block.ts","../../src/selectors/selector.get-focus-child.ts","../../src/selectors/selector.get-focus-span.ts","../../src/selectors/selector.get-selection-end-block.ts","../../src/selectors/selector.get-selection-end-point.ts","../../src/selectors/selector.get-next-span.ts","../../src/selectors/selector.get-selection-start-block.ts","../../src/selectors/selector.get-selection-start-point.ts","../../src/selectors/selector.get-previous-span.ts","../../src/selectors/selector.get-selected-children.ts","../../src/selectors/selector.get-selected-spans.ts","../../src/selectors/selector.get-mark-state.ts","../../src/selectors/selector.get-selected-blocks.ts","../../src/selectors/selector.get-active-annotations.ts","../../src/selectors/selector.get-active-list-item.ts","../../src/selectors/selector.get-active-style.ts","../../src/selectors/selector.get-next-inline-object.ts","../../src/selectors/selector.get-previous-inline-object.ts","../../src/selectors/selector.get-selected-value.ts","../../src/selectors/selector.get-selection-text.ts","../../src/selectors/selector.is-selection-collapsed.ts","../../src/selectors/selector.is-selection-expanded.ts","../../src/selectors/selector.get-caret-word-selection.ts","../../src/selectors/selector.get-focus-block-object.ts","../../src/selectors/selector.get-focus-inline-object.ts","../../src/selectors/selector.get-focus-list-block.ts","../../src/selectors/selector.get-last-block.ts","../../src/selectors/selector.get-next-block.ts","../../src/selectors/selector.get-previous-block.ts","../../src/selectors/selector.get-selected-text-blocks.ts","../../src/selectors/selector.get-selection-end-child.ts","../../src/selectors/selector.get-selection-start-child.ts","../../src/selectors/selector.get-active-annotation-marks.ts","../../src/selectors/selector.is-active-annotation.ts","../../src/selectors/selector.get-active-decorators.ts","../../src/selectors/selector.is-active-decorator.ts","../../src/selectors/selector.is-active-list-item.ts","../../src/selectors/selector.is-active-style.ts","../../src/selectors/selector.is-at-the-end-of-block.ts","../../src/selectors/selector.is-at-the-start-of-block.ts","../../src/utils/util.compare-points.ts","../../src/selectors/selector.is-overlapping-selection.ts","../../src/selectors/selector.is-selecting-entire-blocks.ts"],"sourcesContent":["/**\n * A segment in a path that identifies an element by its `_key` property.\n * @public\n */\nexport interface KeyedSegment {\n  _key: string\n}\n\n/**\n * A tuple representing a range selection, e.g., `[0, 5]` or `['', 3]`.\n * @public\n */\nexport type IndexTuple = [number | '', number | '']\n\n/**\n * A single segment in a path. Can be:\n * - A string (property name)\n * - A number (array index)\n * - A KeyedSegment (object with `_key`)\n * - An IndexTuple (range selection)\n * @public\n */\nexport type PathSegment = string | number | KeyedSegment | IndexTuple\n\n/**\n * A path is an array of path segments that describes a location in a document.\n * @public\n */\nexport type Path = PathSegment[]\n\n/**\n * @public\n */\nexport type BlockPath = [{_key: string}]\n\n/**\n * @public\n */\nexport function isBlockPath(path: Path): path is BlockPath {\n  const firstSegment = path.at(0)\n\n  return (\n    path.length === 1 &&\n    firstSegment !== undefined &&\n    isRecord(firstSegment) &&\n    '_key' in firstSegment &&\n    typeof firstSegment._key === 'string'\n  )\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n\n/**\n * @public\n */\nexport type AnnotationPath = [{_key: string}, 'markDefs', {_key: string}]\n\n/**\n * @public\n */\nexport type ChildPath = [{_key: string}, 'children', {_key: string}]\n","import type {EditorSelection} from '../types/editor'\nimport {isSelectionCollapsed} from './util.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isSelectionExpanded(selection: EditorSelection) {\n  if (!selection) {\n    return false\n  }\n\n  return !isSelectionCollapsed(selection)\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport const getFocusBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const key = getBlockKeyFromSelectionPoint(snapshot.context.selection.focus)\n  const index = key ? snapshot.blockIndexMap.get(key) : undefined\n\n  const node =\n    index !== undefined ? snapshot.context.value.at(index) : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n","import {isTextBlock, type PortableTextTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getFocusTextBlock: EditorSelector<\n  {node: PortableTextTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot)\n\n  return focusBlock && isTextBlock(snapshot.context, focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n","import type {PortableTextObject, PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getChildKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\n\n/**\n * @public\n */\nexport const getFocusChild: EditorSelector<\n  | {\n      node: PortableTextObject | PortableTextSpan\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const focusBlock = getFocusTextBlock(snapshot)\n\n  if (!focusBlock) {\n    return undefined\n  }\n\n  const key = getChildKeyFromSelectionPoint(snapshot.context.selection.focus)\n\n  const node = key\n    ? focusBlock.node.children.find((span) => span._key === key)\n    : undefined\n\n  return node && key\n    ? {node, path: [...focusBlock.path, 'children', {_key: key}]}\n    : undefined\n}\n","import {isSpan, type PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getFocusChild} from './selector.get-focus-child'\n\n/**\n * @public\n */\nexport const getFocusSpan: EditorSelector<\n  {node: PortableTextSpan; path: ChildPath} | undefined\n> = (snapshot) => {\n  const focusChild = getFocusChild(snapshot)\n\n  return focusChild && isSpan(snapshot.context, focusChild.node)\n    ? {node: focusChild.node, path: focusChild.path}\n    : undefined\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getSelectionEndBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: BlockPath\n    }\n  | undefined\n> = (snapshot) => {\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n\n  if (!endPoint) {\n    return undefined\n  }\n\n  return getFocusBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: endPoint,\n        focus: endPoint,\n      },\n    },\n  })\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport const getSelectionEndPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  return snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n}\n","import {isSpan, isTextBlock, type PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {KeyedSegment} from '../types/paths'\nimport {getChildKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport {getSelectionEndBlock} from './selector.get-selection-end-block'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\n\n/**\n * @public\n */\nexport const getNextSpan: EditorSelector<\n  | {\n      node: PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const selectionEndBlock = getSelectionEndBlock(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n\n  if (!selectionEndBlock || !selectionEndPoint) {\n    return undefined\n  }\n\n  if (!isTextBlock(snapshot.context, selectionEndBlock.node)) {\n    return undefined\n  }\n\n  const selectionEndPointChildKey =\n    getChildKeyFromSelectionPoint(selectionEndPoint)\n\n  let endPointChildFound = false\n  let nextSpan:\n    | {\n        node: PortableTextSpan\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of selectionEndBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = true\n      continue\n    }\n\n    if (isSpan(snapshot.context, child) && endPointChildFound) {\n      nextSpan = {\n        node: child,\n        path: [...selectionEndBlock.path, 'children', {_key: child._key}],\n      }\n      break\n    }\n  }\n\n  return nextSpan\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getSelectionStartBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: BlockPath\n    }\n  | undefined\n> = (snapshot) => {\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n\n  if (!startPoint) {\n    return undefined\n  }\n\n  return getFocusBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: startPoint,\n        focus: startPoint,\n      },\n    },\n  })\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport const getSelectionStartPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  return snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n}\n","import {isSpan, isTextBlock, type PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {KeyedSegment} from '../types/paths'\nimport {getChildKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport {getSelectionStartBlock} from './selector.get-selection-start-block'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getPreviousSpan: EditorSelector<\n  | {\n      node: PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const selectionStartBlock = getSelectionStartBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n\n  if (!selectionStartBlock || !selectionStartPoint) {\n    return undefined\n  }\n\n  if (!isTextBlock(snapshot.context, selectionStartBlock.node)) {\n    return undefined\n  }\n\n  const selectionStartPointChildKey =\n    getChildKeyFromSelectionPoint(selectionStartPoint)\n\n  let previousSpan:\n    | {\n        node: PortableTextSpan\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of selectionStartBlock.node.children) {\n    if (child._key === selectionStartPointChildKey) {\n      break\n    }\n\n    if (isSpan(snapshot.context, child)) {\n      previousSpan = {\n        node: child,\n        path: [...selectionStartBlock.path, 'children', {_key: child._key}],\n      }\n    }\n  }\n\n  return previousSpan\n}\n","import {isSpan, isTextBlock} from '@portabletext/schema'\nimport type {PortableTextChild} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../utils/util.selection-point'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\ntype SelectedChild<TChild extends PortableTextChild = PortableTextChild> = {\n  node: TChild\n  path: ChildPath\n}\n\ntype GetSelectedChildrenOptions<\n  TChild extends PortableTextChild = PortableTextChild,\n> = {\n  filter?: (child: PortableTextChild) => child is TChild\n}\n\nexport function getSelectedChildren<\n  TChild extends PortableTextChild = PortableTextChild,\n>(\n  options?: GetSelectedChildrenOptions<TChild>,\n): EditorSelector<Array<SelectedChild<TChild>>> {\n  const filter = options?.filter\n\n  return (snapshot) => {\n    const startPoint = getSelectionStartPoint(snapshot)\n    const endPoint = getSelectionEndPoint(snapshot)\n\n    if (!startPoint || !endPoint) {\n      return []\n    }\n\n    const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n    const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n    const startChildKey = getChildKeyFromSelectionPoint(startPoint)\n    const endChildKey = getChildKeyFromSelectionPoint(endPoint)\n\n    if (!startBlockKey || !endBlockKey) {\n      return []\n    }\n\n    const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n    const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n    if (startBlockIndex === undefined || endBlockIndex === undefined) {\n      return []\n    }\n\n    const selectedChildren: Array<SelectedChild<TChild>> = []\n    const minBlockIndex = Math.min(startBlockIndex, endBlockIndex)\n    const maxBlockIndex = Math.max(startBlockIndex, endBlockIndex)\n    const blocks = snapshot.context.value.slice(\n      minBlockIndex,\n      maxBlockIndex + 1,\n    )\n\n    let startChildFound = false\n\n    for (const block of blocks) {\n      if (!isTextBlock(snapshot.context, block)) {\n        continue\n      }\n\n      const isStartBlock = block._key === startBlockKey\n      const isEndBlock = block._key === endBlockKey\n      const isMiddleBlock = !isStartBlock && !isEndBlock\n\n      for (const child of block.children) {\n        const isStartChild = child._key === startChildKey\n        const isEndChild = child._key === endChildKey\n\n        const addChild = () => {\n          if (!filter || filter(child)) {\n            selectedChildren.push({\n              node: child as TChild,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n        }\n\n        if (isMiddleBlock) {\n          addChild()\n          continue\n        }\n\n        if (isStartChild) {\n          startChildFound = true\n          if (isSpan(snapshot.context, child)) {\n            if (startPoint.offset < child.text.length) {\n              addChild()\n            }\n          } else {\n            addChild()\n          }\n\n          if (startChildKey === endChildKey) {\n            break\n          }\n          continue\n        }\n\n        if (isEndChild) {\n          if (isSpan(snapshot.context, child)) {\n            if (endPoint.offset > 0) {\n              addChild()\n            }\n          } else {\n            addChild()\n          }\n          break\n        }\n\n        if (startChildFound) {\n          addChild()\n        }\n      }\n\n      if (isStartBlock && startBlockKey === endBlockKey) {\n        break\n      }\n\n      if (isStartBlock) {\n        startChildFound = true\n      }\n    }\n\n    return selectedChildren\n  }\n}\n","import {isSpan, type PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getSelectedChildren} from './selector.get-selected-children'\n\n/**\n * @public\n */\nexport const getSelectedSpans: EditorSelector<\n  Array<{\n    node: PortableTextSpan\n    path: ChildPath\n  }>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  return getSelectedChildren({\n    filter: (child) => isSpan(snapshot.context, child),\n  })(snapshot)\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isBlockPath} from '../types/paths'\nimport {blockOffsetToSpanSelectionPoint} from '../utils/util.block-offset'\nimport {isSelectionExpanded} from '../utils/util.is-selection-expanded'\nimport {getFocusSpan} from './selector.get-focus-span'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getNextSpan} from './selector.get-next-span'\nimport {getPreviousSpan} from './selector.get-previous-span'\nimport {getSelectedSpans} from './selector.get-selected-spans'\n\n/**\n * @beta\n */\nexport type MarkState =\n  | {\n      state: 'unchanged'\n      marks: Array<string>\n    }\n  | {\n      state: 'changed'\n      marks: Array<string>\n      previousMarks: Array<string>\n    }\n\n/**\n * Given that text is inserted at the current position, what marks should\n * be applied?\n * @beta\n */\nexport const getMarkState: EditorSelector<MarkState | undefined> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  let selection = snapshot.context.selection\n  const focusTextBlock = getFocusTextBlock(snapshot)\n\n  if (!focusTextBlock) {\n    return undefined\n  }\n\n  if (isBlockPath(selection.anchor.path)) {\n    const spanSelectionPoint = blockOffsetToSpanSelectionPoint({\n      context: snapshot.context,\n      blockOffset: {\n        path: selection.anchor.path,\n        offset: selection.anchor.offset,\n      },\n      direction: selection.backward ? 'backward' : 'forward',\n    })\n\n    selection = spanSelectionPoint\n      ? {\n          ...selection,\n          anchor: spanSelectionPoint,\n        }\n      : selection\n  }\n\n  if (isBlockPath(selection.focus.path)) {\n    const spanSelectionPoint = blockOffsetToSpanSelectionPoint({\n      context: snapshot.context,\n      blockOffset: {\n        path: selection.focus.path,\n        offset: selection.focus.offset,\n      },\n      direction: selection.backward ? 'backward' : 'forward',\n    })\n\n    selection = spanSelectionPoint\n      ? {\n          ...selection,\n          focus: spanSelectionPoint,\n        }\n      : selection\n  }\n\n  const focusSpan = getFocusSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n\n  if (!focusSpan) {\n    return undefined\n  }\n\n  if (isSelectionExpanded(selection)) {\n    const selectedSpans = getSelectedSpans({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n\n    let index = 0\n    let marks: Array<string> = []\n\n    for (const span of selectedSpans) {\n      if (index === 0) {\n        marks = span.node.marks ?? []\n      } else {\n        if (span.node.marks?.length === 0) {\n          marks = []\n          continue\n        }\n\n        marks = marks.filter((mark) =>\n          (span.node.marks ?? []).some((spanMark) => spanMark === mark),\n        )\n      }\n\n      index++\n    }\n\n    return {\n      state: 'unchanged',\n      marks,\n    }\n  }\n\n  const decorators = snapshot.context.schema.decorators.map(\n    (decorator) => decorator.name,\n  )\n  const marks = focusSpan.node.marks ?? []\n  const marksWithoutAnnotations = marks.filter((mark) =>\n    decorators.includes(mark),\n  )\n\n  const spanHasAnnotations = marks.length > marksWithoutAnnotations.length\n\n  const spanIsEmpty = focusSpan.node.text.length === 0\n\n  const atTheBeginningOfSpan = snapshot.context.selection.anchor.offset === 0\n  const atTheEndOfSpan =\n    snapshot.context.selection.anchor.offset === focusSpan.node.text.length\n\n  const previousSpan = getPreviousSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n  const nextSpan = getNextSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n  const nextSpanAnnotations =\n    nextSpan?.node?.marks?.filter((mark) => !decorators.includes(mark)) ?? []\n  const spanAnnotations = marks.filter((mark) => !decorators.includes(mark))\n\n  const previousSpanHasAnnotations = previousSpan\n    ? previousSpan.node.marks?.some((mark) => !decorators.includes(mark))\n    : false\n  const previousSpanHasSameAnnotations = previousSpan\n    ? previousSpan.node.marks\n        ?.filter((mark) => !decorators.includes(mark))\n        .every((mark) => marks.includes(mark))\n    : false\n  const previousSpanHasSameAnnotation = previousSpan\n    ? previousSpan.node.marks?.some(\n        (mark) => !decorators.includes(mark) && marks.includes(mark),\n      )\n    : false\n\n  const previousSpanHasSameMarks = previousSpan\n    ? previousSpan.node.marks?.every((mark) => marks.includes(mark))\n    : false\n  const nextSpanSharesSomeAnnotations = spanAnnotations.some((mark) =>\n    nextSpanAnnotations?.includes(mark),\n  )\n\n  if (spanHasAnnotations && !spanIsEmpty) {\n    if (atTheBeginningOfSpan) {\n      if (previousSpanHasSameMarks) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: previousSpan?.node.marks ?? [],\n        }\n      } else if (previousSpanHasSameAnnotations) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: previousSpan?.node.marks ?? [],\n        }\n      } else if (previousSpanHasSameAnnotation) {\n        return {\n          state: 'unchanged',\n          marks: focusSpan.node.marks ?? [],\n        }\n      } else if (!previousSpan) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: [],\n        }\n      }\n    }\n\n    if (atTheEndOfSpan) {\n      if (!nextSpan) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: [],\n        }\n      }\n\n      if (nextSpanAnnotations.length > 0 && !nextSpanSharesSomeAnnotations) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: [],\n        }\n      }\n\n      if (\n        (nextSpanSharesSomeAnnotations &&\n          nextSpanAnnotations.length < spanAnnotations.length) ||\n        !nextSpanSharesSomeAnnotations\n      ) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: nextSpan?.node.marks ?? [],\n        }\n      }\n    }\n  }\n\n  if (atTheBeginningOfSpan && !spanIsEmpty && !!previousSpan) {\n    if (previousSpanHasAnnotations) {\n      return {\n        state: 'changed',\n        marks,\n        previousMarks: previousSpan?.node.marks ?? [],\n      }\n    } else {\n      return {\n        state: 'changed',\n        previousMarks: marks,\n        marks: (previousSpan?.node.marks ?? []).filter((mark) =>\n          decorators.includes(mark),\n        ),\n      }\n    }\n  }\n\n  return {\n    state: 'unchanged',\n    marks,\n  }\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport const getSelectedBlocks: EditorSelector<\n  Array<{node: PortableTextBlock; path: BlockPath}>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks: Array<{node: PortableTextBlock; path: BlockPath}> = []\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n  const startKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (!startKey || !endKey) {\n    return selectedBlocks\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return selectedBlocks\n  }\n\n  const slicedValue = snapshot.context.value.slice(\n    startBlockIndex,\n    endBlockIndex + 1,\n  )\n\n  for (const block of slicedValue) {\n    if (block._key === startKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n\n      if (startKey === endKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n      break\n    }\n\n    if (selectedBlocks.length > 0) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n    }\n  }\n\n  return selectedBlocks\n}\n","import {isTextBlock, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getMarkState} from './selector.get-mark-state'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\n\n/**\n * @public\n */\nexport const getActiveAnnotations: EditorSelector<Array<PortableTextObject>> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot)\n  const markState = getMarkState(snapshot)\n\n  const activeAnnotations = (markState?.marks ?? []).filter(\n    (mark) =>\n      !snapshot.context.schema.decorators\n        .map((decorator) => decorator.name)\n        .includes(mark),\n  )\n\n  const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n    isTextBlock(snapshot.context, block.node)\n      ? (block.node.markDefs ?? [])\n      : [],\n  )\n\n  return selectionMarkDefs.filter((markDef) =>\n    activeAnnotations.includes(markDef._key),\n  )\n}\n","import {isTextBlock, type PortableTextListBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\n\n/**\n * @public\n */\nexport const getActiveListItem: EditorSelector<\n  PortableTextListBlock['listItem'] | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter((block) =>\n    isTextBlock(snapshot.context, block),\n  )\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstListItem = firstTextBlock.listItem\n\n  if (!firstListItem) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.listItem === firstListItem)) {\n    return firstListItem\n  }\n\n  return undefined\n}\n","import {isTextBlock, type PortableTextTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\n\n/**\n * @public\n */\nexport const getActiveStyle: EditorSelector<PortableTextTextBlock['style']> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter((block) =>\n    isTextBlock(snapshot.context, block),\n  )\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstStyle = firstTextBlock.style\n\n  if (!firstStyle) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.style === firstStyle)) {\n    return firstStyle\n  }\n\n  return undefined\n}\n","import {isSpan, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\n\n/**\n * @public\n */\nexport const getNextInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n  const selectionEndPointChildKey =\n    selectionEndPoint && isKeyedSegment(selectionEndPoint.path[2])\n      ? selectionEndPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionEndPointChildKey) {\n    return undefined\n  }\n\n  let endPointChildFound = false\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: ChildPath\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = true\n      continue\n    }\n\n    if (!isSpan(snapshot.context, child) && endPointChildFound) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n      break\n    }\n  }\n\n  return inlineObject\n}\n","import {isSpan, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getPreviousInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionStartPointChildKey =\n    selectionStartPoint && isKeyedSegment(selectionStartPoint.path[2])\n      ? selectionStartPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionStartPointChildKey) {\n    return undefined\n  }\n\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: ChildPath\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionStartPointChildKey) {\n      break\n    }\n\n    if (!isSpan(snapshot.context, child)) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n    }\n  }\n\n  return inlineObject\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport {sliceBlocks} from '../utils/util.slice-blocks'\n\n/**\n * @public\n */\nexport const getSelectedValue: EditorSelector<Array<PortableTextBlock>> = (\n  snapshot,\n) => {\n  const selection = snapshot.context.selection\n\n  if (!selection) {\n    return []\n  }\n\n  const startPoint = getSelectionStartPoint(selection)\n  const endPoint = getSelectionEndPoint(selection)\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return []\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return []\n  }\n\n  const startBlock = snapshot.context.value.at(startBlockIndex)\n  const slicedStartBlock = startBlock\n    ? sliceBlocks({\n        context: snapshot.context,\n        blocks: [startBlock],\n      }).at(0)\n    : undefined\n\n  if (startBlockIndex === endBlockIndex) {\n    return slicedStartBlock ? [slicedStartBlock] : []\n  }\n\n  const endBlock = snapshot.context.value.at(endBlockIndex)\n  const slicedEndBlock = endBlock\n    ? sliceBlocks({\n        context: snapshot.context,\n        blocks: [endBlock],\n      }).at(0)\n    : undefined\n\n  const middleBlocks = snapshot.context.value.slice(\n    startBlockIndex + 1,\n    endBlockIndex,\n  )\n\n  return [\n    ...(slicedStartBlock ? [slicedStartBlock] : []),\n    ...middleBlocks,\n    ...(slicedEndBlock ? [slicedEndBlock] : []),\n  ]\n}\n","import {isSpan, isTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedValue} from './selector.get-selected-value'\n\n/**\n * @public\n */\nexport const getSelectionText: EditorSelector<string> = (snapshot) => {\n  const selectedValue = getSelectedValue(snapshot)\n\n  return selectedValue.reduce((text, block) => {\n    if (!isTextBlock(snapshot.context, block)) {\n      return text\n    }\n\n    return (\n      text +\n      block.children.reduce((text, child) => {\n        if (isSpan(snapshot.context, child)) {\n          return text + child.text\n        }\n\n        return text\n      }, '')\n    )\n  }, '')\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isEqualPaths} from '../utils/util.is-equal-paths'\n\n/**\n * @public\n */\nexport const isSelectionCollapsed: EditorSelector<boolean> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return false\n  }\n\n  return (\n    isEqualPaths(\n      snapshot.context.selection.anchor.path,\n      snapshot.context.selection.focus.path,\n    ) &&\n    snapshot.context.selection.anchor.offset ===\n      snapshot.context.selection.focus.offset\n  )\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport const isSelectionExpanded: EditorSelector<boolean> = (snapshot) => {\n  return snapshot.context.selection !== null && !isSelectionCollapsed(snapshot)\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelection} from '../types/editor'\nimport {\n  blockOffsetToSpanSelectionPoint,\n  spanSelectionPointToBlockOffset,\n} from '../utils/util.block-offset'\nimport {getBlockEndPoint} from '../utils/util.get-block-end-point'\nimport {getBlockStartPoint} from '../utils/util.get-block-start-point'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getNextInlineObject} from './selector.get-next-inline-object'\nimport {getPreviousInlineObject} from './selector.get-previous-inline-object'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {getSelectionText} from './selector.get-selection-text'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\n\n/**\n * @public\n * Returns the selection of the of the word the caret is placed in.\n * Note: Only returns a word selection if the current selection is collapsed\n */\nexport const getCaretWordSelection: EditorSelector<EditorSelection> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return null\n  }\n\n  if (!isSelectionCollapsed(snapshot)) {\n    return null\n  }\n\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionStartOffset = selectionStartPoint\n    ? spanSelectionPointToBlockOffset({\n        context: snapshot.context,\n        selectionPoint: selectionStartPoint,\n      })\n    : undefined\n\n  if (!focusTextBlock || !selectionStartPoint || !selectionStartOffset) {\n    return null\n  }\n\n  const previousInlineObject = getPreviousInlineObject(snapshot)\n  const blockStartPoint = getBlockStartPoint({\n    context: snapshot.context,\n    block: focusTextBlock,\n  })\n  const textBefore = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: previousInlineObject\n          ? {path: previousInlineObject.path, offset: 0}\n          : blockStartPoint,\n        focus: selectionStartPoint,\n      },\n    },\n  })\n  const textDirectlyBefore = textBefore.split(/\\s+/).at(-1)\n\n  const nextInlineObject = getNextInlineObject(snapshot)\n  const blockEndPoint = getBlockEndPoint({\n    context: snapshot.context,\n    block: focusTextBlock,\n  })\n  const textAfter = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: selectionStartPoint,\n        focus: nextInlineObject\n          ? {path: nextInlineObject.path, offset: 0}\n          : blockEndPoint,\n      },\n    },\n  })\n  const textDirectlyAfter = textAfter.split(/\\s+/).at(0)\n\n  if (\n    (textDirectlyBefore === undefined || textDirectlyBefore === '') &&\n    (textDirectlyAfter === undefined || textDirectlyAfter === '')\n  ) {\n    return null\n  }\n\n  const caretWordStartOffset: BlockOffset = textDirectlyBefore\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset - textDirectlyBefore.length,\n      }\n    : selectionStartOffset\n  const caretWordEndOffset: BlockOffset = textDirectlyAfter\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset + textDirectlyAfter.length,\n      }\n    : selectionStartOffset\n\n  const caretWordStartSelectionPoint = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: caretWordStartOffset,\n    direction: 'backward',\n  })\n  const caretWordEndSelectionPoint = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: caretWordEndOffset,\n    direction: 'forward',\n  })\n\n  if (!caretWordStartSelectionPoint || !caretWordEndSelectionPoint) {\n    return null\n  }\n\n  const caretWordSelection = {\n    anchor: caretWordStartSelectionPoint,\n    focus: caretWordEndSelectionPoint,\n  }\n\n  return isSelectionExpanded({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: caretWordSelection,\n    },\n  })\n    ? caretWordSelection\n    : null\n}\n","import {isTextBlock, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getFocusBlockObject: EditorSelector<\n  {node: PortableTextObject; path: BlockPath} | undefined\n> = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot)\n\n  return focusBlock && !isTextBlock(snapshot.context, focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n","import {isSpan, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getFocusChild} from './selector.get-focus-child'\n\n/**\n * @public\n */\nexport const getFocusInlineObject: EditorSelector<\n  {node: PortableTextObject; path: ChildPath} | undefined\n> = (snapshot) => {\n  const focusChild = getFocusChild(snapshot)\n\n  return focusChild && !isSpan(snapshot.context, focusChild.node)\n    ? {node: focusChild.node, path: focusChild.path}\n    : undefined\n}\n","import type {PortableTextListBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {isListBlock} from '../utils/parse-blocks'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\n\n/**\n * @public\n */\nexport const getFocusListBlock: EditorSelector<\n  {node: PortableTextListBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n\n  return focusTextBlock && isListBlock(snapshot.context, focusTextBlock.node)\n    ? {node: focusTextBlock.node, path: focusTextBlock.path}\n    : undefined\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\n\n/**\n * @public\n */\nexport const getLastBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const node = snapshot.context.value[snapshot.context.value.length - 1]\n    ? snapshot.context.value[snapshot.context.value.length - 1]\n    : undefined\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndBlock} from './selector.get-selection-end-block'\n\n/**\n * @public\n */\nexport const getNextBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const selectionEndBlock = getSelectionEndBlock(snapshot)\n\n  if (!selectionEndBlock) {\n    return undefined\n  }\n\n  const index = snapshot.blockIndexMap.get(selectionEndBlock.node._key)\n\n  if (index === undefined || index === snapshot.context.value.length - 1) {\n    return undefined\n  }\n\n  const nextBlock = snapshot.context.value.at(index + 1)\n\n  return nextBlock\n    ? {node: nextBlock, path: [{_key: nextBlock._key}]}\n    : undefined\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionStartBlock} from './selector.get-selection-start-block'\n\n/**\n * @public\n */\nexport const getPreviousBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const selectionStartBlock = getSelectionStartBlock(snapshot)\n\n  if (!selectionStartBlock) {\n    return undefined\n  }\n\n  const index = snapshot.blockIndexMap.get(selectionStartBlock.node._key)\n\n  if (index === undefined || index === 0) {\n    return undefined\n  }\n\n  const previousBlock = snapshot.context.value.at(index - 1)\n\n  return previousBlock\n    ? {node: previousBlock, path: [{_key: previousBlock._key}]}\n    : undefined\n}\n","import {isTextBlock, type PortableTextTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport const getSelectedTextBlocks: EditorSelector<\n  Array<{node: PortableTextTextBlock; path: BlockPath}>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedTextBlocks: Array<{\n    node: PortableTextTextBlock\n    path: BlockPath\n  }> = []\n\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return selectedTextBlocks\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return selectedTextBlocks\n  }\n\n  const slicedValue = snapshot.context.value.slice(\n    startBlockIndex,\n    endBlockIndex + 1,\n  )\n\n  for (const block of slicedValue) {\n    if (block._key === startBlockKey) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endBlockKey) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n\n      break\n    }\n\n    if (selectedTextBlocks.length > 0) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n    }\n  }\n\n  return selectedTextBlocks\n}\n","import type {PortableTextObject, PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getFocusChild} from './selector.get-focus-child'\n\n/**\n * @public\n */\nexport const getSelectionEndChild: EditorSelector<\n  | {\n      node: PortableTextSpan | PortableTextObject\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n\n  if (!endPoint) {\n    return undefined\n  }\n\n  return getFocusChild({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: endPoint,\n        focus: endPoint,\n      },\n    },\n  })\n}\n","import type {PortableTextObject, PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getFocusChild} from './selector.get-focus-child'\n\n/**\n * @public\n */\nexport const getSelectionStartChild: EditorSelector<\n  | {\n      node: PortableTextSpan | PortableTextObject\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n\n  if (!startPoint) {\n    return undefined\n  }\n\n  return getFocusChild({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: startPoint,\n        focus: startPoint,\n      },\n    },\n  })\n}\n","import type {EditorSnapshot} from '../editor/editor-snapshot'\nimport {getMarkState} from './selector.get-mark-state'\n\nexport function getActiveAnnotationsMarks(snapshot: EditorSnapshot) {\n  const schema = snapshot.context.schema\n  const markState = getMarkState(snapshot)\n\n  return (markState?.marks ?? []).filter(\n    (mark) =>\n      !schema.decorators.map((decorator) => decorator.name).includes(mark),\n  )\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveAnnotationsMarks} from './selector.get-active-annotation-marks'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\nimport {getSelectedValue} from './selector.get-selected-value'\n\n/**\n * Check whether an annotation is active in the given `snapshot`.\n *\n * @public\n */\nexport function isActiveAnnotation(\n  annotation: string,\n  options?: {\n    /**\n     * Choose whether the annotation has to take up the entire selection in the\n     * `snapshot` or if the annotation can be partially selected.\n     *\n     * Defaults to 'full'\n     */\n    mode?: 'partial' | 'full'\n  },\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    const mode = options?.mode ?? 'full'\n\n    if (mode === 'partial') {\n      const selectedValue = getSelectedValue(snapshot)\n\n      const selectionMarkDefs = selectedValue.flatMap((block) =>\n        isTextBlock(snapshot.context, block) ? (block.markDefs ?? []) : [],\n      )\n\n      return selectionMarkDefs.some((markDef) => markDef._type === annotation)\n    }\n\n    const selectedBlocks = getSelectedBlocks(snapshot)\n    const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n      isTextBlock(snapshot.context, block.node)\n        ? (block.node.markDefs ?? [])\n        : [],\n    )\n    const activeAnnotations = getActiveAnnotationsMarks(snapshot)\n    const activeMarkDefs = selectionMarkDefs.filter(\n      (markDef) =>\n        markDef._type === annotation &&\n        activeAnnotations.includes(markDef._key),\n    )\n\n    return activeMarkDefs.length > 0\n  }\n}\n","import type {EditorSnapshot} from '../editor/editor-snapshot'\nimport {getMarkState} from './selector.get-mark-state'\n\nexport function getActiveDecorators(snapshot: EditorSnapshot) {\n  const schema = snapshot.context.schema\n  const decoratorState = snapshot.decoratorState\n  const markState = getMarkState(snapshot)\n  const decorators = schema.decorators.map((decorator) => decorator.name)\n\n  const markStateDecorators = (markState?.marks ?? []).filter((mark) =>\n    decorators.includes(mark),\n  )\n\n  let activeDecorators: Array<string> = markStateDecorators\n\n  for (const decorator in decoratorState) {\n    if (decoratorState[decorator] === false) {\n      activeDecorators = activeDecorators.filter(\n        (activeDecorator) => activeDecorator !== decorator,\n      )\n    } else if (decoratorState[decorator] === true) {\n      if (!activeDecorators.includes(decorator)) {\n        activeDecorators.push(decorator)\n      }\n    }\n  }\n\n  return activeDecorators\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveDecorators} from './selector.get-active-decorators'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\n\n/**\n * @public\n */\nexport function isActiveDecorator(decorator: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (isSelectionExpanded(snapshot)) {\n      const selectedSpans = getSelectedSpans(snapshot)\n\n      return (\n        selectedSpans.length > 0 &&\n        selectedSpans.every((span) => span.node.marks?.includes(decorator))\n      )\n    }\n\n    const activeDecorators = getActiveDecorators(snapshot)\n\n    return activeDecorators.includes(decorator)\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveListItem} from './selector.get-active-list-item'\n\n/**\n * @public\n */\nexport function isActiveListItem(listItem: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeListItem = getActiveListItem(snapshot)\n\n    return activeListItem === listItem\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveStyle} from './selector.get-active-style'\n\n/**\n * @public\n */\nexport function isActiveStyle(style: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeStyle = getActiveStyle(snapshot)\n\n    return activeStyle === style\n  }\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getBlockEndPoint} from '../utils/util.get-block-end-point'\nimport {isEqualSelectionPoints} from '../utils/util.is-equal-selection-points'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheEndOfBlock(block: {\n  node: PortableTextBlock\n  path: BlockPath\n}): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot)) {\n      return false\n    }\n\n    const blockEndPoint = getBlockEndPoint({\n      context: snapshot.context,\n      block,\n    })\n\n    return isEqualSelectionPoints(\n      snapshot.context.selection.focus,\n      blockEndPoint,\n    )\n  }\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getBlockStartPoint} from '../utils/util.get-block-start-point'\nimport {isEqualSelectionPoints} from '../utils/util.is-equal-selection-points'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheStartOfBlock(block: {\n  node: PortableTextBlock\n  path: BlockPath\n}): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot)) {\n      return false\n    }\n\n    const blockStartPoint = getBlockStartPoint({\n      context: snapshot.context,\n      block,\n    })\n\n    return isEqualSelectionPoints(\n      snapshot.context.selection.focus,\n      blockStartPoint,\n    )\n  }\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {EditorSnapshot} from '../editor/editor-snapshot'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from './util.selection-point'\n\n/**\n * Returns:\n *\n * - `-1` if `pointA` is before `pointB`\n * - `0` if `pointA` and `pointB` are equal\n * - `1` if `pointA` is after `pointB`.\n */\nexport function comparePoints(\n  snapshot: EditorSnapshot,\n  pointA: EditorSelectionPoint,\n  pointB: EditorSelectionPoint,\n): -1 | 0 | 1 {\n  const blockKeyA = getBlockKeyFromSelectionPoint(pointA)\n  const blockKeyB = getBlockKeyFromSelectionPoint(pointB)\n\n  if (!blockKeyA) {\n    throw new Error(`Cannot compare points: no block key found for ${pointA}`)\n  }\n\n  if (!blockKeyB) {\n    throw new Error(`Cannot compare points: no block key found for ${pointB}`)\n  }\n\n  const blockIndexA = snapshot.blockIndexMap.get(blockKeyA)\n  const blockIndexB = snapshot.blockIndexMap.get(blockKeyB)\n\n  if (blockIndexA === undefined) {\n    throw new Error(`Cannot compare points: block \"${blockKeyA}\" not found`)\n  }\n\n  if (blockIndexB === undefined) {\n    throw new Error(`Cannot compare points: block \"${blockKeyB}\" not found`)\n  }\n\n  if (blockIndexA < blockIndexB) {\n    return -1\n  }\n\n  if (blockIndexA > blockIndexB) {\n    return 1\n  }\n\n  // Same block - need to compare at child level\n  const block = snapshot.context.value.at(blockIndexA)\n\n  if (!block || !isTextBlock(snapshot.context, block)) {\n    // Block objects - same block means equal position\n    return 0\n  }\n\n  const childKeyA = getChildKeyFromSelectionPoint(pointA)\n  const childKeyB = getChildKeyFromSelectionPoint(pointB)\n\n  if (!childKeyA) {\n    throw new Error(`Cannot compare points: no child key found for ${pointA}`)\n  }\n\n  if (!childKeyB) {\n    throw new Error(`Cannot compare points: no child key found for ${pointB}`)\n  }\n\n  // Find child indices\n  let childIndexA: number | undefined\n  let childIndexB: number | undefined\n\n  for (let i = 0; i < block.children.length; i++) {\n    const child = block.children.at(i)\n\n    if (!child) {\n      continue\n    }\n\n    if (child._key === childKeyA && child._key === childKeyB) {\n      // Same child - compare offsets directly\n      if (pointA.offset < pointB.offset) {\n        return -1\n      }\n\n      if (pointA.offset > pointB.offset) {\n        return 1\n      }\n\n      return 0\n    }\n\n    if (child._key === childKeyA) {\n      childIndexA = i\n    }\n\n    if (child._key === childKeyB) {\n      childIndexB = i\n    }\n\n    if (childIndexA !== undefined && childIndexB !== undefined) {\n      break\n    }\n  }\n\n  if (childIndexA === undefined) {\n    throw new Error(`Cannot compare points: child \"${childKeyA}\" not found`)\n  }\n\n  if (childIndexB === undefined) {\n    throw new Error(`Cannot compare points: child \"${childKeyB}\" not found`)\n  }\n\n  if (childIndexA < childIndexB) {\n    return -1\n  }\n\n  if (childIndexA > childIndexB) {\n    return 1\n  }\n\n  // Same child index but different keys (shouldn't happen)\n  return 0\n}\n","import type {EditorSelection, EditorSelectionPoint} from '../types/editor'\nimport {\n  getSelectionEndPoint,\n  getSelectionStartPoint,\n  isEqualSelectionPoints,\n} from '../utils'\nimport {comparePoints} from '../utils/util.compare-points'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport type {EditorSelector} from './../editor/editor-selector'\nimport type {EditorSnapshot} from './../editor/editor-snapshot'\n\n/**\n * @public\n */\nexport function isOverlappingSelection(\n  selection: EditorSelection,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    const editorSelection = snapshot.context.selection\n\n    if (!selection || !editorSelection) {\n      return false\n    }\n\n    const selectionStart = getSelectionStartPoint(selection)\n    const selectionEnd = getSelectionEndPoint(selection)\n    const editorSelectionStart = getSelectionStartPoint(editorSelection)\n    const editorSelectionEnd = getSelectionEndPoint(editorSelection)\n\n    const selectionStartBlockKey = getBlockKeyFromSelectionPoint(selectionStart)\n    const selectionEndBlockKey = getBlockKeyFromSelectionPoint(selectionEnd)\n    const editorSelectionStartBlockKey =\n      getBlockKeyFromSelectionPoint(editorSelectionStart)\n    const editorSelectionEndBlockKey =\n      getBlockKeyFromSelectionPoint(editorSelectionEnd)\n\n    if (\n      !selectionStartBlockKey ||\n      !selectionEndBlockKey ||\n      !editorSelectionStartBlockKey ||\n      !editorSelectionEndBlockKey\n    ) {\n      return false\n    }\n\n    const selectionStartBlockIndex = snapshot.blockIndexMap.get(\n      selectionStartBlockKey,\n    )\n    const selectionEndBlockIndex =\n      snapshot.blockIndexMap.get(selectionEndBlockKey)\n    const editorSelectionStartBlockIndex = snapshot.blockIndexMap.get(\n      editorSelectionStartBlockKey,\n    )\n    const editorSelectionEndBlockIndex = snapshot.blockIndexMap.get(\n      editorSelectionEndBlockKey,\n    )\n\n    if (\n      selectionStartBlockIndex === undefined ||\n      selectionEndBlockIndex === undefined ||\n      editorSelectionStartBlockIndex === undefined ||\n      editorSelectionEndBlockIndex === undefined\n    ) {\n      return false\n    }\n\n    const [selectionMinBlockIndex, selectionMaxBlockIndex] =\n      selectionStartBlockIndex <= selectionEndBlockIndex\n        ? [selectionStartBlockIndex, selectionEndBlockIndex]\n        : [selectionEndBlockIndex, selectionStartBlockIndex]\n    const [editorSelectionMinBlockIndex, editorSelectionMaxBlockIndex] =\n      editorSelectionStartBlockIndex <= editorSelectionEndBlockIndex\n        ? [editorSelectionStartBlockIndex, editorSelectionEndBlockIndex]\n        : [editorSelectionEndBlockIndex, editorSelectionStartBlockIndex]\n\n    if (selectionMaxBlockIndex < editorSelectionMinBlockIndex) {\n      return false\n    }\n\n    if (selectionMinBlockIndex > editorSelectionMaxBlockIndex) {\n      return false\n    }\n\n    return hasPointLevelOverlap(\n      snapshot,\n      selectionStart,\n      selectionEnd,\n      editorSelectionStart,\n      editorSelectionEnd,\n    )\n  }\n}\n\n/**\n * Check if selections overlap at the point level.\n * Called after confirming block ranges overlap.\n */\nfunction hasPointLevelOverlap(\n  snapshot: EditorSnapshot,\n  selectionStart: EditorSelectionPoint,\n  selectionEnd: EditorSelectionPoint,\n  editorSelectionStart: EditorSelectionPoint,\n  editorSelectionEnd: EditorSelectionPoint,\n): boolean {\n  // Check for exact equality first\n  if (\n    isEqualSelectionPoints(selectionStart, editorSelectionStart) &&\n    isEqualSelectionPoints(selectionEnd, editorSelectionEnd)\n  ) {\n    return true\n  }\n\n  // Compare selection start against editor selection bounds\n  const selectionStartVsEditorSelectionStart = comparePoints(\n    snapshot,\n    selectionStart,\n    editorSelectionStart,\n  )\n  const selectionStartVsEditorSelectionEnd = comparePoints(\n    snapshot,\n    selectionStart,\n    editorSelectionEnd,\n  )\n\n  // Compare selection end against editor selection bounds\n  const selectionEndVsEditorSelectionStart = comparePoints(\n    snapshot,\n    selectionEnd,\n    editorSelectionStart,\n  )\n  const selectionEndVsEditorSelectionEnd = comparePoints(\n    snapshot,\n    selectionEnd,\n    editorSelectionEnd,\n  )\n\n  // Compare editor selection bounds against selection bounds\n  const editorSelectionStartVsSelectionStart = comparePoints(\n    snapshot,\n    editorSelectionStart,\n    selectionStart,\n  )\n  const editorSelectionEndVsSelectionEnd = comparePoints(\n    snapshot,\n    editorSelectionEnd,\n    selectionEnd,\n  )\n\n  // Derive boolean flags\n  const selectionStartBeforeEditorSelectionStart =\n    selectionStartVsEditorSelectionStart === -1\n  const selectionStartAfterEditorSelectionEnd =\n    selectionStartVsEditorSelectionEnd === 1\n  const selectionEndBeforeEditorSelectionStart =\n    selectionEndVsEditorSelectionStart === -1\n  const selectionEndAfterEditorSelectionEnd =\n    selectionEndVsEditorSelectionEnd === 1\n\n  const editorSelectionStartBeforeSelectionStart =\n    editorSelectionStartVsSelectionStart === -1\n  const editorSelectionStartAfterSelectionStart =\n    editorSelectionStartVsSelectionStart === 1\n  const editorSelectionEndBeforeSelectionEnd =\n    editorSelectionEndVsSelectionEnd === -1\n  const editorSelectionEndAfterSelectionEnd =\n    editorSelectionEndVsSelectionEnd === 1\n\n  const selectionStartEqualEditorSelectionEnd = isEqualSelectionPoints(\n    selectionStart,\n    editorSelectionEnd,\n  )\n  const selectionEndEqualEditorSelectionStart = isEqualSelectionPoints(\n    selectionEnd,\n    editorSelectionStart,\n  )\n\n  // If all relative position checks fail, selections don't overlap\n  if (\n    !selectionEndEqualEditorSelectionStart &&\n    !selectionStartEqualEditorSelectionEnd &&\n    !editorSelectionStartBeforeSelectionStart &&\n    !editorSelectionStartAfterSelectionStart &&\n    !editorSelectionEndBeforeSelectionEnd &&\n    !editorSelectionEndAfterSelectionEnd\n  ) {\n    return false\n  }\n\n  // Selection ends before editor selection starts\n  if (\n    selectionEndBeforeEditorSelectionStart &&\n    !selectionEndEqualEditorSelectionStart\n  ) {\n    return false\n  }\n\n  // Selection starts after editor selection ends\n  if (\n    selectionStartAfterEditorSelectionEnd &&\n    !selectionStartEqualEditorSelectionEnd\n  ) {\n    return false\n  }\n\n  // Editor selection is entirely after the input selection start\n  if (\n    !editorSelectionStartBeforeSelectionStart &&\n    editorSelectionStartAfterSelectionStart &&\n    !editorSelectionEndBeforeSelectionEnd &&\n    editorSelectionEndAfterSelectionEnd\n  ) {\n    return !selectionEndEqualEditorSelectionStart\n  }\n\n  // Editor selection is entirely before the input selection end\n  if (\n    editorSelectionStartBeforeSelectionStart &&\n    !editorSelectionStartAfterSelectionStart &&\n    editorSelectionEndBeforeSelectionEnd &&\n    !editorSelectionEndAfterSelectionEnd\n  ) {\n    return !selectionStartEqualEditorSelectionEnd\n  }\n\n  // If any of these conditions is false, there's overlap\n  if (\n    !selectionStartAfterEditorSelectionEnd ||\n    !selectionStartBeforeEditorSelectionStart ||\n    !selectionEndAfterEditorSelectionEnd ||\n    !selectionEndBeforeEditorSelectionStart\n  ) {\n    return true\n  }\n\n  return false\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getBlockEndPoint} from '../utils/util.get-block-end-point'\nimport {getBlockStartPoint} from '../utils/util.get-block-start-point'\nimport {isEqualSelectionPoints} from '../utils/util.is-equal-selection-points'\nimport {getSelectionEndBlock} from './selector.get-selection-end-block'\nimport {getSelectionStartBlock} from './selector.get-selection-start-block'\n\n/**\n * @public\n */\nexport const isSelectingEntireBlocks: EditorSelector<boolean> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return false\n  }\n\n  const startPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n  const endPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n\n  const startBlock = getSelectionStartBlock(snapshot)\n  const endBlock = getSelectionEndBlock(snapshot)\n\n  if (!startBlock || !endBlock) {\n    return false\n  }\n\n  const startBlockStartPoint = getBlockStartPoint({\n    context: snapshot.context,\n    block: startBlock,\n  })\n  const endBlockEndPoint = getBlockEndPoint({\n    context: snapshot.context,\n    block: endBlock,\n  })\n\n  return (\n    isEqualSelectionPoints(startBlockStartPoint, startPoint) &&\n    isEqualSelectionPoints(endBlockEndPoint, endPoint)\n  )\n}\n"],"names":["isBlockPath","path","firstSegment","at","length","undefined","isRecord","_key","value","isSelectionExpanded","selection","isSelectionCollapsed","getFocusBlock","snapshot","context","key","getBlockKeyFromSelectionPoint","focus","index","blockIndexMap","get","node","getFocusTextBlock","focusBlock","isTextBlock","getFocusChild","getChildKeyFromSelectionPoint","children","find","span","getFocusSpan","focusChild","isSpan","getSelectionEndBlock","endPoint","getSelectionEndPoint","anchor","backward","getNextSpan","selectionEndBlock","selectionEndPoint","selectionEndPointChildKey","endPointChildFound","nextSpan","child","getSelectionStartBlock","startPoint","getSelectionStartPoint","getPreviousSpan","selectionStartBlock","selectionStartPoint","selectionStartPointChildKey","previousSpan","getSelectedChildren","options","filter","startBlockKey","endBlockKey","startChildKey","endChildKey","startBlockIndex","endBlockIndex","selectedChildren","minBlockIndex","Math","min","maxBlockIndex","max","blocks","slice","startChildFound","block","isStartBlock","isEndBlock","isMiddleBlock","isStartChild","isEndChild","addChild","push","offset","text","getSelectedSpans","getMarkState","spanSelectionPoint","blockOffsetToSpanSelectionPoint","blockOffset","direction","focusSpan","selectedSpans","marks","mark","some","spanMark","state","decorators","schema","map","decorator","name","marksWithoutAnnotations","includes","spanHasAnnotations","spanIsEmpty","atTheBeginningOfSpan","atTheEndOfSpan","nextSpanAnnotations","spanAnnotations","previousSpanHasAnnotations","previousSpanHasSameAnnotations","every","previousSpanHasSameAnnotation","previousSpanHasSameMarks","nextSpanSharesSomeAnnotations","previousMarks","getSelectedBlocks","selectedBlocks","startKey","endKey","slicedValue","getActiveAnnotations","activeAnnotations","flatMap","markDefs","markDef","getActiveListItem","selectedTextBlocks","firstTextBlock","firstListItem","listItem","getActiveStyle","firstStyle","style","getNextInlineObject","focusTextBlock","isKeyedSegment","inlineObject","getPreviousInlineObject","getSelectedValue","startBlock","slicedStartBlock","sliceBlocks","endBlock","slicedEndBlock","middleBlocks","getSelectionText","reduce","isEqualPaths","getCaretWordSelection","selectionStartOffset","spanSelectionPointToBlockOffset","selectionPoint","previousInlineObject","blockStartPoint","getBlockStartPoint","textDirectlyBefore","split","nextInlineObject","blockEndPoint","getBlockEndPoint","textDirectlyAfter","caretWordStartOffset","caretWordEndOffset","caretWordStartSelectionPoint","caretWordEndSelectionPoint","caretWordSelection","getFocusBlockObject","getFocusInlineObject","getFocusListBlock","isListBlock","getLastBlock","getNextBlock","nextBlock","getPreviousBlock","previousBlock","getSelectedTextBlocks","getSelectionEndChild","getSelectionStartChild","getActiveAnnotationsMarks","isActiveAnnotation","annotation","mode","_type","selectionMarkDefs","getActiveDecorators","decoratorState","markState","activeDecorators","activeDecorator","isActiveDecorator","isActiveListItem","isActiveStyle","isAtTheEndOfBlock","isEqualSelectionPoints","isAtTheStartOfBlock","comparePoints","pointA","pointB","blockKeyA","blockKeyB","Error","blockIndexA","blockIndexB","childKeyA","childKeyB","childIndexA","childIndexB","i","isOverlappingSelection","editorSelection","selectionStart","selectionEnd","editorSelectionStart","editorSelectionEnd","selectionStartBlockKey","selectionEndBlockKey","editorSelectionStartBlockKey","editorSelectionEndBlockKey","selectionStartBlockIndex","selectionEndBlockIndex","editorSelectionStartBlockIndex","editorSelectionEndBlockIndex","selectionMinBlockIndex","selectionMaxBlockIndex","editorSelectionMinBlockIndex","editorSelectionMaxBlockIndex","hasPointLevelOverlap","selectionStartVsEditorSelectionStart","selectionStartVsEditorSelectionEnd","selectionEndVsEditorSelectionStart","selectionEndVsEditorSelectionEnd","editorSelectionStartVsSelectionStart","editorSelectionEndVsSelectionEnd","selectionStartBeforeEditorSelectionStart","selectionStartAfterEditorSelectionEnd","selectionEndBeforeEditorSelectionStart","selectionEndAfterEditorSelectionEnd","editorSelectionStartBeforeSelectionStart","editorSelectionStartAfterSelectionStart","editorSelectionEndBeforeSelectionEnd","editorSelectionEndAfterSelectionEnd","selectionStartEqualEditorSelectionEnd","selectionEndEqualEditorSelectionStart","isSelectingEntireBlocks","startBlockStartPoint","endBlockEndPoint"],"mappings":"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"}