{"version":3,"file":"util.slice-blocks.js","sources":["../../src/utils/util.get-block-end-point.ts","../../src/utils/util.get-block-start-point.ts","../../src/utils/util.is-keyed-segment.ts","../../src/utils/util.is-equal-path-segments.ts","../../src/utils/util.is-equal-paths.ts","../../src/utils/util.is-selection-collapsed.ts","../../src/utils/util.selection-point.ts","../../src/utils/util.block-offset.ts","../../src/utils/util.get-selection-end-point.ts","../../src/utils/util.get-selection-start-point.ts","../../src/utils/util.is-equal-selection-points.ts","../../src/utils/asserters.ts","../../src/utils/parse-blocks.ts","../../src/utils/key-generator.ts","../../src/utils/util.slice-blocks.ts"],"sourcesContent":["import {isSpan, isTextBlock, type PortableTextBlock} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport type {BlockPath} from '../types/paths'\n\n/**\n * @public\n */\nexport function getBlockEndPoint({\n  context,\n  block,\n}: {\n  context: Pick<EditorContext, 'schema'>\n  block: {\n    node: PortableTextBlock\n    path: BlockPath\n  }\n}): EditorSelectionPoint {\n  if (isTextBlock(context, block.node)) {\n    const lastChild = block.node.children[block.node.children.length - 1]\n\n    if (lastChild) {\n      return {\n        path: [...block.path, 'children', {_key: lastChild._key}],\n        offset: isSpan(context, lastChild) ? lastChild.text.length : 0,\n      }\n    }\n  }\n\n  return {\n    path: block.path,\n    offset: 0,\n  }\n}\n","import {isTextBlock, type PortableTextBlock} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport type {BlockPath} from '../types/paths'\n\n/**\n * @public\n */\nexport function getBlockStartPoint({\n  context,\n  block,\n}: {\n  context: Pick<EditorContext, 'schema'>\n  block: {\n    node: PortableTextBlock\n    path: BlockPath\n  }\n}): EditorSelectionPoint {\n  if (isTextBlock(context, block.node)) {\n    const firstChild = block.node.children[0]\n    return {\n      path: [...block.path, 'children', {_key: firstChild?._key ?? ''}],\n      offset: 0,\n    }\n  }\n\n  return {\n    path: block.path,\n    offset: 0,\n  }\n}\n","import type {KeyedSegment} from '../types/paths'\n\n/**\n * @public\n */\nexport function isKeyedSegment(segment: unknown): segment is KeyedSegment {\n  return typeof segment === 'object' && segment !== null && '_key' in segment\n}\n","import type {PathSegment} from '../types/paths'\nimport {isKeyedSegment} from './util.is-keyed-segment'\n\nexport function isEqualPathSegments(\n  segA: PathSegment | undefined,\n  segB: PathSegment | undefined,\n): boolean {\n  if (segA === segB) {\n    return true\n  }\n\n  if (segA === undefined || segB === undefined) {\n    return false\n  }\n\n  if (\n    (typeof segA === 'string' || typeof segA === 'number') &&\n    (typeof segB === 'string' || typeof segB === 'number')\n  ) {\n    return segA === segB\n  }\n\n  if (isKeyedSegment(segA) && isKeyedSegment(segB)) {\n    return segA._key === segB._key\n  }\n\n  if (Array.isArray(segA) && Array.isArray(segB)) {\n    return segA[0] === segB[0] && segA[1] === segB[1]\n  }\n\n  return false\n}\n","import type {Path} from '../types/paths'\nimport {isEqualPathSegments} from './util.is-equal-path-segments'\n\n/**\n * @public\n */\nexport function isEqualPaths(a: Path, b: Path): boolean {\n  if (a.length !== b.length) {\n    return false\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (!isEqualPathSegments(a[i], b[i])) {\n      return false\n    }\n  }\n\n  return true\n}\n","import type {EditorSelection} from '../types/editor'\nimport {isEqualPaths} from './util.is-equal-paths'\n\n/**\n * @public\n */\nexport function isSelectionCollapsed(selection: EditorSelection) {\n  if (!selection) {\n    return false\n  }\n\n  return (\n    isEqualPaths(selection.anchor.path, selection.focus.path) &&\n    selection.anchor.offset === selection.focus.offset\n  )\n}\n","import type {EditorSelectionPoint} from '../types/editor'\nimport {isKeyedSegment} from './util.is-keyed-segment'\n\nexport function getBlockKeyFromSelectionPoint(point: EditorSelectionPoint) {\n  const blockPathSegment = point.path.at(0)\n\n  if (isKeyedSegment(blockPathSegment)) {\n    return blockPathSegment._key\n  }\n\n  return undefined\n}\n\nexport function getChildKeyFromSelectionPoint(point: EditorSelectionPoint) {\n  const childPathSegment = point.path.at(2)\n\n  if (isKeyedSegment(childPathSegment)) {\n    return childPathSegment._key\n  }\n\n  return undefined\n}\n","import {isSpan, isTextBlock} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport type {ChildPath} from '../types/paths'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from './util.selection-point'\n\n/**\n * @public\n */\nexport function blockOffsetToSpanSelectionPoint({\n  context,\n  blockOffset,\n  direction,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  blockOffset: BlockOffset\n  direction: 'forward' | 'backward'\n}) {\n  let offsetLeft = blockOffset.offset\n  let selectionPoint: {path: ChildPath; offset: number} | undefined\n  let skippedInlineObject = false\n\n  for (const block of context.value) {\n    if (block._key !== blockOffset.path[0]._key) {\n      continue\n    }\n\n    if (!isTextBlock(context, block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (direction === 'forward') {\n        if (!isSpan(context, child)) {\n          continue\n        }\n\n        if (offsetLeft <= child.text.length) {\n          selectionPoint = {\n            path: [...blockOffset.path, 'children', {_key: child._key}],\n            offset: offsetLeft,\n          }\n          break\n        }\n\n        offsetLeft -= child.text.length\n\n        continue\n      }\n\n      if (!isSpan(context, child)) {\n        skippedInlineObject = true\n        continue\n      }\n\n      if (offsetLeft === 0 && selectionPoint && !skippedInlineObject) {\n        if (skippedInlineObject) {\n          selectionPoint = {\n            path: [...blockOffset.path, 'children', {_key: child._key}],\n            offset: 0,\n          }\n        }\n        break\n      }\n\n      if (offsetLeft > child.text.length) {\n        offsetLeft -= child.text.length\n        continue\n      }\n\n      if (offsetLeft <= child.text.length) {\n        selectionPoint = {\n          path: [...blockOffset.path, 'children', {_key: child._key}],\n          offset: offsetLeft,\n        }\n\n        offsetLeft -= child.text.length\n\n        if (offsetLeft !== 0) {\n          break\n        }\n      }\n    }\n  }\n\n  return selectionPoint\n}\n\n/**\n * @public\n */\nexport function spanSelectionPointToBlockOffset({\n  context,\n  selectionPoint,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  let offset = 0\n\n  const blockKey = getBlockKeyFromSelectionPoint(selectionPoint)\n  const spanKey = getChildKeyFromSelectionPoint(selectionPoint)\n\n  if (!blockKey || !spanKey) {\n    return undefined\n  }\n\n  for (const block of context.value) {\n    if (block._key !== blockKey) {\n      continue\n    }\n\n    if (!isTextBlock(context, block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (!isSpan(context, child)) {\n        continue\n      }\n\n      if (child._key === spanKey) {\n        return {\n          path: [{_key: block._key}],\n          offset: offset + selectionPoint.offset,\n        }\n      }\n\n      offset += child.text.length\n    }\n  }\n\n  return undefined\n}\n","import type {EditorSelection, EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function getSelectionEndPoint<\n  TEditorSelection extends NonNullable<EditorSelection> | null,\n  TEditorSelectionPoint extends EditorSelectionPoint | null =\n    TEditorSelection extends NonNullable<EditorSelection>\n      ? EditorSelectionPoint\n      : null,\n>(selection: TEditorSelection): TEditorSelectionPoint {\n  if (!selection) {\n    return null as TEditorSelectionPoint\n  }\n\n  return (\n    selection.backward ? selection.anchor : selection.focus\n  ) as TEditorSelectionPoint\n}\n","import type {EditorSelection, EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function getSelectionStartPoint<\n  TEditorSelection extends NonNullable<EditorSelection> | null,\n  TEditorSelectionPoint extends EditorSelectionPoint | null =\n    TEditorSelection extends NonNullable<EditorSelection>\n      ? EditorSelectionPoint\n      : null,\n>(selection: TEditorSelection): TEditorSelectionPoint {\n  if (!selection) {\n    return null as TEditorSelectionPoint\n  }\n\n  return (\n    selection.backward ? selection.focus : selection.anchor\n  ) as TEditorSelectionPoint\n}\n","import type {EditorSelectionPoint} from '../types/editor'\nimport {isEqualPaths} from './util.is-equal-paths'\n\n/**\n * @public\n */\nexport function isEqualSelectionPoints(\n  a: EditorSelectionPoint,\n  b: EditorSelectionPoint,\n) {\n  return a.offset === b.offset && isEqualPaths(a.path, b.path)\n}\n","import type {TypedObject} from '@portabletext/schema'\n\nexport function isTypedObject(object: unknown): object is TypedObject {\n  return isRecord(object) && typeof object['_type'] === 'string'\n}\n\nexport function isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n","import {\n  isSpan,\n  isTextBlock,\n  type PortableTextBlock,\n  type PortableTextListBlock,\n  type PortableTextObject,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n  type TypedObject,\n} from '@portabletext/schema'\nimport type {EditorSchema} from '../editor/editor-schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {isRecord, isTypedObject} from './asserters'\n\nexport function parseBlocks({\n  context,\n  blocks,\n  options,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  blocks: unknown\n  options: {\n    normalize: boolean\n    removeUnusedMarkDefs: boolean\n    validateFields: boolean\n  }\n}): Array<PortableTextBlock> {\n  if (!Array.isArray(blocks)) {\n    return []\n  }\n\n  return blocks.flatMap((block) => {\n    const parsedBlock = parseBlock({context, block, options})\n\n    return parsedBlock ? [parsedBlock] : []\n  })\n}\n\nexport function parseBlock({\n  context,\n  block,\n  options,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  block: unknown\n  options: {\n    normalize: boolean\n    removeUnusedMarkDefs: boolean\n    validateFields: boolean\n  }\n}): PortableTextBlock | undefined {\n  return (\n    parseTextBlock({block, context, options}) ??\n    parseBlockObject({blockObject: block, context, options})\n  )\n}\n\nexport function parseBlockObject({\n  blockObject,\n  context,\n  options,\n}: {\n  blockObject: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {validateFields: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(blockObject)) {\n    return undefined\n  }\n\n  const schemaType = context.schema.blockObjects.find(\n    ({name}) => name === blockObject._type,\n  )\n\n  if (!schemaType) {\n    return undefined\n  }\n\n  return parseObject({\n    object: blockObject,\n    context: {\n      keyGenerator: context.keyGenerator,\n      schemaType,\n    },\n    options,\n  })\n}\n\nexport function isListBlock(\n  context: Pick<EditorContext, 'schema'>,\n  block: unknown,\n): block is PortableTextListBlock {\n  return (\n    isTextBlock(context, block) &&\n    block.level !== undefined &&\n    block.listItem !== undefined\n  )\n}\n\nexport function parseTextBlock({\n  block,\n  context,\n  options,\n}: {\n  block: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {\n    normalize: boolean\n    removeUnusedMarkDefs: boolean\n    validateFields: boolean\n  }\n}): PortableTextTextBlock | undefined {\n  if (!isTypedObject(block)) {\n    return undefined\n  }\n\n  const customFields: Record<string, unknown> = {}\n\n  for (const key of Object.keys(block)) {\n    if (\n      key === '_type' ||\n      key === '_key' ||\n      key === 'children' ||\n      key === 'markDefs' ||\n      key === 'style' ||\n      key === 'listItem' ||\n      key === 'level'\n    ) {\n      continue\n    }\n\n    if (options.validateFields) {\n      if (context.schema.block.fields?.some((field) => field.name === key)) {\n        customFields[key] = block[key]\n      }\n    } else {\n      customFields[key] = block[key]\n    }\n  }\n\n  if (block._type !== context.schema.block.name) {\n    return undefined\n  }\n\n  const _key =\n    typeof block['_key'] === 'string' ? block['_key'] : context.keyGenerator()\n\n  const {markDefs, markDefKeyMap} = parseMarkDefs({\n    context,\n    markDefs: block['markDefs'],\n    options,\n  })\n\n  const unparsedChildren: Array<unknown> = Array.isArray(block['children'])\n    ? block['children']\n    : []\n\n  const parsedChildren = unparsedChildren\n    .map((child) => parseChild({child, context, markDefKeyMap, options}))\n    .filter((child) => child !== undefined)\n  const marks = parsedChildren.flatMap((child) => child.marks ?? [])\n\n  const children =\n    parsedChildren.length > 0\n      ? parsedChildren\n      : [\n          {\n            _key: context.keyGenerator(),\n            _type: context.schema.span.name,\n            text: '',\n            marks: [],\n          },\n        ]\n\n  const normalizedChildren = options.normalize\n    ? // Ensure that inline objects re surrounded by spans\n      children.reduce<Array<PortableTextObject | PortableTextSpan>>(\n        (normalizedChildren, child, index) => {\n          if (isSpan(context, child)) {\n            return [...normalizedChildren, child]\n          }\n\n          const previousChild = normalizedChildren.at(-1)\n\n          if (!previousChild || !isSpan(context, previousChild)) {\n            return [\n              ...normalizedChildren,\n              {\n                _key: context.keyGenerator(),\n                _type: context.schema.span.name,\n                text: '',\n                marks: [],\n              },\n              child,\n              ...(index === children.length - 1\n                ? [\n                    {\n                      _key: context.keyGenerator(),\n                      _type: context.schema.span.name,\n                      text: '',\n                      marks: [],\n                    },\n                  ]\n                : []),\n            ]\n          }\n\n          return [...normalizedChildren, child]\n        },\n        [],\n      )\n    : children\n\n  const parsedBlock: PortableTextTextBlock = {\n    _type: context.schema.block.name,\n    _key,\n    children: normalizedChildren,\n    ...customFields,\n  }\n\n  if (typeof block['markDefs'] === 'object' && block['markDefs'] !== null) {\n    parsedBlock.markDefs = options.removeUnusedMarkDefs\n      ? markDefs.filter((markDef) => marks.includes(markDef._key))\n      : markDefs\n  }\n\n  if (\n    typeof block['style'] === 'string' &&\n    context.schema.styles.find((style) => style.name === block['style'])\n  ) {\n    parsedBlock.style = block['style']\n  }\n\n  if (\n    typeof block['listItem'] === 'string' &&\n    context.schema.lists.find((list) => list.name === block['listItem'])\n  ) {\n    parsedBlock.listItem = block['listItem']\n  }\n\n  if (typeof block['level'] === 'number') {\n    parsedBlock.level = block['level']\n  }\n\n  return parsedBlock\n}\n\nexport function parseMarkDefs({\n  context,\n  markDefs,\n  options,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  markDefs: unknown\n  options: {validateFields: boolean}\n}): {\n  markDefs: Array<PortableTextObject>\n  markDefKeyMap: Map<string, string>\n} {\n  const unparsedMarkDefs: Array<unknown> = Array.isArray(markDefs)\n    ? markDefs\n    : []\n  const markDefKeyMap = new Map<string, string>()\n\n  const parsedMarkDefs = unparsedMarkDefs.flatMap((markDef) => {\n    if (!isTypedObject(markDef)) {\n      return []\n    }\n\n    const schemaType = context.schema.annotations.find(\n      ({name}) => name === markDef._type,\n    )\n\n    if (!schemaType) {\n      return []\n    }\n\n    if (typeof markDef['_key'] !== 'string') {\n      // If the `markDef` doesn't have a `_key` then we don't know what spans\n      // it belongs to and therefore we have to discard it.\n      return []\n    }\n\n    const parsedAnnotation = parseObject({\n      object: markDef,\n      context: {\n        schemaType,\n        keyGenerator: context.keyGenerator,\n      },\n      options,\n    })\n\n    if (!parsedAnnotation) {\n      return []\n    }\n\n    markDefKeyMap.set(markDef['_key'], parsedAnnotation._key)\n\n    return [parsedAnnotation]\n  })\n\n  return {\n    markDefs: parsedMarkDefs,\n    markDefKeyMap,\n  }\n}\n\nexport function parseChild({\n  child,\n  context,\n  markDefKeyMap,\n  options,\n}: {\n  child: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  markDefKeyMap: Map<string, string>\n  options: {validateFields: boolean}\n}): PortableTextSpan | PortableTextObject | undefined {\n  return (\n    parseSpan({span: child, context, markDefKeyMap, options}) ??\n    parseInlineObject({inlineObject: child, context, options})\n  )\n}\n\nexport function parseSpan({\n  span,\n  context,\n  markDefKeyMap,\n  options,\n}: {\n  span: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  markDefKeyMap: Map<string, string>\n  options: {validateFields: boolean}\n}): PortableTextSpan | undefined {\n  if (!isRecord(span)) {\n    return undefined\n  }\n\n  const customFields: Record<string, unknown> = {}\n\n  for (const key of Object.keys(span)) {\n    if (\n      key !== '_type' &&\n      key !== '_key' &&\n      key !== 'text' &&\n      key !== 'marks'\n    ) {\n      customFields[key] = span[key]\n    }\n  }\n\n  const unparsedMarks: Array<unknown> = Array.isArray(span['marks'])\n    ? span['marks']\n    : []\n  const marks = unparsedMarks.flatMap((mark) => {\n    if (typeof mark !== 'string') {\n      return []\n    }\n\n    const markDefKey = markDefKeyMap.get(mark)\n\n    if (markDefKey !== undefined) {\n      return [markDefKey]\n    }\n\n    if (\n      context.schema.decorators.some((decorator) => decorator.name === mark)\n    ) {\n      return [mark]\n    }\n\n    return []\n  })\n\n  if (\n    typeof span['_type'] === 'string' &&\n    span['_type'] !== context.schema.span.name\n  ) {\n    return undefined\n  }\n\n  if (typeof span['_type'] !== 'string') {\n    if (typeof span['text'] === 'string') {\n      return {\n        _type: context.schema.span.name as 'span',\n        _key:\n          typeof span['_key'] === 'string'\n            ? span['_key']\n            : context.keyGenerator(),\n        text: span['text'],\n        marks,\n        ...(options.validateFields ? {} : customFields),\n      }\n    }\n\n    return undefined\n  }\n\n  return {\n    _type: context.schema.span.name as 'span',\n    _key:\n      typeof span['_key'] === 'string' ? span['_key'] : context.keyGenerator(),\n    text: typeof span['text'] === 'string' ? span['text'] : '',\n    marks,\n    ...(options.validateFields ? {} : customFields),\n  }\n}\n\nexport function parseInlineObject({\n  inlineObject,\n  context,\n  options,\n}: {\n  inlineObject: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {validateFields: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(inlineObject)) {\n    return undefined\n  }\n\n  const schemaType = context.schema.inlineObjects.find(\n    ({name}) => name === inlineObject._type,\n  )\n\n  if (!schemaType) {\n    return undefined\n  }\n\n  return parseObject({\n    object: inlineObject,\n    context: {\n      keyGenerator: context.keyGenerator,\n      schemaType,\n    },\n    options,\n  })\n}\n\nexport function parseAnnotation({\n  annotation,\n  context,\n  options,\n}: {\n  annotation: TypedObject\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {validateFields: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(annotation)) {\n    return undefined\n  }\n\n  const schemaType = context.schema.annotations.find(\n    ({name}) => name === annotation._type,\n  )\n\n  if (!schemaType) {\n    return undefined\n  }\n\n  return parseObject({\n    object: annotation,\n    context: {\n      keyGenerator: context.keyGenerator,\n      schemaType,\n    },\n    options,\n  })\n}\n\nfunction parseObject({\n  object,\n  context,\n  options,\n}: {\n  object: TypedObject\n  context: Pick<EditorContext, 'keyGenerator'> & {\n    schemaType: EditorSchema['blockObjects'][0]\n  }\n  options: {validateFields: boolean}\n}): PortableTextObject {\n  const {_type, _key, ...customFields} = object\n\n  // Validates all props on the object and only takes those that match\n  // the name of a field\n  const values = options.validateFields\n    ? context.schemaType.fields.reduce<Record<string, unknown>>(\n        (fieldValues, field) => {\n          const fieldValue = object[field.name]\n\n          if (fieldValue !== undefined) {\n            fieldValues[field.name] = fieldValue\n          }\n\n          return fieldValues\n        },\n        {},\n      )\n    : customFields\n\n  return {\n    _type: context.schemaType.name,\n    _key:\n      typeof object['_key'] === 'string'\n        ? object['_key']\n        : context.keyGenerator(),\n    ...values,\n  }\n}\n","/**\n * @public\n */\nexport const defaultKeyGenerator = (): string => randomKey(12)\n\nconst getByteHexTable = (() => {\n  let table: any[]\n  return () => {\n    if (table) {\n      return table\n    }\n\n    table = []\n    for (let i = 0; i < 256; ++i) {\n      table[i] = (i + 0x100).toString(16).slice(1)\n    }\n    return table\n  }\n})()\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  crypto.getRandomValues(rnds8)\n  return rnds8\n}\n\nfunction randomKey(length?: number): string {\n  const table = getByteHexTable()\n  return whatwgRNG(length)\n    .reduce((str, n) => str + table[n], '')\n    .slice(0, length)\n}\n","import {isSpan, isTextBlock, type PortableTextBlock} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {defaultKeyGenerator} from './key-generator'\nimport {parseBlock} from './parse-blocks'\nimport {getSelectionEndPoint} from './util.get-selection-end-point'\nimport {getSelectionStartPoint} from './util.get-selection-start-point'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from './util.selection-point'\n\n/**\n * @public\n */\nexport function sliceBlocks({\n  context,\n  blocks,\n}: {\n  context: Pick<EditorContext, 'schema' | 'selection'> & {\n    keyGenerator?: () => string\n  }\n  blocks: Array<PortableTextBlock>\n}): Array<PortableTextBlock> {\n  const slice: Array<PortableTextBlock> = []\n\n  if (!context.selection) {\n    return slice\n  }\n\n  let startBlock: PortableTextBlock | undefined\n  const middleBlocks: PortableTextBlock[] = []\n  let endBlock: PortableTextBlock | undefined\n\n  const startPoint = getSelectionStartPoint(context.selection)\n  const endPoint = getSelectionEndPoint(context.selection)\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const startChildKey = getChildKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n  const endChildKey = getChildKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return slice\n  }\n\n  for (const block of blocks) {\n    if (!isTextBlock(context, block)) {\n      if (block._key === startBlockKey && block._key === endBlockKey) {\n        startBlock = block\n        break\n      }\n    }\n\n    if (block._key === startBlockKey) {\n      if (!isTextBlock(context, block)) {\n        startBlock = block\n        continue\n      }\n\n      if (startChildKey) {\n        for (const child of block.children) {\n          if (child._key === startChildKey) {\n            if (isSpan(context, child)) {\n              const text =\n                child._key === endChildKey\n                  ? child.text.slice(startPoint.offset, endPoint.offset)\n                  : child.text.slice(startPoint.offset)\n\n              startBlock = {\n                ...block,\n                children: [\n                  {\n                    ...child,\n                    text,\n                  },\n                ],\n              }\n            } else {\n              startBlock = {\n                ...block,\n                children: [child],\n              }\n            }\n\n            if (block._key === endBlockKey && startChildKey === endChildKey) {\n              break\n            }\n            continue\n          }\n\n          if (startBlock && isTextBlock(context, startBlock)) {\n            if (\n              endChildKey &&\n              child._key === endChildKey &&\n              isSpan(context, child)\n            ) {\n              startBlock.children.push({\n                ...child,\n                text: child.text.slice(0, endPoint.offset),\n              })\n            } else {\n              startBlock.children.push(child)\n            }\n\n            if (\n              block._key === endBlockKey &&\n              endChildKey &&\n              child._key === endChildKey\n            ) {\n              break\n            }\n          }\n        }\n\n        if (startBlockKey === endBlockKey) {\n          break\n        }\n\n        continue\n      }\n\n      startBlock = block\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n    }\n\n    if (block._key === endBlockKey) {\n      if (!isTextBlock(context, block)) {\n        endBlock = block\n        break\n      }\n\n      if (endChildKey) {\n        endBlock = {\n          ...block,\n          children: [],\n        }\n\n        for (const child of block.children) {\n          if (endBlock && isTextBlock(context, endBlock)) {\n            if (child._key === endChildKey && isSpan(context, child)) {\n              endBlock.children.push({\n                ...child,\n                text: child.text.slice(0, endPoint.offset),\n              })\n\n              break\n            }\n\n            endBlock.children.push(child)\n\n            if (endChildKey && child._key === endChildKey) {\n              break\n            }\n          }\n        }\n\n        break\n      }\n\n      endBlock = block\n\n      break\n    }\n\n    if (startBlock) {\n      middleBlocks.push(\n        parseBlock({\n          context: {\n            schema: context.schema,\n            keyGenerator: context.keyGenerator ?? defaultKeyGenerator,\n          },\n          block,\n          options: {\n            normalize: false,\n            removeUnusedMarkDefs: true,\n            validateFields: false,\n          },\n        }) ?? block,\n      )\n    }\n  }\n\n  const parsedStartBlock = startBlock\n    ? parseBlock({\n        context: {\n          schema: context.schema,\n          keyGenerator: context.keyGenerator ?? defaultKeyGenerator,\n        },\n        block: startBlock,\n        options: {\n          normalize: false,\n          removeUnusedMarkDefs: true,\n          validateFields: false,\n        },\n      })\n    : undefined\n\n  const parsedEndBlock = endBlock\n    ? parseBlock({\n        context: {\n          schema: context.schema,\n          keyGenerator: context.keyGenerator ?? defaultKeyGenerator,\n        },\n        block: endBlock,\n        options: {\n          normalize: false,\n          removeUnusedMarkDefs: true,\n          validateFields: false,\n        },\n      })\n    : undefined\n\n  return [\n    ...(parsedStartBlock ? [parsedStartBlock] : []),\n    ...middleBlocks,\n    ...(parsedEndBlock ? [parsedEndBlock] : []),\n  ]\n}\n"],"names":["getBlockEndPoint","context","block","isTextBlock","node","lastChild","children","length","path","_key","offset","isSpan","text","getBlockStartPoint","firstChild","isKeyedSegment","segment","isEqualPathSegments","segA","segB","undefined","Array","isArray","isEqualPaths","a","b","i","isSelectionCollapsed","selection","anchor","focus","getBlockKeyFromSelectionPoint","point","blockPathSegment","at","getChildKeyFromSelectionPoint","childPathSegment","blockOffsetToSpanSelectionPoint","blockOffset","direction","offsetLeft","selectionPoint","skippedInlineObject","value","child","spanSelectionPointToBlockOffset","blockKey","spanKey","getSelectionEndPoint","backward","getSelectionStartPoint","isEqualSelectionPoints","isTypedObject","object","isRecord","parseBlocks","blocks","options","flatMap","parsedBlock","parseBlock","parseTextBlock","parseBlockObject","blockObject","schemaType","schema","blockObjects","find","name","_type","parseObject","keyGenerator","isListBlock","level","listItem","customFields","key","Object","keys","validateFields","fields","some","field","markDefs","markDefKeyMap","parseMarkDefs","parsedChildren","map","parseChild","filter","marks","span","normalizedChildren","normalize","reduce","index","previousChild","removeUnusedMarkDefs","markDef","includes","styles","style","lists","list","unparsedMarkDefs","Map","annotations","parsedAnnotation","set","parseSpan","parseInlineObject","inlineObject","mark","markDefKey","get","decorators","decorator","inlineObjects","parseAnnotation","annotation","values","fieldValues","fieldValue","defaultKeyGenerator","randomKey","getByteHexTable","table","toString","slice","whatwgRNG","rnds8","Uint8Array","crypto","getRandomValues","str","n","sliceBlocks","startBlock","middleBlocks","endBlock","startPoint","endPoint","startBlockKey","startChildKey","endBlockKey","endChildKey","push","parsedStartBlock","parsedEndBlock"],"mappings":"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"}