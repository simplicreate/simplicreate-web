{"version":3,"file":"index.js","sources":["../../src/behaviors/behavior.types.action.ts","../../src/behaviors/behavior.types.behavior.ts"],"sourcesContent":["import type {EditorDom} from '../editor/editor-dom'\nimport type {EditorSnapshot} from '../editor/editor-snapshot'\nimport type {PickFromUnion} from '../type-utils'\nimport type {\n  CustomBehaviorEvent,\n  ExternalBehaviorEvent,\n  NativeBehaviorEvent,\n  SyntheticBehaviorEvent,\n} from './behavior.types.event'\n\n/**\n * @beta\n */\nexport type BehaviorAction =\n  | {\n      type: 'execute'\n      event: SyntheticBehaviorEvent\n    }\n  | {\n      type: 'forward'\n      event: NativeBehaviorEvent | SyntheticBehaviorEvent | CustomBehaviorEvent\n    }\n  | {\n      type: 'raise'\n      event: SyntheticBehaviorEvent | CustomBehaviorEvent\n    }\n  | {\n      type: 'effect'\n      effect: (payload: {\n        /**\n         * Send a Behavior Event back into the Editor.\n         *\n         * @example\n         * ```ts\n         * defineBehavior({\n         *   on: '...',\n         *   actions: [\n         *     () => [\n         *       effect(({send}) => {\n         *         doSomethingAsync()\n         *           .then(() => {\n         *             send({\n         *               type: '...',\n         *             })\n         *           })\n         *       })\n         *     ],\n         *   ],\n         * })\n         * ```\n         */\n        send: (event: ExternalBehaviorEvent) => void\n      }) => void\n    }\n\n/**\n * Directly executes an event, bypassing all Behavior matching.\n *\n * Use `execute` when you want to perform an action without triggering any\n * Behaviors. The event is executed immediately as a direct operation.\n *\n * @example\n * ```ts\n * defineBehavior({\n *   on: 'insert.text',\n *   guard: ({event}) => event.text === 'a',\n *   actions: [() => [execute({type: 'insert.text', text: 'b'})]],\n * })\n * ```\n *\n * @beta\n */\nexport function execute(\n  event: SyntheticBehaviorEvent,\n): PickFromUnion<BehaviorAction, 'type', 'execute'> {\n  return {type: 'execute', event}\n}\n\n/**\n * Forwards an event to the next Behavior(s) in the current chain.\n *\n * Use `forward` to pass an event to succeeding Behaviors without starting a\n * fresh lookup. This is useful for intercepting events, performing side\n * effects, and then letting the default handling continue.\n *\n * **Key rule:** When forwarding to a different event type, only Behaviors that\n * were already in the remaining chain AND match the new type will run. This\n * means cross-type `forward` is mostly useful for falling through to default\n * Behaviors, not for triggering user-defined Behaviors of a different type.\n *\n * To trigger all Behaviors for a different event type, use {@link raise}\n * instead.\n *\n * @example\n * ```ts\n * // Intercept and forward same event type\n * defineBehavior({\n *   on: 'insert.text',\n *   actions: [({event}) => [effect(logEvent), forward(event)]],\n * })\n *\n * // Forward to default handling of different event type\n * defineBehavior({\n *   on: 'clipboard.paste',\n *   actions: [\n *     ({event}) => {\n *       const text = event.originEvent.dataTransfer?.getData('text/plain')\n *       return text ? [forward({type: 'insert.text', text})] : []\n *     },\n *   ],\n * })\n * ```\n *\n * @beta\n */\nexport function forward(\n  event: NativeBehaviorEvent | SyntheticBehaviorEvent | CustomBehaviorEvent,\n): PickFromUnion<BehaviorAction, 'type', 'forward'> {\n  return {type: 'forward', event}\n}\n\n/**\n * Raises an event, triggering a fresh lookup of all Behaviors.\n *\n * Use `raise` when you want to trigger an event \"from scratch\", including all\n * Behaviors that match the event type. This is the appropriate action when you\n * want to trigger Behaviors for a different event type.\n *\n * If no Behavior matches the raised event, synthetic events will fall through\n * to their default operation.\n *\n * @example\n * ```ts\n * // Raise a custom event that triggers other Behaviors\n * defineBehavior({\n *   on: 'insert.text',\n *   guard: ({event}) => event.text === 'a',\n *   actions: [() => [raise({type: 'custom.specialInsert'})]],\n * })\n *\n * // Raise a different event type (fresh lookup includes all Behaviors)\n * defineBehavior({\n *   on: 'clipboard.paste',\n *   actions: [\n *     ({event}) => {\n *       const text = event.originEvent.dataTransfer?.getData('text/plain')\n *       return text ? [raise({type: 'insert.text', text})] : []\n *     },\n *   ],\n * })\n * ```\n *\n * @beta\n */\nexport function raise(\n  event: SyntheticBehaviorEvent | CustomBehaviorEvent,\n): PickFromUnion<BehaviorAction, 'type', 'raise'> {\n  return {type: 'raise', event}\n}\n\n/**\n * Performs a side effect.\n *\n * Use `effect` for logging, analytics, async operations, or other side effects.\n *\n * **Note:** Using `effect` alone (without `forward`) will stop event\n * propagation. To perform a side effect while allowing the default Behavior\n * to continue, combine `effect` with `forward`.\n *\n * The effect callback receives a `send` function that can be used to send\n * events back to the editor asynchronously.\n *\n * @example\n * ```ts\n * // Log events while preserving default Behavior\n * defineBehavior({\n *   on: 'insert.text',\n *   actions: [({event}) => [effect(() => console.log(event)), forward(event)]],\n * })\n *\n * // Effect alone stops propagation (native event is cancelled)\n * defineBehavior({\n *   on: 'keyboard.keydown',\n *   actions: [() => [effect(() => console.log('key pressed'))]],\n * })\n *\n * // Async effect that sends an event later\n * defineBehavior({\n *   on: 'custom.save',\n *   actions: [\n *     () => [\n *       effect(async ({send}) => {\n *         await saveDocument()\n *         send({type: 'custom.saved'})\n *       }),\n *     ],\n *   ],\n * })\n * ```\n *\n * @beta\n */\nexport function effect(\n  effect: PickFromUnion<BehaviorAction, 'type', 'effect'>['effect'],\n): PickFromUnion<BehaviorAction, 'type', 'effect'> {\n  return {type: 'effect', effect}\n}\n\n/**\n * @beta\n */\nexport type BehaviorActionSet<TBehaviorEvent, TGuardResponse> = (\n  payload: {\n    snapshot: EditorSnapshot\n    event: TBehaviorEvent\n    dom: EditorDom\n  },\n  guardResponse: TGuardResponse,\n) => Array<BehaviorAction>\n","import type {BehaviorActionSet} from './behavior.types.action'\nimport type {\n  BehaviorEvent,\n  BehaviorEventTypeNamespace,\n  CustomBehaviorEvent,\n  ResolveBehaviorEvent,\n} from './behavior.types.event'\nimport type {BehaviorGuard} from './behavior.types.guard'\n\n/**\n * @beta\n */\nexport type Behavior<\n  TBehaviorEventType extends\n    | '*'\n    | `${BehaviorEventTypeNamespace}.*`\n    | BehaviorEvent['type'] =\n    | '*'\n    | `${BehaviorEventTypeNamespace}.*`\n    | BehaviorEvent['type'],\n  TGuardResponse = true,\n  TBehaviorEvent extends ResolveBehaviorEvent<TBehaviorEventType> =\n    ResolveBehaviorEvent<TBehaviorEventType>,\n> = {\n  /**\n   * Editor Event that triggers this Behavior.\n   */\n  on: TBehaviorEventType\n  /**\n   * Predicate function that determines if the Behavior should be executed.\n   * Returning a non-nullable value from the guard will pass the value to the\n   * actions and execute them.\n   */\n  guard?: BehaviorGuard<TBehaviorEvent, TGuardResponse>\n  /**\n   * Array of Behavior Action sets.\n   * Each set represents a step in the history stack.\n   */\n  actions: Array<BehaviorActionSet<TBehaviorEvent, TGuardResponse>>\n}\n\n/**\n * @beta\n *\n * @example\n *\n * ```tsx\n * const noLowerCaseA = defineBehavior({\n *   on: 'insert.text',\n *   guard: ({event, snapshot}) => event.text === 'a',\n *   actions: [({event, snapshot}) => [{type: 'insert.text', text: 'A'}]],\n * })\n * ```\n *\n */\nexport function defineBehavior<\n  TPayload extends Record<string, unknown>,\n  TBehaviorEventType extends\n    | '*'\n    | `${BehaviorEventTypeNamespace}.*`\n    | BehaviorEvent['type'] = CustomBehaviorEvent['type'],\n  TGuardResponse = true,\n>(\n  behavior: Behavior<\n    TBehaviorEventType,\n    TGuardResponse,\n    ResolveBehaviorEvent<TBehaviorEventType, TPayload>\n  >,\n): Behavior\nexport function defineBehavior<\n  TPayload extends never = never,\n  TBehaviorEventType extends\n    | '*'\n    | `${BehaviorEventTypeNamespace}.*`\n    | BehaviorEvent['type'] = BehaviorEvent['type'],\n  TGuardResponse = true,\n  TBehaviorEvent extends ResolveBehaviorEvent<TBehaviorEventType, TPayload> =\n    ResolveBehaviorEvent<TBehaviorEventType, TPayload>,\n>(\n  behavior: Behavior<TBehaviorEventType, TGuardResponse, TBehaviorEvent>,\n): Behavior {\n  return behavior as unknown as Behavior\n}\n"],"names":["execute","event","type","forward","raise","effect","defineBehavior","behavior"],"mappings":"AAwEO,SAASA,QACdC,OACkD;AAClD,SAAO;AAAA,IAACC,MAAM;AAAA,IAAWD;AAAAA,EAAAA;AAC3B;AAuCO,SAASE,QACdF,OACkD;AAClD,SAAO;AAAA,IAACC,MAAM;AAAA,IAAWD;AAAAA,EAAAA;AAC3B;AAmCO,SAASG,MACdH,OACgD;AAChD,SAAO;AAAA,IAACC,MAAM;AAAA,IAASD;AAAAA,EAAAA;AACzB;AA4CO,SAASI,OACdA,SACiD;AACjD,SAAO;AAAA,IAACH,MAAM;AAAA,IAAUG,QAAAA;AAAAA,EAAAA;AAC1B;ACzIO,SAASC,eAUdC,UACU;AACV,SAAOA;AACT;"}