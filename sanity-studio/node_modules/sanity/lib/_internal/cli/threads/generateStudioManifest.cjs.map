{"version":3,"file":"generateStudioManifest.cjs","sources":["../../../../src/_internal/cli/threads/generateStudioManifest.ts"],"sourcesContent":["import {isMainThread, parentPort, workerData as _workerData} from 'node:worker_threads'\n\nimport {type ClientConfig, createClient, type SanityClient} from '@sanity/client'\nimport debugit from 'debug'\nimport {generateStudioManifest, type StudioManifest, uploadSchema, type Workspace} from 'sanity'\n\nimport {resolveIcon} from '../../manifest/extractWorkspaceManifest'\nimport {getStudioWorkspaces} from '../util/getStudioWorkspaces'\nimport {mockBrowserEnvironment} from '../util/mockBrowserEnvironment'\n\nconst debug = debugit('sanity:cli:generate-studio-manifest')\n\n/** @internal */\nexport interface DeployedCreateSchema {\n  name: string\n  projectId: string\n  dataset: string\n}\n\n/** @internal */\nexport interface DeployStudioWorkerData {\n  workDir: string\n  clientConfig: Partial<ClientConfig>\n  sanityVersion: string\n}\n\n/** @internal */\nexport interface DeployStudioWorkerSuccess {\n  type: 'success'\n  /** The final studio manifest for deployment registration */\n  studioManifest: StudioManifest | null\n}\n\n/** @internal */\nexport interface DeployStudioWorkerError {\n  type: 'error'\n  message: string\n  workspaceName?: string\n}\n\n/** @internal */\nexport type DeployStudioWorkerResult = DeployStudioWorkerSuccess | DeployStudioWorkerError\n\nasync function main() {\n  if (isMainThread || !parentPort) {\n    throw new Error('This module must be run as a worker thread')\n  }\n\n  const opts = _workerData as DeployStudioWorkerData\n  const cleanup = mockBrowserEnvironment(opts.workDir)\n\n  try {\n    // Load workspaces once\n    const workspaces = await getStudioWorkspaces({basePath: opts.workDir})\n\n    if (!workspaces.length) {\n      parentPort.postMessage({\n        type: 'error',\n        message: 'No workspaces found in studio configuration',\n      } satisfies DeployStudioWorkerError)\n      return\n    }\n\n    // Create client from passed config\n    const client = createClient({\n      ...opts.clientConfig,\n      requestTagPrefix: 'sanity.cli.deploy',\n    })\n\n    // Upload schemas to Lexicon and collect descriptor IDs\n    const schemaDescriptorsResult = await uploadSchemasToLexicon(workspaces, client)\n\n    if (schemaDescriptorsResult.type === 'error') {\n      parentPort.postMessage(schemaDescriptorsResult)\n      return\n    }\n\n    const schemaDescriptors = schemaDescriptorsResult.descriptors\n\n    // Generate studio manifest using the shared utility\n    const manifest = await generateStudioManifest({\n      workspaces,\n      resolveSchemaDescriptorId: (workspace) => schemaDescriptors.get(workspace.name),\n      resolveIcon: (workspace) =>\n        resolveIcon({\n          icon: workspace.icon,\n          title: workspace.title,\n          subtitle: workspace.subtitle,\n        }) ?? undefined,\n      bundleVersion: opts.sanityVersion,\n      buildId: JSON.stringify(Date.now()),\n    })\n\n    const result: DeployStudioWorkerSuccess = {\n      type: 'success',\n      // Return null if no workspaces have schema descriptors\n      studioManifest: manifest.workspaces.length === 0 ? null : manifest,\n    }\n\n    parentPort.postMessage(result)\n  } catch (err) {\n    const message = err instanceof Error ? err.message : 'Unknown error occurred'\n    parentPort.postMessage({\n      type: 'error',\n      message,\n    } satisfies DeployStudioWorkerError)\n  } finally {\n    cleanup()\n  }\n}\n\ninterface UploadSchemasSuccess {\n  type: 'success'\n  descriptors: Map<string, string>\n}\n\n/**\n * Uploads schemas to Lexicon and returns workspace name â†’ descriptor ID mapping.\n * Returns a structured result to allow proper error handling.\n */\nasync function uploadSchemasToLexicon(\n  workspaces: Workspace[],\n  client: SanityClient,\n): Promise<UploadSchemasSuccess | DeployStudioWorkerError> {\n  const schemaDescriptors = new Map<string, string>()\n\n  for (const workspace of workspaces) {\n    // Use the workspace's schema directly (already resolved)\n    const workspaceClient = client.withConfig({\n      projectId: workspace.projectId,\n      dataset: workspace.dataset,\n    })\n\n    try {\n      const descriptorId = await uploadSchema(workspace.schema, workspaceClient)\n\n      if (!descriptorId) {\n        return {\n          type: 'error',\n          message: `Failed to get schema descriptor ID for workspace \"${workspace.name}\": upload returned empty result`,\n          workspaceName: workspace.name,\n        }\n      }\n\n      schemaDescriptors.set(workspace.name, descriptorId)\n      debug(\n        `Uploaded schema for workspace \"${workspace.name}\" to Lexicon with descriptor ID: ${descriptorId}`,\n      )\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error'\n      return {\n        type: 'error',\n        message: `Failed to upload schema for workspace \"${workspace.name}\": ${errorMessage}`,\n        workspaceName: workspace.name,\n      }\n    }\n  }\n\n  return {type: 'success', descriptors: schemaDescriptors}\n}\n\nvoid main()\n"],"names":["debug","debugit","main","isMainThread","parentPort","Error","opts","_workerData","cleanup","mockBrowserEnvironment","workDir","workspaces","getStudioWorkspaces","basePath","length","postMessage","type","message","client","createClient","clientConfig","requestTagPrefix","schemaDescriptorsResult","uploadSchemasToLexicon","schemaDescriptors","descriptors","manifest","generateStudioManifest","resolveSchemaDescriptorId","workspace","get","name","resolveIcon","icon","title","subtitle","undefined","bundleVersion","sanityVersion","buildId","JSON","stringify","Date","now","result","studioManifest","err","Map","workspaceClient","withConfig","projectId","dataset","descriptorId","uploadSchema","schema","workspaceName","set","errorMessage"],"mappings":";;;;;;AAUA,MAAMA,QAAQC,iBAAAA,QAAQ,qCAAqC;AAiC3D,eAAeC,OAAO;AACpB,MAAIC,oBAAAA,gBAAgB,CAACC,oBAAAA;AACnB,UAAM,IAAIC,MAAM,4CAA4C;AAG9D,QAAMC,OAAOC,oBAAAA,YACPC,UAAUC,uBAAAA,uBAAuBH,KAAKI,OAAO;AAEnD,MAAI;AAEF,UAAMC,aAAa,MAAMC,wCAAoB;AAAA,MAACC,UAAUP,KAAKI;AAAAA,IAAAA,CAAQ;AAErE,QAAI,CAACC,WAAWG,QAAQ;AACtBV,0BAAAA,WAAWW,YAAY;AAAA,QACrBC,MAAM;AAAA,QACNC,SAAS;AAAA,MAAA,CACwB;AACnC;AAAA,IACF;AAGA,UAAMC,WAASC,OAAAA,aAAa;AAAA,MAC1B,GAAGb,KAAKc;AAAAA,MACRC,kBAAkB;AAAA,IAAA,CACnB,GAGKC,0BAA0B,MAAMC,uBAAuBZ,YAAYO,QAAM;AAE/E,QAAII,wBAAwBN,SAAS,SAAS;AAC5CZ,0BAAAA,WAAWW,YAAYO,uBAAuB;AAC9C;AAAA,IACF;AAEA,UAAME,oBAAoBF,wBAAwBG,aAG5CC,WAAW,MAAMC,OAAAA,uBAAuB;AAAA,MAC5ChB;AAAAA,MACAiB,2BAA4BC,CAAAA,cAAcL,kBAAkBM,IAAID,UAAUE,IAAI;AAAA,MAC9EC,aAAcH,eACZG,qCAAY;AAAA,QACVC,MAAMJ,UAAUI;AAAAA,QAChBC,OAAOL,UAAUK;AAAAA,QACjBC,UAAUN,UAAUM;AAAAA,MAAAA,CACrB,KAAKC;AAAAA,MACRC,eAAe/B,KAAKgC;AAAAA,MACpBC,SAASC,KAAKC,UAAUC,KAAKC,KAAK;AAAA,IAAA,CACnC,GAEKC,SAAoC;AAAA,MACxC5B,MAAM;AAAA;AAAA,MAEN6B,gBAAgBnB,SAASf,WAAWG,WAAW,IAAI,OAAOY;AAAAA,IAAAA;AAG5DtB,wBAAAA,WAAWW,YAAY6B,MAAM;AAAA,EAC/B,SAASE,KAAK;AACZ,UAAM7B,UAAU6B,eAAezC,QAAQyC,IAAI7B,UAAU;AACrDb,wBAAAA,WAAWW,YAAY;AAAA,MACrBC,MAAM;AAAA,MACNC;AAAAA,IAAAA,CACiC;AAAA,EACrC,UAAA;AACET,YAAAA;AAAAA,EACF;AACF;AAWA,eAAee,uBACbZ,YACAO,SACyD;AACzD,QAAMM,wCAAwBuB,IAAAA;AAE9B,aAAWlB,aAAalB,YAAY;AAElC,UAAMqC,kBAAkB9B,QAAO+B,WAAW;AAAA,MACxCC,WAAWrB,UAAUqB;AAAAA,MACrBC,SAAStB,UAAUsB;AAAAA,IAAAA,CACpB;AAED,QAAI;AACF,YAAMC,eAAe,MAAMC,OAAAA,aAAaxB,UAAUyB,QAAQN,eAAe;AAEzE,UAAI,CAACI;AACH,eAAO;AAAA,UACLpC,MAAM;AAAA,UACNC,SAAS,qDAAqDY,UAAUE,IAAI;AAAA,UAC5EwB,eAAe1B,UAAUE;AAAAA,QAAAA;AAI7BP,wBAAkBgC,IAAI3B,UAAUE,MAAMqB,YAAY,GAClDpD,MACE,kCAAkC6B,UAAUE,IAAI,oCAAoCqB,YAAY,EAClG;AAAA,IACF,SAASN,KAAK;AACZ,YAAMW,eAAeX,eAAezC,QAAQyC,IAAI7B,UAAU;AAC1D,aAAO;AAAA,QACLD,MAAM;AAAA,QACNC,SAAS,0CAA0CY,UAAUE,IAAI,MAAM0B,YAAY;AAAA,QACnFF,eAAe1B,UAAUE;AAAAA,MAAAA;AAAAA,IAE7B;AAAA,EACF;AAEA,SAAO;AAAA,IAACf,MAAM;AAAA,IAAWS,aAAaD;AAAAA,EAAAA;AACxC;AAEKtB,KAAAA;"}