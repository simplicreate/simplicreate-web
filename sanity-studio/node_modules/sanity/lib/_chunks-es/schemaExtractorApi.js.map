{"version":3,"file":"schemaExtractorApi.js","sources":["../../src/_internal/cli/actions/schema/extractSchema.telemetry.ts","../../src/_internal/cli/actions/schema/watchExtract.ts","../../src/_internal/cli/actions/schema/schemaExtractorApi.ts"],"sourcesContent":["import {defineTrace} from '@sanity/telemetry'\n\ninterface SchemaExtractedTraceAttrubutes {\n  schemaAllTypesCount: number\n  schemaDocumentTypesCount: number\n  schemaTypesCount: number\n\n  enforceRequiredFields: boolean\n  schemaFormat: string\n}\n\ntype SchemaExtractionWatchModeAttributes =\n  | {\n      step: 'started'\n      enforceRequiredFields: boolean\n      schemaFormat: string\n    }\n  | {\n      step: 'stopped'\n      extractionSuccessfulCount: number\n      extractionFailedCount: number\n      averageExtractionDuration: number\n      watcherDuration: number\n    }\n\nexport const SchemaExtractedTrace = defineTrace<SchemaExtractedTraceAttrubutes>({\n  name: 'Schema Extracted',\n  version: 0,\n  description: 'Trace emitted when extracting schema',\n})\n\nexport const SchemaExtractionWatchModeTrace = defineTrace<SchemaExtractionWatchModeAttributes>({\n  name: 'Schema Extraction Watch Mode Started',\n  version: 0,\n  description: 'Trace emitted when schema extraction watch mode is run',\n})\n","import path from 'node:path'\n\nimport {type CliOutputter} from '@sanity/cli'\nimport chokidar, {type FSWatcher} from 'chokidar'\nimport {debounce} from 'lodash-es'\n\n/** Default glob patterns to watch for schema changes */\nexport const DEFAULT_WATCH_PATTERNS = [\n  'sanity.config.{js,jsx,ts,tsx,mjs}',\n  'schema*/**/*.{js,jsx,ts,tsx,mjs}',\n]\n\n/** Default patterns to ignore when watching */\nconst IGNORED_PATTERNS = [\n  '**/node_modules/**',\n  '**/.git/**',\n  '**/dist/**',\n  '**/lib/**',\n  '**/.sanity/**',\n]\n\ninterface WatchExtractOptions {\n  workDir: string\n  patterns: string[]\n  debounceMs?: number\n  onExtract: () => Promise<void>\n  output: CliOutputter\n}\n\n/** State for tracking extraction status */\nexport interface WatchState {\n  isExtracting: boolean\n  pendingExtraction: boolean\n}\n\n/** Return type for createExtractionRunner */\nexport interface ExtractionRunner {\n  state: WatchState\n  runExtraction: () => Promise<void>\n}\n\n/**\n * Creates an extraction runner with concurrency control.\n * If extraction is already running, queues one more extraction to run after completion.\n * Multiple queued requests are coalesced into a single pending extraction.\n */\nexport function createExtractionRunner(onExtract: () => Promise<void>): ExtractionRunner {\n  const state: WatchState = {\n    isExtracting: false,\n    pendingExtraction: false,\n  }\n\n  async function runExtraction(): Promise<void> {\n    if (state.isExtracting) {\n      state.pendingExtraction = true\n      return\n    }\n\n    state.isExtracting = true\n    state.pendingExtraction = false\n\n    try {\n      await onExtract()\n    } finally {\n      state.isExtracting = false\n\n      // If a change came in during extraction, run again\n      if (state.pendingExtraction) {\n        state.pendingExtraction = false\n        await runExtraction()\n      }\n    }\n  }\n\n  return {state, runExtraction}\n}\n\n/**\n * Creates a file watcher that triggers schema extraction on changes.\n * Implements debouncing and concurrency control to prevent multiple extractions.\n */\nexport async function createSchemaWatcher(options: WatchExtractOptions): Promise<FSWatcher> {\n  const {workDir, patterns, debounceMs = 1000, onExtract, output} = options\n\n  const {runExtraction} = createExtractionRunner(onExtract)\n\n  // Debounced extraction trigger\n  const debouncedExtract = debounce(() => {\n    void runExtraction()\n  }, debounceMs)\n\n  // Build absolute patterns for watching\n  const absolutePatterns = patterns.map((pattern) =>\n    path.isAbsolute(pattern) ? pattern : path.join(workDir, pattern),\n  )\n\n  const watcher = chokidar.watch(absolutePatterns, {\n    ignoreInitial: true,\n    ignored: IGNORED_PATTERNS,\n    cwd: workDir,\n  })\n\n  watcher.on('all', (event, filePath) => {\n    const timestamp = new Date().toLocaleTimeString()\n    const relativePath = path.isAbsolute(filePath) ? path.relative(workDir, filePath) : filePath\n    output.print(`[${timestamp}] ${event}: ${relativePath}`)\n    debouncedExtract()\n  })\n\n  watcher.on('error', (err) => {\n    output.error(`Watcher error: ${err instanceof Error ? err.message : String(err)}`)\n  })\n\n  return watcher\n}\n","import {writeFile} from 'node:fs/promises'\nimport {dirname, join} from 'node:path'\nimport {fileURLToPath} from 'node:url'\nimport {Worker} from 'node:worker_threads'\n\nimport {type CliOutputter} from '@sanity/cli'\nimport {type SchemaValidationProblemGroup} from '@sanity/types'\nimport {type FSWatcher} from 'chokidar'\nimport {type SchemaType} from 'groq-js'\nimport readPkgUp from 'read-pkg-up'\n\nimport {\n  type ExtractSchemaWorkerData,\n  type ExtractSchemaWorkerMessage,\n} from '../../threads/extractSchema'\nimport {formatSchemaValidation} from './formatSchemaValidation'\nimport {createSchemaWatcher, DEFAULT_WATCH_PATTERNS} from './watchExtract'\n\nconst __dirname = dirname(fileURLToPath(import.meta.url))\n\n/** Error thrown when schema extraction fails, includes validation details if available */\nexport class SchemaExtractionError extends Error {\n  validation?: SchemaValidationProblemGroup[]\n\n  constructor(message: string, validation?: SchemaValidationProblemGroup[]) {\n    super(message)\n    this.name = 'SchemaExtractionError'\n    this.validation = validation\n  }\n}\n\n/** Options for extracting schema to a file */\nexport interface ExtractSchemaOptions {\n  workDir: string\n  outputPath: string\n  workspaceName?: string\n  enforceRequiredFields?: boolean\n  format?: string\n}\n\ninterface OnExtractionCallbackData {\n  success: boolean\n  schema?: SchemaType\n  duration: number\n}\n\n/**\n * Extracts schema to a file. Runs in a worker thread for isolation. Returns the extracted schema\n * after the extraction has completed and the file has been written to the file.\n *\n * Throws SchemaExtractionError with validation details if extraction fails.\n */\nexport async function extractSchemaToFile(options: ExtractSchemaOptions) {\n  const {\n    workDir,\n    outputPath,\n    workspaceName,\n    enforceRequiredFields = false,\n    format = 'groq-type-nodes',\n  } = options\n\n  const rootPkgPath = readPkgUp.sync({cwd: __dirname})?.path\n  if (!rootPkgPath) {\n    throw new Error('Could not find root directory for `sanity` package')\n  }\n\n  const workerPath = join(\n    dirname(rootPkgPath),\n    'lib',\n    '_internal',\n    'cli',\n    'threads',\n    'extractSchema.cjs',\n  )\n\n  const worker = new Worker(workerPath, {\n    workerData: {\n      workDir,\n      workspaceName,\n      enforceRequiredFields,\n      format,\n    } satisfies ExtractSchemaWorkerData,\n    env: process.env,\n  })\n\n  const message = await new Promise<ExtractSchemaWorkerMessage>((resolve, reject) => {\n    worker.addListener('message', resolve)\n    worker.addListener('error', reject)\n  })\n\n  if (message.type === 'error') {\n    throw new SchemaExtractionError(message.error, message.validation)\n  }\n\n  await writeFile(outputPath, `${JSON.stringify(message.schema, null, 2)}\\n`)\n\n  return message.schema\n}\n\n/** Options for starting a schema watcher */\nexport interface SchemaWatcherOptions {\n  workDir: string\n  outputPath: string\n  output: CliOutputter\n  workspaceName?: string\n  enforceRequiredFields?: boolean\n  format?: string\n  patterns?: string[]\n  debounceMs?: number\n\n  /** Optional callback function for listening in on the schema extraction */\n  onExtraction?: (result: OnExtractionCallbackData) => void\n}\n\n/** Result from starting a schema watcher */\nexport interface SchemaWatcherResult {\n  /** Call to stop the watcher */\n  stop: () => Promise<void>\n  /** The underlying FSWatcher instance */\n  watcher: FSWatcher\n}\n\n/**\n * Starts a schema watcher that extracts schema on file changes.\n * Runs an initial extraction before starting to watch.\n * Returns a cleanup function to stop the watcher.\n */\nexport async function startSchemaWatcher(\n  options: SchemaWatcherOptions,\n): Promise<SchemaWatcherResult> {\n  const {\n    workDir,\n    outputPath,\n    output,\n    workspaceName,\n    enforceRequiredFields = false,\n    format = 'groq-type-nodes',\n    patterns = DEFAULT_WATCH_PATTERNS,\n    onExtraction,\n  } = options\n\n  // Helper to run extraction with spinner and error display\n  const runExtraction = async (spinnerText: string, successText: string): Promise<boolean> => {\n    const spinner = output.spinner({}).start(spinnerText)\n    const startTime = Date.now()\n\n    try {\n      const schema = await extractSchemaToFile({\n        workDir,\n        outputPath,\n        workspaceName,\n        enforceRequiredFields,\n        format,\n      })\n\n      onExtraction?.({success: true, schema, duration: Date.now() - startTime})\n      spinner.succeed(successText)\n      return true\n    } catch (err) {\n      onExtraction?.({success: false, duration: Date.now() - startTime})\n      spinner.fail(`Extraction failed: ${err instanceof Error ? err.message : String(err)}`)\n      if (err instanceof SchemaExtractionError && err.validation && err.validation.length > 0) {\n        output.print('')\n        output.print(formatSchemaValidation(err.validation))\n      }\n      return false\n    }\n  }\n\n  // Run initial extraction\n  await runExtraction('Extracting schema...', `Extracted schema to ${outputPath}`)\n\n  // Create extraction callback for watch mode\n  const onExtract = async () => {\n    await runExtraction('Extracting schema...', `Extracted schema to ${outputPath}`)\n  }\n\n  // Start watcher\n  const watcher = await createSchemaWatcher({\n    workDir,\n    patterns,\n    onExtract,\n    output,\n  })\n\n  const stop = async () => {\n    await watcher.close()\n  }\n\n  return {stop, watcher}\n}\n\nexport {DEFAULT_WATCH_PATTERNS}\n"],"names":["SchemaExtractedTrace","defineTrace","name","version","description","SchemaExtractionWatchModeTrace","DEFAULT_WATCH_PATTERNS","IGNORED_PATTERNS","createExtractionRunner","onExtract","state","isExtracting","pendingExtraction","runExtraction","createSchemaWatcher","options","workDir","patterns","debounceMs","output","debouncedExtract","debounce","absolutePatterns","map","pattern","path","isAbsolute","join","watcher","chokidar","watch","ignoreInitial","ignored","cwd","on","event","filePath","timestamp","Date","toLocaleTimeString","relativePath","relative","print","err","error","Error","message","String","__dirname","dirname","fileURLToPath","import","url","SchemaExtractionError","constructor","validation","extractSchemaToFile","outputPath","workspaceName","enforceRequiredFields","format","rootPkgPath","readPkgUp","sync","workerPath","worker","Worker","workerData","env","process","Promise","resolve","reject","addListener","type","writeFile","JSON","stringify","schema","startSchemaWatcher","onExtraction","spinnerText","successText","spinner","start","startTime","now","success","duration","succeed","fail","length","formatSchemaValidation","stop","close"],"mappings":"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"}