{"version":3,"file":"helpers.js","sources":["../../src/_internal/cli/actions/deploy/helpers.ts"],"sourcesContent":["import fs from 'node:fs/promises'\nimport path from 'node:path'\nimport {PassThrough} from 'node:stream'\nimport {fileURLToPath} from 'node:url'\nimport {type Gzip} from 'node:zlib'\n\nimport {type CliCommandContext, type CliOutputter} from '@sanity/cli'\nimport {type SanityClient} from '@sanity/client'\nimport FormData from 'form-data'\nimport {customAlphabet} from 'nanoid'\nimport readPkgUp from 'read-pkg-up'\n\nimport {debug as debugIt} from '../../debug'\nimport {determineIsApp} from '../../util/determineIsApp'\nimport {promiseWithResolvers} from '../../util/promiseWithResolvers'\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url))\n\nexport const debug = debugIt.extend('deploy')\n\nexport interface ActiveDeployment {\n  deployedAt: string\n  deployedBy: string\n  isActiveDeployment: boolean\n  isAutoUpdating: boolean | null\n  size: string | null\n  createdAt: string\n  updatedAt: string\n  version: string\n}\n\nexport interface UserApplication {\n  id: string\n  projectId: string | null\n  organizationId: string | null\n  title: string | null\n  appHost: string\n  urlType: 'internal' | 'external'\n  createdAt: string\n  updatedAt: string\n  type: 'studio' | 'coreApp'\n  activeDeployment?: ActiveDeployment | null\n}\n\nexport interface GetUserApplicationsOptions {\n  client: SanityClient\n  organizationId?: string\n}\n\nexport interface GetUserApplicationOptions {\n  client: SanityClient\n  appHost?: string\n  appId?: string\n  isSdkApp?: boolean\n}\nexport async function getUserApplication({\n  client,\n  appHost,\n  appId,\n  isSdkApp,\n}: GetUserApplicationOptions): Promise<UserApplication | null> {\n  let query: undefined | Record<string, string>\n\n  const uri = appId ? `/user-applications/${appId}` : '/user-applications'\n\n  if (isSdkApp) {\n    query = {appType: 'coreApp'}\n  } else if (!appId) {\n    // either request the app by host or get the default app\n    query = appHost ? {appHost} : {default: 'true'}\n  }\n  try {\n    return await client.request({\n      uri,\n      query,\n    })\n  } catch (e) {\n    if (e?.statusCode === 404) {\n      return null\n    }\n\n    debug('Error getting user application', e)\n    throw e\n  }\n}\nexport async function getUserApplications({\n  client,\n  organizationId,\n}: GetUserApplicationsOptions): Promise<UserApplication[] | null> {\n  const query: Record<string, string> = organizationId\n    ? {organizationId: organizationId, appType: 'coreApp'}\n    : {appType: 'studio'}\n  try {\n    return await client.request({\n      uri: '/user-applications',\n      query,\n    })\n  } catch (e) {\n    if (e?.statusCode === 404) {\n      return null\n    }\n\n    debug('Error getting user applications', e)\n    throw e\n  }\n}\n\nfunction createUserApplication(\n  client: SanityClient,\n  body: Pick<UserApplication, 'appHost' | 'urlType' | 'type'> & {\n    title?: string\n  },\n  organizationId?: string,\n): Promise<UserApplication> {\n  const query: Record<string, string> = organizationId\n    ? {organizationId: organizationId, appType: 'coreApp'}\n    : {appType: 'studio'}\n  return client.request({uri: '/user-applications', method: 'POST', body, query})\n}\n\n/**\n * Creates an external studio application.\n * Validates and normalizes the URL before creation.\n *\n * @internal\n */\nasync function createExternalStudio({\n  client,\n  appHost,\n}: {\n  client: SanityClient\n  appHost: string\n}): Promise<UserApplication> {\n  const validationResult = validateUrl(appHost)\n  if (validationResult !== true) {\n    throw new Error(validationResult)\n  }\n\n  const normalizedUrl = normalizeUrl(appHost)\n\n  try {\n    return await createUserApplication(client, {\n      appHost: normalizedUrl,\n      urlType: 'external',\n      type: 'studio',\n    })\n  } catch (e) {\n    debug('Error creating external user application', e)\n    if ([402, 409].includes(e?.statusCode)) {\n      throw new Error(e?.response?.body?.message || 'Bad request', {cause: e})\n    }\n    throw e\n  }\n}\n\ninterface SelectApplicationOptions {\n  client: SanityClient\n  prompt: GetOrCreateUserApplicationOptions['context']['prompt']\n  message: string\n  createNewLabel: string\n  organizationId?: string\n  urlType?: 'internal' | 'external'\n}\n\n/**\n * Shared utility for selecting an existing application or opting to create a new one\n * @internal\n */\nasync function selectExistingApplication({\n  client,\n  prompt,\n  message,\n  createNewLabel,\n  organizationId,\n  urlType,\n}: SelectApplicationOptions): Promise<UserApplication | null> {\n  const allUserApplications = await getUserApplications({client, organizationId})\n\n  // Filter by urlType if specified\n  const userApplications = urlType\n    ? allUserApplications?.filter((app) => app.urlType === urlType)\n    : allUserApplications\n\n  if (!userApplications?.length) {\n    return null\n  }\n\n  const choices = userApplications.map((app) => ({\n    value: app.appHost,\n    name: app.title ?? app.appHost,\n  }))\n\n  const selected = await prompt.single({\n    message,\n    type: 'list',\n    choices: [...choices, new prompt.Separator(), {value: 'new', name: createNewLabel}],\n  })\n\n  if (selected === 'new') {\n    return null\n  }\n\n  return userApplications.find((app) => app.appHost === selected)!\n}\n\nexport interface GetOrCreateUserApplicationOptions {\n  client: SanityClient\n  context: Pick<CliCommandContext, 'output' | 'prompt' | 'cliConfig'>\n  spinner: ReturnType<CliOutputter['spinner']>\n  urlType?: 'internal' | 'external'\n}\n\n/**\n * These functions handle the logic for managing user applications when\n * studioHost is not provided in the CLI config.\n *\n * @internal\n *\n *    +-------------------------------+\n *    |   Fetch Existing user-app?   |\n *    +---------+--------------------+\n *              |\n *        +-----+-----+\n *        |           |\n *        v           v\n *   +---------+  +-------------------------+\n *   | Return  |  | Fetch all user apps     |\n *   | user-app|  +-------------------------+\n *   +---------+            |\n *                          v\n *           +---------------------------+\n *           |  User apps found?         |\n *           +-----------+---------------+\n *                       |\n *                +------v------+\n *                |             |\n *                v             v\n *   +--------------------+  +------------------------+\n *   | Show list and      |  | Prompt for hostname    |\n *   | prompt selection   |  | and create new app     |\n *   +--------------------+  +------------------------+\n */\n\n/**\n * Validates that a URL is a valid HTTP or HTTPS URL\n */\nexport function validateUrl(url: string): true | string {\n  try {\n    const parsed = new URL(url)\n    if (!['http:', 'https:'].includes(parsed.protocol)) {\n      return 'URL must start with http:// or https://'\n    }\n    return true\n  } catch {\n    return 'Please enter a valid URL'\n  }\n}\n\n/**\n * Normalizes an external URL by removing trailing slashes\n */\nexport function normalizeUrl(url: string): string {\n  return url.replace(/\\/+$/, '')\n}\n\nexport async function getOrCreateStudio({\n  client,\n  spinner,\n  context,\n  urlType = 'internal',\n}: GetOrCreateUserApplicationOptions): Promise<UserApplication> {\n  const {output, prompt} = context\n\n  // For external URLs, show existing external studios or prompt for a new URL\n  if (urlType === 'external') {\n    spinner.succeed()\n\n    // Use shared selection helper for existing external studios\n    const selectedApp = await selectExistingApplication({\n      client,\n      prompt,\n      message: 'Select existing external studio or create new',\n      createNewLabel: 'Create new external studio',\n      urlType: 'external',\n    })\n\n    if (selectedApp) {\n      return selectedApp\n    }\n\n    // Prompt for new external URL\n    output.print('Enter the URL to your studio.')\n\n    const {promise, resolve} = promiseWithResolvers<UserApplication>()\n\n    await prompt.single({\n      type: 'input',\n      filter: normalizeUrl,\n      message: 'Studio URL (https://...):',\n      validate: async (externalUrl: string) => {\n        try {\n          const response = await createExternalStudio({client, appHost: externalUrl})\n          resolve(response)\n          return true\n        } catch (e) {\n          // Convert error to string for prompt validation\n          if (e instanceof Error) {\n            return e.message\n          }\n          throw e\n        }\n      },\n    })\n\n    return await promise\n  }\n\n  // if there is already an existing user-app, then just return it\n  const existingUserApplication = await getUserApplication({client})\n\n  // Complete the spinner so prompt can properly work\n  spinner.succeed()\n\n  if (existingUserApplication) {\n    return existingUserApplication\n  }\n\n  const selectedApp = await selectExistingApplication({\n    client,\n    prompt,\n    message: 'Select existing studio hostname',\n    createNewLabel: 'Create new studio hostname',\n    urlType: 'internal',\n  })\n\n  if (selectedApp) {\n    return selectedApp\n  }\n\n  // otherwise, prompt the user for a hostname\n  output.print('Your project has not been assigned a studio hostname.')\n  output.print('To deploy your Sanity Studio to our hosted sanity.studio service,')\n  output.print('you will need one. Please enter the part you want to use.')\n\n  const {promise, resolve} = promiseWithResolvers<UserApplication>()\n\n  await prompt.single({\n    type: 'input',\n    filter: (inp: string) => inp.replace(/\\.sanity\\.studio$/i, ''),\n    message: 'Studio hostname (<value>.sanity.studio):',\n    // if a string is returned here, it is relayed to the user and prompt allows\n    // the user to try again until this function returns true\n    validate: async (appHost: string) => {\n      try {\n        const response = await createUserApplication(client, {\n          appHost,\n          urlType: 'internal',\n          type: 'studio',\n        })\n        resolve(response)\n        return true\n      } catch (e) {\n        // if the name is taken, it should return a 409 so we relay to the user\n        if ([402, 409].includes(e?.statusCode)) {\n          return e?.response?.body?.message || 'Bad request' // just in case\n        }\n\n        debug('Error creating user application', e)\n        // otherwise, it's a fatal error\n        throw e\n      }\n    },\n  })\n\n  return await promise\n}\n\n/**\n * Creates a core application with an auto-generated hostname\n *\n * @internal\n */\nexport async function getOrCreateApplication({\n  client,\n  context,\n  spinner,\n}: GetOrCreateUserApplicationOptions): Promise<UserApplication> {\n  const {prompt, cliConfig} = context\n  const organizationId = cliConfig && 'app' in cliConfig && cliConfig.app?.organizationId\n\n  // Complete the spinner so prompt can properly work\n  spinner.succeed()\n\n  const selectedApp = await selectExistingApplication({\n    client,\n    prompt,\n    message: 'Select an existing deployed application',\n    createNewLabel: 'Create new deployed application',\n    organizationId: organizationId || undefined,\n    urlType: 'internal',\n  })\n\n  if (selectedApp) {\n    return selectedApp\n  }\n\n  // First get the title from the user\n  const title = await prompt.single({\n    type: 'input',\n    message: 'Enter a title for your application:',\n    validate: (input: string) => input.length > 0 || 'Title is required',\n  })\n\n  const {promise, resolve, reject} = promiseWithResolvers<UserApplication>()\n\n  // Try to create the application, retrying with new hostnames if needed\n  const tryCreateApp = async () => {\n    // appHosts have some restrictions (no uppercase, must start with a letter)\n    const generateId = () => {\n      const letters = 'abcdefghijklmnopqrstuvwxyz'\n      const firstChar = customAlphabet(letters, 1)()\n      const rest = customAlphabet('abcdefghijklmnopqrstuvwxyz0123456789', 11)()\n      return `${firstChar}${rest}`\n    }\n\n    // we will likely prepend this with an org ID or other parameter in the future\n    const appHost = generateId()\n\n    try {\n      const response = await createUserApplication(\n        client,\n        {\n          appHost,\n          urlType: 'internal',\n          title,\n          type: 'coreApp',\n        },\n        organizationId || undefined,\n      )\n      resolve(response)\n      return true\n    } catch (e) {\n      // if the name is taken, generate a new one and try again\n      if ([402, 409].includes(e?.statusCode)) {\n        debug('App host taken, retrying with new host')\n        return tryCreateApp()\n      }\n\n      debug('Error creating core application', e)\n      reject(e)\n      // otherwise, it's a fatal error\n      throw e\n    }\n  }\n\n  spinner.start('Creating application')\n\n  await tryCreateApp()\n  const response = await promise\n\n  spinner.succeed()\n  return response\n}\n\nexport interface BaseConfigOptions {\n  client: SanityClient\n  context: Pick<CliCommandContext, 'output' | 'prompt' | 'cliConfig'>\n  spinner: ReturnType<CliOutputter['spinner']>\n  urlType?: 'internal' | 'external'\n}\n\ntype UserApplicationConfigOptions = BaseConfigOptions &\n  (\n    | {\n        /**\n         * @deprecated – appHost is replaced by appId, but kept for backwards compat\n         */\n        appHost: string | undefined\n        appId: undefined\n      }\n    | {\n        appId: string | undefined\n        /**\n         * @deprecated – appHost is replaced by appId, but kept for backwards compat\n         */\n        appHost: undefined\n      }\n  )\n\nasync function getOrCreateStudioFromConfig({\n  client,\n  context,\n  spinner,\n  appHost,\n  appId,\n}: UserApplicationConfigOptions): Promise<UserApplication> {\n  const {output} = context\n\n  // if there is already an existing user-app, then just return it\n  const existingUserApplication = await getUserApplication({client, appId, appHost})\n\n  // Complete the spinner so prompt can properly work\n  spinner.succeed()\n\n  if (existingUserApplication) {\n    return existingUserApplication\n  }\n\n  if (!appHost) {\n    throw new Error(`Application not found. Application with id ${appId} does not exist`)\n  }\n\n  output.print('Your project has not been assigned a studio hostname.')\n  output.print(`Creating https://${appHost}.sanity.studio`)\n  output.print('')\n  spinner.start('Creating studio hostname')\n\n  try {\n    const response = await createUserApplication(client, {\n      appHost,\n      urlType: 'internal',\n      type: 'studio',\n    })\n    spinner.succeed()\n    return response\n  } catch (e) {\n    spinner.fail()\n    // if the name is taken, it should return a 409 so we relay to the user\n    if ([402, 409].includes(e?.statusCode)) {\n      throw new Error(e?.response?.body?.message || 'Bad request', {cause: e}) // just in case\n    }\n    debug('Error creating user application from config', e)\n    // otherwise, it's a fatal error\n    throw e\n  }\n}\n\nasync function getOrCreateAppFromConfig({\n  client,\n  context,\n  spinner,\n  appHost,\n  appId,\n}: UserApplicationConfigOptions): Promise<UserApplication> {\n  const {output, cliConfig} = context\n  if (appId) {\n    const existingUserApplication = await getUserApplication({\n      client,\n      appId,\n      appHost,\n      isSdkApp: determineIsApp(cliConfig),\n    })\n    spinner.succeed()\n\n    if (existingUserApplication) {\n      return existingUserApplication\n    }\n  }\n\n  // custom apps cannot arbitrarily create ids or hosts, so send them to create option\n  output.print('The id provided in your configuration is not recognized.')\n  output.print('Checking existing applications...')\n  return getOrCreateApplication({client, context, spinner})\n}\n\n/**\n * This function handles the logic for managing user applications when\n * studioHost or appId is provided in the CLI config.\n *\n * @internal\n */\nexport async function getOrCreateUserApplicationFromConfig(\n  options: UserApplicationConfigOptions,\n): Promise<UserApplication> {\n  const {client, context, spinner, appId, appHost, urlType} = options\n  const {output} = context\n  const isSdkApp = determineIsApp(context.cliConfig)\n\n  if (isSdkApp) {\n    return getOrCreateAppFromConfig(options)\n  }\n\n  // Handle external URLs: studioHost contains the full URL\n  if (urlType === 'external') {\n    // If appId is provided, look up the existing application by ID\n    if (appId) {\n      const existingUserApplication = await getUserApplication({client, appId})\n\n      spinner.succeed()\n\n      if (existingUserApplication) {\n        return existingUserApplication\n      }\n\n      throw new Error(`Application not found. Application with id ${appId} does not exist`)\n    }\n\n    if (!appHost) {\n      throw new Error(\n        'External deployment requires studioHost to be set in sanity.cli.ts with a full URL, or deployment.appId to reference an existing application',\n      )\n    }\n\n    // Validate and normalize URL for existence check\n    const validationResult = validateUrl(appHost)\n    if (validationResult !== true) {\n      throw new Error(validationResult)\n    }\n    const normalizedUrl = normalizeUrl(appHost)\n\n    // Check if an external application with this URL already exists\n    const existingUserApplication = await getUserApplication({client, appHost: normalizedUrl})\n\n    spinner.succeed()\n\n    if (existingUserApplication) {\n      return existingUserApplication\n    }\n\n    // Create new external studio using shared helper\n    output.print(`Registering external studio at ${normalizedUrl}`)\n    output.print('')\n    spinner.start('Registering external studio URL')\n\n    try {\n      const response = await createExternalStudio({client, appHost: normalizedUrl})\n      spinner.succeed()\n      return response\n    } catch (e) {\n      spinner.fail()\n      throw e\n    }\n  }\n\n  if (!appId && !appHost) {\n    throw new Error(\n      'Studio was detected, but neither appId or appHost (deprecated) found in CLI config',\n    )\n  }\n\n  return getOrCreateStudioFromConfig(options)\n}\n\nexport interface CreateDeploymentOptions {\n  client: SanityClient\n  applicationId: string\n  version: string\n  isAutoUpdating: boolean\n  tarball: Gzip | undefined\n  isSdkApp?: boolean\n  /** StudioManifest to include in the deployment */\n  manifest?: object\n}\n\nexport async function createDeployment({\n  client,\n  tarball,\n  applicationId,\n  isAutoUpdating,\n  version,\n  isSdkApp,\n  manifest,\n}: CreateDeploymentOptions): Promise<{location: string}> {\n  const formData = new FormData()\n  formData.append('isAutoUpdating', isAutoUpdating.toString())\n  formData.append('version', version)\n  // manifest must come before tarball - fastify-multipart's req.file() only captures\n  // fields that appear before the file stream in multipart form data\n  if (manifest) {\n    formData.append('manifest', JSON.stringify(manifest))\n  }\n  if (tarball) {\n    formData.append('tarball', tarball, {contentType: 'application/gzip', filename: 'app.tar.gz'})\n  }\n\n  return client.request({\n    uri: `/user-applications/${applicationId}/deployments`,\n    method: 'POST',\n    headers: formData.getHeaders(),\n    body: formData.pipe(new PassThrough()),\n    query: isSdkApp ? {appType: 'coreApp'} : {appType: 'studio'},\n  })\n}\n\nexport interface DeleteUserApplicationOptions {\n  client: SanityClient\n  applicationId: string\n  appType: 'coreApp' | 'studio'\n}\n\nexport async function deleteUserApplication({\n  applicationId,\n  client,\n  appType,\n}: DeleteUserApplicationOptions): Promise<void> {\n  await client.request({\n    uri: `/user-applications/${applicationId}`,\n    query: {\n      appType,\n    },\n    method: 'DELETE',\n  })\n}\n\nexport async function getInstalledSanityVersion(): Promise<string> {\n  const sanityPkgPath = (await readPkgUp({cwd: __dirname}))?.path\n  if (!sanityPkgPath) {\n    throw new Error('Unable to resolve `sanity` module root')\n  }\n\n  const pkg = JSON.parse(await fs.readFile(sanityPkgPath, 'utf-8'))\n  if (typeof pkg?.version !== 'string') {\n    throw new Error('Unable to find version of `sanity` module')\n  }\n  return pkg.version\n}\n\nexport async function dirIsEmptyOrNonExistent(sourceDir: string): Promise<boolean> {\n  try {\n    const stats = await fs.stat(sourceDir)\n    if (!stats.isDirectory()) {\n      throw new Error(`Directory ${sourceDir} is not a directory`)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return true\n    }\n\n    throw err\n  }\n\n  const content = await fs.readdir(sourceDir)\n  return content.length === 0\n}\n\nexport async function checkDir(sourceDir: string): Promise<void> {\n  try {\n    const stats = await fs.stat(sourceDir)\n    if (!stats.isDirectory()) {\n      throw new Error(`Directory ${sourceDir} is not a directory`)\n    }\n  } catch (err) {\n    const error = err.code === 'ENOENT' ? new Error(`Directory \"${sourceDir}\" does not exist`) : err\n\n    throw error\n  }\n\n  try {\n    await fs.stat(path.join(sourceDir, 'index.html'))\n  } catch (err) {\n    const error =\n      err.code === 'ENOENT'\n        ? new Error(\n            [\n              `\"${sourceDir}/index.html\" does not exist -`,\n              '[SOURCE_DIR] must be a directory containing',\n              'a Sanity studio built using \"sanity build\"',\n            ].join(' '),\n          )\n        : err\n\n    throw error\n  }\n}\n"],"names":["__dirname","path","dirname","fileURLToPath","import","url","debug","debugIt","extend","getUserApplication","client","appHost","appId","isSdkApp","query","uri","appType","default","request","e","statusCode","getUserApplications","organizationId","createUserApplication","body","method","createExternalStudio","validationResult","validateUrl","Error","normalizedUrl","normalizeUrl","urlType","type","includes","response","message","cause","selectExistingApplication","prompt","createNewLabel","allUserApplications","userApplications","filter","app","length","choices","map","value","name","title","selected","single","Separator","find","parsed","URL","protocol","replace","getOrCreateStudio","spinner","context","output","succeed","selectedApp","print","promise","resolve","promiseWithResolvers","validate","externalUrl","existingUserApplication","inp","getOrCreateApplication","cliConfig","undefined","input","reject","tryCreateApp","generateId","firstChar","customAlphabet","rest","start","getOrCreateStudioFromConfig","fail","getOrCreateAppFromConfig","determineIsApp","getOrCreateUserApplicationFromConfig","options","createDeployment","tarball","applicationId","isAutoUpdating","version","manifest","formData","FormData","append","toString","JSON","stringify","contentType","filename","headers","getHeaders","pipe","PassThrough","deleteUserApplication","getInstalledSanityVersion","sanityPkgPath","readPkgUp","cwd","pkg","parse","fs","readFile","dirIsEmptyOrNonExistent","sourceDir","stat","isDirectory","err","code","readdir","checkDir","join"],"mappings":"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"}