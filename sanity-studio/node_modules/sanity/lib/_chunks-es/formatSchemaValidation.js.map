{"version":3,"file":"formatSchemaValidation.js","sources":["../../src/_internal/cli/actions/schema/formatSchemaValidation.ts"],"sourcesContent":["import {isatty} from 'node:tty'\n\nimport {generateHelpUrl} from '@sanity/generate-help-url'\nimport {type SchemaValidationProblemGroup, type SchemaValidationProblemPath} from '@sanity/types'\nimport chalk from 'chalk'\nimport logSymbols from 'log-symbols'\n\nconst isTty = isatty(1)\n\nconst headers = {\n  error: isTty ? chalk.bold(chalk.bgRed(chalk.black(' ERROR '))) : chalk.red('[ERROR]'),\n  warning: isTty ? chalk.bold(chalk.bgYellow(chalk.black(' WARN '))) : chalk.yellow('[WARN]'),\n}\n\nconst severityValues = {error: 0, warning: 1}\n\n/**\n * Formats a schema validation path into a human-readable dot/bracket notation string.\n * e.g. `[{kind: 'type', name: 'post'}, {kind: 'property', name: 'of'}, {kind: 'type', name: 'image'}]`\n * becomes `[image]` (array notation because parent property was 'of').\n */\nfunction formatPath(pathSegments: SchemaValidationProblemPath) {\n  const format = (\n    [curr, ...next]: SchemaValidationProblemPath,\n    mode: 'object' | 'array' = 'object',\n  ): string => {\n    if (!curr) return ''\n    // 'property' segments control notation for the next type segment:\n    // 'of' property means array items, so use bracket notation; otherwise use dot notation\n    if (curr.kind === 'property') return format(next, curr.name === 'of' ? 'array' : 'object')\n\n    const name = curr.name ? curr.name : `<anonymous_${curr.type}>`\n    return `${mode === 'array' ? `[${name}]` : `.${name}`}${format(next)}`\n  }\n\n  // Skip the first segment (top-level type) and trim the leading '.' from the result\n  return format(pathSegments.slice(1)).slice(1)\n}\n\nexport function getAggregatedSeverity(\n  groupOrGroups: SchemaValidationProblemGroup | SchemaValidationProblemGroup[],\n): 'error' | 'warning' {\n  const groups = Array.isArray(groupOrGroups) ? groupOrGroups : [groupOrGroups]\n  return groups\n    .flatMap((group) => group.problems.map((problem) => problem.severity))\n    .find((severity) => severity === 'error')\n    ? 'error'\n    : 'warning'\n}\n\nexport function formatSchemaValidation(validation: SchemaValidationProblemGroup[]): string {\n  let unnamedTopLevelTypeCount = 0\n  // Group validation problems by their top-level schema type (e.g., 'post', 'author')\n  // so errors can be displayed organized by which type they belong to\n  const validationByType = Object.entries(\n    validation.reduce<Record<string, SchemaValidationProblemGroup[]>>((acc, next) => {\n      const [firstSegment] = next.path\n      if (!firstSegment) return acc\n      if (firstSegment.kind !== 'type') return acc\n\n      const topLevelType =\n        firstSegment.name || `<unnamed_${firstSegment.type}_type_${unnamedTopLevelTypeCount++}>`\n      const problems = acc[topLevelType] ?? []\n\n      problems.push(next)\n\n      acc[topLevelType] = problems\n      return acc\n    }, {}),\n  )\n\n  // Sort types by severity (errors first), then alphabetically within each severity level\n  const formatted = validationByType\n    .sort((a, b) => {\n      const [aType, aGroups] = a\n      const [bType, bGroups] = b\n      const aValue = severityValues[getAggregatedSeverity(aGroups)]\n      const bValue = severityValues[getAggregatedSeverity(bGroups)]\n      if (aValue === bValue) return aType.localeCompare(bType, 'en-US')\n      return aValue - bValue\n    })\n    .map(([topLevelType, groups]) => {\n      const formattedTopLevelType = isTty\n        ? chalk.bgWhite(chalk.black(` ${topLevelType} `))\n        : `[${topLevelType}]`\n\n      const header = `${headers[getAggregatedSeverity(groups)]} ${formattedTopLevelType}`\n      const body = groups\n        .sort(\n          (a, b) =>\n            severityValues[getAggregatedSeverity(a)] - severityValues[getAggregatedSeverity(b)],\n        )\n        .map((group) => {\n          const formattedPath = `  ${chalk.bold(formatPath(group.path) || '(root)')}`\n          const formattedMessages = group.problems\n            .sort((a, b) => severityValues[a.severity] - severityValues[b.severity])\n            .map(({severity, message, helpId}) => {\n              const help = helpId ? `\\n      See ${generateHelpUrl(helpId)}` : ''\n              return `    ${logSymbols[severity]} ${message}${help}`\n            })\n            .join('\\n')\n\n          return `${formattedPath}\\n${formattedMessages}`\n        })\n        .join('\\n')\n\n      return `${header}\\n${body}`\n    })\n    .join('\\n\\n')\n\n  return formatted\n}\n"],"names":["isTty","isatty","headers","error","chalk","bold","bgRed","black","red","warning","bgYellow","yellow","severityValues","formatPath","pathSegments","format","curr","next","mode","kind","name","type","slice","getAggregatedSeverity","groupOrGroups","Array","isArray","flatMap","group","problems","map","problem","severity","find","formatSchemaValidation","validation","unnamedTopLevelTypeCount","Object","entries","reduce","acc","firstSegment","path","topLevelType","push","sort","a","b","aType","aGroups","bType","bGroups","aValue","bValue","localeCompare","groups","formattedTopLevelType","bgWhite","header","body","formattedPath","formattedMessages","message","helpId","help","generateHelpUrl","logSymbols","join"],"mappings":"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"}