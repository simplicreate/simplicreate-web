{"version":3,"file":"deployAction2.js","sources":["../../src/_internal/cli/util/extractClientConfig.ts","../../src/_internal/cli/actions/deploy/deployAction.ts"],"sourcesContent":["import {type ClientConfig, type SanityClient} from '@sanity/client'\n\n/**\n * Extracts a serializable client configuration from a SanityClient instance.\n *\n * This is used to pass client configuration to worker threads, which cannot\n * receive non-serializable objects. The worker can then use this config to\n * create its own SanityClient instance.\n *\n * @param client - The SanityClient instance to extract config from\n * @returns A serializable partial ClientConfig\n */\nexport function extractClientConfig(client: SanityClient): Partial<ClientConfig> {\n  const config = client.config()\n\n  // Use JSON.parse/stringify to strip non-serializable properties (functions, etc.)\n  // and add flags needed for worker environment\n  return {\n    ...JSON.parse(JSON.stringify(config)),\n    // Ensure we use project hostname even if the original config didn't require project\n    useProjectHostname: true,\n    // Suppress browser token warning since we mock browser environment in workers\n    ignoreBrowserTokenWarning: true,\n  }\n}\n","/* eslint-disable max-statements */\nimport path from 'node:path'\nimport {fileURLToPath} from 'node:url'\nimport {Worker} from 'node:worker_threads'\nimport zlib from 'node:zlib'\n\nimport {type CliCommandArguments, type CliCommandContext} from '@sanity/cli'\nimport {minutesToMilliseconds} from 'date-fns'\nimport readPkgUp from 'read-pkg-up'\nimport tar from 'tar-fs'\n\nimport {\n  type DeployStudioWorkerResult,\n  type DeployStudioWorkerSuccess,\n} from '../../threads/generateStudioManifest'\nimport {extractClientConfig} from '../../util/extractClientConfig'\nimport {getAppId} from '../../util/getAppId'\nimport {shouldAutoUpdate} from '../../util/shouldAutoUpdate'\nimport buildSanityStudio, {type BuildSanityStudioCommandFlags} from '../build/buildAction'\nimport {deploySchemasAction} from '../schema/deploySchemasAction'\nimport {createManifestExtractor} from '../schema/utils/mainfestExtractor'\nimport {\n  checkDir,\n  createDeployment,\n  debug,\n  dirIsEmptyOrNonExistent,\n  getInstalledSanityVersion,\n  getOrCreateStudio,\n  getOrCreateUserApplicationFromConfig,\n  type UserApplication,\n} from './helpers'\n\nexport interface DeployStudioActionFlags extends BuildSanityStudioCommandFlags {\n  'build'?: boolean\n  'schema-required'?: boolean\n  'verbose'?: boolean\n  'external'?: boolean\n}\n\nexport default async function deployStudioAction(\n  args: CliCommandArguments<DeployStudioActionFlags>,\n  context: CliCommandContext,\n): Promise<void> {\n  const {apiClient, workDir, chalk, output, prompt, cliConfig} = context\n  const flags = {build: true, ...args.extOptions}\n  const customSourceDir = args.argsWithoutOptions[0]\n  const sourceDir = path.resolve(process.cwd(), customSourceDir || path.join(workDir, 'dist'))\n  const isAutoUpdating = shouldAutoUpdate({flags, cliConfig, output})\n  const isExternal = !!flags.external\n  const urlType: 'internal' | 'external' = isExternal ? 'external' : 'internal'\n\n  const installedSanityVersion = await getInstalledSanityVersion()\n\n  const client = apiClient({\n    requireUser: true,\n    requireProject: true,\n  }).withConfig({apiVersion: 'v2024-08-01'})\n\n  if (customSourceDir === 'graphql') {\n    throw new Error('Did you mean `sanity graphql deploy`?')\n  }\n\n  // Skip source directory checks for external deployments\n  if (customSourceDir && !isExternal) {\n    let relativeOutput = path.relative(process.cwd(), sourceDir)\n    if (relativeOutput[0] !== '.') {\n      relativeOutput = `./${relativeOutput}`\n    }\n\n    const isEmpty = await dirIsEmptyOrNonExistent(sourceDir)\n    const shouldProceed =\n      isEmpty ||\n      (await prompt.single({\n        type: 'confirm',\n        message: `\"${relativeOutput}\" is not empty, do you want to proceed?`,\n        default: false,\n      }))\n\n    if (!shouldProceed) {\n      output.print('Cancelled.')\n      return\n    }\n\n    output.print(`Building to ${relativeOutput}\\n`)\n  }\n\n  // Check that the project has a studio hostname\n  let spinner = output.spinner('Checking project info').start()\n\n  const appId = getAppId({cliConfig, output})\n  const configStudioHost = cliConfig && 'studioHost' in cliConfig ? cliConfig.studioHost : undefined\n\n  let userApplication: UserApplication\n  try {\n    // If the user has provided an appId in the config, use that\n    if (appId || configStudioHost) {\n      userApplication = await getOrCreateUserApplicationFromConfig({\n        client,\n        context,\n        spinner,\n        urlType,\n        ...(appId ? {appId, appHost: undefined} : {appId: undefined, appHost: configStudioHost}),\n      })\n    } else {\n      userApplication = await getOrCreateStudio({client, context, spinner, urlType})\n    }\n  } catch (err) {\n    if (err.message) {\n      output.error(chalk.red(err.message))\n      return\n    }\n\n    debug('Error creating user application', err)\n    throw err\n  }\n\n  // Always build the project, unless --no-build is passed or --external is used\n  const shouldBuild = flags.build && !isExternal\n  if (shouldBuild) {\n    const buildArgs = {\n      ...args,\n      extOptions: flags,\n      argsWithoutOptions: [customSourceDir].filter(Boolean),\n    }\n    const {didCompile} = await buildSanityStudio(buildArgs, context, {basePath: '/'})\n\n    if (!didCompile) {\n      return\n    }\n  }\n\n  // Deploy schemas: for internal, always run; for external, only with --schema-required\n  if (!isExternal || flags['schema-required']) {\n    await deploySchemasAction(\n      {\n        // For external, always extract from source (no dist folder)\n        'extract-manifest': isExternal ? true : shouldBuild,\n        'manifest-dir': isExternal ? undefined : `${sourceDir}/static`,\n        'schema-required': flags['schema-required'],\n        'verbose': flags.verbose,\n      },\n      {...context, manifestExtractor: createManifestExtractor(context)},\n    )\n  }\n\n  spinner = output.spinner('Generating studio manifest').start()\n\n  const clientConfig = extractClientConfig(client)\n\n  const {studioManifest} = await runGenerateStudioManifestWorker(\n    workDir,\n    clientConfig,\n    installedSanityVersion,\n    spinner,\n  )\n\n  spinner.succeed('Generated studio manifest')\n\n  if (flags.verbose) {\n    if (studioManifest) {\n      for (const workspace of studioManifest.workspaces) {\n        output.print(\n          chalk.gray(\n            `↳ projectId: ${workspace.projectId}, dataset: ${workspace.dataset}, schemaDescriptorId: ${workspace.schemaDescriptorId}`,\n          ),\n        )\n      }\n    } else {\n      output.print(chalk.gray(`↳ No workspaces found`))\n    }\n  }\n\n  let tarball\n  if (!isExternal) {\n    // Ensure that the directory exists, is a directory and seems to have valid content\n    spinner = output.spinner('Verifying local content').start()\n    try {\n      await checkDir(sourceDir)\n      spinner.succeed()\n    } catch (err) {\n      spinner.fail()\n      debug('Error checking directory', err)\n      throw err\n    }\n\n    // Now create a tarball of the given directory\n    const parentDir = path.dirname(sourceDir)\n    const base = path.basename(sourceDir)\n    tarball = tar.pack(parentDir, {entries: [base]}).pipe(zlib.createGzip())\n  }\n\n  spinner = output.spinner(isExternal ? 'Registering studio' : 'Deploying to sanity.studio').start()\n  try {\n    const {location} = await createDeployment({\n      client,\n      applicationId: userApplication.id,\n      version: installedSanityVersion,\n      isAutoUpdating,\n      tarball,\n      manifest: studioManifest ?? undefined,\n    })\n\n    spinner.succeed()\n\n    // And let the user know we're done\n    if (isExternal) {\n      output.print(`\\nSuccess! Studio registered`)\n    } else {\n      output.print(`\\nSuccess! Studio deployed to ${chalk.cyan(location)}`)\n    }\n\n    if (!appId) {\n      const example = `Example:\nexport default defineCliConfig({\n  //…\n  deployment: {\n    ${chalk.cyan`appId: '${userApplication.id}'`},\n  },\n  //…\n})`\n      output.print(`\\nAdd ${chalk.cyan(`appId: '${userApplication.id}'`)}`)\n      output.print(`to the \\`deployment\\` section in sanity.cli.js or sanity.cli.ts`)\n      output.print(`to avoid prompting for application id on next deploy.`)\n      output.print(`\\n${example}`)\n    }\n  } catch (err) {\n    spinner.fail()\n    debug('Error deploying studio', err)\n    throw err\n  }\n}\n\nconst DEPLOY_WORKER_TIMEOUT_MS = minutesToMilliseconds(5)\nconst DEPLOY_WORKER_TIMEOUT_HUMAN = '5 minutes'\nconst __dirname = path.dirname(fileURLToPath(import.meta.url))\n\n/**\n * Runs the deploy studio worker to process workspaces.\n * The worker loads Workspace[] once and performs all workspace-dependent operations.\n * If the worker fails, the spinner is failed and the error is rethrown.\n */\nasync function runGenerateStudioManifestWorker(\n  workDir: string,\n  clientConfig: ReturnType<typeof extractClientConfig>,\n  sanityVersion: string,\n  spinner: ReturnType<CliCommandContext['output']['spinner']>,\n): Promise<DeployStudioWorkerSuccess> {\n  const rootPkgPath = readPkgUp.sync({cwd: __dirname})?.path\n  if (!rootPkgPath) {\n    throw new Error('Could not find root directory for `sanity` package')\n  }\n\n  const workerPath = path.join(\n    path.dirname(rootPkgPath),\n    'lib',\n    '_internal',\n    'cli',\n    'threads',\n    'generateStudioManifest.cjs',\n  )\n\n  const worker = new Worker(workerPath, {\n    workerData: {\n      workDir,\n      clientConfig,\n      sanityVersion,\n    },\n    env: process.env,\n  })\n\n  let timedOut = false\n  const timeoutId = setTimeout(() => {\n    timedOut = true\n    void worker.terminate()\n  }, DEPLOY_WORKER_TIMEOUT_MS)\n\n  try {\n    const result = await new Promise<DeployStudioWorkerResult>((resolve, reject) => {\n      // Use `once` for automatic listener cleanup after first invocation\n      worker.once('message', (message: DeployStudioWorkerResult) => {\n        resolve(message)\n      })\n      worker.once('error', reject)\n      worker.once('exit', (exitCode) => {\n        // Only reject if we haven't already resolved via message\n        // Non-zero exit without a message indicates an unexpected failure\n        if (exitCode !== 0) {\n          const error = timedOut\n            ? new Error(`Deploy worker was aborted after ${DEPLOY_WORKER_TIMEOUT_HUMAN}`)\n            : new Error(`Deploy worker exited with code ${exitCode}`)\n          reject(error)\n        }\n      })\n    })\n\n    // Handle structured error responses from the worker\n    if (result.type === 'error') {\n      throw new Error(result.message)\n    }\n\n    return result\n  } catch (err) {\n    spinner.fail()\n    debug('Failed to process studio configuration', err)\n    throw err\n  } finally {\n    clearTimeout(timeoutId)\n    // Ensure worker is terminated for cleanup (no-op if already terminated)\n    await worker.terminate()\n  }\n}\n"],"names":["extractClientConfig","client","config","JSON","parse","stringify","useProjectHostname","ignoreBrowserTokenWarning","deployStudioAction","args","context","apiClient","workDir","chalk","output","prompt","cliConfig","flags","build","extOptions","customSourceDir","argsWithoutOptions","sourceDir","path","resolve","process","cwd","join","isAutoUpdating","shouldAutoUpdate","isExternal","external","urlType","installedSanityVersion","getInstalledSanityVersion","requireUser","requireProject","withConfig","apiVersion","Error","relativeOutput","relative","dirIsEmptyOrNonExistent","single","type","message","default","print","spinner","start","appId","getAppId","configStudioHost","studioHost","undefined","userApplication","getOrCreateUserApplicationFromConfig","appHost","getOrCreateStudio","err","error","red","debug","shouldBuild","buildArgs","filter","Boolean","didCompile","buildSanityStudio","basePath","deploySchemasAction","verbose","manifestExtractor","createManifestExtractor","clientConfig","studioManifest","runGenerateStudioManifestWorker","succeed","workspace","workspaces","gray","projectId","dataset","schemaDescriptorId","tarball","checkDir","fail","parentDir","dirname","base","basename","tar","pack","entries","pipe","zlib","createGzip","location","createDeployment","applicationId","id","version","manifest","cyan","example","DEPLOY_WORKER_TIMEOUT_MS","minutesToMilliseconds","DEPLOY_WORKER_TIMEOUT_HUMAN","__dirname","fileURLToPath","import","url","sanityVersion","rootPkgPath","readPkgUp","sync","workerPath","worker","Worker","workerData","env","timedOut","timeoutId","setTimeout","terminate","result","Promise","reject","once","exitCode","clearTimeout"],"mappings":"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"}