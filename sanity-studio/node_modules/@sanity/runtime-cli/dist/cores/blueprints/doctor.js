import { cwd } from 'node:process';
import { readLocalBlueprint, } from '../../actions/blueprints/blueprint.js';
import { getStack } from '../../actions/blueprints/stacks.js';
import config from '../../config.js';
import { capitalize, check, filePathRelativeToCwd, indent, niceId, severe, unsure, } from '../../utils/display/presenters.js';
import { styleText } from '../../utils/style-text.js';
import { createTracedFetch } from '../../utils/traced-fetch.js';
import { validTokenOrErrorMessage } from '../../utils/validated-token.js';
import { blueprintConfigCore } from './config.js';
const diagLookup = {
    online: 'Online',
    tokenValid: 'Authenticated',
    blueprintValid: 'Blueprint valid',
    stackReady: 'Stack ready',
    userHasAccess: 'User has access',
};
export async function blueprintDoctorCore(options) {
    const { bin, log, token, validateResources, flags: { verbose: v, path: p, fix }, } = options;
    const yikes = (s) => {
        log.error(styleText(['bgRedBright', 'whiteBright', 'bold'], ` ${s} `));
    };
    const here = cwd();
    const path = p || here;
    let tokenOrError;
    log.verbose(`Checking ${filePathRelativeToCwd(path)}`);
    // 3 states: null == unknown, true == good, false == bad
    const diagnostics = {};
    for (const key in diagLookup) {
        diagnostics[key] = null;
    }
    // ONLINE
    const fetchFn = createTracedFetch(log);
    try {
        const res = await fetchFn(config.apiUrl);
        if (res.ok) {
            log.verbose(`Successfully pinged ${config.apiUrl}`);
            diagnostics.online = res.ok;
        }
        else {
            yikes(`Failed to ping ${config.apiUrl}: ${res.status} ${res.statusText}`);
            diagnostics.online = false;
        }
    }
    catch {
        yikes(`Failed to ping ${config.apiUrl}`);
    }
    // TOKEN
    if (token) {
        tokenOrError = await validTokenOrErrorMessage(log, token);
        if (tokenOrError.ok) {
            diagnostics.tokenValid = true;
        }
        else {
            yikes(`Token error: ${tokenOrError.error.message}`);
            diagnostics.tokenValid = false;
        }
    }
    else {
        yikes('No authentication token found');
        diagnostics.tokenValid = false;
    }
    // BLUEPRINT file
    let localBlueprint;
    try {
        localBlueprint = await readLocalBlueprint(log, { resources: options.validateResources || false }, path);
        log.verbose(`Found blueprint file at ${filePathRelativeToCwd(localBlueprint.fileInfo.blueprintFilePath)}`);
        if (localBlueprint.errors.length === 0) {
            log.verbose(`Blueprint has no errors`);
            diagnostics.blueprintValid = true;
        }
        else {
            log.verbose(`Blueprint errors: \n${localBlueprint.errors.join('\n  ')}`);
            diagnostics.blueprintValid = false;
        }
    }
    catch {
        yikes(`Unable to read blueprint`);
        diagnostics.blueprintValid = false;
    }
    if (localBlueprint) {
        const { scopeType, scopeId, stackId, sources } = localBlueprint;
        const sourceLabel = (source) => {
            switch (source) {
                case 'env':
                    return 'environment';
                case 'module':
                    return 'blueprint module';
                case 'config':
                    return 'config file';
                case 'inferred':
                    return 'inferred';
                default:
                    return 'unknown';
            }
        };
        if (scopeType && scopeId) {
            const scopeSourceKey = scopeType === 'project' ? 'projectId' : 'organizationId';
            log.verbose(indent(`${capitalize(scopeType)}: ${niceId(scopeId)} (from ${sourceLabel(sources?.[scopeSourceKey])})`));
        }
        if (stackId) {
            log.verbose(indent(`Deployment: ${niceId(stackId)} (from ${sourceLabel(sources?.stackId)})`));
        }
        // STACK + ACCESS
        if (diagnostics.online && diagnostics.tokenValid && token && stackId && scopeType && scopeId) {
            const stackResponse = await getStack({
                auth: { token, scopeType, scopeId },
                stackId,
                logger: log,
            });
            if (stackResponse.ok) {
                log.verbose(`Deployment "Stack" ${niceId(stackId)} ready`);
                diagnostics.stackReady = true;
                diagnostics.userHasAccess = true;
            }
            else if (stackResponse.response?.status === 404) {
                yikes(`Deployment "Stack" <${stackId}> not found`);
                diagnostics.stackReady = false;
            }
            else if (stackResponse.response?.status === 403 || stackResponse.response?.status === 401) {
                yikes(`User does not have access to "Stack" <${stackId}>`);
                diagnostics.userHasAccess = false;
            }
            else {
                yikes(`Unknown error with "Stack" <${stackId}>: ${stackResponse.error}`);
            }
        }
        else {
            if (!stackId)
                yikes(`Blueprints configuration is missing a Stack ID`);
            if (scopeType === 'project') {
                if (!scopeId)
                    yikes(`Blueprints configuration is missing a Project ID`);
            }
            else if (scopeType === 'organization') {
                if (!scopeId)
                    yikes(`Blueprints configuration is missing an Organization ID`);
            }
            else {
                if (!scopeType)
                    yikes(`Blueprints configuration is missing a Scope Type`);
                if (!scopeId)
                    yikes(`Blueprints configuration is missing a Scope ID`);
            }
        }
    }
    log('');
    let allGood = true;
    for (const [key, value] of Object.entries(diagnostics)) {
        switch (value) {
            case true:
                log(check(diagLookup[key]));
                break;
            case false:
                allGood = false;
                log(severe(diagLookup[key]));
                break;
            case null:
                allGood = false;
                log(unsure(diagLookup[key]));
                break;
            default:
                allGood = false;
                log(severe(`${key} is ${value}`));
        }
    }
    const errorMessage = 'One or more checks failed';
    if (allGood) {
        log(styleText(['bold', 'green'], 'All checks passed'));
        if (fix)
            log(styleText(['bold', 'yellow'], 'Nothing to fix; --fix flag is ignored'));
        return { success: true, data: { diagnostics } };
    }
    else if (fix) {
        if (p) {
            return {
                success: false,
                error: `${errorMessage}. --fix cannot be used with --path`,
                data: { diagnostics },
            };
        }
        if (!tokenOrError) {
            return {
                success: false,
                error: `${errorMessage}. Unable to fix: Missing authentication token`,
                data: { diagnostics },
            };
        }
        if (tokenOrError?.ok === false) {
            return {
                success: false,
                error: `${errorMessage}. Unable to fix: ${tokenOrError.error.message}`,
                data: { diagnostics },
            };
        }
        if (!localBlueprint) {
            return {
                success: false,
                error: `${errorMessage}. Unable to fix: Blueprint is missing or invalid`,
                data: { diagnostics },
            };
        }
        return blueprintConfigCore({
            bin,
            log,
            token: tokenOrError.value,
            blueprint: localBlueprint,
            validateResources,
            flags: { edit: true, verbose: v },
        });
    }
    return { success: false, error: errorMessage, data: { diagnostics } };
}
