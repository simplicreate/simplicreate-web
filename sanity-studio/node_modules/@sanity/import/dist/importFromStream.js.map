{"version":3,"sources":["../src/importFromStream.ts"],"sourcesContent":["import os from 'node:os'\nimport path from 'node:path'\nimport {Transform} from 'node:stream'\nimport {pipeline} from 'node:stream/promises'\n\nimport createDebug from 'debug'\nimport gunzipMaybe from 'gunzip-maybe'\nimport tar from 'tar-fs'\nimport {glob} from 'tinyglobby'\n\nimport type {ImportOptions, ImportResult, SanityDocument} from './types.js'\nimport {getJsonStreamer} from './util/getJsonStreamer.js'\nimport {isTar} from './util/isTar.js'\n\nconst debug = createDebug('sanity:import:stream')\n\ninterface ImportersContext {\n  fromStream: (\n    stream: NodeJS.ReadableStream,\n    options: ImportOptions,\n    importers: ImportersContext,\n  ) => Promise<ImportResult>\n  fromArray: (documents: SanityDocument[], options: ImportOptions) => Promise<ImportResult>\n  fromFolder: (\n    fromDir: string,\n    options: ImportOptions & {deleteOnComplete?: boolean},\n    importers: ImportersContext,\n  ) => Promise<ImportResult>\n}\n\n// StreamRouter handles the peek functionality and routes to appropriate handler\nclass StreamRouter extends Transform {\n  private firstChunk: Buffer | null = null\n  private outputPath: string\n  private options: ImportOptions\n  private targetStream: NodeJS.WritableStream | null = null\n  private jsonDocuments: SanityDocument[] = []\n  private isTarFile = false\n\n  constructor(outputPath: string, options: ImportOptions) {\n    super()\n    this.outputPath = outputPath\n    this.options = options\n  }\n\n  get isTar(): boolean {\n    return this.isTarFile\n  }\n\n  get documents(): SanityDocument[] {\n    return this.jsonDocuments\n  }\n\n  _transform(chunk: Buffer, _encoding: BufferEncoding, callback: (error?: Error | null) => void) {\n    if (!this.firstChunk) {\n      this.firstChunk = chunk\n\n      // Determine file type from first chunk\n      if (isTar(chunk)) {\n        debug('Stream is a tarball, extracting to %s', this.outputPath)\n        this.isTarFile = true\n        // tar.extract returns a writable stream for extracting files\n        this.targetStream = tar.extract(this.outputPath)\n      } else {\n        debug('Stream is an ndjson file, streaming JSON')\n        this.isTarFile = false\n        const jsonStreamer = getJsonStreamer({\n          allowReplacementCharacters: this.options.allowReplacementCharacters,\n        })\n        this.targetStream = jsonStreamer\n\n        // Collect documents as they're parsed\n        jsonStreamer.on('data', (doc: SanityDocument) => {\n          this.jsonDocuments.push(doc)\n        })\n      }\n\n      // Set up error handling\n      if (this.targetStream) {\n        this.targetStream.on('error', (err: Error) => {\n          this.emit('error', err)\n        })\n      }\n    }\n\n    if (this.targetStream) {\n      const written = this.targetStream.write(chunk)\n      if (written) {\n        callback()\n      } else {\n        this.targetStream.once('drain', callback)\n      }\n    } else {\n      callback(new Error('Target stream not initialized'))\n    }\n  }\n\n  _flush(callback: (error?: Error | null) => void) {\n    if (this.targetStream) {\n      this.targetStream.end()\n      this.targetStream.on('finish', callback)\n      this.targetStream.on('error', callback)\n    } else {\n      callback()\n    }\n  }\n}\n\nexport async function importFromStream(\n  stream: NodeJS.ReadableStream,\n  options: ImportOptions,\n  importers: ImportersContext,\n): Promise<ImportResult> {\n  const slugDate = new Date()\n    .toISOString()\n    .replace(/[^a-z0-9]/gi, '-')\n    .toLowerCase()\n\n  const outputPath = path.join(os.tmpdir(), `sanity-import-${slugDate}`)\n  debug('Importing from stream')\n\n  const router = new StreamRouter(outputPath, options)\n\n  try {\n    // gunzipMaybe is an untyped library\n     \n    await pipeline(stream, gunzipMaybe(), router)\n\n    if (router.isTar) {\n      return await findAndImportFromTar(outputPath, options, importers)\n    }\n    return await importers.fromArray(router.documents, options)\n  } catch (err) {\n    throw err instanceof Error ? err : new Error(String(err))\n  }\n}\n\nasync function findAndImportFromTar(\n  outputPath: string,\n  options: ImportOptions,\n  importers: ImportersContext,\n): Promise<ImportResult> {\n  debug('Tarball extracted, looking for ndjson')\n\n  const files = await glob(['**/*.ndjson'], {cwd: outputPath, deep: 2, absolute: true})\n  if (!files.length) {\n    throw new Error('ndjson-file not found in tarball')\n  }\n\n  const importBaseDir = path.dirname(files[0]!)\n  return importers.fromFolder(importBaseDir, {...options, deleteOnComplete: true}, importers)\n}\n"],"names":["os","path","Transform","pipeline","createDebug","gunzipMaybe","tar","glob","getJsonStreamer","isTar","debug","StreamRouter","firstChunk","outputPath","options","targetStream","jsonDocuments","isTarFile","documents","_transform","chunk","_encoding","callback","extract","jsonStreamer","allowReplacementCharacters","on","doc","push","err","emit","written","write","once","Error","_flush","end","importFromStream","stream","importers","slugDate","Date","toISOString","replace","toLowerCase","join","tmpdir","router","findAndImportFromTar","fromArray","String","files","cwd","deep","absolute","length","importBaseDir","dirname","fromFolder","deleteOnComplete"],"mappings":"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"}