{"version":3,"sources":["../../src/util/getHashedBufferForUri.ts"],"sourcesContent":["import {createHash} from 'node:crypto'\nimport {open} from 'node:fs/promises'\nimport {finished} from 'node:stream/promises'\nimport {fileURLToPath} from 'node:url'\n\nimport {getIt} from 'get-it'\nimport {promise} from 'get-it/middleware'\nimport {getUri} from 'get-uri'\n\nimport type {GetItResponse} from '../types.js'\nimport {retryOnFailure} from './retryOnFailure.js'\nimport {isReadableStream} from './streamTypeGuards.js'\n\nconst request = getIt([promise()])\n\ninterface HashedBuffer {\n  buffer: Buffer\n  sha1hash: string\n}\n\nexport const getHashedBufferForUri = (uri: string): Promise<HashedBuffer> =>\n  retryOnFailure(() => getHashedBufferForUriInternal(uri))\n\nasync function getHashedBufferForUriInternal(uri: string): Promise<HashedBuffer> {\n  // Handle file:// URIs directly to properly manage FileHandle lifecycle.\n  // The get-uri package has a bug where it extracts the numeric fd from a FileHandle\n  // and passes it to createReadStream, but never closes the FileHandle itself.\n  // This causes EBADF errors in Node.js 22+ when the FileHandle is garbage collected.\n  if (/^file:\\/\\//i.test(uri)) {\n    return getHashedBufferForFileUri(uri)\n  }\n\n  const stream = await getStream(uri)\n  const hash = createHash('sha1')\n  const chunks: Buffer[] = []\n\n  try {\n    stream.on('data', (chunk: Buffer) => {\n      chunks.push(chunk)\n      hash.update(chunk)\n    })\n\n    await finished(stream)\n    return {\n      buffer: Buffer.concat(chunks),\n      sha1hash: hash.digest('hex'),\n    }\n  } finally {\n    // Explicitly destroy the stream to ensure cleanup\n    if ('destroy' in stream && typeof stream.destroy === 'function') {\n      stream.destroy()\n    }\n  }\n}\n\n/**\n * Handle file:// URIs with proper FileHandle management to avoid EBADF errors.\n * We use fs.promises.readFile which properly manages the FileHandle internally.\n */\nasync function getHashedBufferForFileUri(uri: string): Promise<HashedBuffer> {\n  const filepath = fileURLToPath(uri)\n  const fileHandle = await open(filepath, 'r')\n\n  try {\n    const buffer = await fileHandle.readFile()\n    const hash = createHash('sha1')\n    hash.update(buffer)\n    return {\n      buffer,\n      sha1hash: hash.digest('hex'),\n    }\n  } finally {\n    await fileHandle.close()\n  }\n}\n\nasync function getStream(uri: string): Promise<NodeJS.ReadableStream> {\n  const isHttp = /^https?:\\/\\//i.test(uri)\n  const parsed = new URL(uri)\n  if (isHttp) {\n    const res = (await request({url: parsed.href, stream: true})) as GetItResponse\n    return res.body\n  }\n\n  // For ftp, data urls (file:// is handled separately above)\n  try {\n    const stream = await getUri(uri)\n    if (!isReadableStream(stream)) {\n      throw new Error(`Invalid stream type returned for URI: ${uri}`)\n    }\n    return stream\n  } catch (err) {\n    throw new Error(readError(uri, err as Error))\n  }\n}\n\nfunction readError(uri: string, err: Error): string {\n  return `Error while fetching asset from \"${uri}\":\\n${err.message}`\n}\n"],"names":["createHash","open","finished","fileURLToPath","getIt","promise","getUri","retryOnFailure","isReadableStream","request","getHashedBufferForUri","uri","getHashedBufferForUriInternal","test","getHashedBufferForFileUri","stream","getStream","hash","chunks","on","chunk","push","update","buffer","Buffer","concat","sha1hash","digest","destroy","filepath","fileHandle","readFile","close","isHttp","parsed","URL","res","url","href","body","Error","err","readError","message"],"mappings":"AAAA,SAAQA,UAAU,QAAO,cAAa;AACtC,SAAQC,IAAI,QAAO,mBAAkB;AACrC,SAAQC,QAAQ,QAAO,uBAAsB;AAC7C,SAAQC,aAAa,QAAO,WAAU;AAEtC,SAAQC,KAAK,QAAO,SAAQ;AAC5B,SAAQC,OAAO,QAAO,oBAAmB;AACzC,SAAQC,MAAM,QAAO,UAAS;AAG9B,SAAQC,cAAc,QAAO,sBAAqB;AAClD,SAAQC,gBAAgB,QAAO,wBAAuB;AAEtD,MAAMC,UAAUL,MAAM;IAACC;CAAU;AAOjC,OAAO,MAAMK,wBAAwB,CAACC,MACpCJ,eAAe,IAAMK,8BAA8BD,MAAK;AAE1D,eAAeC,8BAA8BD,GAAW;IACtD,wEAAwE;IACxE,mFAAmF;IACnF,6EAA6E;IAC7E,oFAAoF;IACpF,IAAI,cAAcE,IAAI,CAACF,MAAM;QAC3B,OAAOG,0BAA0BH;IACnC;IAEA,MAAMI,SAAS,MAAMC,UAAUL;IAC/B,MAAMM,OAAOjB,WAAW;IACxB,MAAMkB,SAAmB,EAAE;IAE3B,IAAI;QACFH,OAAOI,EAAE,CAAC,QAAQ,CAACC;YACjBF,OAAOG,IAAI,CAACD;YACZH,KAAKK,MAAM,CAACF;QACd;QAEA,MAAMlB,SAASa;QACf,OAAO;YACLQ,QAAQC,OAAOC,MAAM,CAACP;YACtBQ,UAAUT,KAAKU,MAAM,CAAC;QACxB;IACF,SAAU;QACR,kDAAkD;QAClD,IAAI,aAAaZ,UAAU,OAAOA,OAAOa,OAAO,KAAK,YAAY;YAC/Db,OAAOa,OAAO;QAChB;IACF;AACF;AAEA;;;CAGC,GACD,eAAed,0BAA0BH,GAAW;IAClD,MAAMkB,WAAW1B,cAAcQ;IAC/B,MAAMmB,aAAa,MAAM7B,KAAK4B,UAAU;IAExC,IAAI;QACF,MAAMN,SAAS,MAAMO,WAAWC,QAAQ;QACxC,MAAMd,OAAOjB,WAAW;QACxBiB,KAAKK,MAAM,CAACC;QACZ,OAAO;YACLA;YACAG,UAAUT,KAAKU,MAAM,CAAC;QACxB;IACF,SAAU;QACR,MAAMG,WAAWE,KAAK;IACxB;AACF;AAEA,eAAehB,UAAUL,GAAW;IAClC,MAAMsB,SAAS,gBAAgBpB,IAAI,CAACF;IACpC,MAAMuB,SAAS,IAAIC,IAAIxB;IACvB,IAAIsB,QAAQ;QACV,MAAMG,MAAO,MAAM3B,QAAQ;YAAC4B,KAAKH,OAAOI,IAAI;YAAEvB,QAAQ;QAAI;QAC1D,OAAOqB,IAAIG,IAAI;IACjB;IAEA,2DAA2D;IAC3D,IAAI;QACF,MAAMxB,SAAS,MAAMT,OAAOK;QAC5B,IAAI,CAACH,iBAAiBO,SAAS;YAC7B,MAAM,IAAIyB,MAAM,CAAC,sCAAsC,EAAE7B,KAAK;QAChE;QACA,OAAOI;IACT,EAAE,OAAO0B,KAAK;QACZ,MAAM,IAAID,MAAME,UAAU/B,KAAK8B;IACjC;AACF;AAEA,SAASC,UAAU/B,GAAW,EAAE8B,GAAU;IACxC,OAAO,CAAC,iCAAiC,EAAE9B,IAAI,IAAI,EAAE8B,IAAIE,OAAO,EAAE;AACpE"}