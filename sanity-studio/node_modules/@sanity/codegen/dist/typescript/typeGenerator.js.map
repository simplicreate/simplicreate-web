{"version":3,"sources":["../../src/typescript/typeGenerator.ts"],"sourcesContent":["/* eslint-disable unicorn/consistent-function-scoping */\nimport process from 'node:process'\n\nimport * as t from '@babel/types'\nimport {type WorkerChannel, type WorkerChannelReporter} from '@sanity/worker-channels'\nimport {type SchemaType} from 'groq-js'\nimport {createSelector} from 'reselect'\n\nimport {resultSuffix} from '../casing.js'\nimport {\n  ALL_SANITY_SCHEMA_TYPES,\n  ARRAY_OF,\n  INTERNAL_REFERENCE_SYMBOL,\n  SANITY_QUERIES,\n} from './constants.js'\nimport {\n  computeOnce,\n  generateCode,\n  getUniqueIdentifierForName,\n  normalizePrintablePath,\n} from './helpers.js'\nimport {SchemaTypeGenerator} from './schemaTypeGenerator.js'\nimport {\n  type EvaluatedModule,\n  type EvaluatedQuery,\n  type ExtractedModule,\n  QueryEvaluationError,\n  type QueryExtractionError,\n} from './types.js'\n\nexport type TypegenWorkerChannel = WorkerChannel.Definition<{\n  evaluatedModules: WorkerChannel.Stream<EvaluatedModule>\n  generatedQueryTypes: WorkerChannel.Event<{\n    queryMapDeclaration: {ast: t.Program; code: string}\n  }>\n  generatedSchemaTypes: WorkerChannel.Event<{\n    allSanitySchemaTypesDeclaration: {\n      ast: t.ExportNamedDeclaration\n      code: string\n      id: t.Identifier\n    }\n    internalReferenceSymbol: {\n      ast: t.ExportNamedDeclaration\n      code: string\n      id: t.Identifier\n    }\n    schemaTypeDeclarations: {\n      ast: t.ExportNamedDeclaration\n      code: string\n      id: t.Identifier\n      name: string\n      tsType: t.TSType\n    }[]\n  }>\n}>\n\nexport interface GenerateTypesOptions {\n  schema: SchemaType\n\n  overloadClientMethods?: boolean\n  queries?: AsyncIterable<ExtractedModule>\n  reporter?: WorkerChannelReporter<TypegenWorkerChannel>\n  root?: string\n  schemaPath?: string\n}\n\ntype GetEvaluatedModulesOptions = GenerateTypesOptions & {\n  schemaTypeDeclarations: ReturnType<TypeGenerator['getSchemaTypeDeclarations']>\n  schemaTypeGenerator: SchemaTypeGenerator\n}\ntype GetQueryMapDeclarationOptions = GenerateTypesOptions & {\n  evaluatedModules: EvaluatedModule[]\n}\n\n/**\n * A class used to generate TypeScript types from a given schema\n * @beta\n */\nexport class TypeGenerator {\n  private getSchemaTypeGenerator = createSelector(\n    [(options: GenerateTypesOptions) => options.schema],\n\n    (schema) => new SchemaTypeGenerator(schema),\n  )\n\n  private getSchemaTypeDeclarations = createSelector(\n    [\n      (options: GenerateTypesOptions) => options.root,\n      (options: GenerateTypesOptions) => options.schemaPath,\n      this.getSchemaTypeGenerator,\n    ],\n\n    (root = process.cwd(), schemaPath, schema) =>\n      [...schema].map(({id, name, tsType}, index) => {\n        const typeAlias = t.tsTypeAliasDeclaration(id, null, tsType)\n        let ast = t.exportNamedDeclaration(typeAlias)\n\n        if (index === 0 && schemaPath) {\n          ast = t.addComments(ast, 'leading', [\n            {type: 'CommentLine', value: ` Source: ${normalizePrintablePath(root, schemaPath)}`},\n          ])\n        }\n        const code = generateCode(ast)\n        return {ast, code, id, name, tsType}\n      }),\n  )\n\n  private getAllSanitySchemaTypesDeclaration = createSelector(\n    [this.getSchemaTypeDeclarations],\n    (schemaTypes) => {\n      const ast = t.exportNamedDeclaration(\n        t.tsTypeAliasDeclaration(\n          ALL_SANITY_SCHEMA_TYPES,\n          null,\n          schemaTypes.length > 0\n            ? t.tsUnionType(schemaTypes.map(({id}) => t.tsTypeReference(id)))\n            : t.tsNeverKeyword(),\n        ),\n      )\n      const code = generateCode(ast)\n\n      return {ast, code, id: ALL_SANITY_SCHEMA_TYPES}\n    },\n  )\n\n  private getArrayOfDeclaration = computeOnce(() => {\n    // Creates: type ArrayOf<T> = Array<T & { _key: string }>;\n    const typeParam = t.tsTypeParameter(null, null, 'T')\n    const intersectionType = t.tsIntersectionType([\n      t.tsTypeReference(t.identifier('T')),\n      t.tsTypeLiteral([\n        t.tsPropertySignature(t.identifier('_key'), t.tsTypeAnnotation(t.tsStringKeyword())),\n      ]),\n    ])\n    const arrayType = t.tsTypeReference(\n      t.identifier('Array'),\n      t.tsTypeParameterInstantiation([intersectionType]),\n    )\n\n    const ast = t.tsTypeAliasDeclaration(\n      ARRAY_OF,\n      t.tsTypeParameterDeclaration([typeParam]),\n      arrayType,\n    )\n    const code = generateCode(ast)\n\n    return {ast, code, id: ARRAY_OF}\n  })\n\n  private getInternalReferenceSymbolDeclaration = computeOnce(() => {\n    const typeOperator = t.tsTypeOperator(t.tsSymbolKeyword(), 'unique')\n\n    const id = INTERNAL_REFERENCE_SYMBOL\n    id.typeAnnotation = t.tsTypeAnnotation(typeOperator)\n\n    const declaration = t.variableDeclaration('const', [t.variableDeclarator(id)])\n    declaration.declare = true\n    const ast = t.exportNamedDeclaration(declaration)\n    const code = generateCode(ast)\n\n    return {ast, code, id}\n  })\n\n  private static async getEvaluatedModules({\n    queries: extractedModules,\n    reporter: report,\n    root = process.cwd(),\n    schemaTypeDeclarations,\n    schemaTypeGenerator,\n  }: GetEvaluatedModulesOptions) {\n    if (!extractedModules) {\n      report?.stream.evaluatedModules.end()\n      return []\n    }\n\n    const currentIdentifiers = new Set<string>(schemaTypeDeclarations.map(({id}) => id.name))\n    const evaluatedModuleResults: EvaluatedModule[] = []\n\n    for await (const {filename, ...extractedModule} of extractedModules) {\n      const queries: EvaluatedQuery[] = []\n      const errors: (QueryEvaluationError | QueryExtractionError)[] = [...extractedModule.errors]\n\n      for (const extractedQuery of extractedModule.queries) {\n        const {variable} = extractedQuery\n        try {\n          const {stats, tsType} = schemaTypeGenerator.evaluateQuery(extractedQuery)\n          const id = getUniqueIdentifierForName(resultSuffix(variable.id.name), currentIdentifiers)\n          const typeAlias = t.tsTypeAliasDeclaration(id, null, tsType)\n          const trimmedQuery = extractedQuery.query.replaceAll(/(\\r\\n|\\n|\\r)/gm, '').trim()\n          const ast = t.addComments(t.exportNamedDeclaration(typeAlias), 'leading', [\n            {type: 'CommentLine', value: ` Source: ${normalizePrintablePath(root, filename)}`},\n            {type: 'CommentLine', value: ` Variable: ${variable.id.name}`},\n            {type: 'CommentLine', value: ` Query: ${trimmedQuery}`},\n          ])\n\n          const evaluatedQueryResult: EvaluatedQuery = {\n            ast,\n            code: generateCode(ast),\n            id,\n            stats,\n            tsType,\n            ...extractedQuery,\n          }\n\n          currentIdentifiers.add(id.name)\n          queries.push(evaluatedQueryResult)\n        } catch (cause) {\n          errors.push(new QueryEvaluationError({cause, filename, variable}))\n        }\n      }\n\n      const evaluatedModule: EvaluatedModule = {\n        errors,\n        filename,\n        queries,\n      }\n      report?.stream.evaluatedModules.emit(evaluatedModule)\n      evaluatedModuleResults.push(evaluatedModule)\n    }\n    report?.stream.evaluatedModules.end()\n\n    return evaluatedModuleResults\n  }\n\n  private static async getQueryMapDeclaration({\n    evaluatedModules,\n    overloadClientMethods = true,\n  }: GetQueryMapDeclarationOptions) {\n    if (!overloadClientMethods) return {ast: t.program([]), code: ''}\n\n    const queries = evaluatedModules.flatMap((module) => module.queries)\n    if (queries.length === 0) return {ast: t.program([]), code: ''}\n\n    const typesByQuerystring: {[query: string]: string[]} = {}\n    for (const {id, query} of queries) {\n      typesByQuerystring[query] ??= []\n      typesByQuerystring[query].push(id.name)\n    }\n\n    const queryReturnInterface = t.tsInterfaceDeclaration(\n      SANITY_QUERIES,\n      null,\n      [],\n      t.tsInterfaceBody(\n        Object.entries(typesByQuerystring).map(([query, types]) => {\n          return t.tsPropertySignature(\n            t.stringLiteral(query),\n            t.tsTypeAnnotation(\n              types.length > 0\n                ? t.tsUnionType(types.map((type) => t.tsTypeReference(t.identifier(type))))\n                : t.tsNeverKeyword(),\n            ),\n          )\n        }),\n      ),\n    )\n\n    const declareModule = t.declareModule(\n      t.stringLiteral('@sanity/client'),\n      t.blockStatement([queryReturnInterface]),\n    )\n\n    const clientImport = t.addComments(\n      t.importDeclaration([], t.stringLiteral('@sanity/client')),\n      'leading',\n      [{type: 'CommentLine', value: ' Query TypeMap'}],\n    )\n\n    const ast = t.program([clientImport, declareModule])\n    const code = generateCode(ast)\n    return {ast, code}\n  }\n\n  async generateTypes(options: GenerateTypesOptions) {\n    const {reporter: report} = options\n    const internalReferenceSymbol = this.getInternalReferenceSymbolDeclaration()\n    const schemaTypeGenerator = this.getSchemaTypeGenerator(options)\n    const schemaTypeDeclarations = this.getSchemaTypeDeclarations(options)\n    const allSanitySchemaTypesDeclaration = this.getAllSanitySchemaTypesDeclaration(options)\n\n    report?.event.generatedSchemaTypes({\n      allSanitySchemaTypesDeclaration,\n      internalReferenceSymbol,\n      schemaTypeDeclarations,\n    })\n\n    const program = t.program([])\n    let code = ''\n\n    for (const declaration of schemaTypeDeclarations) {\n      program.body.push(declaration.ast)\n      code += declaration.code\n    }\n\n    program.body.push(allSanitySchemaTypesDeclaration.ast)\n    code += allSanitySchemaTypesDeclaration.code\n\n    program.body.push(internalReferenceSymbol.ast)\n    code += internalReferenceSymbol.code\n\n    const evaluatedModules = await TypeGenerator.getEvaluatedModules({\n      ...options,\n      schemaTypeDeclarations,\n      schemaTypeGenerator,\n    })\n\n    // Only generate ArrayOf if it's actually used\n    if (schemaTypeGenerator.isArrayOfUsed()) {\n      const arrayOfDeclaration = this.getArrayOfDeclaration()\n      program.body.push(arrayOfDeclaration.ast)\n      code += arrayOfDeclaration.code\n    }\n\n    for (const {queries} of evaluatedModules) {\n      for (const query of queries) {\n        program.body.push(query.ast)\n        code += query.code\n      }\n    }\n\n    const queryMapDeclaration = await TypeGenerator.getQueryMapDeclaration({\n      ...options,\n      evaluatedModules,\n    })\n    program.body.push(...queryMapDeclaration.ast.body)\n    code += queryMapDeclaration.code\n\n    report?.event.generatedQueryTypes({queryMapDeclaration})\n\n    return {ast: program, code}\n  }\n}\n"],"names":["process","t","createSelector","resultSuffix","ALL_SANITY_SCHEMA_TYPES","ARRAY_OF","INTERNAL_REFERENCE_SYMBOL","SANITY_QUERIES","computeOnce","generateCode","getUniqueIdentifierForName","normalizePrintablePath","SchemaTypeGenerator","QueryEvaluationError","TypeGenerator","getSchemaTypeGenerator","options","schema","getSchemaTypeDeclarations","root","schemaPath","cwd","map","id","name","tsType","index","typeAlias","tsTypeAliasDeclaration","ast","exportNamedDeclaration","addComments","type","value","code","getAllSanitySchemaTypesDeclaration","schemaTypes","length","tsUnionType","tsTypeReference","tsNeverKeyword","getArrayOfDeclaration","typeParam","tsTypeParameter","intersectionType","tsIntersectionType","identifier","tsTypeLiteral","tsPropertySignature","tsTypeAnnotation","tsStringKeyword","arrayType","tsTypeParameterInstantiation","tsTypeParameterDeclaration","getInternalReferenceSymbolDeclaration","typeOperator","tsTypeOperator","tsSymbolKeyword","typeAnnotation","declaration","variableDeclaration","variableDeclarator","declare","getEvaluatedModules","queries","extractedModules","reporter","report","schemaTypeDeclarations","schemaTypeGenerator","stream","evaluatedModules","end","currentIdentifiers","Set","evaluatedModuleResults","filename","extractedModule","errors","extractedQuery","variable","stats","evaluateQuery","trimmedQuery","query","replaceAll","trim","evaluatedQueryResult","add","push","cause","evaluatedModule","emit","getQueryMapDeclaration","overloadClientMethods","program","flatMap","module","typesByQuerystring","queryReturnInterface","tsInterfaceDeclaration","tsInterfaceBody","Object","entries","types","stringLiteral","declareModule","blockStatement","clientImport","importDeclaration","generateTypes","internalReferenceSymbol","allSanitySchemaTypesDeclaration","event","generatedSchemaTypes","body","isArrayOfUsed","arrayOfDeclaration","queryMapDeclaration","generatedQueryTypes"],"mappings":"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"}