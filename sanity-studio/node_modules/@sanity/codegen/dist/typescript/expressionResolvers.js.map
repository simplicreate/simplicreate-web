{"version":3,"sources":["../../src/typescript/expressionResolvers.ts"],"sourcesContent":["import fs from 'node:fs'\nimport path from 'node:path'\n\nimport {type TransformOptions, traverse} from '@babel/core'\nimport {Scope} from '@babel/traverse'\nimport * as babelTypes from '@babel/types'\nimport createDebug from 'debug'\n\nimport {formatPath} from '../utils/formatPath.js'\nimport {parseSourceFile} from './parseSource.js'\n\nconst debug = createDebug('sanity:codegen:findQueries:debug')\n\ntype resolveExpressionReturnType = string\n\nconst TAGGED_TEMPLATE_ALLOW_LIST = new Set(['groq'])\nconst FUNCTION_WRAPPER_ALLOW_LIST = new Set(['defineQuery'])\n\n/**\n * resolveExpression takes a node and returns the resolved value of the expression.\n * @beta\n * @internal\n */\nexport function resolveExpression({\n  babelConfig,\n  file,\n  filename,\n  fnArguments = [],\n  node,\n  params = [],\n  resolver,\n  scope,\n}: {\n  babelConfig: TransformOptions\n  file: babelTypes.File\n  filename: string\n  fnArguments?: babelTypes.Node[]\n  node: babelTypes.Node\n  params?: babelTypes.Node[]\n  resolver: NodeJS.RequireResolve\n  scope: Scope\n}): resolveExpressionReturnType {\n  debug(\n    `Resolving node ${node.type} in ${filename}:${node.loc?.start.line}:${node.loc?.start.column}`,\n  )\n  if (\n    babelTypes.isTaggedTemplateExpression(node) &&\n    babelTypes.isIdentifier(node.tag) &&\n    TAGGED_TEMPLATE_ALLOW_LIST.has(node.tag.name)\n  ) {\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node: node.quasi,\n      params,\n      resolver,\n      scope,\n    })\n  }\n\n  if (babelTypes.isTemplateLiteral(node)) {\n    const resolvedExpressions = node.expressions.map((expression) =>\n      resolveExpression({\n        babelConfig,\n        file,\n        filename,\n        fnArguments,\n        node: expression,\n        params,\n        resolver,\n        scope,\n      }),\n    )\n    return node.quasis\n      .map((quasi, idx) => {\n        return (quasi.value.cooked || '') + (resolvedExpressions[idx] || '')\n      })\n      .join('')\n  }\n\n  if (babelTypes.isLiteral(node)) {\n    if (node.type === 'NullLiteral' || node.type === 'RegExpLiteral') {\n      throw new Error(`Unsupported literal type: ${node.type}`)\n    }\n\n    return node.value.toString()\n  }\n\n  if (babelTypes.isIdentifier(node)) {\n    return resolveIdentifier({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node,\n      params,\n      resolver,\n      scope,\n    })\n  }\n\n  if (babelTypes.isVariableDeclarator(node)) {\n    const init = node.init ?? (babelTypes.isAssignmentPattern(node.id) && node.id.right)\n    if (!init) {\n      throw new Error(`Unsupported variable declarator`)\n    }\n\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node: init,\n      resolver,\n      scope,\n    })\n  }\n\n  if (\n    babelTypes.isCallExpression(node) &&\n    babelTypes.isIdentifier(node.callee) &&\n    FUNCTION_WRAPPER_ALLOW_LIST.has(node.callee.name)\n  ) {\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      node: node.arguments[0]!,\n      params,\n      resolver,\n      scope,\n    })\n  }\n\n  if (babelTypes.isCallExpression(node)) {\n    return resolveCallExpression({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node,\n      params,\n      resolver,\n      scope,\n    })\n  }\n\n  if (\n    babelTypes.isArrowFunctionExpression(node) ||\n    babelTypes.isFunctionDeclaration(node) ||\n    babelTypes.isFunctionExpression(node)\n  ) {\n    const newScope = new Scope(scope.path, scope)\n\n    for (const [i, param] of params.entries()) {\n      newScope.push({\n        id: param as babelTypes.LVal,\n        init: fnArguments[i] as babelTypes.Expression | undefined,\n      })\n    }\n\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node: node.body,\n      params: node.params,\n      resolver,\n      scope: newScope,\n    })\n  }\n\n  if (babelTypes.isNewExpression(node)) {\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      node: node.callee,\n      resolver,\n      scope,\n    })\n  }\n\n  if (babelTypes.isImportDefaultSpecifier(node) || babelTypes.isImportSpecifier(node)) {\n    return resolveImportSpecifier({babelConfig, file, filename, fnArguments, node, resolver})\n  }\n\n  if (babelTypes.isAssignmentPattern(node)) {\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node: node.right,\n      params,\n      resolver,\n      scope,\n    })\n  }\n\n  // Handle TypeScript type assertions (e.g., `'foo' as string`)\n  if (babelTypes.isTSAsExpression(node)) {\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node: node.expression,\n      params,\n      resolver,\n      scope,\n    })\n  }\n\n  if (babelTypes.isMemberExpression(node)) {\n    const propertyName = getMemberPropertyName(node)\n    const objExpr = resolveToObjectExpression({\n      babelConfig,\n      file,\n      filename,\n      node: node.object,\n      resolver,\n      scope,\n    })\n    const prop = findObjectProperty(objExpr, propertyName, filename, node)\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node: prop.value,\n      params,\n      resolver,\n      scope,\n    })\n  }\n\n  throw new Error(\n    `Unsupported expression type: ${node.type} in ${filename}:${node.loc?.start.line}:${node.loc?.start.column}`,\n  )\n}\n\nfunction resolveIdentifier({\n  babelConfig,\n  file,\n  filename,\n  fnArguments,\n  node,\n  params,\n  resolver,\n  scope,\n}: {\n  babelConfig: TransformOptions\n  file: babelTypes.File\n  filename: string\n  fnArguments: babelTypes.Node[]\n  node: babelTypes.Identifier\n  params: babelTypes.Node[]\n  resolver: NodeJS.RequireResolve\n  scope: Scope\n}): resolveExpressionReturnType {\n  const paramIndex = params.findIndex(\n    (param) =>\n      (babelTypes.isIdentifier(param) && node.name === param.name) ||\n      (babelTypes.isAssignmentPattern(param) &&\n        babelTypes.isIdentifier(param.left) &&\n        node.name === param.left.name),\n  )\n  let argument = fnArguments[paramIndex]\n  if (!argument && paramIndex !== -1 && babelTypes.isAssignmentPattern(params[paramIndex])) {\n    argument = params[paramIndex].right\n  }\n  if (argument && babelTypes.isLiteral(argument)) {\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node: argument,\n      params,\n      resolver,\n      scope,\n    })\n  }\n  const binding = scope.getBinding(node.name)\n  if (binding) {\n    if (babelTypes.isIdentifier(binding.path.node)) {\n      const isSame = binding.path.node.name === node.name\n      if (isSame) {\n        throw new Error(\n          `Could not resolve same identifier \"${node.name}\" in \"${filename}:${node.loc?.start.line}:${node.loc?.start.column}\"`,\n        )\n      }\n    }\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node: binding.path.node,\n      params,\n      resolver,\n      scope,\n    })\n  }\n\n  throw new Error(\n    `Could not find binding for node \"${node.name}\" in ${filename}:${node.loc?.start.line}:${node.loc?.start.column}`,\n  )\n}\n\nfunction resolveCallExpression({\n  babelConfig,\n  file,\n  filename,\n  node,\n  params,\n  resolver,\n  scope,\n}: {\n  babelConfig: TransformOptions\n  file: babelTypes.File\n  filename: string\n  fnArguments: babelTypes.Node[]\n  node: babelTypes.CallExpression\n  params: babelTypes.Node[]\n  resolver: NodeJS.RequireResolve\n  scope: Scope\n}): resolveExpressionReturnType {\n  const {callee} = node\n  return resolveExpression({\n    babelConfig,\n    file,\n    filename,\n    fnArguments: node.arguments,\n    node: callee,\n    params,\n    resolver,\n    scope,\n  })\n}\n\nfunction resolveImportBinding({\n  babelConfig,\n  file,\n  filename,\n  node,\n  resolver,\n}: {\n  babelConfig: TransformOptions\n  file: babelTypes.File\n  filename: string\n  node: babelTypes.ExportSpecifier | babelTypes.ImportDefaultSpecifier | babelTypes.ImportSpecifier\n  resolver: NodeJS.RequireResolve\n}) {\n  let importDeclaration: babelTypes.ImportDeclaration | undefined\n  traverse(file, {\n    ImportDeclaration(n) {\n      if (!babelTypes.isImportDeclaration(n.node)) {\n        return\n      }\n      for (const specifier of n.node.specifiers) {\n        if (\n          babelTypes.isImportDefaultSpecifier(specifier) &&\n          specifier.local.loc?.identifierName === node.local.name\n        ) {\n          importDeclaration = n.node\n          break\n        }\n        if (specifier.local.name === node.local.name) {\n          importDeclaration = n.node\n        }\n      }\n    },\n  })\n\n  if (!importDeclaration) {\n    throw new Error(`Could not find import declaration for ${node.local.name}`)\n  }\n\n  const importName = node.local.name\n  const importFileName = importDeclaration.source.value\n\n  const importPath =\n    importFileName.startsWith('./') || importFileName.startsWith('../')\n      ? path.resolve(path.dirname(filename), importFileName)\n      : importFileName\n\n  const resolvedFile = resolver(formatPath(importPath))\n  const source = fs.readFileSync(resolvedFile)\n  const tree = parseSourceFile(source.toString(), resolvedFile, babelConfig)\n\n  let scope: Scope | undefined\n  traverse(tree, {\n    Program(p) {\n      scope = p.scope\n    },\n  })\n  if (!scope) {\n    throw new Error(`Could not find scope for ${filename}`)\n  }\n\n  const binding = scope.getBinding(importName)\n  return {binding, importFileName, importName, resolvedFile, scope, tree}\n}\n\nfunction resolveImportSpecifier({\n  babelConfig,\n  file,\n  filename,\n  fnArguments,\n  node,\n  resolver,\n}: {\n  babelConfig: TransformOptions\n  file: babelTypes.File\n  filename: string\n  fnArguments: babelTypes.Node[]\n  node: babelTypes.ExportSpecifier | babelTypes.ImportDefaultSpecifier | babelTypes.ImportSpecifier\n  resolver: NodeJS.RequireResolve\n}): resolveExpressionReturnType {\n  const {binding, importFileName, importName, resolvedFile, scope, tree} = resolveImportBinding({\n    babelConfig,\n    file,\n    filename,\n    node,\n    resolver,\n  })\n\n  if (binding) {\n    return resolveExpression({\n      babelConfig,\n      file: tree,\n      filename: resolvedFile,\n      fnArguments,\n      node: binding.path.node,\n      resolver,\n      scope,\n    })\n  }\n\n  // It's not a global binding, but it might be a named export\n  let namedExport: babelTypes.ExportNamedDeclaration | undefined\n  let newImportName: string | undefined\n  traverse(tree, {\n    ExportDeclaration(p) {\n      if (p.node.type === 'ExportNamedDeclaration') {\n        for (const specifier of p.node.specifiers) {\n          if (\n            specifier.type === 'ExportSpecifier' &&\n            specifier.exported.type === 'Identifier' &&\n            specifier.exported.name === importName\n          ) {\n            namedExport = p.node\n            newImportName = specifier.exported.name\n          }\n        }\n      }\n    },\n  })\n\n  if (namedExport && newImportName) {\n    return resolveExportSpecifier({\n      babelConfig,\n      filename: resolvedFile,\n      fnArguments,\n      importName: newImportName,\n      node: namedExport,\n      resolver,\n    })\n  }\n\n  let result: resolveExpressionReturnType | undefined\n  traverse(tree, {\n    ExportDeclaration(p) {\n      if (p.node.type === 'ExportAllDeclaration') {\n        try {\n          result = resolveExportSpecifier({\n            babelConfig,\n            filename: resolvedFile,\n            fnArguments,\n            importName,\n            node: p.node,\n            resolver,\n          })\n        } catch (e) {\n          if ((e as Error).cause !== `noBinding:${importName}`) throw e\n        }\n      }\n    },\n  })\n  if (result) return result\n\n  throw new Error(`Could not find binding for import \"${importName}\" in ${importFileName}`)\n}\n\nfunction resolveExportSpecifier({\n  babelConfig,\n  filename,\n  fnArguments,\n  importName,\n  node,\n  resolver,\n}: {\n  babelConfig: TransformOptions\n  filename: string\n  fnArguments: babelTypes.Node[]\n  importName: string\n  node: babelTypes.ExportAllDeclaration | babelTypes.ExportNamedDeclaration\n  resolver: NodeJS.RequireResolve\n}): resolveExpressionReturnType {\n  if (!node.source) {\n    throw new Error(`Could not find source for export \"${importName}\" in ${filename}`)\n  }\n\n  const importFileName = node.source.value\n  const importPath = path.resolve(path.dirname(filename), importFileName)\n  const resolvedFile = resolver(formatPath(importPath))\n  const source = fs.readFileSync(resolvedFile)\n  const tree = parseSourceFile(source.toString(), resolvedFile, babelConfig)\n\n  let newScope: Scope | undefined\n  traverse(tree, {\n    Program(p) {\n      newScope = p.scope\n    },\n  })\n  if (!newScope) {\n    throw new Error(`Could not find scope for ${filename}`)\n  }\n\n  const binding = newScope.getBinding(importName)\n  if (binding) {\n    return resolveExpression({\n      babelConfig,\n      file: tree,\n      filename: resolvedFile,\n      fnArguments,\n      node: binding.path.node,\n      resolver,\n      scope: newScope,\n    })\n  }\n\n  throw new Error(`Could not find binding for export \"${importName}\" in ${importFileName}`, {\n    cause: `noBinding:${importName}`,\n  })\n}\n\nfunction getMemberPropertyName(node: babelTypes.MemberExpression): string {\n  const {computed, loc, property} = node\n  if (!computed && babelTypes.isIdentifier(property)) {\n    return property.name\n  }\n  if (computed && babelTypes.isStringLiteral(property)) {\n    return property.value\n  }\n  const locInfo = loc ? `${loc.filename}:${loc.start.line}:${loc.start.column}` : 'unknown location'\n  throw new Error(`Unsupported MemberExpression property type: ${property.type} @ ${locInfo}`)\n}\n\nfunction findObjectProperty(\n  objExpr: babelTypes.ObjectExpression,\n  propertyName: string,\n  filename: string,\n  node: babelTypes.Node,\n): babelTypes.ObjectProperty {\n  for (const prop of objExpr.properties) {\n    if (!babelTypes.isObjectProperty(prop)) continue\n    if (babelTypes.isIdentifier(prop.key) && prop.key.name === propertyName) {\n      return prop\n    }\n    if (babelTypes.isStringLiteral(prop.key) && prop.key.value === propertyName) {\n      return prop\n    }\n  }\n  throw new Error(\n    `Could not find property \"${propertyName}\" in object expression in ${filename}:${node.loc?.start.line}:${node.loc?.start.column}`,\n  )\n}\n\nfunction resolveToObjectExpression({\n  babelConfig,\n  file,\n  filename,\n  node,\n  resolver,\n  scope,\n}: {\n  babelConfig: TransformOptions\n  file: babelTypes.File\n  filename: string\n  node: babelTypes.Node\n  resolver: NodeJS.RequireResolve\n  scope: Scope\n}): babelTypes.ObjectExpression {\n  if (babelTypes.isObjectExpression(node)) {\n    return node\n  }\n  if (babelTypes.isTSAsExpression(node)) {\n    return resolveToObjectExpression({\n      babelConfig,\n      file,\n      filename,\n      node: node.expression,\n      resolver,\n      scope,\n    })\n  }\n  if (babelTypes.isIdentifier(node)) {\n    const binding = scope.getBinding(node.name)\n    if (!binding) {\n      throw new Error(`Could not find binding for \"${node.name}\" in ${filename}`)\n    }\n    return resolveToObjectExpression({\n      babelConfig,\n      file,\n      filename,\n      node: binding.path.node,\n      resolver,\n      scope,\n    })\n  }\n  if (babelTypes.isVariableDeclarator(node)) {\n    if (!node.init) {\n      throw new Error(`Variable declarator has no init`)\n    }\n    return resolveToObjectExpression({\n      babelConfig,\n      file,\n      filename,\n      node: node.init,\n      resolver,\n      scope,\n    })\n  }\n  if (babelTypes.isMemberExpression(node)) {\n    const propertyName = getMemberPropertyName(node)\n    const objExpr = resolveToObjectExpression({\n      babelConfig,\n      file,\n      filename,\n      node: node.object,\n      resolver,\n      scope,\n    })\n    const prop = findObjectProperty(objExpr, propertyName, filename, node)\n    return resolveToObjectExpression({\n      babelConfig,\n      file,\n      filename,\n      node: prop.value,\n      resolver,\n      scope,\n    })\n  }\n  if (babelTypes.isImportDefaultSpecifier(node) || babelTypes.isImportSpecifier(node)) {\n    return resolveImportToObjectExpression({babelConfig, file, filename, node, resolver})\n  }\n  throw new Error(\n    `Cannot resolve node type \"${node.type}\" to ObjectExpression in ${filename}:${node.loc?.start.line}:${node.loc?.start.column}`,\n  )\n}\n\nfunction resolveImportToObjectExpression({\n  babelConfig,\n  file,\n  filename,\n  node,\n  resolver,\n}: {\n  babelConfig: TransformOptions\n  file: babelTypes.File\n  filename: string\n  node: babelTypes.ImportDefaultSpecifier | babelTypes.ImportSpecifier\n  resolver: NodeJS.RequireResolve\n}): babelTypes.ObjectExpression {\n  const {binding, importFileName, importName, resolvedFile, scope, tree} = resolveImportBinding({\n    babelConfig,\n    file,\n    filename,\n    node,\n    resolver,\n  })\n\n  if (!binding) {\n    throw new Error(`Could not find binding for import \"${importName}\" in ${importFileName}`)\n  }\n\n  return resolveToObjectExpression({\n    babelConfig,\n    file: tree,\n    filename: resolvedFile,\n    node: binding.path.node,\n    resolver,\n    scope,\n  })\n}\n"],"names":["fs","path","traverse","Scope","babelTypes","createDebug","formatPath","parseSourceFile","debug","TAGGED_TEMPLATE_ALLOW_LIST","Set","FUNCTION_WRAPPER_ALLOW_LIST","resolveExpression","babelConfig","file","filename","fnArguments","node","params","resolver","scope","type","loc","start","line","column","isTaggedTemplateExpression","isIdentifier","tag","has","name","quasi","isTemplateLiteral","resolvedExpressions","expressions","map","expression","quasis","idx","value","cooked","join","isLiteral","Error","toString","resolveIdentifier","isVariableDeclarator","init","isAssignmentPattern","id","right","isCallExpression","callee","arguments","resolveCallExpression","isArrowFunctionExpression","isFunctionDeclaration","isFunctionExpression","newScope","i","param","entries","push","body","isNewExpression","isImportDefaultSpecifier","isImportSpecifier","resolveImportSpecifier","isTSAsExpression","isMemberExpression","propertyName","getMemberPropertyName","objExpr","resolveToObjectExpression","object","prop","findObjectProperty","paramIndex","findIndex","left","argument","binding","getBinding","isSame","resolveImportBinding","importDeclaration","ImportDeclaration","n","isImportDeclaration","specifier","specifiers","local","identifierName","importName","importFileName","source","importPath","startsWith","resolve","dirname","resolvedFile","readFileSync","tree","Program","p","namedExport","newImportName","ExportDeclaration","exported","resolveExportSpecifier","result","e","cause","computed","property","isStringLiteral","locInfo","properties","isObjectProperty","key","isObjectExpression","resolveImportToObjectExpression"],"mappings":"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"}