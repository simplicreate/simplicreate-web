{"version":3,"sources":["../../src/typescript/expressionResolvers.ts"],"sourcesContent":["import fs from 'node:fs'\nimport path from 'node:path'\n\nimport {type TransformOptions, traverse} from '@babel/core'\nimport {Scope} from '@babel/traverse'\nimport * as babelTypes from '@babel/types'\nimport createDebug from 'debug'\n\nimport {formatPath} from '../utils/formatPath.js'\nimport {parseSourceFile} from './parseSource.js'\n\nconst debug = createDebug('sanity:codegen:findQueries:debug')\n\ntype resolveExpressionReturnType = string\n\nconst TAGGED_TEMPLATE_ALLOW_LIST = new Set(['groq'])\nconst FUNCTION_WRAPPER_ALLOW_LIST = new Set(['defineQuery'])\n\n/**\n * resolveExpression takes a node and returns the resolved value of the expression.\n * @beta\n * @internal\n */\nexport function resolveExpression({\n  babelConfig,\n  file,\n  filename,\n  fnArguments = [],\n  node,\n  params = [],\n  resolver,\n  scope,\n}: {\n  babelConfig: TransformOptions\n  file: babelTypes.File\n  filename: string\n  fnArguments?: babelTypes.Node[]\n  node: babelTypes.Node\n  params?: babelTypes.Node[]\n  resolver: NodeJS.RequireResolve\n  scope: Scope\n}): resolveExpressionReturnType {\n  debug(\n    `Resolving node ${node.type} in ${filename}:${node.loc?.start.line}:${node.loc?.start.column}`,\n  )\n  if (\n    babelTypes.isTaggedTemplateExpression(node) &&\n    babelTypes.isIdentifier(node.tag) &&\n    TAGGED_TEMPLATE_ALLOW_LIST.has(node.tag.name)\n  ) {\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node: node.quasi,\n      params,\n      resolver,\n      scope,\n    })\n  }\n\n  if (babelTypes.isTemplateLiteral(node)) {\n    const resolvedExpressions = node.expressions.map((expression) =>\n      resolveExpression({\n        babelConfig,\n        file,\n        filename,\n        fnArguments,\n        node: expression,\n        params,\n        resolver,\n        scope,\n      }),\n    )\n    return node.quasis\n      .map((quasi, idx) => {\n        return (quasi.value.cooked || '') + (resolvedExpressions[idx] || '')\n      })\n      .join('')\n  }\n\n  if (babelTypes.isLiteral(node)) {\n    if (node.type === 'NullLiteral' || node.type === 'RegExpLiteral') {\n      throw new Error(`Unsupported literal type: ${node.type}`)\n    }\n\n    return node.value.toString()\n  }\n\n  if (babelTypes.isIdentifier(node)) {\n    return resolveIdentifier({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node,\n      params,\n      resolver,\n      scope,\n    })\n  }\n\n  if (babelTypes.isVariableDeclarator(node)) {\n    const init = node.init ?? (babelTypes.isAssignmentPattern(node.id) && node.id.right)\n    if (!init) {\n      throw new Error(`Unsupported variable declarator`)\n    }\n\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node: init,\n      resolver,\n      scope,\n    })\n  }\n\n  if (\n    babelTypes.isCallExpression(node) &&\n    babelTypes.isIdentifier(node.callee) &&\n    FUNCTION_WRAPPER_ALLOW_LIST.has(node.callee.name)\n  ) {\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      node: node.arguments[0]!,\n      params,\n      resolver,\n      scope,\n    })\n  }\n\n  if (babelTypes.isCallExpression(node)) {\n    return resolveCallExpression({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node,\n      params,\n      resolver,\n      scope,\n    })\n  }\n\n  if (\n    babelTypes.isArrowFunctionExpression(node) ||\n    babelTypes.isFunctionDeclaration(node) ||\n    babelTypes.isFunctionExpression(node)\n  ) {\n    const newScope = new Scope(scope.path, scope)\n\n    for (const [i, param] of params.entries()) {\n      newScope.push({\n        id: param as babelTypes.LVal,\n        init: fnArguments[i] as babelTypes.Expression | undefined,\n      })\n    }\n\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node: node.body,\n      params: node.params,\n      resolver,\n      scope: newScope,\n    })\n  }\n\n  if (babelTypes.isNewExpression(node)) {\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      node: node.callee,\n      resolver,\n      scope,\n    })\n  }\n\n  if (babelTypes.isImportDefaultSpecifier(node) || babelTypes.isImportSpecifier(node)) {\n    return resolveImportSpecifier({babelConfig, file, filename, fnArguments, node, resolver, scope})\n  }\n\n  if (babelTypes.isAssignmentPattern(node)) {\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node: node.right,\n      params,\n      resolver,\n      scope,\n    })\n  }\n\n  // Handle TypeScript type assertions (e.g., `'foo' as string`)\n  if (babelTypes.isTSAsExpression(node)) {\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node: node.expression,\n      params,\n      resolver,\n      scope,\n    })\n  }\n\n  throw new Error(\n    `Unsupported expression type: ${node.type} in ${filename}:${node.loc?.start.line}:${node.loc?.start.column}`,\n  )\n}\n\nfunction resolveIdentifier({\n  babelConfig,\n  file,\n  filename,\n  fnArguments,\n  node,\n  params,\n  resolver,\n  scope,\n}: {\n  babelConfig: TransformOptions\n  file: babelTypes.File\n  filename: string\n  fnArguments: babelTypes.Node[]\n  node: babelTypes.Identifier\n  params: babelTypes.Node[]\n  resolver: NodeJS.RequireResolve\n  scope: Scope\n}): resolveExpressionReturnType {\n  const paramIndex = params.findIndex(\n    (param) =>\n      (babelTypes.isIdentifier(param) && node.name === param.name) ||\n      (babelTypes.isAssignmentPattern(param) &&\n        babelTypes.isIdentifier(param.left) &&\n        node.name === param.left.name),\n  )\n  let argument = fnArguments[paramIndex]\n  if (!argument && paramIndex !== -1 && babelTypes.isAssignmentPattern(params[paramIndex])) {\n    argument = params[paramIndex].right\n  }\n  if (argument && babelTypes.isLiteral(argument)) {\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node: argument,\n      params,\n      resolver,\n      scope,\n    })\n  }\n  const binding = scope.getBinding(node.name)\n  if (binding) {\n    if (babelTypes.isIdentifier(binding.path.node)) {\n      const isSame = binding.path.node.name === node.name\n      if (isSame) {\n        throw new Error(\n          `Could not resolve same identifier \"${node.name}\" in \"${filename}:${node.loc?.start.line}:${node.loc?.start.column}\"`,\n        )\n      }\n    }\n    return resolveExpression({\n      babelConfig,\n      file,\n      filename,\n      fnArguments,\n      node: binding.path.node,\n      params,\n      resolver,\n      scope,\n    })\n  }\n\n  throw new Error(\n    `Could not find binding for node \"${node.name}\" in ${filename}:${node.loc?.start.line}:${node.loc?.start.column}`,\n  )\n}\n\nfunction resolveCallExpression({\n  babelConfig,\n  file,\n  filename,\n  node,\n  params,\n  resolver,\n  scope,\n}: {\n  babelConfig: TransformOptions\n  file: babelTypes.File\n  filename: string\n  fnArguments: babelTypes.Node[]\n  node: babelTypes.CallExpression\n  params: babelTypes.Node[]\n  resolver: NodeJS.RequireResolve\n  scope: Scope\n}): resolveExpressionReturnType {\n  const {callee} = node\n  return resolveExpression({\n    babelConfig,\n    file,\n    filename,\n    fnArguments: node.arguments,\n    node: callee,\n    params,\n    resolver,\n    scope,\n  })\n}\n\nfunction resolveImportSpecifier({\n  babelConfig,\n  file,\n  filename,\n  fnArguments,\n  node,\n  resolver,\n}: {\n  babelConfig: TransformOptions\n  file: babelTypes.File\n  filename: string\n  fnArguments: babelTypes.Node[]\n  node: babelTypes.ExportSpecifier | babelTypes.ImportDefaultSpecifier | babelTypes.ImportSpecifier\n  resolver: NodeJS.RequireResolve\n  scope: Scope\n}): resolveExpressionReturnType {\n  let importDeclaration: babelTypes.ImportDeclaration | undefined\n  traverse(file, {\n    ImportDeclaration(n) {\n      if (!babelTypes.isImportDeclaration(n.node)) {\n        return\n      }\n      for (const specifier of n.node.specifiers) {\n        if (\n          babelTypes.isImportDefaultSpecifier(specifier) &&\n          specifier.local.loc?.identifierName === node.local.name\n        ) {\n          importDeclaration = n.node\n          break\n        }\n        if (specifier.local.name === node.local.name) {\n          importDeclaration = n.node\n        }\n      }\n    },\n  })\n\n  if (!importDeclaration) {\n    throw new Error(`Could not find import declaration for ${node.local.name}`)\n  }\n\n  const importName = node.local.name // the name of the variable to import\n  const importFileName = importDeclaration.source.value // the file to import from\n\n  const importPath =\n    importFileName.startsWith('./') || importFileName.startsWith('../')\n      ? path.resolve(path.dirname(filename), importFileName)\n      : importFileName\n\n  const resolvedFile = resolver(formatPath(importPath))\n  const source = fs.readFileSync(resolvedFile)\n  const tree = parseSourceFile(source.toString(), resolvedFile, babelConfig)\n\n  let newScope: Scope | undefined\n  traverse(tree, {\n    Program(p) {\n      newScope = p.scope\n    },\n  })\n  if (!newScope) {\n    throw new Error(`Could not find scope for ${filename}`)\n  }\n\n  const binding = newScope.getBinding(importName)\n  if (binding) {\n    return resolveExpression({\n      babelConfig,\n      file: tree,\n      filename: resolvedFile,\n      fnArguments,\n      node: binding.path.node,\n      resolver,\n      scope: newScope,\n    })\n  }\n\n  // It's not a global binding, but it might be a named export\n  let namedExport: babelTypes.ExportNamedDeclaration | undefined\n  let newImportName: string | undefined\n  traverse(tree, {\n    ExportDeclaration(p) {\n      if (p.node.type === 'ExportNamedDeclaration') {\n        for (const specifier of p.node.specifiers) {\n          if (\n            specifier.type === 'ExportSpecifier' &&\n            specifier.exported.type === 'Identifier' &&\n            specifier.exported.name === importName\n          ) {\n            namedExport = p.node\n            newImportName = specifier.exported.name\n          }\n        }\n      }\n    },\n  })\n\n  if (namedExport && newImportName) {\n    return resolveExportSpecifier({\n      babelConfig,\n      filename: resolvedFile,\n      fnArguments,\n      importName: newImportName,\n      node: namedExport,\n      resolver,\n    })\n  }\n\n  let result: resolveExpressionReturnType | undefined\n  traverse(tree, {\n    ExportDeclaration(p) {\n      if (p.node.type === 'ExportAllDeclaration') {\n        try {\n          result = resolveExportSpecifier({\n            babelConfig,\n            filename: resolvedFile,\n            fnArguments,\n            importName,\n            node: p.node,\n            resolver,\n          })\n        } catch (e) {\n          if ((e as Error).cause !== `noBinding:${importName}`) throw e\n        }\n      }\n    },\n  })\n  if (result) return result\n\n  throw new Error(`Could not find binding for import \"${importName}\" in ${importFileName}`)\n}\n\nfunction resolveExportSpecifier({\n  babelConfig,\n  filename,\n  fnArguments,\n  importName,\n  node,\n  resolver,\n}: {\n  babelConfig: TransformOptions\n  filename: string\n  fnArguments: babelTypes.Node[]\n  importName: string\n  node: babelTypes.ExportAllDeclaration | babelTypes.ExportNamedDeclaration\n  resolver: NodeJS.RequireResolve\n}): resolveExpressionReturnType {\n  if (!node.source) {\n    throw new Error(`Could not find source for export \"${importName}\" in ${filename}`)\n  }\n\n  const importFileName = node.source.value\n  const importPath = path.resolve(path.dirname(filename), importFileName)\n  const resolvedFile = resolver(formatPath(importPath))\n  const source = fs.readFileSync(resolvedFile)\n  const tree = parseSourceFile(source.toString(), resolvedFile, babelConfig)\n\n  let newScope: Scope | undefined\n  traverse(tree, {\n    Program(p) {\n      newScope = p.scope\n    },\n  })\n  if (!newScope) {\n    throw new Error(`Could not find scope for ${filename}`)\n  }\n\n  const binding = newScope.getBinding(importName)\n  if (binding) {\n    return resolveExpression({\n      babelConfig,\n      file: tree,\n      filename: resolvedFile,\n      fnArguments,\n      node: binding.path.node,\n      resolver,\n      scope: newScope,\n    })\n  }\n\n  throw new Error(`Could not find binding for export \"${importName}\" in ${importFileName}`, {\n    cause: `noBinding:${importName}`,\n  })\n}\n"],"names":["fs","path","traverse","Scope","babelTypes","createDebug","formatPath","parseSourceFile","debug","TAGGED_TEMPLATE_ALLOW_LIST","Set","FUNCTION_WRAPPER_ALLOW_LIST","resolveExpression","babelConfig","file","filename","fnArguments","node","params","resolver","scope","type","loc","start","line","column","isTaggedTemplateExpression","isIdentifier","tag","has","name","quasi","isTemplateLiteral","resolvedExpressions","expressions","map","expression","quasis","idx","value","cooked","join","isLiteral","Error","toString","resolveIdentifier","isVariableDeclarator","init","isAssignmentPattern","id","right","isCallExpression","callee","arguments","resolveCallExpression","isArrowFunctionExpression","isFunctionDeclaration","isFunctionExpression","newScope","i","param","entries","push","body","isNewExpression","isImportDefaultSpecifier","isImportSpecifier","resolveImportSpecifier","isTSAsExpression","paramIndex","findIndex","left","argument","binding","getBinding","isSame","importDeclaration","ImportDeclaration","n","isImportDeclaration","specifier","specifiers","local","identifierName","importName","importFileName","source","importPath","startsWith","resolve","dirname","resolvedFile","readFileSync","tree","Program","p","namedExport","newImportName","ExportDeclaration","exported","resolveExportSpecifier","result","e","cause"],"mappings":"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"}