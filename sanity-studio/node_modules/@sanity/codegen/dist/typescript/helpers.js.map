{"version":3,"sources":["../../src/typescript/helpers.ts"],"sourcesContent":["import path from 'node:path'\n\nimport {CodeGenerator} from '@babel/generator'\nimport * as t from '@babel/types'\nimport {type ArrayTypeNode, type UnionTypeNode} from 'groq-js'\n\nimport {formatPath} from '../utils/formatPath.js'\nimport {RESERVED_IDENTIFIERS} from './constants.js'\n\nexport function normalizePrintablePath(root: string, filename: string) {\n  const resolved = path.resolve(root, filename)\n  // Always use Unix-style paths for consistent output across platforms\n  return formatPath(path.relative(root, resolved))\n}\n\n/**\n * Normalizes a glob pattern to use forward slashes (POSIX-style paths).\n * Glob patterns must use forward slashes, even on Windows.\n *\n * @param pattern - A glob pattern string or array of patterns\n * @returns The normalized pattern(s) with forward slashes\n * @see https://github.com/sindresorhus/globby#api\n */\nexport function normalizeGlobPattern(pattern: string | string[]): string | string[] {\n  if (Array.isArray(pattern)) {\n    return pattern.map((p) => formatPath(p))\n  }\n  return formatPath(pattern)\n}\n\nfunction sanitizeIdentifier(input: string): string {\n  return `${input.replace(/^\\d/, '_').replaceAll(/[^$\\w]+(.)/g, (_, char) => char.toUpperCase())}`\n}\n\n/**\n * Checks if a string is a valid ECMAScript IdentifierName.\n * IdentifierNames start with a letter, underscore, or $, and contain only\n * alphanumeric characters, underscores, or $.\n */\nexport function isIdentifierName(input: string): boolean {\n  return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(input)\n}\n\nfunction normalizeIdentifier(input: string): string {\n  const sanitized = sanitizeIdentifier(input)\n  return `${sanitized.charAt(0).toUpperCase()}${sanitized.slice(1)}`\n}\n\nexport function getUniqueIdentifierForName(name: string, currentIdentifiers: Set<string>) {\n  const desiredName = normalizeIdentifier(name)\n  let resultingName = desiredName\n  let index = 2\n  while (currentIdentifiers.has(resultingName) || RESERVED_IDENTIFIERS.has(resultingName)) {\n    resultingName = `${desiredName}_${index}`\n    index++\n  }\n  return t.identifier(resultingName)\n}\n\nexport function computeOnce<TReturn>(fn: () => TReturn): () => TReturn {\n  const ref = {computed: false, current: undefined as TReturn | undefined}\n\n  return function () {\n    if (ref.computed) return ref.current as TReturn\n    ref.current = fn()\n    ref.computed = true\n    return ref.current\n  }\n}\n\nexport function weakMapMemo<TParam extends object, TReturn>(fn: (arg: TParam) => TReturn) {\n  const cache = new WeakMap<object, TReturn>()\n\n  const wrapped = function (arg: TParam) {\n    if (cache.has(arg)) return cache.get(arg)!\n    const result = fn(arg)\n    cache.set(arg, result)\n    return result\n  }\n\n  return wrapped\n}\n\nexport function generateCode(node: t.Node) {\n  return `${new CodeGenerator(node).generate().code.trim()}\\n\\n`\n}\n\nexport function getFilterArrayUnionType(\n  typeNode: ArrayTypeNode,\n  predicate: (unionTypeNode: UnionTypeNode['of'][number]) => boolean,\n): ArrayTypeNode {\n  if (typeNode.of.type !== 'union') {\n    return typeNode\n  }\n\n  return {\n    ...typeNode,\n    of: {\n      ...typeNode.of,\n      of: typeNode.of.of.filter((unionTypeNode) => predicate(unionTypeNode)),\n    },\n  } satisfies ArrayTypeNode<UnionTypeNode>\n}\n"],"names":["path","CodeGenerator","t","formatPath","RESERVED_IDENTIFIERS","normalizePrintablePath","root","filename","resolved","resolve","relative","normalizeGlobPattern","pattern","Array","isArray","map","p","sanitizeIdentifier","input","replace","replaceAll","_","char","toUpperCase","isIdentifierName","test","normalizeIdentifier","sanitized","charAt","slice","getUniqueIdentifierForName","name","currentIdentifiers","desiredName","resultingName","index","has","identifier","computeOnce","fn","ref","computed","current","undefined","weakMapMemo","cache","WeakMap","wrapped","arg","get","result","set","generateCode","node","generate","code","trim","getFilterArrayUnionType","typeNode","predicate","of","type","filter","unionTypeNode"],"mappings":"AAAA,OAAOA,UAAU,YAAW;AAE5B,SAAQC,aAAa,QAAO,mBAAkB;AAC9C,YAAYC,OAAO,eAAc;AAGjC,SAAQC,UAAU,QAAO,yBAAwB;AACjD,SAAQC,oBAAoB,QAAO,iBAAgB;AAEnD,OAAO,SAASC,uBAAuBC,IAAY,EAAEC,QAAgB;IACnE,MAAMC,WAAWR,KAAKS,OAAO,CAACH,MAAMC;IACpC,qEAAqE;IACrE,OAAOJ,WAAWH,KAAKU,QAAQ,CAACJ,MAAME;AACxC;AAEA;;;;;;;CAOC,GACD,OAAO,SAASG,qBAAqBC,OAA0B;IAC7D,IAAIC,MAAMC,OAAO,CAACF,UAAU;QAC1B,OAAOA,QAAQG,GAAG,CAAC,CAACC,IAAMb,WAAWa;IACvC;IACA,OAAOb,WAAWS;AACpB;AAEA,SAASK,mBAAmBC,KAAa;IACvC,OAAO,GAAGA,MAAMC,OAAO,CAAC,OAAO,KAAKC,UAAU,CAAC,eAAe,CAACC,GAAGC,OAASA,KAAKC,WAAW,KAAK;AAClG;AAEA;;;;CAIC,GACD,OAAO,SAASC,iBAAiBN,KAAa;IAC5C,OAAO,6BAA6BO,IAAI,CAACP;AAC3C;AAEA,SAASQ,oBAAoBR,KAAa;IACxC,MAAMS,YAAYV,mBAAmBC;IACrC,OAAO,GAAGS,UAAUC,MAAM,CAAC,GAAGL,WAAW,KAAKI,UAAUE,KAAK,CAAC,IAAI;AACpE;AAEA,OAAO,SAASC,2BAA2BC,IAAY,EAAEC,kBAA+B;IACtF,MAAMC,cAAcP,oBAAoBK;IACxC,IAAIG,gBAAgBD;IACpB,IAAIE,QAAQ;IACZ,MAAOH,mBAAmBI,GAAG,CAACF,kBAAkB9B,qBAAqBgC,GAAG,CAACF,eAAgB;QACvFA,gBAAgB,GAAGD,YAAY,CAAC,EAAEE,OAAO;QACzCA;IACF;IACA,OAAOjC,EAAEmC,UAAU,CAACH;AACtB;AAEA,OAAO,SAASI,YAAqBC,EAAiB;IACpD,MAAMC,MAAM;QAACC,UAAU;QAAOC,SAASC;IAAgC;IAEvE,OAAO;QACL,IAAIH,IAAIC,QAAQ,EAAE,OAAOD,IAAIE,OAAO;QACpCF,IAAIE,OAAO,GAAGH;QACdC,IAAIC,QAAQ,GAAG;QACf,OAAOD,IAAIE,OAAO;IACpB;AACF;AAEA,OAAO,SAASE,YAA4CL,EAA4B;IACtF,MAAMM,QAAQ,IAAIC;IAElB,MAAMC,UAAU,SAAUC,GAAW;QACnC,IAAIH,MAAMT,GAAG,CAACY,MAAM,OAAOH,MAAMI,GAAG,CAACD;QACrC,MAAME,SAASX,GAAGS;QAClBH,MAAMM,GAAG,CAACH,KAAKE;QACf,OAAOA;IACT;IAEA,OAAOH;AACT;AAEA,OAAO,SAASK,aAAaC,IAAY;IACvC,OAAO,GAAG,IAAIpD,cAAcoD,MAAMC,QAAQ,GAAGC,IAAI,CAACC,IAAI,GAAG,IAAI,CAAC;AAChE;AAEA,OAAO,SAASC,wBACdC,QAAuB,EACvBC,SAAkE;IAElE,IAAID,SAASE,EAAE,CAACC,IAAI,KAAK,SAAS;QAChC,OAAOH;IACT;IAEA,OAAO;QACL,GAAGA,QAAQ;QACXE,IAAI;YACF,GAAGF,SAASE,EAAE;YACdA,IAAIF,SAASE,EAAE,CAACA,EAAE,CAACE,MAAM,CAAC,CAACC,gBAAkBJ,UAAUI;QACzD;IACF;AACF"}