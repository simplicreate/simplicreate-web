{"version":3,"sources":["../../src/typescript/schemaTypeGenerator.ts"],"sourcesContent":["import * as t from '@babel/types'\nimport {\n  type ArrayTypeNode,\n  type DocumentSchemaType,\n  type InlineTypeNode,\n  type ObjectAttribute,\n  type ObjectTypeNode,\n  type SchemaType,\n  type TypeDeclarationSchemaType,\n  typeEvaluate,\n  type TypeNode,\n  type UnionTypeNode,\n} from 'groq-js'\n\nimport {safeParseQuery} from '../safeParseQuery.js'\nimport {ARRAY_OF, INTERNAL_REFERENCE_SYMBOL} from './constants.js'\nimport {\n  getFilterArrayUnionType,\n  getUniqueIdentifierForName,\n  isIdentifierName,\n  weakMapMemo,\n} from './helpers.js'\nimport {type ExtractedQuery, type TypeEvaluationStats} from './types.js'\n\nexport class SchemaTypeGenerator {\n  public readonly schema: SchemaType\n  evaluateQuery = weakMapMemo(\n    // eslint-disable-next-line unicorn/consistent-function-scoping\n    ({query}: Pick<ExtractedQuery, 'query'>): {stats: TypeEvaluationStats; tsType: t.TSType} => {\n      const ast = safeParseQuery(query)\n      const typeNode = typeEvaluate(ast, this.schema)\n      const tsType = this.generateTsType(typeNode)\n      const stats = walkAndCountQueryTypeNodeStats(typeNode)\n      return {stats, tsType}\n    },\n  )\n  private arrayOfUsed = false\n\n  private identifiers = new Map<string, t.Identifier>()\n\n  private tsTypes = new Map<string, t.TSType>()\n\n  constructor(schema: SchemaType) {\n    this.schema = schema\n\n    const uniqueTypeNames = new Set<string>()\n    for (const type of schema) {\n      if (uniqueTypeNames.has(type.name)) {\n        throw new Error(\n          `Duplicate type name \"${type.name}\" in schema. Type names must be unique within the same schema.`,\n        )\n      }\n      uniqueTypeNames.add(type.name)\n    }\n\n    for (const type of schema) {\n      const currentIdentifierNames = new Set([...this.identifiers.values()].map((id) => id.name))\n      const uniqueIdentifier = getUniqueIdentifierForName(type.name, currentIdentifierNames)\n      this.identifiers.set(type.name, uniqueIdentifier)\n    }\n\n    for (const type of schema) {\n      this.tsTypes.set(type.name, this.generateTsType(type))\n    }\n  }\n\n  getType(typeName: string): {id: t.Identifier; tsType: t.TSType} | undefined {\n    const tsType = this.tsTypes.get(typeName)\n    const id = this.identifiers.get(typeName)\n    if (tsType && id) return {id, tsType}\n    return undefined\n  }\n\n  hasType(typeName: string): boolean {\n    return this.tsTypes.has(typeName)\n  }\n\n  isArrayOfUsed(): boolean {\n    return this.arrayOfUsed\n  }\n\n  *[Symbol.iterator]() {\n    for (const {name} of this.schema) {\n      yield {name, ...this.getType(name)!}\n    }\n  }\n\n  typeNames(): string[] {\n    return this.schema.map((schemaType) => schemaType.name)\n  }\n\n  /**\n   * Helper function used to generate TS types for arrays of inline types, or arrays of inline types\n   * wrapped in the ArrayOf wrapper that adds _key prop\n   */\n  private generateArrayOfTsType(typeNode: ArrayTypeNode): t.TSTypeReference {\n    this.arrayOfUsed = true\n    const typeNodes = this.generateTsType(typeNode.of)\n    return t.tsTypeReference(ARRAY_OF, t.tsTypeParameterInstantiation([typeNodes]))\n  }\n\n  // Helper function used to generate TS types for array type nodes.\n  private generateArrayTsType(typeNode: ArrayTypeNode): t.TSTypeReference | t.TSUnionType {\n    // if it's an array of a single inline type, wrap it in ArrayOf\n    if (typeNode.of.type === 'inline') {\n      return this.generateArrayOfTsType(typeNode)\n    }\n\n    // if it's not an inline object and not a union, wrap in Array\n    if (typeNode.of.type !== 'union') {\n      const typeNodes = this.generateTsType(typeNode.of)\n      return t.tsTypeReference(t.identifier('Array'), t.tsTypeParameterInstantiation([typeNodes]))\n    }\n\n    // if it's not a union type or all of the union type members are non-inlines, wrap type in Array\n    if (typeNode.of.of.every((unionTypeNode) => unionTypeNode.type !== 'inline')) {\n      const typeNodes = this.generateTsType(typeNode.of)\n      return t.tsTypeReference(t.identifier('Array'), t.tsTypeParameterInstantiation([typeNodes]))\n    }\n\n    // all the union types nodes are inline\n    if (typeNode.of.of.every((unionMember) => unionMember.type === 'inline')) {\n      return this.generateArrayOfTsType(typeNode)\n    }\n\n    // some of the union types are inlines, while some are not - split and recurse\n    const arrayOfNonInline = getFilterArrayUnionType(typeNode, (member) => member.type !== 'inline')\n    const arrayOfInline = getFilterArrayUnionType(typeNode, (member) => member.type === 'inline')\n\n    return t.tsUnionType([\n      this.generateArrayTsType(arrayOfNonInline),\n      this.generateArrayTsType(arrayOfInline),\n    ])\n  }\n\n  // Helper function used to generate TS types for document type nodes.\n  private generateDocumentTsType(document: DocumentSchemaType): t.TSType {\n    const props = Object.entries(document.attributes).map(([key, node]) =>\n      this.generateTsObjectProperty(key, node),\n    )\n\n    return t.tsTypeLiteral(props)\n  }\n\n  private generateInlineTsType(typeNode: InlineTypeNode): t.TSType {\n    const id = this.identifiers.get(typeNode.name)\n    if (!id) {\n      // Not found in schema, return unknown type\n      return t.addComment(\n        t.tsUnknownKeyword(),\n        'trailing',\n        ` Unable to locate the referenced type \"${typeNode.name}\" in schema`,\n        true,\n      )\n    }\n\n    return t.tsTypeReference(id)\n  }\n\n  // Helper function used to generate TS types for object type nodes.\n  private generateObjectTsType(typeNode: ObjectTypeNode): t.TSType {\n    const props: t.TSPropertySignature[] = []\n    for (const [key, attribute] of Object.entries(typeNode.attributes)) {\n      props.push(this.generateTsObjectProperty(key, attribute))\n    }\n    const rest = typeNode.rest\n\n    if (rest) {\n      switch (rest.type) {\n        case 'inline': {\n          const resolved = this.generateInlineTsType(rest)\n          // if object rest is unknown, we can't generate a type literal for it\n          if (t.isTSUnknownKeyword(resolved)) return resolved\n          return t.tsIntersectionType([t.tsTypeLiteral(props), resolved])\n        }\n        case 'object': {\n          for (const [key, attribute] of Object.entries(rest.attributes)) {\n            props.push(this.generateTsObjectProperty(key, attribute))\n          }\n          break\n        }\n        case 'unknown': {\n          return t.tsUnknownKeyword()\n        }\n        default: {\n          // @ts-expect-error This should never happen\n          throw new Error(`Type \"${rest.type}\" not found in schema`)\n        }\n      }\n    }\n\n    if (typeNode.dereferencesTo) {\n      const derefType = Object.assign(\n        t.tsPropertySignature(\n          INTERNAL_REFERENCE_SYMBOL,\n          t.tsTypeAnnotation(t.tsLiteralType(t.stringLiteral(typeNode.dereferencesTo))),\n        ),\n        {computed: true, optional: true},\n      )\n      props.push(derefType)\n    }\n\n    return t.tsTypeLiteral(props)\n  }\n\n  // Helper function used to generate TS types for object properties.\n  private generateTsObjectProperty(key: string, attribute: ObjectAttribute): t.TSPropertySignature {\n    const type = this.generateTsType(attribute.value)\n    const keyNode = isIdentifierName(key) ? t.identifier(key) : t.stringLiteral(key)\n    const propertySignature = t.tsPropertySignature(keyNode, t.tsTypeAnnotation(type))\n    propertySignature.optional = attribute.optional\n\n    return propertySignature\n  }\n\n  private generateTsType(\n    typeNode: DocumentSchemaType | TypeDeclarationSchemaType | TypeNode,\n  ): t.TSType {\n    switch (typeNode.type) {\n      case 'array': {\n        return this.generateArrayTsType(typeNode)\n      }\n      case 'boolean': {\n        if (typeNode.value !== undefined) {\n          return t.tsLiteralType(t.booleanLiteral(typeNode.value))\n        }\n        return t.tsBooleanKeyword()\n      }\n      case 'document': {\n        return this.generateDocumentTsType(typeNode)\n      }\n      case 'inline': {\n        return this.generateInlineTsType(typeNode)\n      }\n      case 'null': {\n        return t.tsNullKeyword()\n      }\n      case 'number': {\n        if (typeNode.value !== undefined) {\n          return t.tsLiteralType(t.numericLiteral(typeNode.value))\n        }\n        return t.tsNumberKeyword()\n      }\n      case 'object': {\n        return this.generateObjectTsType(typeNode)\n      }\n      case 'string': {\n        if (typeNode.value !== undefined) {\n          return t.tsLiteralType(t.stringLiteral(typeNode.value))\n        }\n        return t.tsStringKeyword()\n      }\n      case 'type': {\n        return this.generateTsType(typeNode.value)\n      }\n      case 'union': {\n        return this.generateUnionTsType(typeNode)\n      }\n      case 'unknown': {\n        return t.tsUnknownKeyword()\n      }\n\n      default: {\n        throw new Error(\n          `Encountered unsupported node type \"${\n            // @ts-expect-error This should never happen\n            typeNode.type\n          }\" while generating schema types`,\n        )\n      }\n    }\n  }\n\n  // Helper function used to generate TS types for union type nodes.\n  private generateUnionTsType(typeNode: UnionTypeNode): t.TSType {\n    if (typeNode.of.length === 0) return t.tsNeverKeyword()\n    if (typeNode.of.length === 1) return this.generateTsType(typeNode.of[0]!)\n    return t.tsUnionType(typeNode.of.map((node) => this.generateTsType(node)))\n  }\n}\n\nexport function walkAndCountQueryTypeNodeStats(typeNode: TypeNode): TypeEvaluationStats {\n  switch (typeNode.type) {\n    case 'array': {\n      const acc = walkAndCountQueryTypeNodeStats(typeNode.of)\n      acc.allTypes += 1 // count the array type itself\n      return acc\n    }\n    case 'object': {\n      // if the rest is unknown, we count it as one unknown type\n      if (typeNode.rest && typeNode.rest.type === 'unknown') {\n        return {allTypes: 2, emptyUnions: 0, unknownTypes: 1} // count the object type itself as well\n      }\n\n      const restStats = typeNode.rest\n        ? walkAndCountQueryTypeNodeStats(typeNode.rest)\n        : {allTypes: 0, emptyUnions: 0, unknownTypes: 0}\n\n      // count the object type itself\n      restStats.allTypes += 1\n\n      const attrs = Object.values(typeNode.attributes)\n      let acc = restStats\n      for (const attribute of attrs) {\n        const {allTypes, emptyUnions, unknownTypes} = walkAndCountQueryTypeNodeStats(\n          attribute.value,\n        )\n        acc = {\n          allTypes: acc.allTypes + allTypes,\n          emptyUnions: acc.emptyUnions + emptyUnions,\n          unknownTypes: acc.unknownTypes + unknownTypes,\n        }\n      }\n      return acc\n    }\n    case 'union': {\n      if (typeNode.of.length === 0) {\n        return {allTypes: 1, emptyUnions: 1, unknownTypes: 0}\n      }\n\n      let acc = {allTypes: 1, emptyUnions: 0, unknownTypes: 0} // count the union type itself\n      for (const type of typeNode.of) {\n        const {allTypes, emptyUnions, unknownTypes} = walkAndCountQueryTypeNodeStats(type)\n        acc = {\n          allTypes: acc.allTypes + allTypes,\n          emptyUnions: acc.emptyUnions + emptyUnions,\n          unknownTypes: acc.unknownTypes + unknownTypes,\n        }\n      }\n      return acc\n    }\n    case 'unknown': {\n      return {allTypes: 1, emptyUnions: 0, unknownTypes: 1}\n    }\n    default: {\n      return {allTypes: 1, emptyUnions: 0, unknownTypes: 0}\n    }\n  }\n}\n"],"names":["t","typeEvaluate","safeParseQuery","ARRAY_OF","INTERNAL_REFERENCE_SYMBOL","getFilterArrayUnionType","getUniqueIdentifierForName","isIdentifierName","weakMapMemo","SchemaTypeGenerator","schema","evaluateQuery","query","ast","typeNode","tsType","generateTsType","stats","walkAndCountQueryTypeNodeStats","arrayOfUsed","identifiers","Map","tsTypes","uniqueTypeNames","Set","type","has","name","Error","add","currentIdentifierNames","values","map","id","uniqueIdentifier","set","getType","typeName","get","undefined","hasType","isArrayOfUsed","Symbol","iterator","typeNames","schemaType","generateArrayOfTsType","typeNodes","of","tsTypeReference","tsTypeParameterInstantiation","generateArrayTsType","identifier","every","unionTypeNode","unionMember","arrayOfNonInline","member","arrayOfInline","tsUnionType","generateDocumentTsType","document","props","Object","entries","attributes","key","node","generateTsObjectProperty","tsTypeLiteral","generateInlineTsType","addComment","tsUnknownKeyword","generateObjectTsType","attribute","push","rest","resolved","isTSUnknownKeyword","tsIntersectionType","dereferencesTo","derefType","assign","tsPropertySignature","tsTypeAnnotation","tsLiteralType","stringLiteral","computed","optional","value","keyNode","propertySignature","booleanLiteral","tsBooleanKeyword","tsNullKeyword","numericLiteral","tsNumberKeyword","tsStringKeyword","generateUnionTsType","length","tsNeverKeyword","acc","allTypes","emptyUnions","unknownTypes","restStats","attrs"],"mappings":"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"}