{"version":3,"sources":["../../src/typescript/findQueriesInSource.ts"],"sourcesContent":["import {createRequire} from 'node:module'\n\nimport {type NodePath, type TransformOptions, traverse} from '@babel/core'\nimport {type Scope} from '@babel/traverse'\nimport * as babelTypes from '@babel/types'\n\nimport {getBabelConfig} from '../getBabelConfig.js'\nimport {resolveExpression} from './expressionResolvers.js'\nimport {parseSourceFile} from './parseSource.js'\nimport {type ExtractedModule, type ExtractedQuery, QueryExtractionError} from './types.js'\n\nconst require = createRequire(import.meta.url)\n\nconst groqTagName = 'groq'\nconst defineQueryFunctionName = 'defineQuery'\nconst groqModuleName = 'groq'\nconst nextSanityModuleName = 'next-sanity'\nconst sveltekitModuleName = '@sanity/sveltekit'\n\nconst ignoreValue = '@sanity-typegen-ignore'\n\n/**\n * findQueriesInSource takes a source string and returns all GROQ queries in it.\n * @param source - The source code to search for queries\n * @param filename - The filename of the source code\n * @param babelConfig - The babel configuration to use when parsing the source\n * @param resolver - A resolver function to use when resolving module imports\n * @returns\n * @beta\n * @internal\n */\nexport function findQueriesInSource(\n  source: string,\n  filename: string,\n  babelConfig: TransformOptions = getBabelConfig(),\n  resolver: NodeJS.RequireResolve = require.resolve,\n): ExtractedModule {\n  const queries: ExtractedQuery[] = []\n  const errors: QueryExtractionError[] = []\n  const file = parseSourceFile(source, filename, babelConfig)\n\n  traverse(file, {\n    // Look for variable declarations, e.g. `const myQuery = groq`... and extract the query.\n    // The variable name is used as the name of the query result type\n    VariableDeclarator(path) {\n      const {node, scope} = path\n\n      const init = node.init\n\n      // Look for tagged template expressions that are called with the `groq` tag\n      const isGroqTemplateTag =\n        babelTypes.isTaggedTemplateExpression(init) &&\n        babelTypes.isIdentifier(init.tag) &&\n        init.tag.name === groqTagName\n\n      // Look for strings wrapped in a defineQuery function call\n      const isDefineQueryCall =\n        babelTypes.isCallExpression(init) &&\n        (isImportFrom(groqModuleName, defineQueryFunctionName, scope, init.callee) ||\n          isImportFrom(nextSanityModuleName, defineQueryFunctionName, scope, init.callee) ||\n          isImportFrom(sveltekitModuleName, defineQueryFunctionName, scope, init.callee))\n\n      if (babelTypes.isIdentifier(node.id) && (isGroqTemplateTag || isDefineQueryCall)) {\n        // If we find a comment leading the decleration which macthes with ignoreValue we don't add\n        // the query\n        if (declarationLeadingCommentContains(path, ignoreValue)) {\n          return\n        }\n\n        const {end, id, start} = node\n        const variable = {id, ...(start && {start}), ...(end && {end})}\n\n        try {\n          const query = resolveExpression({\n            babelConfig,\n            file,\n            filename,\n            node: init,\n            resolver,\n            scope,\n          })\n          queries.push({filename, query, variable})\n        } catch (cause) {\n          errors.push(new QueryExtractionError({cause, filename, variable}))\n        }\n      }\n    },\n  })\n\n  return {errors, filename, queries}\n}\n\nfunction declarationLeadingCommentContains(path: NodePath, comment: string): boolean {\n  /*\n   * We have to consider these cases:\n   *\n   * // @sanity-typegen-ignore\n   * const query = groq`...`\n   *\n   * // AST\n   * VariableDeclaration {\n   *   declarations: [\n   *     VariableDeclarator: {init: tag: {name: \"groq\"}}\n   *   ],\n   *   leadingComments: ...\n   * }\n   *\n   * // @sanity-typegen-ignore\n   * const query1 = groq`...`, query2 = groq`...`\n   *\n   * // AST\n   * VariableDeclaration {\n   *   declarations: [\n   *     VariableDeclarator: {init: tag: {name: \"groq\"}}\n   *     VariableDeclarator: {init: tag: {name: \"groq\"}}\n   *   ],\n   *   leadingComments: ...\n   * }\n   *\n   * // @sanity-typegen-ignore\n   * export const query = groq`...`\n   *\n   * // AST\n   * ExportNamedDeclaration {\n   *   declaration: VariableDeclaration {\n   *     declarations: [\n   *       VariableDeclarator: {init: tag: {name: \"groq\"}}\n   *       VariableDeclarator: {init: tag: {name: \"groq\"}}\n   *     ],\n   *   },\n   *   leadingComments: ...\n   * }\n   *\n   * In the case where multiple variables are under the same VariableDeclaration the leadingComments\n   * will still be on the VariableDeclaration\n   *\n   * In the case where the variable is exported, the leadingComments are on the\n   * ExportNamedDeclaration which includes the VariableDeclaration in its own declaration property\n   */\n\n  const variableDeclaration = path.find((node) => node.isVariableDeclaration())\n  if (!variableDeclaration) return false\n\n  if (\n    variableDeclaration.node.leadingComments?.find(\n      (commentItem) => commentItem.value.trim() === comment,\n    )\n  ) {\n    return true\n  }\n\n  // If the declaration is exported, the comment lies on the parent of the export declaration\n  if (\n    variableDeclaration.parent.leadingComments?.find(\n      (commentItem) => commentItem.value.trim() === comment,\n    )\n  ) {\n    return true\n  }\n\n  return false\n}\n\nfunction isImportFrom(\n  moduleName: string,\n  importName: string,\n  scope: Scope,\n  node: babelTypes.Expression | babelTypes.V8IntrinsicIdentifier,\n) {\n  if (babelTypes.isIdentifier(node)) {\n    const binding = scope.getBinding(node.name)\n    if (!binding) {\n      return false\n    }\n\n    const {path} = binding\n\n    // import { foo } from 'groq'\n    if (babelTypes.isImportSpecifier(path.node)) {\n      return (\n        path.node.importKind === 'value' &&\n        path.parentPath &&\n        babelTypes.isImportDeclaration(path.parentPath.node) &&\n        path.parentPath.node.source.value === moduleName &&\n        babelTypes.isIdentifier(path.node.imported) &&\n        path.node.imported.name === importName\n      )\n    }\n\n    // const { defineQuery } = require('groq')\n    if (babelTypes.isVariableDeclarator(path.node)) {\n      const {init} = path.node\n      return (\n        babelTypes.isCallExpression(init) &&\n        babelTypes.isIdentifier(init.callee) &&\n        init.callee.name === 'require' &&\n        babelTypes.isStringLiteral(init.arguments[0]) &&\n        init.arguments[0].value === moduleName\n      )\n    }\n  }\n\n  // import * as foo from 'groq'\n  // foo.defineQuery(...)\n  if (babelTypes.isMemberExpression(node)) {\n    const {object, property} = node\n\n    if (!babelTypes.isIdentifier(object)) {\n      return false\n    }\n\n    const binding = scope.getBinding(object.name)\n    if (!binding) {\n      return false\n    }\n    const {path} = binding\n\n    return (\n      babelTypes.isIdentifier(object) &&\n      babelTypes.isIdentifier(property) &&\n      property.name === importName &&\n      babelTypes.isImportNamespaceSpecifier(path.node) &&\n      path.parentPath &&\n      babelTypes.isImportDeclaration(path.parentPath.node) &&\n      path.parentPath.node.source.value === moduleName\n    )\n  }\n\n  return false\n}\n"],"names":["createRequire","traverse","babelTypes","getBabelConfig","resolveExpression","parseSourceFile","QueryExtractionError","require","url","groqTagName","defineQueryFunctionName","groqModuleName","nextSanityModuleName","sveltekitModuleName","ignoreValue","findQueriesInSource","source","filename","babelConfig","resolver","resolve","queries","errors","file","VariableDeclarator","path","node","scope","init","isGroqTemplateTag","isTaggedTemplateExpression","isIdentifier","tag","name","isDefineQueryCall","isCallExpression","isImportFrom","callee","id","declarationLeadingCommentContains","end","start","variable","query","push","cause","comment","variableDeclaration","find","isVariableDeclaration","leadingComments","commentItem","value","trim","parent","moduleName","importName","binding","getBinding","isImportSpecifier","importKind","parentPath","isImportDeclaration","imported","isVariableDeclarator","isStringLiteral","arguments","isMemberExpression","object","property","isImportNamespaceSpecifier"],"mappings":"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"}