{"version":3,"sources":["../src/typeUtils.ts"],"sourcesContent":["/** Excludes `null` and `undefined` from a type. */\ntype NonNullish<T> = T extends null | undefined ? never : T\n\n/** Builds a tuple from elements, stopping at the first `never`. */\ntype TakeUntilNever<T extends unknown[]> = T extends [infer H, ...infer Rest]\n  ? [H] extends [never]\n    ? []\n    : [H, ...TakeUntilNever<Rest>]\n  : []\n\n/** Recursively navigates through a path, stripping nullability for key lookup. */\ntype NavigatePath<T, Path extends unknown[]> = Path extends []\n  ? NonNullish<T>\n  : Path extends [infer K, ...infer Rest]\n    ? K extends keyof NonNullish<T>\n      ? NavigatePath<NonNullish<T>[K], Rest>\n      : never\n    : never\n\n/** Recursively gets value at path, preserving nullability at final access. */\ntype GetAtPath<T, Path extends unknown[]> = Path extends []\n  ? T\n  : Path extends [infer K]\n    ? K extends keyof NonNullish<T>\n      ? NonNullish<T>[K]\n      : never\n    : Path extends [infer K, ...infer Rest]\n      ? K extends keyof NonNullish<T>\n        ? GetAtPath<NonNullish<T>[K], Rest>\n        : never\n      : never\n\n/**\n * Get a deeply nested property type from a complex type structure. Safely navigates\n * through nullable types (`T | null | undefined`) at each level, preserving the\n * nullability of the final accessed property.\n *\n * Supports up to 20 levels of nesting.\n *\n * @example\n * ```ts\n * type POST_QUERY_RESULT = {\n *   _id: string\n *   author: {\n *     profile: {\n *       name: string;\n *     } | null;\n *   } | null;\n *   links: Array<{\n *     _key: string\n *     type: 'link'\n *     label: string\n *     url: string\n *   }> | null\n * } | null\n *\n * // Basic property access:\n * type Id = Get<POST_QUERY_RESULT, '_id'>;\n * // → string\n *\n * // Nested property access:\n * type Profile = Get<POST_QUERY_RESULT, 'author', 'profile';\n * // → { name: string } | null\n *\n * // Array element access using `number`:\n * type Link = Get<POST_QUERY_RESULT, 'links', number, 'label'>;\n * // → string\n * ```\n */\nexport type Get<\n  T,\n  K1 extends keyof NonNullish<T>,\n  K2 extends keyof NavigatePath<T, [K1]> = never,\n  K3 extends keyof NavigatePath<T, [K1, K2]> = never,\n  K4 extends keyof NavigatePath<T, [K1, K2, K3]> = never,\n  K5 extends keyof NavigatePath<T, [K1, K2, K3, K4]> = never,\n  K6 extends keyof NavigatePath<T, [K1, K2, K3, K4, K5]> = never,\n  K7 extends keyof NavigatePath<T, [K1, K2, K3, K4, K5, K6]> = never,\n  K8 extends keyof NavigatePath<T, [K1, K2, K3, K4, K5, K6, K7]> = never,\n  K9 extends keyof NavigatePath<T, [K1, K2, K3, K4, K5, K6, K7, K8]> = never,\n  K10 extends keyof NavigatePath<T, [K1, K2, K3, K4, K5, K6, K7, K8, K9]> = never,\n  K11 extends keyof NavigatePath<T, [K1, K2, K3, K4, K5, K6, K7, K8, K9, K10]> = never,\n  K12 extends keyof NavigatePath<T, [K1, K2, K3, K4, K5, K6, K7, K8, K9, K10, K11]> = never,\n  K13 extends keyof NavigatePath<T, [K1, K2, K3, K4, K5, K6, K7, K8, K9, K10, K11, K12]> = never,\n  K14 extends keyof NavigatePath<T, [K1, K2, K3, K4, K5, K6, K7, K8, K9, K10, K11, K12, K13]> =\n    never,\n  K15 extends keyof NavigatePath<T, [K1, K2, K3, K4, K5, K6, K7, K8, K9, K10, K11, K12, K13, K14]> =\n    never,\n  K16 extends keyof NavigatePath<\n    T,\n    [K1, K2, K3, K4, K5, K6, K7, K8, K9, K10, K11, K12, K13, K14, K15]\n  > = never,\n  K17 extends keyof NavigatePath<\n    T,\n    [K1, K2, K3, K4, K5, K6, K7, K8, K9, K10, K11, K12, K13, K14, K15, K16]\n  > = never,\n  K18 extends keyof NavigatePath<\n    T,\n    [K1, K2, K3, K4, K5, K6, K7, K8, K9, K10, K11, K12, K13, K14, K15, K16, K17]\n  > = never,\n  K19 extends keyof NavigatePath<\n    T,\n    [K1, K2, K3, K4, K5, K6, K7, K8, K9, K10, K11, K12, K13, K14, K15, K16, K17, K18]\n  > = never,\n  K20 extends keyof NavigatePath<\n    T,\n    [K1, K2, K3, K4, K5, K6, K7, K8, K9, K10, K11, K12, K13, K14, K15, K16, K17, K18, K19]\n  > = never,\n> = GetAtPath<\n  T,\n  TakeUntilNever<\n    [K1, K2, K3, K4, K5, K6, K7, K8, K9, K10, K11, K12, K13, K14, K15, K16, K17, K18, K19, K20]\n  >\n>\n\n/**\n * Filter a union of object types by the _type property. This is handy when working with page builder\n * setups where the returned type is an array containing multiple types.\n *\n * @example\n * ```ts\n *\n * export type Callout = {\n *   _type: 'callout'\n *   title?: string\n *   content?: string\n * }\n *\n * export type Video = {\n *   _type: 'video'\n *   url?: string\n *   caption?: string\n * }\n * type FORM_QUERY_RESULT = {\n *   _id: string\n *   title?: string\n *   content?: Array<\n *     | ({ _key: string } & Callout)\n *     | ({ _key: string } & Video)\n *   >\n * } | null\n *\n * // Get the type of the content with the Get helper\n * type Content = Get<FORM_QUERY_RESULT, 'content', number>\n *\n * // Get the type for a callout module from the page builder type\n * type CalloutModule = FilterByType<Content, 'callout'>\n * // → { _key: string } & Callout\n * ```\n */\nexport type FilterByType<U extends {_type: string}, T extends U['_type']> = Extract<U, {_type: T}>\n"],"names":[],"mappings":"AAAA,iDAAiD,GAmHjD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkCC,GACD,WAAkG"}