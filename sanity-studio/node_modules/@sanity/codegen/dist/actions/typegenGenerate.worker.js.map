{"version":3,"sources":["../../src/actions/typegenGenerate.worker.ts"],"sourcesContent":["import {stat} from 'node:fs/promises'\nimport {isAbsolute, join} from 'node:path'\nimport {isMainThread, parentPort, workerData} from 'node:worker_threads'\n\nimport {WorkerChannelReporter} from '@sanity/worker-channels'\n\nimport {readSchema} from '../readSchema.js'\nimport {findQueriesInPath} from '../typescript/findQueriesInPath.js'\nimport {getResolver} from '../typescript/moduleResolver.js'\nimport {registerBabel} from '../typescript/registerBabel.js'\nimport {TypeGenerator} from '../typescript/typeGenerator.js'\nimport {TypegenGenerateTypesWorkerData, TypegenWorkerChannel} from './types.js'\n\nif (isMainThread || !parentPort) {\n  throw new Error('This module must be run as a worker thread')\n}\n\nregisterBabel()\n\nasync function main({\n  overloadClientMethods,\n  schemaPath,\n  searchPath,\n  workDir,\n}: TypegenGenerateTypesWorkerData) {\n  const report = WorkerChannelReporter.from<TypegenWorkerChannel>(parentPort)\n\n  const fullPath = isAbsolute(schemaPath) ? schemaPath : join(workDir, schemaPath)\n\n  try {\n    const schemaStats = await stat(fullPath)\n    if (!schemaStats.isFile()) {\n      throw new Error(`Schema path is not a file: ${schemaPath}`)\n    }\n  } catch (err) {\n    if (err instanceof Error && 'code' in err && err.code === 'ENOENT') {\n      // If the user has not provided a specific schema path (eg we're using the default), give some help\n      const hint = schemaPath === './schema.json' ? ` - did you run \"sanity schema extract\"?` : ''\n      throw new Error(`Schema file not found: ${fullPath}${hint}`, {cause: err})\n    }\n    throw err\n  }\n\n  const schema = await readSchema(fullPath)\n\n  report.event.loadedSchema()\n\n  const typeGenerator = new TypeGenerator()\n\n  const {files, queries} = findQueriesInPath({\n    path: searchPath,\n    resolver: getResolver(workDir),\n  })\n  report.event.typegenStarted({expectedFileCount: files.length})\n\n  const result = await typeGenerator.generateTypes({\n    overloadClientMethods,\n    queries,\n    reporter: report,\n    root: workDir,\n    schema,\n    schemaPath,\n  })\n  report.event.typegenComplete(result)\n}\n\nawait main(workerData)\n"],"names":["stat","isAbsolute","join","isMainThread","parentPort","workerData","WorkerChannelReporter","readSchema","findQueriesInPath","getResolver","registerBabel","TypeGenerator","Error","main","overloadClientMethods","schemaPath","searchPath","workDir","report","from","fullPath","schemaStats","isFile","err","code","hint","cause","schema","event","loadedSchema","typeGenerator","files","queries","path","resolver","typegenStarted","expectedFileCount","length","result","generateTypes","reporter","root","typegenComplete"],"mappings":"AAAA,SAAQA,IAAI,QAAO,mBAAkB;AACrC,SAAQC,UAAU,EAAEC,IAAI,QAAO,YAAW;AAC1C,SAAQC,YAAY,EAAEC,UAAU,EAAEC,UAAU,QAAO,sBAAqB;AAExE,SAAQC,qBAAqB,QAAO,0BAAyB;AAE7D,SAAQC,UAAU,QAAO,mBAAkB;AAC3C,SAAQC,iBAAiB,QAAO,qCAAoC;AACpE,SAAQC,WAAW,QAAO,kCAAiC;AAC3D,SAAQC,aAAa,QAAO,iCAAgC;AAC5D,SAAQC,aAAa,QAAO,iCAAgC;AAG5D,IAAIR,gBAAgB,CAACC,YAAY;IAC/B,MAAM,IAAIQ,MAAM;AAClB;AAEAF;AAEA,eAAeG,KAAK,EAClBC,qBAAqB,EACrBC,UAAU,EACVC,UAAU,EACVC,OAAO,EACwB;IAC/B,MAAMC,SAASZ,sBAAsBa,IAAI,CAAuBf;IAEhE,MAAMgB,WAAWnB,WAAWc,cAAcA,aAAab,KAAKe,SAASF;IAErE,IAAI;QACF,MAAMM,cAAc,MAAMrB,KAAKoB;QAC/B,IAAI,CAACC,YAAYC,MAAM,IAAI;YACzB,MAAM,IAAIV,MAAM,CAAC,2BAA2B,EAAEG,YAAY;QAC5D;IACF,EAAE,OAAOQ,KAAK;QACZ,IAAIA,eAAeX,SAAS,UAAUW,OAAOA,IAAIC,IAAI,KAAK,UAAU;YAClE,mGAAmG;YACnG,MAAMC,OAAOV,eAAe,kBAAkB,CAAC,uCAAuC,CAAC,GAAG;YAC1F,MAAM,IAAIH,MAAM,CAAC,uBAAuB,EAAEQ,WAAWK,MAAM,EAAE;gBAACC,OAAOH;YAAG;QAC1E;QACA,MAAMA;IACR;IAEA,MAAMI,SAAS,MAAMpB,WAAWa;IAEhCF,OAAOU,KAAK,CAACC,YAAY;IAEzB,MAAMC,gBAAgB,IAAInB;IAE1B,MAAM,EAACoB,KAAK,EAAEC,OAAO,EAAC,GAAGxB,kBAAkB;QACzCyB,MAAMjB;QACNkB,UAAUzB,YAAYQ;IACxB;IACAC,OAAOU,KAAK,CAACO,cAAc,CAAC;QAACC,mBAAmBL,MAAMM,MAAM;IAAA;IAE5D,MAAMC,SAAS,MAAMR,cAAcS,aAAa,CAAC;QAC/CzB;QACAkB;QACAQ,UAAUtB;QACVuB,MAAMxB;QACNU;QACAZ;IACF;IACAG,OAAOU,KAAK,CAACc,eAAe,CAACJ;AAC/B;AAEA,MAAMzB,KAAKR"}