{"version":3,"sources":["../../src/actions/typegenGenerate.ts"],"sourcesContent":["import {mkdir} from 'node:fs/promises'\nimport {dirname, isAbsolute, join} from 'node:path'\nimport {env} from 'node:process'\nimport {Worker} from 'node:worker_threads'\n\nimport {WorkerChannelReceiver} from '@sanity/worker-channels'\n\nimport {prepareConfig} from '../utils/config.js'\nimport {debug} from '../utils/debug.js'\nimport {processTypegenWorkerStream} from './streamProcessor.js'\nimport {\n  type GenerationResult,\n  type RunTypegenOptions,\n  TypegenGenerateTypesWorkerData,\n  TypegenWorkerChannel,\n} from './types.js'\n\n/**\n * Runs a single typegen generation.\n *\n * This is the programmatic API for generating TypeScript types from GROQ queries.\n * It spawns a worker thread to perform the generation and displays progress via CLI spinners.\n *\n * @param options - Configuration options including typegen config and working directory\n * @returns Generation result containing the generated code and statistics\n */\nexport async function runTypegenGenerate(options: RunTypegenOptions): Promise<GenerationResult> {\n  const {config, workDir} = options\n\n  const {formatGeneratedCode, generates, overloadClientMethods, path, schema} =\n    prepareConfig(config)\n\n  const outputPath = isAbsolute(generates) ? generates : join(workDir, generates)\n\n  // create output dir if it isn't there\n  const outputDir = dirname(outputPath)\n  await mkdir(outputDir, {recursive: true})\n\n  // set up worker\n  const workerPath = new URL('../actions/typegenGenerate.worker.js', import.meta.url)\n  const workerData: TypegenGenerateTypesWorkerData = {\n    overloadClientMethods,\n    schemaPath: schema,\n    searchPath: path,\n    workDir,\n  }\n  const worker = new Worker(workerPath, {env, workerData})\n\n  try {\n    const result = await processTypegenWorkerStream(\n      WorkerChannelReceiver.from<TypegenWorkerChannel>(worker),\n      {\n        formatGeneratedCode,\n        generates: outputPath,\n        overloadClientMethods,\n        path,\n        schema,\n      },\n    )\n\n    return result\n  } catch (err) {\n    debug('error generating types', err)\n    throw err\n  } finally {\n    worker.terminate()\n  }\n}\n"],"names":["mkdir","dirname","isAbsolute","join","env","Worker","WorkerChannelReceiver","prepareConfig","debug","processTypegenWorkerStream","runTypegenGenerate","options","config","workDir","formatGeneratedCode","generates","overloadClientMethods","path","schema","outputPath","outputDir","recursive","workerPath","URL","url","workerData","schemaPath","searchPath","worker","result","from","err","terminate"],"mappings":"AAAA,SAAQA,KAAK,QAAO,mBAAkB;AACtC,SAAQC,OAAO,EAAEC,UAAU,EAAEC,IAAI,QAAO,YAAW;AACnD,SAAQC,GAAG,QAAO,eAAc;AAChC,SAAQC,MAAM,QAAO,sBAAqB;AAE1C,SAAQC,qBAAqB,QAAO,0BAAyB;AAE7D,SAAQC,aAAa,QAAO,qBAAoB;AAChD,SAAQC,KAAK,QAAO,oBAAmB;AACvC,SAAQC,0BAA0B,QAAO,uBAAsB;AAQ/D;;;;;;;;CAQC,GACD,OAAO,eAAeC,mBAAmBC,OAA0B;IACjE,MAAM,EAACC,MAAM,EAAEC,OAAO,EAAC,GAAGF;IAE1B,MAAM,EAACG,mBAAmB,EAAEC,SAAS,EAAEC,qBAAqB,EAAEC,IAAI,EAAEC,MAAM,EAAC,GACzEX,cAAcK;IAEhB,MAAMO,aAAajB,WAAWa,aAAaA,YAAYZ,KAAKU,SAASE;IAErE,sCAAsC;IACtC,MAAMK,YAAYnB,QAAQkB;IAC1B,MAAMnB,MAAMoB,WAAW;QAACC,WAAW;IAAI;IAEvC,gBAAgB;IAChB,MAAMC,aAAa,IAAIC,IAAI,wCAAwC,YAAYC,GAAG;IAClF,MAAMC,aAA6C;QACjDT;QACAU,YAAYR;QACZS,YAAYV;QACZJ;IACF;IACA,MAAMe,SAAS,IAAIvB,OAAOiB,YAAY;QAAClB;QAAKqB;IAAU;IAEtD,IAAI;QACF,MAAMI,SAAS,MAAMpB,2BACnBH,sBAAsBwB,IAAI,CAAuBF,SACjD;YACEd;YACAC,WAAWI;YACXH;YACAC;YACAC;QACF;QAGF,OAAOW;IACT,EAAE,OAAOE,KAAK;QACZvB,MAAM,0BAA0BuB;QAChC,MAAMA;IACR,SAAU;QACRH,OAAOI,SAAS;IAClB;AACF"}