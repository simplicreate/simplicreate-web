{"version":3,"sources":["../../../src/loaders/studio/studioWorkerTask.ts"],"sourcesContent":["import {fileURLToPath} from 'node:url'\nimport {Worker, type WorkerOptions} from 'node:worker_threads'\n\nimport {type RequireProps} from '../../types.js'\nimport {isRecord} from '../../util/isRecord.js'\nimport {promisifyWorker} from '../../util/promisifyWorker.js'\n\n/**\n * Options for the studio worker task\n *\n * @internal\n */\ninterface StudioWorkerTaskOptions extends RequireProps<WorkerOptions, 'name'> {\n  studioRootPath: string\n}\n\n/**\n * Executes a worker file in a Sanity Studio browser context.\n *\n * This uses a combination of vite for \"bundling\" + jsdom for emulating a browser\n * environment under the hood, which means that the same thing that will work in vite\n * _should_ work in the worker - to a degree. If the user has defined any typescript\n * path aliases, these will have to be added as aliases to the vite config - the same\n * behavior as you would see with regular vite. Other things that are accounted for:\n *\n * - TypeScript support (+JSX, enums and other \"compilation needed\" features)\n * - CSS, font and other file imports will resolve to a file path\n * - CSS module imports will resolve to a javascript object of class names\n * - Environment variables are available both as `import.meta.env` and `process.env`,\n *   and `.env` files are loaded in the same way that they would in a Sanity studio.\n * - Browser globals not available in a Node.js environment but _are_ provided by JSDOM\n *   are defined directly to the Node environment as globals. While this polutes the\n *   global namespace, it is done only in the worker thread.\n * - Certain browser globals that are _not_ available in JSDOM are also provided to the\n *   global namespace - things like `requestIdleCallback`, `IntersectionObserver` etc.\n *   These are provided with a minimal stub implementation to make them not crash.\n *\n * @param filePath - Path to the worker file (`.ts` works and is encouraged)\n * @param options - Options to pass to the worker\n * @returns A promise that resolves with the message from the worker\n * @throws If the file does not exist\n * @throws If the worker exits with a non-zero code\n * @internal\n */\nexport function studioWorkerTask<T = unknown>(\n  filePath: URL,\n  options: StudioWorkerTaskOptions,\n): Promise<T> {\n  const worker = createStudioWorker(filePath, options)\n  return promisifyWorker<T>(worker)\n}\n\n/**\n * Creates a new worker for a studio worker task.\n *\n * This uses a combination of vite for \"bundling\" + jsdom for emulating a browser\n * environment under the hood, which means that the same thing that will work in vite\n * _should_ work in the worker - to a degree. If the user has defined any typescript\n * path aliases, these will have to be added as aliases to the vite config - the same\n * behavior as you would see with regular vite. Other things that are accounted for:\n *\n * - TypeScript support (+JSX, enums and other \"compilation needed\" features)\n * - CSS, font and other file imports will resolve to a file path\n * - CSS module imports will resolve to a javascript object of class names\n * - Environment variables are available both as `import.meta.env` and `process.env`,\n *   and `.env` files are loaded in the same way that they would in a Sanity studio.\n * - Browser globals not available in a Node.js environment but _are_ provided by JSDOM\n *   are defined directly to the Node environment as globals. While this polutes the\n *   global namespace, it is done only in the worker thread.\n * - Certain browser globals that are _not_ available in JSDOM are also provided to the\n *   global namespace - things like `requestIdleCallback`, `IntersectionObserver` etc.\n *   These are provided with a minimal stub implementation to make them not crash.\n *\n * @param filePath - Path to the worker file (`.ts` works and is encouraged)\n * @param options - Options to pass to the worker\n * @returns A promise that resolves with the message from the worker\n * @throws If the file does not exist\n * @throws If the worker exits with a non-zero code\n * @internal\n */\nexport function createStudioWorker(filePath: URL, options: StudioWorkerTaskOptions) {\n  const normalizedFilePath = fileURLToPath(filePath)\n\n  if (!/\\.worker\\.(js|ts)$/.test(normalizedFilePath)) {\n    throw new Error('Studio worker tasks must include `.worker.(js|ts)` in path')\n  }\n\n  return new Worker(new URL('studioWorkerLoader.worker.js', import.meta.url), {\n    ...options,\n    env: {\n      ...(isRecord(options.env) ? options.env : process.env),\n      STUDIO_WORKER_STUDIO_ROOT_PATH: options.studioRootPath,\n      STUDIO_WORKER_TASK_FILE: normalizedFilePath,\n    },\n  })\n}\n"],"names":["fileURLToPath","Worker","isRecord","promisifyWorker","studioWorkerTask","filePath","options","worker","createStudioWorker","normalizedFilePath","test","Error","URL","url","env","process","STUDIO_WORKER_STUDIO_ROOT_PATH","studioRootPath","STUDIO_WORKER_TASK_FILE"],"mappings":"AAAA,SAAQA,aAAa,QAAO,WAAU;AACtC,SAAQC,MAAM,QAA2B,sBAAqB;AAG9D,SAAQC,QAAQ,QAAO,yBAAwB;AAC/C,SAAQC,eAAe,QAAO,gCAA+B;AAW7D;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2BC,GACD,OAAO,SAASC,iBACdC,QAAa,EACbC,OAAgC;IAEhC,MAAMC,SAASC,mBAAmBH,UAAUC;IAC5C,OAAOH,gBAAmBI;AAC5B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2BC,GACD,OAAO,SAASC,mBAAmBH,QAAa,EAAEC,OAAgC;IAChF,MAAMG,qBAAqBT,cAAcK;IAEzC,IAAI,CAAC,qBAAqBK,IAAI,CAACD,qBAAqB;QAClD,MAAM,IAAIE,MAAM;IAClB;IAEA,OAAO,IAAIV,OAAO,IAAIW,IAAI,gCAAgC,YAAYC,GAAG,GAAG;QAC1E,GAAGP,OAAO;QACVQ,KAAK;YACH,GAAIZ,SAASI,QAAQQ,GAAG,IAAIR,QAAQQ,GAAG,GAAGC,QAAQD,GAAG;YACrDE,gCAAgCV,QAAQW,cAAc;YACtDC,yBAAyBT;QAC3B;IACF;AACF"}