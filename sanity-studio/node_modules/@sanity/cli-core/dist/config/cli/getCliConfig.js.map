{"version":3,"sources":["../../../src/config/cli/getCliConfig.ts"],"sourcesContent":["import {debug} from '../../debug.js'\nimport {importModule} from '../../util/importModule.js'\nimport {NotFoundError} from '../../util/NotFoundError.js'\nimport {findPathForFiles} from '../util/findConfigsPaths.js'\nimport {cliConfigSchema} from './schemas.js'\nimport {type CliConfig} from './types/cliConfig.js'\n\n/**\n * Get the CLI config for a project, given the root path.\n *\n * We really want to avoid loading the CLI config in the main thread, as we'll need\n * TypeScript loading logic, potentially with ts path aliases, syntax extensions and all\n * sorts of nonsense. Thus, we _attempt_ to use a worker thread - but have to fall back\n * to using the main thread if not possible. This can be the case if the configuration\n * contains non-serializable properties, such as functions. This is unfortunately used\n * by the vite config, for example.\n *\n * @param rootPath - Root path for the project, eg where `sanity.cli.(ts|js)` is located.\n * @returns The CLI config\n * @internal\n */\nexport async function getCliConfig(rootPath: string): Promise<CliConfig> {\n  const paths = await findPathForFiles(rootPath, ['sanity.cli.ts', 'sanity.cli.js'])\n  const configPaths = paths.filter((path) => path.exists)\n\n  if (configPaths.length === 0) {\n    throw new NotFoundError(`No CLI config found at ${rootPath}/sanity.cli.(ts|js)`)\n  }\n\n  if (configPaths.length > 1) {\n    throw new Error(\n      `Multiple CLI config files found (${configPaths.map((path) => path.path).join(', ')})`,\n    )\n  }\n\n  const configPath = configPaths[0].path\n\n  debug(`Loading CLI config from: ${configPath}`)\n\n  let cliConfig: CliConfig | undefined\n  try {\n    const result = await importModule<CliConfig>(configPath)\n\n    debug('CLI config loaded: %o', result)\n\n    cliConfig = result\n  } catch (err) {\n    debug('Failed to load CLI config in worker thread: %s', err)\n\n    throw new Error('CLI config cannot be loaded', {cause: err})\n  }\n\n  const {data, error, success} = cliConfigSchema.safeParse(cliConfig)\n  if (!success) {\n    debug(`Invalid CLI config: ${error.message}`)\n    throw new Error(`Invalid CLI config: ${error.message}`, {cause: error})\n  }\n\n  return data\n}\n"],"names":["debug","importModule","NotFoundError","findPathForFiles","cliConfigSchema","getCliConfig","rootPath","paths","configPaths","filter","path","exists","length","Error","map","join","configPath","cliConfig","result","err","cause","data","error","success","safeParse","message"],"mappings":"AAAA,SAAQA,KAAK,QAAO,iBAAgB;AACpC,SAAQC,YAAY,QAAO,6BAA4B;AACvD,SAAQC,aAAa,QAAO,8BAA6B;AACzD,SAAQC,gBAAgB,QAAO,8BAA6B;AAC5D,SAAQC,eAAe,QAAO,eAAc;AAG5C;;;;;;;;;;;;;CAaC,GACD,OAAO,eAAeC,aAAaC,QAAgB;IACjD,MAAMC,QAAQ,MAAMJ,iBAAiBG,UAAU;QAAC;QAAiB;KAAgB;IACjF,MAAME,cAAcD,MAAME,MAAM,CAAC,CAACC,OAASA,KAAKC,MAAM;IAEtD,IAAIH,YAAYI,MAAM,KAAK,GAAG;QAC5B,MAAM,IAAIV,cAAc,CAAC,uBAAuB,EAAEI,SAAS,mBAAmB,CAAC;IACjF;IAEA,IAAIE,YAAYI,MAAM,GAAG,GAAG;QAC1B,MAAM,IAAIC,MACR,CAAC,iCAAiC,EAAEL,YAAYM,GAAG,CAAC,CAACJ,OAASA,KAAKA,IAAI,EAAEK,IAAI,CAAC,MAAM,CAAC,CAAC;IAE1F;IAEA,MAAMC,aAAaR,WAAW,CAAC,EAAE,CAACE,IAAI;IAEtCV,MAAM,CAAC,yBAAyB,EAAEgB,YAAY;IAE9C,IAAIC;IACJ,IAAI;QACF,MAAMC,SAAS,MAAMjB,aAAwBe;QAE7ChB,MAAM,yBAAyBkB;QAE/BD,YAAYC;IACd,EAAE,OAAOC,KAAK;QACZnB,MAAM,kDAAkDmB;QAExD,MAAM,IAAIN,MAAM,+BAA+B;YAACO,OAAOD;QAAG;IAC5D;IAEA,MAAM,EAACE,IAAI,EAAEC,KAAK,EAAEC,OAAO,EAAC,GAAGnB,gBAAgBoB,SAAS,CAACP;IACzD,IAAI,CAACM,SAAS;QACZvB,MAAM,CAAC,oBAAoB,EAAEsB,MAAMG,OAAO,EAAE;QAC5C,MAAM,IAAIZ,MAAM,CAAC,oBAAoB,EAAES,MAAMG,OAAO,EAAE,EAAE;YAACL,OAAOE;QAAK;IACvE;IAEA,OAAOD;AACT"}