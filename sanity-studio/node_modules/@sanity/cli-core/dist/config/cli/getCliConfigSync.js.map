{"version":3,"sources":["../../../src/config/cli/getCliConfigSync.ts"],"sourcesContent":["import {existsSync} from 'node:fs'\nimport {createRequire} from 'node:module'\nimport {join} from 'node:path'\n\nimport {register} from 'tsx/esm/api'\n\nimport {NotFoundError} from '../../util/NotFoundError.js'\nimport {tryGetDefaultExport} from '../../util/tryGetDefaultExport.js'\nimport {cliConfigSchema} from './schemas.js'\nimport {type CliConfig} from './types/cliConfig.js'\n\n/**\n * Get the CLI config for a project synchronously, given the root path.\n *\n * This loads the CLI config in the main thread using tsx/register for TypeScript support.\n * Note: This is a synchronous operation and does not use worker threads like the async version.\n *\n * @param rootPath - Root path for the project, eg where `sanity.cli.(ts|js)` is located.\n * @returns The CLI config\n * @internal\n */\nexport function getCliConfigSync(rootPath: string): CliConfig {\n  const possiblePaths = ['sanity.cli.ts', 'sanity.cli.js'].map((file) => join(rootPath, file))\n  const configPaths = possiblePaths.filter((path) => existsSync(path))\n\n  if (configPaths.length === 0) {\n    throw new NotFoundError(`No CLI config found at ${rootPath}/sanity.cli.(ts|js)`)\n  }\n\n  if (configPaths.length > 1) {\n    throw new Error(`Multiple CLI config files found (${configPaths.join(', ')})`)\n  }\n\n  const configPath = configPaths[0]\n\n  // Register tsx for TypeScript support\n  const unregister = register()\n\n  let cliConfig: CliConfig | undefined\n  try {\n    // Use createRequire for synchronous loading in ESM contexts\n    // This works when tsx loader is active\n    const require = createRequire(import.meta.url)\n    const loaded = require(configPath)\n    cliConfig = tryGetDefaultExport(loaded) as CliConfig | undefined\n  } finally {\n    unregister()\n  }\n\n  const {data, error, success} = cliConfigSchema.safeParse(cliConfig)\n  if (!success) {\n    throw new Error(`Invalid CLI config: ${error.message}`)\n  }\n\n  // There is a minor difference here because of the `vite` property and how the types\n  // aren't as specific as our manually typed `CliConfig` type, thus the cast.\n  return data as CliConfig\n}\n"],"names":["existsSync","createRequire","join","register","NotFoundError","tryGetDefaultExport","cliConfigSchema","getCliConfigSync","rootPath","possiblePaths","map","file","configPaths","filter","path","length","Error","configPath","unregister","cliConfig","require","url","loaded","data","error","success","safeParse","message"],"mappings":"AAAA,SAAQA,UAAU,QAAO,UAAS;AAClC,SAAQC,aAAa,QAAO,cAAa;AACzC,SAAQC,IAAI,QAAO,YAAW;AAE9B,SAAQC,QAAQ,QAAO,cAAa;AAEpC,SAAQC,aAAa,QAAO,8BAA6B;AACzD,SAAQC,mBAAmB,QAAO,oCAAmC;AACrE,SAAQC,eAAe,QAAO,eAAc;AAG5C;;;;;;;;;CASC,GACD,OAAO,SAASC,iBAAiBC,QAAgB;IAC/C,MAAMC,gBAAgB;QAAC;QAAiB;KAAgB,CAACC,GAAG,CAAC,CAACC,OAAST,KAAKM,UAAUG;IACtF,MAAMC,cAAcH,cAAcI,MAAM,CAAC,CAACC,OAASd,WAAWc;IAE9D,IAAIF,YAAYG,MAAM,KAAK,GAAG;QAC5B,MAAM,IAAIX,cAAc,CAAC,uBAAuB,EAAEI,SAAS,mBAAmB,CAAC;IACjF;IAEA,IAAII,YAAYG,MAAM,GAAG,GAAG;QAC1B,MAAM,IAAIC,MAAM,CAAC,iCAAiC,EAAEJ,YAAYV,IAAI,CAAC,MAAM,CAAC,CAAC;IAC/E;IAEA,MAAMe,aAAaL,WAAW,CAAC,EAAE;IAEjC,sCAAsC;IACtC,MAAMM,aAAaf;IAEnB,IAAIgB;IACJ,IAAI;QACF,4DAA4D;QAC5D,uCAAuC;QACvC,MAAMC,UAAUnB,cAAc,YAAYoB,GAAG;QAC7C,MAAMC,SAASF,QAAQH;QACvBE,YAAYd,oBAAoBiB;IAClC,SAAU;QACRJ;IACF;IAEA,MAAM,EAACK,IAAI,EAAEC,KAAK,EAAEC,OAAO,EAAC,GAAGnB,gBAAgBoB,SAAS,CAACP;IACzD,IAAI,CAACM,SAAS;QACZ,MAAM,IAAIT,MAAM,CAAC,oBAAoB,EAAEQ,MAAMG,OAAO,EAAE;IACxD;IAEA,oFAAoF;IACpF,4EAA4E;IAC5E,OAAOJ;AACT"}