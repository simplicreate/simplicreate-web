{"version":3,"sources":["../../src/telemetry/createTelemetryStore.ts"],"sourcesContent":["import {appendFileSync} from 'node:fs'\nimport {mkdir} from 'node:fs/promises'\nimport {dirname} from 'node:path'\n\nimport {type TelemetryEvent} from '@sanity/telemetry'\n\nimport {generateTelemetryFilePath} from './generateTelemetryFilePath.js'\nimport {createLogger} from './logger.js'\nimport {telemetryStoreDebug} from './telemetryStoreDebug.js'\nimport {type CLITelemetryStore, type ConsentInformation, TelemetryUserProperties} from './types.js'\n\n/**\n * FILE MANAGEMENT STRATEGY:\n *\n * The telemetry system uses a multi-file approach to handle concurrent CLI processes:\n *\n * 1. WRITING (per session):\n *    - Each CLI session gets a unique file: telemetry-\\{hash\\}-\\{env\\}-\\{sessionId\\}.ndjson\n *    - Prevents write conflicts when multiple CLI commands run simultaneously\n *    - Events are written using an RxJS queue for ordered processing with retry logic\n *\n * 2. FLUSHING (aggregate all sessions):\n *    - findTelemetryFiles() discovers ALL telemetry files for user/environment\n *    - Events are collected from all session files and sent as a batch\n *    - Files are deleted after successful transmission\n *\n * 3. CLEANUP (background maintenance):\n *    - cleanupOldTelemetryFiles() removes stale files older than 7 days\n *    - Prevents disk space accumulation from abandoned sessions\n */\n\ninterface CreateTelemetryStoreOptions {\n  resolveConsent: () => Promise<ConsentInformation>\n}\n\n/**\n * Creates a file-based telemetry store with cached consent and reliable synchronous I/O.\n *\n * Key optimizations:\n * - Consent resolved once at creation and cached (vs checking on every emit)\n * - File path generated and directory created once during initialization\n * - Synchronous file writes to ensure events are captured even during process exit\n *\n * @param sessionId - Unique session identifier for file isolation\n * @param options - Configuration options\n * @returns TelemetryStore instance compatible with the telemetry interface\n *\n * @internal\n */\nexport function createTelemetryStore(\n  sessionId: string,\n  options: CreateTelemetryStoreOptions,\n): CLITelemetryStore {\n  telemetryStoreDebug('Creating telemetry store with sessionId: %s', sessionId)\n\n  let cachedConsent: ConsentInformation | null = null\n  let filePath: string | null = null\n\n  const initializeConsent = async () => {\n    if (cachedConsent) return\n\n    try {\n      cachedConsent = await options.resolveConsent()\n      telemetryStoreDebug('Cached consent status: %s', cachedConsent.status)\n    } catch (error) {\n      telemetryStoreDebug('Failed to initialize consent, treating as undetermined: %o', error)\n      cachedConsent = {reason: 'fetchError', status: 'undetermined'}\n    }\n  }\n\n  const initializeFilePath = async () => {\n    if (filePath) return\n\n    try {\n      filePath = await generateTelemetryFilePath(sessionId)\n      telemetryStoreDebug('Generated file path: %s', filePath)\n\n      await mkdir(dirname(filePath), {recursive: true})\n      telemetryStoreDebug('Created directory structure for: %s', filePath)\n    } catch (error) {\n      telemetryStoreDebug('Failed to initialize file path: %o', error)\n      filePath = null\n    }\n  }\n\n  const emit = (event: TelemetryEvent) => {\n    if (!cachedConsent || cachedConsent.status !== 'granted') {\n      if (cachedConsent) {\n        telemetryStoreDebug(\n          'Cached consent not granted (%s), skipping event: %s',\n          cachedConsent.status,\n          event.type,\n        )\n      } else {\n        telemetryStoreDebug('Consent not resolved, skipping event: %s', event.type)\n      }\n      return\n    }\n\n    if (!filePath) {\n      telemetryStoreDebug('File path not initialized, skipping event: %s', event.type)\n      return\n    }\n\n    telemetryStoreDebug('Emitting event: %s', event.type)\n\n    try {\n      const eventLine = JSON.stringify(event) + '\\n'\n\n      // We use synchronous file writes to ensure telemetry events are captured even when\n      // the process exits abruptly (process.exit, uncaught exceptions, SIGTERM, etc.).\n      // The performance impact is probably negligible and is worth the trade-off\n      // for 100% reliability. Async writes would be lost when the event loop\n      // shuts down during process exit.\n      appendFileSync(filePath, eventLine, 'utf8')\n      telemetryStoreDebug('Successfully wrote event to file: %s', filePath)\n    } catch (error) {\n      telemetryStoreDebug('Failed to write telemetry event: %o', error)\n      // Silent failure - don't break CLI functionality\n    }\n  }\n\n  const logger = createLogger<TelemetryUserProperties>(sessionId, emit)\n\n  // Initialize both consent and file path concurrently\n  Promise.allSettled([initializeConsent(), initializeFilePath()]).then((results) => {\n    for (const [index, result] of results.entries()) {\n      if (result.status === 'rejected') {\n        const type = index === 0 ? 'consent' : 'file path'\n        telemetryStoreDebug('Error initializing %s: %o', type, result.reason)\n      }\n    }\n  })\n\n  return logger\n}\n"],"names":["appendFileSync","mkdir","dirname","generateTelemetryFilePath","createLogger","telemetryStoreDebug","createTelemetryStore","sessionId","options","cachedConsent","filePath","initializeConsent","resolveConsent","status","error","reason","initializeFilePath","recursive","emit","event","type","eventLine","JSON","stringify","logger","Promise","allSettled","then","results","index","result","entries"],"mappings":"AAAA,SAAQA,cAAc,QAAO,UAAS;AACtC,SAAQC,KAAK,QAAO,mBAAkB;AACtC,SAAQC,OAAO,QAAO,YAAW;AAIjC,SAAQC,yBAAyB,QAAO,iCAAgC;AACxE,SAAQC,YAAY,QAAO,cAAa;AACxC,SAAQC,mBAAmB,QAAO,2BAA0B;AA2B5D;;;;;;;;;;;;;CAaC,GACD,OAAO,SAASC,qBACdC,SAAiB,EACjBC,OAAoC;IAEpCH,oBAAoB,+CAA+CE;IAEnE,IAAIE,gBAA2C;IAC/C,IAAIC,WAA0B;IAE9B,MAAMC,oBAAoB;QACxB,IAAIF,eAAe;QAEnB,IAAI;YACFA,gBAAgB,MAAMD,QAAQI,cAAc;YAC5CP,oBAAoB,6BAA6BI,cAAcI,MAAM;QACvE,EAAE,OAAOC,OAAO;YACdT,oBAAoB,8DAA8DS;YAClFL,gBAAgB;gBAACM,QAAQ;gBAAcF,QAAQ;YAAc;QAC/D;IACF;IAEA,MAAMG,qBAAqB;QACzB,IAAIN,UAAU;QAEd,IAAI;YACFA,WAAW,MAAMP,0BAA0BI;YAC3CF,oBAAoB,2BAA2BK;YAE/C,MAAMT,MAAMC,QAAQQ,WAAW;gBAACO,WAAW;YAAI;YAC/CZ,oBAAoB,uCAAuCK;QAC7D,EAAE,OAAOI,OAAO;YACdT,oBAAoB,sCAAsCS;YAC1DJ,WAAW;QACb;IACF;IAEA,MAAMQ,OAAO,CAACC;QACZ,IAAI,CAACV,iBAAiBA,cAAcI,MAAM,KAAK,WAAW;YACxD,IAAIJ,eAAe;gBACjBJ,oBACE,uDACAI,cAAcI,MAAM,EACpBM,MAAMC,IAAI;YAEd,OAAO;gBACLf,oBAAoB,4CAA4Cc,MAAMC,IAAI;YAC5E;YACA;QACF;QAEA,IAAI,CAACV,UAAU;YACbL,oBAAoB,iDAAiDc,MAAMC,IAAI;YAC/E;QACF;QAEAf,oBAAoB,sBAAsBc,MAAMC,IAAI;QAEpD,IAAI;YACF,MAAMC,YAAYC,KAAKC,SAAS,CAACJ,SAAS;YAE1C,mFAAmF;YACnF,iFAAiF;YACjF,2EAA2E;YAC3E,uEAAuE;YACvE,kCAAkC;YAClCnB,eAAeU,UAAUW,WAAW;YACpChB,oBAAoB,wCAAwCK;QAC9D,EAAE,OAAOI,OAAO;YACdT,oBAAoB,uCAAuCS;QAC3D,iDAAiD;QACnD;IACF;IAEA,MAAMU,SAASpB,aAAsCG,WAAWW;IAEhE,qDAAqD;IACrDO,QAAQC,UAAU,CAAC;QAACf;QAAqBK;KAAqB,EAAEW,IAAI,CAAC,CAACC;QACpE,KAAK,MAAM,CAACC,OAAOC,OAAO,IAAIF,QAAQG,OAAO,GAAI;YAC/C,IAAID,OAAOjB,MAAM,KAAK,YAAY;gBAChC,MAAMO,OAAOS,UAAU,IAAI,YAAY;gBACvCxB,oBAAoB,6BAA6Be,MAAMU,OAAOf,MAAM;YACtE;QACF;IACF;IAEA,OAAOS;AACT"}