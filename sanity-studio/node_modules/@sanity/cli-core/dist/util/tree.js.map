{"version":3,"sources":["../../src/util/tree.ts"],"sourcesContent":["import {isIndexSegment, isIndexTuple, isKeySegment, type Path} from '@sanity/types'\n\n// FIXME: de-dupe this\n// copy/paste of `pathToString` from 'sanity' to prevent circular imports\nfunction pathToString(path: Path): string {\n  if (!Array.isArray(path)) {\n    throw new TypeError('Path is not an array')\n  }\n\n  let target = ''\n  let i = 0\n  for (const segment of path) {\n    if (isIndexSegment(segment)) {\n      target = `${target}[${segment}]`\n    } else if (isKeySegment(segment) && segment._key) {\n      target = `${target}[_key==\"${segment._key}\"]`\n    } else if (isIndexTuple(segment)) {\n      const [from, to] = segment\n      target = `${target}[${from}:${to}]`\n    } else if (typeof segment === 'string') {\n      const separator = i === 0 ? '' : '.'\n      target = `${target}${separator}${segment}`\n    } else {\n      throw new TypeError(`Unsupported path segment \\`${JSON.stringify(segment)}\\``)\n    }\n    i++\n  }\n  return target\n}\n\ninterface BaseNode {\n  path: Path\n}\n\nexport interface Tree<Node extends BaseNode> {\n  children?: Record<string, Tree<Node>>\n  nodes?: Node[]\n}\n\n/**\n * Recursively calculates the max length of all the keys in the given validation\n * tree respecting extra length due to indentation depth. Used to calculate the\n * padding for the rest of the tree.\n */\nexport const maxKeyLength = (children: Record<string, Tree<BaseNode>> = {}, depth = 0): number => {\n  let max = 0\n  for (const [key, child] of Object.entries(children)) {\n    const currentMax = Math.max(key.length + depth * 2, maxKeyLength(child.children, depth + 1))\n    max = Math.max(max, currentMax)\n  }\n  return max\n}\n\ninterface Options<Node extends BaseNode> {\n  getMessage: (node: Node) => string\n  paddingLength: number\n\n  getNodes?: (node: Tree<Node>) => Node[] | undefined\n  indent?: string\n  node?: Record<string, Tree<Node>>\n}\n\n/**\n * Recursively formats a given tree into a printed user-friendly tree structure\n */\nexport const formatTree = <Node extends BaseNode>({\n  getMessage,\n  getNodes: getLeaves = ({nodes}) => nodes,\n  indent = '',\n  node = {},\n  paddingLength,\n}: Options<Node>): string => {\n  const entries = Object.entries(node)\n\n  return entries\n    .map(([key, child], index) => {\n      const isLast = index === entries.length - 1\n      const nextIndent = `${indent}${isLast ? '  ' : '│ '}`\n      const leaves = getLeaves(child)\n\n      const nested = formatTree({\n        getMessage,\n        getNodes: getLeaves,\n        indent: nextIndent,\n        node: child.children,\n        paddingLength,\n      })\n\n      if (!leaves?.length) {\n        const current = `${indent}${isLast ? '└' : '├'}─ ${key}`\n        return [current, nested].filter(Boolean).join('\\n')\n      }\n\n      const [first, ...rest] = leaves\n      const firstPadding = '.'.repeat(paddingLength - indent.length - key.length)\n      const elbow = isLast ? '└' : '├'\n      const subsequentPadding = ' '.repeat(paddingLength - indent.length + 2)\n\n      const firstMessage = `${indent}${elbow}─ ${key} ${firstPadding} ${getMessage(first)}`\n      const subsequentMessages = rest\n        .map((marker) => `${nextIndent}${subsequentPadding} ${getMessage(marker)}`)\n        .join('\\n')\n\n      const current = [firstMessage, subsequentMessages].filter(Boolean).join('\\n')\n      return [current, nested].filter(Boolean).join('\\n')\n    })\n    .join('\\n')\n}\n\n/**\n * Converts a set of markers with paths into a tree of markers where the paths\n * are embedded in the tree\n */\nexport function convertToTree<const Node extends BaseNode>(nodes: Node[]): Tree<Node> {\n  const root: Tree<Node> = {}\n\n  // add the markers to the tree\n  function addNode(node: Node, tree: Tree<Node> = root) {\n    // if we've traversed the whole path\n    if (node.path.length === 0) {\n      if (!tree.nodes) tree.nodes = [] // ensure markers is defined\n\n      // then add the marker to the front\n      tree.nodes.push(node)\n      return\n    }\n\n    const [current, ...rest] = node.path\n    const key = pathToString([current])\n\n    // ensure the current node has children and the next node\n    if (!tree.children) tree.children = {}\n    if (!(key in tree.children)) tree.children[key] = {}\n\n    addNode({...node, path: rest}, tree.children[key])\n  }\n\n  for (const node of nodes) addNode(node)\n  return root\n}\n"],"names":["isIndexSegment","isIndexTuple","isKeySegment","pathToString","path","Array","isArray","TypeError","target","i","segment","_key","from","to","separator","JSON","stringify","maxKeyLength","children","depth","max","key","child","Object","entries","currentMax","Math","length","formatTree","getMessage","getNodes","getLeaves","nodes","indent","node","paddingLength","map","index","isLast","nextIndent","leaves","nested","current","filter","Boolean","join","first","rest","firstPadding","repeat","elbow","subsequentPadding","firstMessage","subsequentMessages","marker","convertToTree","root","addNode","tree","push"],"mappings":"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"}