{"version":3,"sources":["../../src/util/createExpiringConfig.ts"],"sourcesContent":["import type ConfigStore from 'configstore'\n\ninterface ExpiringConfigValue {\n  updatedAt: number\n  value: unknown\n}\n\nexport interface ExpiringConfigOptions<Type> {\n  /** Fetch value */\n  fetchValue: () => Promise<Type> | Type\n  /** Config key */\n  key: string\n  /** Config store */\n  store: ConfigStore\n  /** TTL (milliseconds) */\n  ttl: number\n\n  /** Subscribe to cache hit event */\n  onCacheHit?: () => void\n  /** Subscribe to fetch event */\n  onFetch?: () => void\n  /** Subscribe to revalidate event */\n  onRevalidate?: () => void\n\n  /**\n   * Assert the fetched value is valid, or throw if invalid.\n   * If none is provided, it will always accept the fetched value.\n   */\n  validateValue?: (value: unknown) => value is Type\n}\n\nexport interface ExpiringConfigApi<Type> {\n  /**\n   * Delete the cached value.\n   */\n  delete: () => void\n  /**\n   * Attempt to get the cached value. If there is no cached value, or the cached value has expired,\n   * fetch, cache, and return the value.\n   */\n  get: () => Promise<Type>\n}\n\n/**\n * Create a config in the provided config store that expires after the provided TTL.\n */\nexport function createExpiringConfig<Type>({\n  fetchValue,\n  key,\n  onCacheHit = () => null,\n  onFetch = () => null,\n  onRevalidate = () => null,\n  store,\n  ttl,\n  validateValue = (value: unknown): value is Type => true,\n}: ExpiringConfigOptions<Type>): ExpiringConfigApi<Type> {\n  let currentFetch: Promise<Type> | null = null\n  return {\n    delete() {\n      store.delete(key)\n    },\n    async get(): Promise<Type> {\n      const stored = store.get(key)\n\n      if (isExpiringValue(stored)) {\n        const {updatedAt, value} = stored\n        if (!validateValue(value)) {\n          throw new Error('Stored value is invalid')\n        }\n\n        const hasExpired = Date.now() - updatedAt > ttl\n\n        if (!hasExpired) {\n          onCacheHit()\n          return value\n        }\n\n        onRevalidate()\n      }\n\n      // Return existing fetch if one is already in progress\n      if (currentFetch) {\n        return currentFetch\n      }\n\n      onFetch()\n\n      currentFetch = Promise.resolve(fetchValue())\n      const nextValue = await currentFetch\n      if (!validateValue(nextValue)) {\n        throw new Error('Fetched value is invalid')\n      }\n\n      currentFetch = null\n\n      store.set(key, {\n        updatedAt: Date.now(),\n        value: nextValue,\n      })\n\n      return nextValue\n    },\n  }\n}\n\n/**\n * Checks if the given stored value is valid (does not check if expired, only verified shape)\n *\n * @param stored - The stored value to check\n * @returns True if the stored value is valid\n * @internal\n */\nfunction isExpiringValue(stored: unknown): stored is ExpiringConfigValue {\n  if (typeof stored !== 'object' || stored === null || Array.isArray(stored)) {\n    return false\n  }\n\n  if (!('updatedAt' in stored) || typeof stored.updatedAt !== 'number') {\n    return false\n  }\n\n  if (!('value' in stored)) {\n    return false\n  }\n\n  return true\n}\n"],"names":["createExpiringConfig","fetchValue","key","onCacheHit","onFetch","onRevalidate","store","ttl","validateValue","value","currentFetch","delete","get","stored","isExpiringValue","updatedAt","Error","hasExpired","Date","now","Promise","resolve","nextValue","set","Array","isArray"],"mappings":"AA2CA;;CAEC,GACD,OAAO,SAASA,qBAA2B,EACzCC,UAAU,EACVC,GAAG,EACHC,aAAa,IAAM,IAAI,EACvBC,UAAU,IAAM,IAAI,EACpBC,eAAe,IAAM,IAAI,EACzBC,KAAK,EACLC,GAAG,EACHC,gBAAgB,CAACC,QAAkC,IAAI,EAC3B;IAC5B,IAAIC,eAAqC;IACzC,OAAO;QACLC;YACEL,MAAMK,MAAM,CAACT;QACf;QACA,MAAMU;YACJ,MAAMC,SAASP,MAAMM,GAAG,CAACV;YAEzB,IAAIY,gBAAgBD,SAAS;gBAC3B,MAAM,EAACE,SAAS,EAAEN,KAAK,EAAC,GAAGI;gBAC3B,IAAI,CAACL,cAAcC,QAAQ;oBACzB,MAAM,IAAIO,MAAM;gBAClB;gBAEA,MAAMC,aAAaC,KAAKC,GAAG,KAAKJ,YAAYR;gBAE5C,IAAI,CAACU,YAAY;oBACfd;oBACA,OAAOM;gBACT;gBAEAJ;YACF;YAEA,sDAAsD;YACtD,IAAIK,cAAc;gBAChB,OAAOA;YACT;YAEAN;YAEAM,eAAeU,QAAQC,OAAO,CAACpB;YAC/B,MAAMqB,YAAY,MAAMZ;YACxB,IAAI,CAACF,cAAcc,YAAY;gBAC7B,MAAM,IAAIN,MAAM;YAClB;YAEAN,eAAe;YAEfJ,MAAMiB,GAAG,CAACrB,KAAK;gBACba,WAAWG,KAAKC,GAAG;gBACnBV,OAAOa;YACT;YAEA,OAAOA;QACT;IACF;AACF;AAEA;;;;;;CAMC,GACD,SAASR,gBAAgBD,MAAe;IACtC,IAAI,OAAOA,WAAW,YAAYA,WAAW,QAAQW,MAAMC,OAAO,CAACZ,SAAS;QAC1E,OAAO;IACT;IAEA,IAAI,CAAE,CAAA,eAAeA,MAAK,KAAM,OAAOA,OAAOE,SAAS,KAAK,UAAU;QACpE,OAAO;IACT;IAEA,IAAI,CAAE,CAAA,WAAWF,MAAK,GAAI;QACxB,OAAO;IACT;IAEA,OAAO;AACT"}