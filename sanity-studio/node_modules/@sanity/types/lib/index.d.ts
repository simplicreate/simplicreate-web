import { ComponentType, ElementType, ReactNode } from "react";
import { ClientPerspective, SanityClient, StackablePerspective } from "@sanity/client";
import { Asset as Asset$1, AssetInstanceDocument } from "@sanity/media-library-types";
/** @public */
interface SanityDocument {
  _id: string;
  _type: string;
  _createdAt: string;
  _updatedAt: string;
  _rev: string;
  [key: string]: unknown;
}
/**
 * Similar to `SanityDocument` but only requires the `_id` and `_type`
 *
 * @see SanityDocument
 *
 * @public
 */
interface SanityDocumentLike {
  _id: string;
  _type: string;
  _createdAt?: string;
  _updatedAt?: string;
  _rev?: string;
  _system?: {
    delete?: boolean;
  };
  [key: string]: unknown;
}
/** @public */
interface TypedObject {
  [key: string]: unknown;
  _type: string;
}
/** @public */
interface KeyedObject {
  [key: string]: unknown;
  _key: string;
}
/**
 * @internal
 */
interface StrictVersionLayeringOptions {
  /**
   * By default, version layering includes all document versions, regardless of their expected
   * publication time—or lack thereof. For example, it includes all ASAP and undecided versions,
   * despite ASAP and undecided versions having no fixed chronology. There is no way to determine
   * which ASAP or undecided version is expected to be published before another.
   *
   * It also includes any existing draft, which has no fixed chronology, either.
   *
   * This functionality is useful for listing all document versions in a deterministic order, but
   * doesn't accurately portray the upstream and downstream versions based on expected publication
   * time.
   *
   * In strict mode, version layering instead only includes versions that have a fixed chronology.
   * **Cross-version layering is only effective for scheduled versions, with all other
   * versions being layered directly onto the published version (if it exists).**
   */
  strict?: boolean;
}
/** @public */
declare function isSanityDocument(document: unknown): document is SanityDocument;
/** @public */
declare function isTypedObject(obj: unknown): obj is TypedObject;
/** @public */
declare function isKeyedObject(obj: unknown): obj is KeyedObject;
/** @public */
type KeyedSegment = {
  _key: string;
};
/** @public */
type IndexTuple = [number | '', number | ''];
/** @public */
type PathSegment = string | number | KeyedSegment | IndexTuple;
/** @public */
type Path = PathSegment[];
/** @internal */
declare function isIndexSegment(segment: PathSegment): segment is number;
/** @internal */
declare function isKeySegment(segment: PathSegment): segment is KeyedSegment;
/** @internal */
declare function isIndexTuple(segment: PathSegment): segment is IndexTuple;
/** @beta */
interface CrossDatasetReferenceValue {
  _type: string;
  _dataset: string;
  _projectId: string;
  _ref: string;
  _key?: string;
  _weak?: boolean;
}
/** @beta */
interface WeakCrossDatasetReferenceValue extends CrossDatasetReferenceValue {
  _weak: true;
}
/** @beta */
type CrossDatasetReferenceFilterSearchOptions = {
  filter?: string;
  params?: Record<string, unknown>;
  tag?: string;
};
/** @beta */
type CrossDatasetReferenceFilterResolver = (options: {
  document: SanityDocument;
  parent?: Record<string, unknown> | Record<string, unknown>[];
  parentPath: Path;
}) => CrossDatasetReferenceFilterSearchOptions | Promise<CrossDatasetReferenceFilterSearchOptions>;
/** @beta */
interface CrossDatasetType {
  type: string;
  title?: string;
  icon: ComponentType;
  preview: PreviewConfig;
  /** @deprecated Unused. Configuring search is no longer supported for cross-dataset references. */
  __experimental_search?: ObjectSchemaType['__experimental_search'];
}
/** @beta */
interface CrossDatasetReferenceSchemaType extends Omit<ObjectSchemaType, 'options'> {
  jsonType: 'object';
  to: CrossDatasetType[];
  dataset: string;
  studioUrl?: (document: {
    id: string;
    type?: string;
  }) => string | null;
  weak?: boolean;
  options?: ReferenceFilterOptions;
}
/** @beta */
declare function isCrossDatasetReference(reference: unknown): reference is CrossDatasetReferenceValue;
/** @public */
interface Role {
  name: string;
  title: string;
  description?: string;
}
/** @public */
interface CurrentUser {
  id: string;
  name: string;
  email: string;
  profileImage?: string;
  provider?: string;
  /** @deprecated use `roles` instead */
  role: string;
  roles: Role[];
}
/** @public */
interface User {
  id: string;
  displayName?: string;
  imageUrl?: string;
  email?: string;
}
/** @public */
interface ValidationMarker {
  level: 'error' | 'warning' | 'info';
  /**
   * The validation message for this marker. E.g. "Must be greater than 0"
   */
  message: string;
  /**
   * @deprecated use `message` instead
   */
  item?: ValidationError;
  /**
   * The sanity path _relative to the root of the current document_ to this
   * marker.
   *
   * NOTE: Sanity paths may contain keyed segments (i.e. `{_key: string}`) that
   * are not compatible with deep getters like lodash/get
   */
  path: Path;
  /**
   * Extra metadata for the validation marker. Currently used by the Media Library asset source to ignore
   * certain validation markers when validating asset source media library assets.
   *
   * @internal
   */
  __internal_metadata?: unknown;
}
/** @internal */
declare function isValidationErrorMarker(marker: ValidationMarker): marker is ValidationMarker & {
  level: 'error';
};
/** @internal */
declare function isValidationWarningMarker(marker: ValidationMarker): marker is ValidationMarker & {
  level: 'warning';
};
/** @internal */
declare function isValidationInfoMarker(marker: ValidationMarker): marker is ValidationMarker & {
  level: 'info';
};
/**
 * A slug object, currently holding a `current` property
 *
 * In the future, this may be extended with a `history` property
 *
 * @public
 */
interface Slug {
  _type: 'slug';
  current: string;
}
/** @public */
type SlugParent = Record<string, unknown> | Record<string, unknown>[];
/** @public */
interface SlugSourceContext {
  parentPath: Path;
  parent: SlugParent;
  projectId: string;
  dataset: string;
  schema: Schema;
  currentUser: CurrentUser | null;
  getClient: (options: {
    apiVersion: string;
  }) => SanityClient;
}
/** @public */
type SlugSourceFn = (document: SanityDocument, context: SlugSourceContext) => string | Promise<string>;
/** @public */
type SlugifierFn = (source: string, schemaType: SlugSchemaType, context: SlugSourceContext) => string | Promise<string>;
/**
 * Checks whether the given `thing` is a slug, eg an object with a `current` string property.
 *
 * @param thing - The thing to check
 * @returns True if slug, false otherwise
 * @public
 */
declare function isSlug(thing: unknown): thing is Slug;
/** @public */
type RuleTypeConstraint = 'Array' | 'Boolean' | 'Date' | 'Number' | 'Object' | 'String';
/** @public */
type FieldRules = {
  [fieldKey: string]: SchemaValidationValue;
};
/**
 * Holds localized validation messages for a given field.
 *
 * @example Custom message for English (US) and Norwegian (Bokmål):
 * ```
 * {
 *   'en-US': 'Needs to start with a capital letter',
 *   'no-NB': 'Må starte med stor bokstav',
 * }
 * ```
 * @public
 */
interface LocalizedValidationMessages {
  [locale: string]: string;
}
/**
 * Note: `RuleClass` and `Rule` are split to fit the current `@sanity/types`
 * setup. Classes are a bit weird in the `@sanity/types` package because classes
 * create an actual javascript class while simultaneously creating a type
 * definition.
 *
 * This implicitly creates two types:
 * 1. the instance type — `Rule` and
 * 2. the static/class type - `RuleClass`
 *
 * The `RuleClass` type contains the static methods and the `Rule` instance
 * contains the instance methods. Downstream in the validation package, the Rule
 * implementation asserts the class declaration is of this type.
 *
 * @internal
 */
interface RuleClass {
  FIELD_REF: symbol;
  array: (def?: SchemaType) => Rule;
  object: (def?: SchemaType) => Rule;
  string: (def?: SchemaType) => Rule;
  number: (def?: SchemaType) => Rule;
  boolean: (def?: SchemaType) => Rule;
  dateTime: (def?: SchemaType) => Rule;
  valueOfField: Rule['valueOfField'];
  new (typeDef?: SchemaType): Rule;
}
/**
 * Holds a reference to a different field
 * NOTE: Only use this through {@link Rule.valueOfField}
 *
 * @public
 */
interface FieldReference {
  type: symbol;
  path: string | string[];
}
/** @public */
interface UriValidationOptions {
  scheme?: (string | RegExp) | Array<string | RegExp>;
  allowRelative?: boolean;
  relativeOnly?: boolean;
  allowCredentials?: boolean;
}
/** @public */
interface Rule {
  /**
   * @internal
   * @deprecated internal use only
   */
  _type: RuleTypeConstraint | undefined;
  /**
   * @internal
   * @deprecated internal use only
   */
  _level: 'error' | 'warning' | 'info' | undefined;
  /**
   * @internal
   * @deprecated internal use only
   */
  _required: 'required' | 'optional' | undefined;
  /**
   * @internal
   * @deprecated internal use only
   */
  _typeDef: SchemaType | undefined;
  /**
   * @internal
   * @deprecated internal use only
   */
  _message: string | LocalizedValidationMessages | undefined;
  /**
   * @internal
   * @deprecated internal use only
   */
  _rules: RuleSpec[];
  /**
   * @internal
   * @deprecated internal use only
   */
  _fieldRules: FieldRules | undefined;
  /**
   * Takes in a path and returns an object with a symbol.
   *
   * When the validation lib sees this symbol, it will use the provided path to
   * get a value from the current field's parent and use that value as the input
   * to the Rule.
   *
   * The path that's given is forwarded to `lodash/get`
   *
   * ```js
   * fields: [
   * // ...
   *   {
   *     // ...
   *     name: 'highestTemperature',
   *     type: 'number',
   *     validation: (Rule) => Rule.positive().min(Rule.valueOfField('lowestTemperature')),
   *     // ...
   *   },
   * ]
   * ```
   */
  valueOfField: (path: string | string[]) => FieldReference;
  error(message?: string | LocalizedValidationMessages): Rule;
  warning(message?: string | LocalizedValidationMessages): Rule;
  info(message?: string | LocalizedValidationMessages): Rule;
  reset(): this;
  isRequired(): boolean;
  clone(): Rule;
  cloneWithRules(rules: RuleSpec[]): Rule;
  merge(rule: Rule): Rule;
  type(targetType: RuleTypeConstraint | Lowercase<RuleTypeConstraint>): Rule;
  all(children: Rule[]): Rule;
  either(children: Rule[]): Rule;
  optional(): Rule;
  required(): Rule;
  skip(): Rule;
  custom<T = unknown>(fn: CustomValidator<T>, options?: {
    bypassConcurrencyLimit?: boolean;
  }): Rule;
  media<T extends MediaAssetTypes = MediaAssetTypes>(fn: MediaValidator<T>): Rule;
  min(len: number | string | FieldReference): Rule;
  max(len: number | string | FieldReference): Rule;
  length(len: number | FieldReference): Rule;
  valid(value: unknown | unknown[]): Rule;
  integer(): Rule;
  precision(limit: number | FieldReference): Rule;
  positive(): Rule;
  negative(): Rule;
  greaterThan(num: number | FieldReference): Rule;
  lessThan(num: number | FieldReference): Rule;
  uppercase(): Rule;
  lowercase(): Rule;
  regex(pattern: RegExp, name: string, options: {
    name?: string;
    invert?: boolean;
  }): Rule;
  regex(pattern: RegExp, options: {
    name?: string;
    invert?: boolean;
  }): Rule;
  regex(pattern: RegExp, name: string): Rule;
  regex(pattern: RegExp): Rule;
  email(): Rule;
  uri(options?: UriValidationOptions): Rule;
  unique(): Rule;
  reference(): Rule;
  fields(rules: FieldRules): Rule;
  assetRequired(): Rule;
  validate(value: unknown, options: ValidationContext & {
    /**
     * @deprecated Internal use only
     * @internal
     */
    __internal?: {
      customValidationConcurrencyLimiter?: {
        ready: () => Promise<void>;
        release: () => void;
      };
    };
  }): Promise<ValidationMarker[]>;
}
/** @public */
type RuleSpec = {
  flag: 'integer';
} | {
  flag: 'email';
} | {
  flag: 'unique';
} | {
  flag: 'reference';
} | {
  flag: 'type';
  constraint: RuleTypeConstraint;
} | {
  flag: 'all';
  constraint: Rule[];
} | {
  flag: 'either';
  constraint: Rule[];
} | {
  flag: 'presence';
  constraint: 'optional' | 'required';
} | {
  flag: 'custom';
  constraint: CustomValidator;
} | {
  flag: 'min';
  constraint: number | string | FieldReference;
} | {
  flag: 'max';
  constraint: number | string | FieldReference;
} | {
  flag: 'length';
  constraint: number | FieldReference;
} | {
  flag: 'valid';
  constraint: unknown[];
} | {
  flag: 'precision';
  constraint: number | FieldReference;
} | {
  flag: 'lessThan';
  constraint: number | FieldReference;
} | {
  flag: 'greaterThan';
  constraint: number | FieldReference;
} | {
  flag: 'stringCasing';
  constraint: 'uppercase' | 'lowercase';
} | {
  flag: 'assetRequired';
  constraint: {
    assetType: 'asset' | 'image' | 'file';
  };
} | {
  flag: 'media';
  constraint: MediaValidator<any>;
} | {
  flag: 'regex';
  constraint: {
    pattern: RegExp;
    name?: string;
    invert: boolean;
  };
} | {
  flag: 'uri';
  constraint: {
    options: {
      scheme: RegExp[];
      allowRelative: boolean;
      relativeOnly: boolean;
      allowCredentials: boolean;
    };
  };
};
/**
 * this is used to get allow index access (e.g. `RuleSpec['constraint']`) to
 * constraint when a rule spec might not have a `constraint` prop
 *
 * @internal
 */
type ConditionalIndexAccess<T, U> = U extends keyof T ? T[U] : undefined;
/** @internal */
type RuleSpecConstraint<T extends RuleSpec['flag']> = ConditionalIndexAccess<Extract<RuleSpec, {
  flag: T;
}>, 'constraint'>;
/**
 * A context object passed around during validation. This includes the
 * `Rule.custom` context.
 *
 * e.g.
 *
 * ```js
 * Rule.custom((_, validationContext) => {
 *   // ...
 * })`
 * ```
 *
 * @public
 */
interface ValidationContext {
  getClient: (options: {
    apiVersion: string;
  }) => SanityClient;
  schema: Schema;
  parent?: unknown;
  type?: SchemaType;
  document?: SanityDocument;
  path?: Path;
  getDocumentExists?: (options: {
    id: string;
  }) => Promise<boolean>;
  environment: 'cli' | 'studio';
  /**
   * Whether this field is hidden for any reason (either itself or any of its ancestors).
   */
  hidden?: boolean;
}
/**
 * The base type for all validators in the validation library. Takes in a
 * `RuleSpec`'s constraint, the value to check, an optional override message,
 * and the validation context.
 *
 * @see Rule.validate from `sanity/src/core/validation/Rule`
 *
 * @internal
 */
type Validator<T = any, Value = any> = (constraint: T, value: Value, message: string | undefined, context: ValidationContext) => ValidationError[] | ValidationError | string | true | Promise<ValidationError[] | ValidationError | string | true>;
/**
 * A type helper used to define a group of validators. The type of the
 * `RuleSpec` constraint is inferred via the key.
 *
 * E.g.
 *
 * ```ts
 * const booleanValidators: Validators = {
 *   ...genericValidator,
 *
 *   presence: (v, value, message) => {
 *     if (v === 'required' && typeof value !== 'boolean') return message || 'Required'
 *     return true
 *   },
 * }
 * ```
 *
 * @internal
 */
type Validators = Partial<{ [P in RuleSpec['flag']]: Validator<Exclude<ConditionalIndexAccess<Extract<RuleSpec, {
  flag: P;
}>, 'constraint'>, FieldReference>> }>;
/** @internal */
interface ValidationErrorOptions {
  paths?: Path[];
  children?: ValidationMarker[];
  operation?: 'AND' | 'OR';
}
/**
 * This follows the same pattern as `RuleClass` and `Rule` above
 * Note: this class does not actually extend `Error` since it's never thrown
 * within the validation library
 *
 * @deprecated It is preferred to a plain object that adheres to `ValidationError`
 * @internal
 */
interface ValidationErrorClass {
  new (message: string, options?: ValidationErrorOptions): ValidationError;
}
/**
 * The shape that can be returned from a custom validator to be converted into
 * a validation marker by the validation logic. Inside of a custom validator,
 * you can return an array of these in order to specify multiple paths within
 * an object or array.
 *
 * @public
 */
interface ValidationError {
  /**
   * The message describing why the value is not valid. This message will be
   * included in the validation markers after validation has finished running.
   */
  message: string;
  /**
   * If writing a custom validator, you can return validation messages to
   * specific path inside of the current value (object or array) by populating
   * this `path` prop.
   *
   * NOTE: This path is relative to the current value and _not_ relative to
   * the document.
   */
  path?: Path;
  /**
   * Extra metadata for the validation error. Currently used by the Media Library asset source to ignore
   * certain validation markers when validating asset source media library assets.
   *
   * @internal
   */
  __internal_metadata?: unknown;
  /**
   * Same as `path` but allows more than one value. If provided, the same
   * message will create two markers from each path with the same message
   * provided.
   *
   * @deprecated prefer `path`
   */
  paths?: Path[];
  /**
   * @deprecated Unused. Was used to store the results from `.either()` /`.all()`
   */
  children?: ValidationMarker[];
  /**
   * @deprecated Unused. Was used to signal if this error came from an `.either()`/`.all()`.
   */
  operation?: 'AND' | 'OR';
  /**
   * @deprecated Unused. Was relevant when validation error was used as a class.
   */
  cloneWithMessage?(message: string): ValidationError;
}
/** @public */
type CustomValidatorResult = true | string | ValidationError | ValidationError[] | LocalizedValidationMessages;
/** @public */
interface CustomValidator<T = unknown> {
  (value: T, context: ValidationContext): CustomValidatorResult | Promise<CustomValidatorResult>;
  bypassConcurrencyLimit?: boolean;
}
/** @public */
type MediaAssetTypes = AssetInstanceDocument['_type'];
/** @public */
interface MediaValidator<T extends MediaAssetTypes = MediaAssetTypes> {
  (value: MediaValidationValue<T>, context: ValidationContext): CustomValidatorResult | Promise<CustomValidatorResult>;
}
/** @public */
interface MediaValidationValue<T extends MediaAssetTypes = MediaAssetTypes> {
  /**
   * Media information
   */
  media: {
    /**
     * The Media Library Asset.
     */
    asset: Asset$1 & {
      currentVersion: Extract<AssetInstanceDocument, {
        _type: T;
      }>;
    };
  };
  /**
   * The field value which the media is used in.
   */
  value: unknown;
}
/** @public */
interface SlugValidationContext extends ValidationContext {
  parent: SlugParent;
  type: SlugSchemaType;
  defaultIsUnique: SlugIsUniqueValidator;
}
/** @public */
type SlugIsUniqueValidator = (slug: string, context: SlugValidationContext) => boolean | Promise<boolean>;
/** @public */
interface FormNodeValidation {
  level: 'error' | 'warning' | 'info';
  message: string;
  path: Path;
}
/** @internal */
declare function isValidationError(node: FormNodeValidation): node is FormNodeValidation & {
  level: 'error';
};
/** @internal */
declare function isValidationWarning(node: FormNodeValidation): node is FormNodeValidation & {
  level: 'warning';
};
/** @internal */
declare function isValidationInfo(node: FormNodeValidation): node is FormNodeValidation & {
  level: 'info';
};
/** @alpha This API may change */
declare interface InsertMenuOptions {
  /**
   * @defaultValue `'auto'`
   * `filter: 'auto'` automatically turns on filtering if there are more than 5
   * schema types added to the menu.
   */
  filter?: "auto" | boolean | undefined;
  groups?: Array<{
    name: string;
    title?: string;
    of?: Array<string>;
  }> | undefined;
  /** defaultValue `true` */
  showIcons?: boolean | undefined;
  /** @defaultValue `[{name: 'list'}]` */
  views?: Array<{
    name: "list";
  } | {
    name: "grid";
    previewImageUrl?: (schemaTypeName: string) => string | undefined;
  }> | undefined;
}
/** @public */
interface RuleDef<T, FieldValue = unknown> {
  required: () => T;
  skip: () => T;
  custom: <LenientFieldValue extends FieldValue>(fn: CustomValidator<LenientFieldValue | undefined>) => T;
  info: (message?: string | LocalizedValidationMessages) => T;
  error: (message?: string | LocalizedValidationMessages) => T;
  warning: (message?: string | LocalizedValidationMessages) => T;
  valueOfField: (path: string | string[]) => FieldReference;
}
/** @public */
type RuleBuilder<T extends RuleDef<T, FieldValue>, FieldValue = unknown> = T | T[];
/** @public */
type ValidationBuilder<T extends RuleDef<T, FieldValue>, FieldValue = unknown> = (rule: T, context?: ValidationContext) => RuleBuilder<T, FieldValue>;
/** @public */
interface ObjectOptions extends BaseSchemaTypeOptions {
  collapsible?: boolean;
  collapsed?: boolean;
  columns?: number;
  modal?: {
    type?: 'dialog' | 'popover';
    width?: number | number[] | 'auto';
  };
}
/** @public */
interface ObjectRule extends RuleDef<ObjectRule, Record<string, unknown>> {}
/** @public */
interface ObjectDefinition extends BaseSchemaDefinition {
  type: 'object';
  /**
   * Object must have at least one field. This is validated at Studio startup.
   */
  fields: FieldDefinition[];
  groups?: FieldGroupDefinition[];
  fieldsets?: FieldsetDefinition[];
  preview?: PreviewConfig;
  options?: ObjectOptions;
  validation?: ValidationBuilder<ObjectRule, Record<string, unknown>>;
  initialValue?: InitialValueProperty<any, Record<string, unknown>>;
}
/** @public */
interface FieldsetDefinition {
  name: string;
  title?: string;
  description?: string;
  group?: string;
  hidden?: ConditionalProperty;
  readOnly?: ConditionalProperty;
  options?: ObjectOptions;
}
/** @public */
type FieldGroupDefinition = {
  name: string;
  title?: string;
  hidden?: ConditionalProperty;
  icon?: ComponentType;
  default?: boolean;
  i18n?: I18nTextRecord<'title'>;
};
/**
 * Options for configuring how Sanity Create interfaces with the type or field.
 *
 * @public
 */
interface SanityCreateOptions {
  /** Set to true to exclude a type or field from appearing in Sanity Create */
  exclude?: boolean;
  /**
   * A short description of what the type or field is used for.
   * Purpose can be used to improve how and when content mapping uses the field.
   * */
  purpose?: string;
}
/**
 * Options for configuring how Canvas app interfaces with the type or field.
 *
 * @public
 */
interface CanvasAppOptions {
  /** Set to true to exclude a type or field from appearing in Canvas */
  exclude?: boolean;
  /**
   * A short description of what the type or field is used for.
   * Purpose can be used to improve how and when content mapping uses the field.
   * */
  purpose?: string;
}
/**
 * `BaseOptions` applies to all type options.
 *
 *  It can be extended by interface declaration merging in plugins to provide generic options to all types and fields.
 *
 *  @public
 *  */
interface BaseSchemaTypeOptions {
  sanityCreate?: SanityCreateOptions;
  canvasApp?: CanvasAppOptions;
}
/** @public */
interface BaseSchemaDefinition {
  name: string;
  title?: string;
  description?: string | React.JSX.Element;
  hidden?: ConditionalProperty;
  readOnly?: ConditionalProperty;
  icon?: ComponentType | ReactNode;
  validation?: unknown;
  initialValue?: unknown;
  deprecated?: DeprecatedProperty;
}
/** @public */
interface TitledListValue<V = unknown> {
  _key?: string;
  title: string;
  value?: V;
}
/** @public */
interface I18nTitledListValue<V = unknown> {
  _key?: string;
  title: string;
  i18nTitleKey?: string;
  value?: V;
}
/** @public */
interface EnumListProps<V = unknown> {
  list?: Array<TitledListValue<V> | V>;
  layout?: 'radio' | 'dropdown';
  direction?: 'horizontal' | 'vertical';
}
/** @public */
interface SearchConfiguration {
  search?: {
    /**
     * Defines a search weight for this field to prioritize its importance
     * during search operations in the Studio. This setting allows the specified
     * field to be ranked higher in search results compared to other fields.
     *
     * By default, all fields are assigned a weight of 1. However, if a field is
     * chosen as the `title` in the preview configuration's `select` option, it
     * will automatically receive a default weight of 10. Similarly, if selected
     * as the `subtitle`, the default weight is 5. Fields marked as
     * `hidden: true` (no function) are assigned a weight of 0 by default.
     *
     * Note: Search weight configuration is currently supported only for fields
     * of type string or portable text arrays.
     */
    weight?: number;
  };
}
/**
 * Types of array actions that can be performed
 * @beta
 */
type ArrayActionName =
/**
 * Add any item to the array at any position
 */
'add'
/**
 * Add item after an existing item
 */
| 'addBefore'
/**
 * Add item after an existing item
 */
| 'addAfter'
/**
 * Remove any item
 */
| 'remove'
/**
 * Duplicate item
 */
| 'duplicate'
/**
 * Copy item
 */
| 'copy';
/** @public */
interface ArrayOptions<V = unknown> extends SearchConfiguration, BaseSchemaTypeOptions {
  list?: TitledListValue<V>[] | V[];
  layout?: 'list' | 'tags' | 'grid';
  /** @deprecated This option does not have any effect anymore */
  direction?: 'horizontal' | 'vertical';
  sortable?: boolean;
  modal?: {
    type?: 'dialog' | 'popover';
    width?: number | 'auto';
  };
  /** @alpha This API may change */
  insertMenu?: InsertMenuOptions;
  /**
   * A boolean flag to enable or disable tree editing for the array.
   * If there are any nested arrays, they will inherit this value.
   * @deprecated tree editing beta feature has been disabled
   */
  treeEditing?: boolean;
  /**
   * A list of array actions to disable
   * Possible options are defined by {@link ArrayActionName}
   * @beta
   */
  disableActions?: ArrayActionName[];
}
/** @public */
interface ArrayRule<Value> extends RuleDef<ArrayRule<Value>, Value> {
  min: (length: number | FieldReference) => ArrayRule<Value>;
  max: (length: number | FieldReference) => ArrayRule<Value>;
  length: (length: number | FieldReference) => ArrayRule<Value>;
  unique: () => ArrayRule<Value>;
}
/** @public */
type ArrayOfEntry<T> = Omit<T, 'name' | 'hidden'> & {
  name?: string;
};
/** @public */
type IntrinsicArrayOfDefinition = { [K in keyof IntrinsicDefinitions]: Omit<ArrayOfEntry<IntrinsicDefinitions[K]>, 'validation' | 'initialValue'> & {
  validation?: SchemaValidationValue;
  initialValue?: InitialValueProperty<any, any>;
} };
/** @public */
type ArrayOfType<TType extends IntrinsicTypeName = IntrinsicTypeName, TAlias extends IntrinsicTypeName | undefined = undefined> = IntrinsicArrayOfDefinition[TType] | ArrayOfEntry<TypeAliasDefinition<string, TAlias>>;
/** @public */
interface ArrayDefinition extends BaseSchemaDefinition {
  type: 'array';
  of: ArrayOfType[];
  initialValue?: InitialValueProperty<any, unknown[]>;
  validation?: ValidationBuilder<ArrayRule<unknown[]>, unknown[]>;
  options?: ArrayOptions;
}
/**
 * Schema options for a Block schema definition
 * @public */
interface BlockOptions extends BaseSchemaTypeOptions {
  /**
   * Turn on or off the builtin browser spellchecking. Default is on.
   */
  spellCheck?: boolean;
  unstable_whitespaceOnPasteMode?: 'preserve' | 'normalize' | 'remove';
  /**
   * When enabled, the editor will restrict all line breaks and soft breaks,
   * forcing content to remain on a single line. This will also update
   * the styling of the editor to reflect the single-line constraint.
   *
   * Pasting content that is on multiple lines will be normalized to a single line, if possible.
   *
   * @defaultValue false
   */
  oneLine?: boolean;
}
/** @public */
interface BlockRule extends RuleDef<BlockRule, any[]> {}
/**
 * Schema definition for text block decorators.
 *
 * @public
 * @example The default set of decorators
 * ```ts
 * {
 *   name: 'blockContent',
 *   title: 'Content',
 *   type: 'array',
 *   of: [
 *     {
 *       type: 'block',
 *       marks: {
 *         decorators: [
 *           {title: 'Strong', value: 'strong'},
 *           {title: 'Emphasis', value: 'em'},
 *           {title: 'Underline', value: 'underline'},
 *           {title: 'Strike', value: 'strike-through'},
 *           {title: 'Code', value: 'code'},
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 */
interface BlockDecoratorDefinition {
  title: string;
  i18nTitleKey?: string;
  value: string;
  icon?: ReactNode | ComponentType;
}
/**
 * Schema definition for a text block style.
 * A text block may have a block style like 'header', 'normal', 'lead'
 * attached to it, which is stored on the `.style` property for that block.
 *
 * @public
 * @remarks The first defined style will become the default style.´´
 * @example The default set of styles
 * ```ts
 * {
 *   name: 'blockContent',
 *   title: 'Content',
 *   type: 'array',
 *   of: [
 *     {
 *       type: 'block',
 *       styles: [
 *         {title: 'Normal', value: 'normal'},
 *         {title: 'H1', value: 'h1'},
 *         {title: 'H2', value: 'h2'},
 *         {title: 'H3', value: 'h3'},
 *         {title: 'H4', value: 'h4'},
 *         {title: 'H5', value: 'h5'},
 *         {title: 'H6', value: 'h6'},
 *         {title: 'Quote', value: 'blockquote'}
 *       ]
 *     }
 *   ]
 * }
 * ```
 * @example Example of defining a block type with custom styles and render components.
 * ```ts
 * defineArrayMember({
 *   type: 'block',
 *   styles: [
 *     {
 *       title: 'Paragraph',
 *       value: 'paragraph',
 *       component: ParagraphStyle,
 *     },
 *     {
 *       title: 'Lead',
 *       value: 'lead',
 *       component: LeadStyle,
 *     },
 *     {
 *       title: 'Heading',
 *       value: 'heading',
 *       component: HeadingStyle,
 *     },
 *   ],
 * })
 * ```
 */
interface BlockStyleDefinition {
  title: string;
  value: string;
  i18nTitleKey?: string;
  icon?: ReactNode | ComponentType;
}
/**
 * Schema definition for a text block list style.
 *
 * @public
 * @example The defaults lists
 * ```ts
 * {
 *   name: 'blockContent',
 *   title: 'Content',
 *   type: 'array',
 *   of: [
 *     {
 *       type: 'block',
 *       lists: [
 *         {title: 'Bullet', value: 'bullet'},
 *         {title: 'Number', value: 'number'},
 *       ]
 *     }
 *   ]
 * }
 * ```
 */
interface BlockListDefinition {
  title: string;
  i18nTitleKey?: string;
  value: string;
  icon?: ReactNode | ComponentType;
}
/**
 * Schema definition for a text block annotation object.
 *
 * @public
 * @example The default link annotation
 * ```ts
 * {
 *   name: 'blockContent',
 *   title: 'Content',
 *   type: 'array',
 *   of: [
 *     {
 *       type: 'block',
 *       marks: {
 *         annotations: [
 *           {
 *             type: 'object',
 *             name: 'link',
 *             fields: [
 *               {
 *                 type: 'string',
 *                 name: 'href',
 *               },
 *             ],
 *           },
 *         ]
 *       },
 *     }
 *   ]
 * }
 * ```
 */
interface BlockAnnotationDefinition extends ObjectDefinition {
  icon?: ReactNode | ComponentType;
}
/**
 * Schema definition for text block marks (decorators and annotations).
 *
 * @public */
interface BlockMarksDefinition {
  decorators?: BlockDecoratorDefinition[];
  annotations?: ArrayOfType<'object' | 'reference'>[];
}
/**
 * Schema definition for text blocks.
 *
 * @public
 * @example the default block definition
 * ```ts
 * {
 *   name: 'blockContent',
 *   title: 'Content',
 *   type: 'array',
 *   of: [
 *     {
 *       type: 'block',
 *       marks: {
 *         decorators: [
 *           {title: 'Strong', value: 'strong'},
 *           {title: 'Emphasis', value: 'em'},
 *           {title: 'Underline', value: 'underline'},
 *           {title: 'Strike', value: 'strike-through'},
 *           {title: 'Code', value: 'code'},
 *         ],
 *         annotations: [
 *           {
 *             type: 'object',
 *             name: 'link',
 *             fields: [
 *               {
 *                 type: 'string',
 *                 name: 'href',
 *               },
 *             ],
 *           },
 *         ]
 *       },
 *       styles: [
 *         {title: 'Normal', value: 'normal'},
 *         {title: 'H1', value: 'h1'},
 *         {title: 'H2', value: 'h2'},
 *         {title: 'H3', value: 'h3'},
 *         {title: 'H4', value: 'h4'},
 *         {title: 'H5', value: 'h5'},
 *         {title: 'H6', value: 'h6'},
 *         {title: 'Quote', value: 'blockquote'}
 *       ],
 *       lists: [
 *         {title: 'Bullet', value: 'bullet'},
 *         {title: 'Number', value: 'number'},
 *       ],
 *     },
 *   ]
 * }
 * ```
 */
interface BlockDefinition extends BaseSchemaDefinition {
  type: 'block';
  styles?: BlockStyleDefinition[];
  lists?: BlockListDefinition[];
  marks?: BlockMarksDefinition;
  of?: ArrayOfType<'object' | 'reference'>[];
  initialValue?: InitialValueProperty<any, any[]>;
  options?: BlockOptions;
  validation?: ValidationBuilder<BlockRule, any[]>;
}
/** @public */
interface BooleanOptions extends BaseSchemaTypeOptions {
  layout?: 'switch' | 'checkbox';
}
/** @public */
interface BooleanRule extends RuleDef<BooleanRule, boolean> {}
/** @public */
interface BooleanDefinition extends BaseSchemaDefinition {
  type: 'boolean';
  options?: BooleanOptions;
  initialValue?: InitialValueProperty<any, boolean>;
  validation?: ValidationBuilder<BooleanRule, boolean>;
}
/** @public */
type ReferenceValue = Reference;
/** @public */
interface ReferenceRule extends RuleDef<ReferenceRule, ReferenceValue> {}
/** @public */
type ReferenceTo = SchemaTypeDefinition | TypeReference | Array<SchemaTypeDefinition | TypeReference>;
/**
 * Types are closed for extension. To add properties via declaration merging to this type,
 * redeclare and add the properties to the interfaces that make up ReferenceOptions type.
 *
 * @see ReferenceFilterOptions
 * @see ReferenceFilterResolverOptions
 * @see ReferenceBaseOptions
 *
 * @public
 */
type ReferenceOptions = ReferenceBaseOptions & ReferenceFilterOptions;
/** @public */
interface ReferenceDefinition extends BaseSchemaDefinition {
  type: 'reference';
  to: ReferenceTo;
  weak?: boolean;
  options?: ReferenceOptions;
  validation?: ValidationBuilder<ReferenceRule, ReferenceValue>;
  initialValue?: InitialValueProperty<any, Omit<ReferenceValue, '_type'>>;
}
/** @public */
interface CrossDatasetReferenceDefinition extends BaseSchemaDefinition {
  type: 'crossDatasetReference';
  weak?: boolean;
  to: {
    type: string;
    title?: string;
    icon?: ComponentType;
    preview?: PreviewConfig;
    /**
     * @deprecated Unused. Configuring search is no longer supported.
     */
    __experimental_search?: {
      path: string | string[];
      weight?: number;
      mapWith?: string;
    }[];
  }[];
  dataset: string;
  studioUrl?: (document: {
    id: string;
    type?: string;
  }) => string | null;
  tokenId?: string;
  options?: ReferenceOptions;
  /**
   * @deprecated Cross-project references are no longer supported, only cross-dataset
   */
  projectId?: string;
}
/** @public */
interface DateOptions extends BaseSchemaTypeOptions {
  dateFormat?: string;
}
/** @public */
interface DateRule extends RuleDef<DateRule, string> {
  /**
   * @param minDate - Minimum date (inclusive). minDate should be in ISO 8601 format.
   */
  min: (minDate: string | FieldReference) => DateRule;
  /**
   * @param maxDate - Maximum date (inclusive). maxDate should be in ISO 8601 format.
   */
  max: (maxDate: string | FieldReference) => DateRule;
}
/** @public */
interface DateDefinition extends BaseSchemaDefinition {
  type: 'date';
  options?: DateOptions;
  placeholder?: string;
  validation?: ValidationBuilder<DateRule, string>;
  initialValue?: InitialValueProperty<any, string>;
}
/** @public */
interface DatetimeOptions extends BaseSchemaTypeOptions {
  dateFormat?: string;
  timeFormat?: string;
  timeStep?: number;
  displayTimeZone?: string;
  allowTimeZoneSwitch?: boolean;
}
/** @public */
interface DatetimeRule extends RuleDef<DatetimeRule, string> {
  /**
   * @param minDate - Minimum date (inclusive). minDate should be in ISO 8601 format.
   */
  min: (minDate: string | FieldReference) => DatetimeRule;
  /**
   * @param maxDate - Maximum date (inclusive). maxDate should be in ISO 8601 format.
   */
  max: (maxDate: string | FieldReference) => DatetimeRule;
}
/** @public */
interface DatetimeDefinition extends BaseSchemaDefinition {
  type: 'datetime';
  options?: DatetimeOptions;
  placeholder?: string;
  validation?: ValidationBuilder<DatetimeRule, string>;
  initialValue?: InitialValueProperty<any, string>;
}
/**
 * This exists only to allow for extensions using declaration-merging.
 *
 * @public
 */
interface DocumentOptions extends BaseSchemaTypeOptions {}
/** @public */
interface DocumentRule extends RuleDef<DocumentRule, SanityDocument> {}
/** @public */
interface DocumentDefinition extends Omit<ObjectDefinition, 'type'> {
  type: 'document';
  liveEdit?: boolean;
  /** @beta */
  orderings?: SortOrdering[];
  options?: DocumentOptions;
  validation?: ValidationBuilder<DocumentRule, SanityDocument>;
  initialValue?: InitialValueProperty<any, Record<string, unknown>>;
  /** @deprecated Unused. Use the new field-level search config. */
  __experimental_search?: {
    path: string;
    weight: number;
    mapWith?: string;
  }[];
  /** @alpha */
  __experimental_omnisearch_visibility?: boolean;
  /**
   * Determines whether the large preview title is displayed in the document pane form
   * @alpha
   * */
  __experimental_formPreviewTitle?: boolean;
}
/** @public */
interface EmailRule extends RuleDef<EmailRule, string> {}
/** @public */
interface EmailOptions extends BaseSchemaTypeOptions {}
/** @public */
interface EmailDefinition extends BaseSchemaDefinition {
  type: 'email';
  options?: EmailOptions;
  placeholder?: string;
  validation?: ValidationBuilder<EmailRule, string>;
  initialValue?: InitialValueProperty<any, string>;
}
/** @public */
interface MediaLibraryFilter {
  name: string;
  query: string;
}
/** @public */
interface MediaLibraryOptions {
  filters?: MediaLibraryFilter[];
}
/** @public */
interface FileOptions extends ObjectOptions {
  storeOriginalFilename?: boolean;
  accept?: string;
  sources?: AssetSource[];
  mediaLibrary?: MediaLibraryOptions;
  /**
   * When set to `true`, hides the upload UI, only allowing selection of existing assets from the media library.
   * Useful for centralized asset management workflows where ad-hoc uploads should be prevented.
   */
  disableNew?: boolean;
}
/** @public */
interface FileRule extends RuleDef<FileRule, FileValue> {
  /**
   * Require a file field has an asset.
   *
   * @example
   * ```ts
   * defineField({
   *  name: 'file',
   *  title: 'File',
   *  type: 'file',
   *  validation: (Rule) => Rule.required().assetRequired(),
   * })
   * ```
   */
  assetRequired(): FileRule;
}
/** @public */
interface FileValue {
  asset?: Reference;
  [index: string]: unknown;
}
/** @public */
interface FileDefinition extends Omit<ObjectDefinition, 'type' | 'fields' | 'options' | 'groups' | 'validation'> {
  type: 'file';
  fields?: ObjectDefinition['fields'];
  options?: FileOptions;
  validation?: ValidationBuilder<FileRule, FileValue>;
  initialValue?: InitialValueProperty<any, FileValue>;
}
/**
 * Geographical point representing a pair of latitude and longitude coordinates,
 * stored as degrees, in the World Geodetic System 1984 (WGS 84) format. Also
 * includes an optional `alt` property representing the altitude in meters.
 *
 * @public
 */
interface GeopointValue {
  /**
   * Type of the object. Must be `geopoint`.
   */
  _type: 'geopoint';
  /**
   * Latitude in degrees
   */
  lat: number;
  /**
   * Longitude in degrees
   */
  lng: number;
  /**
   * Altitude in meters
   */
  alt?: number;
}
/** @public */
interface GeopointRule extends RuleDef<GeopointRule, GeopointValue> {}
/** @public */
interface GeopointOptions extends BaseSchemaTypeOptions {}
/** @public */
interface GeopointDefinition extends BaseSchemaDefinition {
  type: 'geopoint';
  options?: GeopointOptions;
  validation?: ValidationBuilder<GeopointRule, GeopointValue>;
  initialValue?: InitialValueProperty<any, Omit<GeopointValue, '_type'>>;
}
/** @public */
interface GlobalDocumentReferenceDefinition extends BaseSchemaDefinition {
  type: 'globalDocumentReference';
  weak?: boolean;
  to: {
    type: string;
    title?: string;
    icon?: ComponentType;
    preview?: PreviewConfig;
  }[];
  resourceType: string;
  resourceId: string;
  options?: ReferenceOptions;
  studioUrl?: string | ((document: {
    id: string;
    type?: string;
  }) => string | null);
}
/** @public */
type ImageMetadataType = 'blurhash' | 'thumbhash' | 'lqip' | 'palette' | 'exif' | 'image' | 'location';
/** @public */
interface HotspotPreview {
  title: string;
  aspectRatio: number;
}
/** @public */
interface HotspotOptions {
  previews?: HotspotPreview[];
}
/** @public */
interface ImageOptions extends FileOptions {
  metadata?: ImageMetadataType[];
  hotspot?: boolean | HotspotOptions;
}
/** @public */
interface ImageValue extends FileValue {
  crop?: ImageCrop;
  hotspot?: ImageHotspot;
  [index: string]: unknown;
}
/** @public */
interface ImageRule extends RuleDef<ImageRule, ImageValue> {
  /**
   * Require an image field has an asset.
   *
   * @example
   * ```ts
   * defineField({
   *  name: 'image',
   *  title: 'Image',
   *  type: 'image',
   *  validation: (Rule) => Rule.required().assetRequired(),
   * })
   * ```
   */
  assetRequired(): ImageRule;
}
/** @public */
interface ImageDefinition extends Omit<ObjectDefinition, 'type' | 'fields' | 'options' | 'groups' | 'validation'> {
  type: 'image';
  fields?: FieldDefinition[];
  options?: ImageOptions;
  validation?: ValidationBuilder<ImageRule, ImageValue>;
  initialValue?: InitialValueProperty<any, ImageValue>;
}
/** @public */
interface NumberOptions extends EnumListProps<number>, BaseSchemaTypeOptions {}
/** @public */
interface NumberRule extends RuleDef<NumberRule, number> {
  min: (minNumber: number | FieldReference) => NumberRule;
  max: (maxNumber: number | FieldReference) => NumberRule;
  lessThan: (limit: number | FieldReference) => NumberRule;
  greaterThan: (limit: number | FieldReference) => NumberRule;
  integer: () => NumberRule;
  precision: (limit: number | FieldReference) => NumberRule;
  positive: () => NumberRule;
  negative: () => NumberRule;
}
/** @public */
interface NumberDefinition extends BaseSchemaDefinition {
  type: 'number';
  options?: NumberOptions;
  placeholder?: string;
  validation?: ValidationBuilder<NumberRule, number>;
  initialValue?: InitialValueProperty<any, number>;
}
/** @public */
interface SlugValue {
  _type: 'slug';
  current?: string;
}
/** @public */
interface SlugRule extends RuleDef<SlugRule, SlugValue> {}
/** @public */
interface SlugOptions extends SearchConfiguration, BaseSchemaTypeOptions {
  source?: string | Path | SlugSourceFn;
  maxLength?: number;
  slugify?: SlugifierFn;
  isUnique?: SlugIsUniqueValidator;
  disableArrayWarning?: boolean;
}
/** @public */
interface SlugDefinition extends BaseSchemaDefinition {
  type: 'slug';
  options?: SlugOptions;
  validation?: ValidationBuilder<SlugRule, SlugValue>;
  initialValue?: InitialValueProperty<any, Omit<SlugValue, '_type'>>;
}
/** @public */
interface StringOptions extends EnumListProps<string>, SearchConfiguration, BaseSchemaTypeOptions {}
/** @public */
interface StringRule extends RuleDef<StringRule, string> {
  min: (minNumber: number | FieldReference) => StringRule;
  max: (maxNumber: number | FieldReference) => StringRule;
  length: (exactLength: number | FieldReference) => StringRule;
  uppercase: () => StringRule;
  lowercase: () => StringRule;
  regex(pattern: RegExp, name: string, options: {
    name?: string;
    invert?: boolean;
  }): StringRule;
  regex(pattern: RegExp, options: {
    name?: string;
    invert?: boolean;
  }): StringRule;
  regex(pattern: RegExp, name: string): StringRule;
  regex(pattern: RegExp): StringRule;
  email(): StringRule;
}
/** @public */
interface StringDefinition extends BaseSchemaDefinition {
  type: 'string';
  options?: StringOptions;
  placeholder?: string;
  validation?: ValidationBuilder<StringRule, string>;
  initialValue?: InitialValueProperty<any, string>;
}
/** @public */
interface TextRule extends StringRule {}
/** @public */
interface TextOptions extends StringOptions {}
/** @public */
interface TextDefinition extends BaseSchemaDefinition {
  type: 'text';
  rows?: number;
  options?: TextOptions;
  placeholder?: string;
  validation?: ValidationBuilder<TextRule, string>;
  initialValue?: InitialValueProperty<any, string>;
}
/** @public */
interface UrlRule extends RuleDef<UrlRule, string> {
  uri(options: UriValidationOptions): UrlRule;
}
/** @public */
interface UrlOptions extends BaseSchemaTypeOptions {}
/** @public */
interface UrlDefinition extends BaseSchemaDefinition {
  type: 'url';
  options?: UrlOptions;
  placeholder?: string;
  validation?: ValidationBuilder<UrlRule, string>;
  initialValue?: InitialValueProperty<any, string>;
}
/** @beta */
interface DefineSchemaOptions<TStrict extends StrictDefinition, TAlias extends IntrinsicTypeName | undefined> {
  /**
   * `strict: false` allows unknown properties in the schema.
   * Use this when adding customizations to the schema that are not part of sanity core.
   *
   * If you want to extend the Sanity Schema types with your own properties or options to make them typesafe,
   * you can use [TypeScript declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html).
   *
   * See {@link defineType} for more.
   *
   * @see defineType
   */
  strict?: TStrict;
  /** Should be provided when type is a non-intrinsic type, ie type is a type alias */
  aliasFor?: TAlias extends IntrinsicTypeName ? TAlias : never;
}
/** @beta */
type IntrinsicBase = { [K in keyof IntrinsicDefinitions]: Omit<IntrinsicDefinitions[K], 'preview'> };
/** @beta */
type IntrinsicArrayOfBase = { [K in keyof IntrinsicDefinitions]: Omit<ArrayOfEntry<IntrinsicDefinitions[K]>, 'preview'> };
/** @beta */
type DefineSchemaBase<TType extends string, TAlias extends IntrinsicTypeName | undefined> = TType extends IntrinsicTypeName ? IntrinsicBase[TType] : TypeAliasDefinition<TType, TAlias>;
/** @beta */
type DefineSchemaType<TType extends string, TAlias extends IntrinsicTypeName | undefined> = TType extends IntrinsicTypeName ? IntrinsicDefinitions[TType] : TypeAliasDefinition<TType, TAlias>;
/** @beta */
type DefineArrayMemberBase<TType extends string, TAlias extends IntrinsicTypeName | undefined> = TType extends IntrinsicTypeName ? IntrinsicArrayOfBase[TType] : ArrayOfEntry<TypeAliasDefinition<string, TAlias>>;
/** @beta */
type StrictDefinition = boolean | undefined;
/** @beta */
type MaybeAllowUnknownProps<TStrict extends StrictDefinition> = TStrict extends false ? {
  options?: {
    [index: string]: any;
  };
  [index: string]: any;
} : unknown;
/** @beta */
type MaybePreview<Select extends Record<string, string> | undefined, PrepareValue extends Record<keyof Select, any> | undefined> = Select extends Record<string, string> ? PrepareValue extends Record<keyof Select, any> ? PreviewConfig<Select, PrepareValue> : never : never;
/** @beta */
type NarrowPreview<TType extends string, TAlias extends IntrinsicTypeName | undefined, TSelect extends Record<string, string> | undefined, TPrepareValue extends Record<keyof TSelect, any> | undefined> = DefineSchemaType<TType, TAlias> extends {
  preview?: Record<string, any>;
} ? {
  preview?: MaybePreview<TSelect, TPrepareValue>;
} : unknown;
/** @beta */
interface WidenValidation {
  validation?: SchemaValidationValue;
}
/** @beta */
interface WidenInitialValue {
  initialValue?: InitialValueProperty<any, any>;
}
/**
 * Helper function for defining a Sanity type definition. This function does not do anything on its own;
 * it exists to check that your schema definition is correct, and help autocompletion in your IDE.
 *
 * This function will narrow the schema type down to fields and options based on the provided type-string.
 *
 * Schema types defined using `defineType` should typically be added to the Studio config under `schema.types`.
 * Defined types can be referenced by their `name`. This is referred to as a type-alias.
 *
 * When using type-aliases as `type`, `defineType` cannot know the base-type, so type-safety will be reduced.
 * If you know the base type of the type-alias, provide `defineOptions.aliasFor: <base type name>`.
 * This will enforce that the schema definition conforms with the provided type.
 *
 * By default, `defineType` only allows known properties and options.
 * Use `defineOptions.strict: false` to allow unknown properties and options.
 *
 * ### Basic usage
 *
 * ```ts
 * defineType({
 *   type: 'object',
 *   name: 'custom-object',
 *   fields: [ {type: 'string', name: 'title', title: 'Title'}],
 * })
 * ```
 *
 * ### Usage with aliasFor narrowing
 *
 * ```ts
 * defineType({
 *   type: 'custom-object',
 *   name: 'redefined-custom-object',
 *   options: {
 *     columns: 2
 *   }
 * }, {aliasFor: 'object' })
 * ```
 *
 * ### Allow unknown properties
 *
 * ```ts
 * defineType({
 *   type: 'custom-object',
 *   name: 'redefined-custom-object',
 *   allowsUnknownProperties: true
 *   options: {
 *     columns: 2,
 *     allowsUnknownOptions: true
 *   }
 * }, {strict: false})
 * ```
 * ### Maximum safety and best autocompletion
 *
 * Use {@link defineType}, {@link defineField} and {@link defineArrayMember}:
 *
 * ```ts
 *  defineType({
 *    type: 'object',
 *    name: 'custom-object',
 *    fields: [
 *      defineField({
 *        type: 'array',
 *        name: 'arrayField',
 *        title: 'Things',
 *        of: [
 *          defineArrayMember({
 *            type: 'object',
 *            name: 'type-name-in-array',
 *            fields: [defineField({type: 'string', name: 'title', title: 'Title'})],
 *          }),
 *        ],
 *      }),
 *    ],
 *  })
 * ```
 *
 * ## Note on type-safety in the current implementation
 *
 * Type-safety inside array-like properties (schema properties like `fields` and `of`) can only be guaranteed when
 * {@link defineField} and {@link defineArrayMember} are used to wrap each value in the array.
 *
 * For array-values without a function-wrapper, TypeScript will resolve to a union type of all possible properties across
 * all schema types. This result in less precise typing.
 *
 * ### Extending the Sanity Schema types
 *
 * If you want to extend the Sanity Schema types with your own properties or options to make them typesafe,
 * you can use [TypeScript declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html).
 *
 * With declaration merging, properties and options will be available in a type-safe manner, and
 * `strict: false` will not be necessary.
 *
 * #### Example: Add option to StringOptions
 *
 * ```ts
 * // string.ts
 *
 * //redeclare the sanity module
 * declare module 'sanity' {
 *  // redeclare StringOptions; it will be merged with StringOptions in the sanity module
 *  export interface StringOptions {
 *    myCustomOption?: boolean
 *  }
 * }
 *
 * // the option is now part of the StringOptions type, just as if it was declared in the sanity codebase:
 * defineType({
 *   type: 'string',
 *   name: 'my-string',
 *   options: {
 *     myCustomOption: true // this does not give an error anymore
 *   }
 * })
 *
 * ```
 *
 * #### Example: Add a schema definition to "intrinsic-types"
 *
 * ```ts
 * //my-custom-type-definition.ts
 *
 * // create a new schema definition based on object (we remove the ability to assign field, change the type add some options)
 *  export type MagicallyAddedDefinition = Omit<Schema.ObjectDefinition, 'type' | 'fields'> & {
 *    type: 'magically-added-type'
 *    options?: {
 *      sparkles?: boolean
 *    }
 *  }
 *
 *  // redeclares sanity module so we can add interfaces props to it
 * declare module 'sanity' {
 *     // redeclares IntrinsicDefinitions and adds a named definition to it
 *     // it is important that the key is the same as the type in the definition ('magically-added-type')
 *     export interface IntrinsicDefinitions {
 *       'magically-added-type': MagicallyAddedDefinition
 *     }
 * }
 *
 * // defineType will now narrow `type: 'magically-added-type'` to `MagicallyAddedDefinition`
 * defineType({
 *   type: 'magically-added-type'
 *   name: 'magic',
 *   options: {
 *     sparkles: true // this is allowed,
 *     //@ts-expect-error this is not allowed in MagicallyAddedDefinition.options
 *     sparks: true
 *   }
 * })
 * ```
 *
 * @param schemaDefinition - should be a valid schema type definition.
 * @param defineOptions - optional param to provide type hints for `schemaDefinition`.
 *
 * @see defineField
 * @see defineArrayMember
 * @see typed
 *
 * @beta
 */
declare function defineType<const TType extends IntrinsicTypeName | AutocompleteString, const TName extends string, TSelect extends Record<string, string> | undefined, TPrepareValue extends Record<keyof TSelect, any> | undefined, TAlias extends IntrinsicTypeName | undefined, TStrict extends StrictDefinition>(schemaDefinition: {
  type: TType;
  name: TName;
} & DefineSchemaBase<TType, TAlias> & NarrowPreview<TType, TAlias, TSelect, TPrepareValue> & MaybeAllowUnknownProps<TStrict>, defineOptions?: DefineSchemaOptions<TStrict, TAlias>): typeof schemaDefinition;
/**
 * Define a field within a document, object, image or file definition `fields` array.
 *
 * This function will narrow the schema type down to fields and options based on the provided
 * type-string.
 *
 * Using `defineField` is optional, but should provide improved autocompletion in your IDE, when building your schema.
 * Field-properties like `validation` and `initialValue`will also be more specific.
 *
 * See {@link defineType} for more examples.
 *
 * @param schemaField - should be a valid field type definition.
 * @param defineOptions - optional param to provide type hints for `schemaField`.
 *
 * @see defineField
 * @see defineArrayMember
 * @see typed
 *
 * @beta
 */
declare function defineField<const TType extends IntrinsicTypeName | AutocompleteString, const TName extends string, TSelect extends Record<string, string> | undefined, TPrepareValue extends Record<keyof TSelect, any> | undefined, TAlias extends IntrinsicTypeName | undefined, TStrict extends StrictDefinition>(schemaField: {
  type: TType;
  name: TName;
} & DefineSchemaBase<TType, TAlias> & NarrowPreview<TType, TAlias, TSelect, TPrepareValue> & MaybeAllowUnknownProps<TStrict> & FieldDefinitionBase, defineOptions?: DefineSchemaOptions<TStrict, TAlias>): typeof schemaField & WidenValidation & WidenInitialValue;
/**
 * Define an array item member type within an array definition `of`-array.
 *
 * This function will narrow the schema type down to fields and options based on the provided
 * `type` string.
 *
 * Using `defineArrayMember` is optional, but should provide improved autocompletion in your IDE, when building your schema.
 * Field properties like `validation` and `initialValue` will also be more specific.
 *
 * See {@link defineType} for example usage.
 *
 * @param arrayOfSchema - should be a valid `array.of` member definition.
 * @param defineOptions - optional param to provide type hints for `arrayOfSchema`.
 *
 * @see defineType
 * @see defineField
 * @see typed
 *
 * @beta
 */
declare function defineArrayMember<const TType extends IntrinsicTypeName | AutocompleteString, const TName extends string, TSelect extends Record<string, string> | undefined, TPrepareValue extends Record<keyof TSelect, any> | undefined, TAlias extends IntrinsicTypeName | undefined, TStrict extends StrictDefinition>(arrayOfSchema: {
  type: TType;
  /**
   * When provided, `name` is used as `_type` for the array item when stored.
   *
   * Necessary when an array contains multiple entries with the same `type`, each with
   * different configuration (title and initialValue for instance).
   */
  name?: TName;
} & DefineArrayMemberBase<TType, TAlias> & NarrowPreview<TType, TAlias, TSelect, TPrepareValue> & MaybeAllowUnknownProps<TStrict>, defineOptions?: DefineSchemaOptions<TStrict, TAlias>): typeof arrayOfSchema & WidenValidation & WidenInitialValue;
/**
 * `typed` can be used to ensure that an object conforms to an exact interface.
 *
 * It can be useful when working with `defineType` and `defineField` on occasions where a wider type with
 * custom options or properties is required.
 *
 * ## Example  usage
 * ```ts
 *  defineField({
 *    type: 'string',
 *    name: 'nestedField',
 *    options: typed<StringOptions & {myCustomOption: boolean}>({
 *      layout: 'radio',
 *      // allowed
 *      myCustomOption: true,
 *      //@ts-expect-error unknownProp is not part of StringOptions & {myCustomOption: boolean}
 *      unknownProp: 'not allowed in typed context',
 *    }),
 *  }),
 * ```
 *
 * @param input - returned directly
 *
 * @internal
 */
declare function typed<T>(input: T): T;
/**
 * Enhances VSCode autocomplete by using a distinct type for strings.
 *
 * `AllowOtherStrings` is defined as `string & {}`, an intersection that behaves
 * like `string` but is treated differently by TypeScript's type system for
 * internal processing. This helps in improving the specificity and relevance of
 * autocomplete suggestions by potentially prioritizing `IntrinsicTypeName`
 * over general string inputs, addressing issues where `string` type suggestions
 * might overshadow more useful specific literals.
 *
 * @beta
 */
type AutocompleteString = string & {};
/**
 * Note: you probably want `SchemaTypeDefinition` instead
 * @see SchemaTypeDefinition
 *
 * @public
 */
type SchemaType = ArraySchemaType | BooleanSchemaType | FileSchemaType | NumberSchemaType | ObjectSchemaType | StringSchemaType | ReferenceSchemaType;
/** @public */
interface SchemaValidationError {
  helpId?: string;
  message: string;
  severity: 'error';
}
/** @internal */
interface SchemaValidationWarning {
  helpId?: string;
  message: string;
  severity: 'warning';
}
/** @internal */
type SchemaValidationProblem = SchemaValidationError | SchemaValidationWarning;
/** @internal */
type SchemaValidationProblemPath = Array<{
  kind: 'type';
  type: string;
  name?: string;
} | {
  kind: 'property';
  name: string;
}>;
/** @internal */
interface SchemaValidationProblemGroup {
  path: SchemaValidationProblemPath;
  problems: SchemaValidationProblem[];
}
/** @public */
interface Schema {
  /** @internal */
  _original?: {
    name: string;
    types: SchemaTypeDefinition[];
  };
  /** @internal */
  _registry: {
    [typeName: string]: any;
  };
  /** @internal */
  _validation?: SchemaValidationProblemGroup[];
  name: string;
  get: (name: string) => SchemaType | undefined;
  has: (name: string) => boolean;
  getTypeNames: () => string[];
  /**
   * Returns the types which were explicitly defined in this schema,
   * as opposed to the types which were inherited from the parent.
   */
  getLocalTypeNames: () => string[];
  /**
   * Returns the parent schema.
   */
  parent?: Schema;
}
/** @beta */
interface SortOrderingItem {
  field: string;
  direction: 'asc' | 'desc';
}
/** @public */
type I18nTextRecord<K extends string> = { [P in K]?: {
  key: string;
  ns: string;
} };
/** @beta */
type SortOrdering = {
  title: string;
  i18n?: I18nTextRecord<'title'>;
  name: string;
  by: SortOrderingItem[];
};
/** @public */
interface ConditionalPropertyCallbackContext {
  document: SanityDocument | undefined;
  parent: any;
  value: any;
  currentUser: Omit<CurrentUser, 'role'> | null;
  path: Path;
}
/** @public */
type ConditionalPropertyCallback = (context: ConditionalPropertyCallbackContext) => boolean;
/** @public */
type ConditionalProperty = boolean | ConditionalPropertyCallback | undefined;
/** @public */
interface DeprecatedProperty {
  reason: string;
}
/**
 * @public
 */
interface DeprecationConfiguration {
  deprecated: DeprecatedProperty;
}
/** @public */
interface InitialValueResolverContext {
  projectId: string;
  dataset: string;
  schema: Schema;
  currentUser: CurrentUser | null;
  getClient: (options: {
    apiVersion: string;
  }) => SanityClient;
}
/** @public */
type InitialValueResolver<Params, Value> = (params: Params | undefined, context: InitialValueResolverContext) => Promise<Value> | Value;
/** @public */
type InitialValueProperty<Params, Value> = Value | InitialValueResolver<Params, Value> | undefined;
/**
 * Represents the possible values of a schema type's `validation` field.
 *
 * If the schema has not been run through `inferFromSchema` from
 * `sanity/validation` then value could be a function.
 *
 * `inferFromSchema` mutates the schema converts this value to an array of
 * `Rule` instances.
 *
 * @privateRemarks
 *
 * Usage of the schema inside the studio will almost always be from the compiled
 * `createSchema` function. In this case, you can cast the value or throw to
 * narrow the type. E.g.:
 *
 * ```ts
 * if (typeof type.validation === 'function') {
 *   throw new Error(
 *     `Schema type "${type.name}"'s \`validation\` was not run though \`inferFromSchema\``
 *   )
 * }
 * ```
 *
 * @public
 */
type SchemaValidationValue = false | undefined | Rule | SchemaValidationValue[] | ((rule: Rule, context?: ValidationContext) => SchemaValidationValue);
/** @public */
type DeprecatedSchemaType<TSchemaType extends BaseSchemaType = BaseSchemaType> = TSchemaType & DeprecationConfiguration;
/** @public */
interface BaseSchemaType extends Partial<DeprecationConfiguration> {
  name: string;
  title?: string;
  description?: string;
  type?: SchemaType;
  liveEdit?: boolean;
  readOnly?: ConditionalProperty;
  hidden?: ConditionalProperty;
  icon?: ComponentType;
  initialValue?: InitialValueProperty<any, any>;
  validation?: SchemaValidationValue;
  preview?: PreviewConfig;
  /** @beta */
  components?: {
    block?: ComponentType<any>;
    inlineBlock?: ComponentType<any>;
    annotation?: ComponentType<any>;
    diff?: ComponentType<any>;
    field?: ComponentType<any>;
    input?: ComponentType<any>;
    item?: ComponentType<any>;
    preview?: ComponentType<any>;
    portableText?: {
      plugins?: ComponentType<any>;
    };
  };
  /**
   * @deprecated This will be removed.
   */
  placeholder?: string;
}
/**
 * This is used for string, text, date and datetime.
 * This interface represent the compiled version at runtime, when accessed through Schema.
 *
 * @public
 */
interface StringSchemaType extends BaseSchemaType {
  jsonType: 'string';
  options?: StringOptions & TextOptions & DateOptions & DatetimeOptions;
  initialValue?: InitialValueProperty<any, string>;
}
/** @public */
interface TextSchemaType extends StringSchemaType {
  rows?: number;
}
/** @public */
interface NumberSchemaType extends BaseSchemaType {
  jsonType: 'number';
  options?: NumberOptions;
  initialValue?: InitialValueProperty<any, number>;
}
/** @public */
interface BooleanSchemaType extends BaseSchemaType {
  jsonType: 'boolean';
  options?: BooleanOptions;
  initialValue?: InitialValueProperty<any, boolean>;
}
/** @public */
interface ArraySchemaType<V = unknown> extends BaseSchemaType {
  jsonType: 'array';
  of: (Exclude<SchemaType, ArraySchemaType> | ReferenceSchemaType)[];
  options?: ArrayOptions<V> & {
    layout?: V extends string ? 'tag' : 'grid';
  };
}
/** @internal */
type ArraySchemaTypeOf<TSchemaType extends ArraySchemaType['of'][number]> = Omit<ArraySchemaType, 'of'> & {
  of: TSchemaType[];
};
/**
 * A specific `ObjectField` for `marks` in `SpanSchemaType`
 * @see SpanSchemaType
 *
 * @internal
 */
type SpanMarksObjectField = {
  name: 'marks';
} & ObjectField<ArraySchemaTypeOf<StringSchemaType>>;
/**
 * A specific `ObjectField` for `text` in `SpanSchemaType`
 * @see SpanSchemaType
 *
 * @internal
 */
type SpanTextObjectField = {
  name: 'text';
} & ObjectField<TextSchemaType>;
/**
 * A specific `ObjectField` for `style` in `BlockSchemaType`
 * @see BlockSchemaType
 *
 * @internal
 */
type BlockStyleObjectField = {
  name: 'style';
} & ObjectField<StringSchemaType>;
/**
 * A specific `ObjectField` for `list` in `BlockSchemaType`
 * @see BlockSchemaType
 *
 * @internal
 */
type BlockListObjectField = {
  name: 'list';
} & ObjectField<StringSchemaType>;
/**
 * The specific `children` field of a `block` type (`BlockSchemaType`)
 * @see BlockSchemaType
 *
 * @internal
 */
type BlockChildrenObjectField = {
  name: 'children';
} & ObjectField<ArraySchemaType>;
/**
 * Represents the compiled schema shape for `span`s for portable text.
 *
 * Note: this does _not_ represent the schema definition shape.
 *
 * @internal
 */
interface SpanSchemaType extends Omit<ObjectSchemaType, 'fields'> {
  annotations: (ObjectSchemaType & {
    icon?: string | ComponentType;
    components?: {
      item?: ComponentType;
    };
  })[];
  decorators: BlockDecoratorDefinition[];
  fields: [SpanMarksObjectField, SpanTextObjectField];
}
/**
 * Represents the compiled schema shape for `block`s for portable text.
 *
 * Note: this does _not_ represent the schema definition shape.
 *
 * @internal
 */
interface BlockSchemaType extends ObjectSchemaType {
  fields: [BlockChildrenObjectField, BlockStyleObjectField, BlockListObjectField, ...ObjectField[]];
  options?: BlockOptions;
}
/** @public */
interface SlugSchemaType extends ObjectSchemaType {
  jsonType: 'object';
  options?: SlugOptions;
}
/** @public */
type ObjectFieldType<T extends SchemaType = SchemaType> = T & {
  hidden?: ConditionalProperty;
  readOnly?: ConditionalProperty;
};
/** @public */
interface ObjectField<T extends SchemaType = SchemaType> {
  name: string;
  fieldset?: string;
  group?: string | string[];
  type: ObjectFieldType<T>;
}
/** @public */
interface FieldGroup {
  name: string;
  icon?: ComponentType;
  title?: string;
  description?: string;
  i18n?: I18nTextRecord<'title'>;
  hidden?: ConditionalProperty;
  default?: boolean;
  fields?: ObjectField[];
}
/** @public */
interface ObjectSchemaType extends BaseSchemaType {
  jsonType: 'object';
  fields: ObjectField[];
  groups?: FieldGroup[];
  fieldsets?: Fieldset[];
  initialValue?: InitialValueProperty<any, Record<string, unknown>>;
  weak?: boolean;
  /** @deprecated Unused. Use the new field-level search config. */
  __experimental_search?: {
    path: (string | number)[];
    weight: number;
    mapWith?: string;
  }[];
  /** @alpha */
  __experimental_omnisearch_visibility?: boolean;
  /** @alpha */
  __experimental_actions?: string[];
  /** @alpha */
  __experimental_formPreviewTitle?: boolean;
  /**
   * @beta
   */
  orderings?: SortOrdering[];
  options?: any;
}
/** @internal */
interface ObjectSchemaTypeWithOptions extends Omit<ObjectSchemaType, 'options'> {
  options?: CollapseOptions & {
    columns?: number;
  };
}
/** @public */
interface SingleFieldSet {
  single: true;
  field: ObjectField;
  hidden?: ConditionalProperty;
  readOnly?: ConditionalProperty;
  group?: string | string[];
}
/** @public */
interface MultiFieldSet {
  name: string;
  title?: string;
  description?: string;
  single?: false;
  group?: string | string[];
  options?: CollapseOptions & {
    columns?: number;
  };
  fields: ObjectField[];
  hidden?: ConditionalProperty;
  readOnly?: ConditionalProperty;
}
/** @public */
type Fieldset = SingleFieldSet | MultiFieldSet;
/** @public */
interface CollapseOptions {
  collapsed?: boolean;
  collapsible?: boolean;
  /**
   * @deprecated Use `collapsible` instead
   */
  collapsable?: boolean;
}
/** @public */
interface ReferenceSchemaType extends Omit<ObjectSchemaType, 'options'> {
  jsonType: 'object';
  to: ObjectSchemaType[];
  weak?: boolean;
  options?: ReferenceOptions;
}
/** @public */
interface AssetSchemaTypeOptions {
  accept?: string;
  storeOriginalFilename?: boolean;
}
/** @public */
interface FileSchemaType extends Omit<ObjectSchemaType, 'options'> {
  options?: FileOptions;
}
/** @public */
interface ImageSchemaType extends Omit<ObjectSchemaType, 'options'> {
  options?: ImageOptions;
}
/** @public */
interface PrepareViewOptions {
  /** @beta */
  ordering?: SortOrdering;
}
/** @public */
interface PreviewValue {
  _id?: string;
  _createdAt?: string;
  _updatedAt?: string;
  title?: string;
  subtitle?: string;
  description?: string;
  media?: ReactNode | ElementType;
  imageUrl?: string;
}
/** @public */
interface PreviewConfig<Select extends Record<string, string> = Record<string, string>, PrepareValue extends Record<keyof Select, any> = Record<keyof Select, any>> {
  select?: Select;
  prepare?: (value: PrepareValue, viewOptions?: PrepareViewOptions) => PreviewValue;
}
/**
 * `IntrinsicDefinitions` is a lookup map for "predefined" schema definitions.
 * Schema types in `IntrinsicDefinitions` will have good type-completion and type-safety in {@link defineType},
 * {@link defineField} and {@link defineArrayMember} once the `type` property is provided.
 *
 * By default, `IntrinsicDefinitions` contains all standard Sanity schema types (`array`, `string`, `number` ect),
 * but it is an interface and as such, open for extension.
 *
 * This type can be extended using declaration merging; this way new entries can be added.
 * See {@link defineType} for examples on how this can be accomplished.
 *
 * @see defineType
 *
 * @public
 */
interface IntrinsicDefinitions {
  array: ArrayDefinition;
  block: BlockDefinition;
  boolean: BooleanDefinition;
  date: DateDefinition;
  datetime: DatetimeDefinition;
  document: DocumentDefinition;
  file: FileDefinition;
  geopoint: GeopointDefinition;
  image: ImageDefinition;
  number: NumberDefinition;
  object: ObjectDefinition;
  reference: ReferenceDefinition;
  crossDatasetReference: CrossDatasetReferenceDefinition;
  globalDocumentReference: GlobalDocumentReferenceDefinition;
  slug: SlugDefinition;
  string: StringDefinition;
  text: TextDefinition;
  url: UrlDefinition;
  email: EmailDefinition;
}
/**
 * A union of all intrinsic types allowed natively in the schema.
 *
 * @see IntrinsicDefinitions
 *
 * @public
 */
type IntrinsicTypeName = IntrinsicDefinitions[keyof IntrinsicDefinitions]['type'];
/**
 * Represents a Sanity schema type definition with an optional type parameter.
 *
 * It's recommend to use the `defineType` helper instead of this type by
 * itself.
 *
 * @see defineType
 *
 * @public
 */
type SchemaTypeDefinition<TType extends IntrinsicTypeName = IntrinsicTypeName> = IntrinsicDefinitions[IntrinsicTypeName] | TypeAliasDefinition<string, TType>;
/**
 * Represents a reference to another type registered top-level in your schema.
 *
 * @public
 */
interface TypeReference {
  type: string;
  name?: string;
  icon?: ComponentType | ReactNode;
  options?: {
    [key: string]: unknown;
  };
}
/**
 * Represents a type definition that is an alias/extension of an existing type
 * in your schema. Creating a type alias will re-register that existing type
 * under a different name. You can also override the default type options with
 * a type alias definition.
 *
 * @public
 */
interface TypeAliasDefinition<TType extends string, TAlias extends IntrinsicTypeName | undefined> extends BaseSchemaDefinition {
  type: TType;
  options?: TAlias extends IntrinsicTypeName ? IntrinsicDefinitions[TAlias]['options'] : unknown;
  validation?: SchemaValidationValue;
  initialValue?: InitialValueProperty<any, any>;
  preview?: PreviewConfig;
  components?: {
    annotation?: ComponentType<any>;
    block?: ComponentType<any>;
    inlineBlock?: ComponentType<any>;
    diff?: ComponentType<any>;
    field?: ComponentType<any>;
    input?: ComponentType<any>;
    item?: ComponentType<any>;
    preview?: ComponentType<any>;
  };
}
/** @public */
interface FieldDefinitionBase {
  fieldset?: string;
  group?: string | string[];
}
/** @public */
type InlineFieldDefinition = { [K in keyof IntrinsicDefinitions]: Omit<IntrinsicDefinitions[K], 'initialValue' | 'validation'> & {
  validation?: SchemaValidationValue;
  initialValue?: InitialValueProperty<any, any>;
} };
/**
 * The shape of a field definition. Note, it's recommended to use the
 * `defineField` function instead of using this type directly.
 *
 * Where `defineField` infers the exact field type,
 * FieldDefinition is a compromise union of all types a field can have.
 *
 * A field definition can be a reference to another registered top-level type
 * or a inline type definition.
 *
 * @public
 */
type FieldDefinition<TType extends IntrinsicTypeName = IntrinsicTypeName, TAlias extends IntrinsicTypeName | undefined = undefined> = (InlineFieldDefinition[TType] | TypeAliasDefinition<string, TAlias>) & FieldDefinitionBase;
/**
 * Returns wether or not the given type is a document type
 * (eg that it was defined as `type: 'document'`)
 *
 * @param type - Schema type to test
 * @returns True if type is a document type, false otherwise
 *
 * @public
 */
declare function isDocumentSchemaType(type: unknown): type is ObjectSchemaType;
/** @internal */
declare function isObjectSchemaType(type: unknown): type is ObjectSchemaType;
/** @internal */
declare function isArraySchemaType(type: unknown): type is ArraySchemaType;
/** @internal */
declare function isArrayOfBlocksSchemaType(type: unknown): type is ArraySchemaType<ObjectSchemaType>;
/** @internal */
declare function isArrayOfObjectsSchemaType(type: unknown): type is ArraySchemaType<ObjectSchemaType>;
/** @internal */
declare function isArrayOfPrimitivesSchemaType(type: unknown): type is ArraySchemaType;
/** @internal */
declare function isBooleanSchemaType(type: unknown): type is BooleanSchemaType;
/** @internal */
declare function isStringSchemaType(type: unknown): type is StringSchemaType;
/** @internal */
declare function isDateTimeSchemaType(type: unknown): type is StringSchemaType;
/** @internal */
declare function isNumberSchemaType(type: unknown): type is NumberSchemaType;
/** @internal */
declare function isPrimitiveSchemaType(type: unknown): type is BooleanSchemaType | StringSchemaType | NumberSchemaType;
/** @internal */
declare function isReferenceSchemaType(type: unknown): type is ReferenceSchemaType;
/** @internal */
declare function isImageSchemaType(type: unknown): type is ImageSchemaType;
/** @internal */
declare function isFileSchemaType(type: unknown): type is FileSchemaType;
/** @internal */
declare function isDeprecatedSchemaType<TSchemaType extends BaseSchemaType>(type: TSchemaType): type is DeprecatedSchemaType<TSchemaType>;
/** @internal */
declare function isDeprecationConfiguration(type: unknown): type is DeprecationConfiguration;
/** @internal */
declare function isCrossDatasetReferenceSchemaType(type: unknown): type is CrossDatasetReferenceSchemaType;
/** @internal */
declare function isTitledListValue(item: unknown): item is TitledListValue;
/** @internal */
declare function isSpanSchemaType(type: unknown): type is SpanSchemaType;
/** @internal */
declare function isBlockSchemaType(type: unknown): type is BlockSchemaType;
/** @internal */
declare function isBlockStyleObjectField(field: unknown): field is BlockStyleObjectField;
/** @internal */
declare function isBlockListObjectField(field: unknown): field is BlockListObjectField;
/** @internal */
declare function isBlockChildrenObjectField(field: unknown): field is BlockChildrenObjectField;
/**
 * @public
 */
declare const searchStrategies: readonly ["groqLegacy", "groq2024"];
/**
 * @public
 */
type SearchStrategy = (typeof searchStrategies)[number];
/** @public */
interface Reference {
  _type: string;
  _ref: string;
  _key?: string;
  _weak?: boolean;
  _strengthenOnPublish?: {
    type: string;
    weak?: boolean;
    template?: {
      id: string;
      params: Record<string, string | number | boolean>;
    };
  };
}
/** @internal */
interface WeakReference extends Reference {
  _weak: true;
}
/** @public */
type ReferenceFilterSearchOptions = {
  filter?: string;
  params?: Record<string, unknown>;
  tag?: string;
  maxFieldDepth?: number;
  strategy?: SearchStrategy;
  perspective?: Exclude<ClientPerspective, 'raw' | 'previewDrafts'>;
};
/** @public */
interface ReferenceFilterResolverContext {
  document: SanityDocument;
  parent?: Record<string, unknown> | Record<string, unknown>[];
  parentPath: Path;
  perspective: StackablePerspective[];
  getClient: (options: {
    apiVersion: string;
  }) => SanityClient;
}
/** @public */
type ReferenceFilterResolver = (context: ReferenceFilterResolverContext) => ReferenceFilterSearchOptions | Promise<ReferenceFilterSearchOptions>;
/** @public */
interface ReferenceTypeOption {
  type: string;
}
/**
 * Context object passed to the creationTypeFilter callback.
 *
 * @public
 */
interface ReferenceTypeFilterContext {
  /** The current document being edited */
  document: SanityDocument;
  /** The parent value containing this reference field */
  parent?: Record<string, unknown> | Record<string, unknown>[];
  /** The path to the parent value in the document */
  parentPath: Path;
}
/**
 * Function type for filtering which document types can be created from a reference field.
 *
 * The `creationTypeFilter` specifically controls the types
 * available when clicking "Create new" in the reference input.
 *
 * This is distinct from the `filter` option, which controls which existing documents appear in search results.
 *
 * @param context - Information about the current document and field location
 * @param toTypes - Array of type options from the reference field's `to` configuration
 * @returns Filtered array of type options that should be available for creation
 *
 * @public
 */
type ReferenceTypeFilter = (context: ReferenceTypeFilterContext, toTypes: ReferenceTypeOption[]) => ReferenceTypeOption[];
/** @public */
interface ReferenceFilterResolverOptions {
  filter?: ReferenceFilterResolver;
  filterParams?: never;
}
/** @public */
interface ReferenceFilterQueryOptions {
  filter: string;
  filterParams?: Record<string, unknown>;
}
/** @public */
interface ReferenceBaseOptions extends BaseSchemaTypeOptions {
  /**
   * When `true`, hides the "Create new" button in the reference input,
   * preventing users from creating new documents from this field.
   *
   * For more granular control (e.g., allowing creation of only specific types,
   * or conditionally hiding the button based on document state), use the
   * `creationTypeFilter` option instead.
   */
  disableNew?: boolean;
  /**
   * Callback function to dynamically filter which document types can be created
   * from this reference field based on the current document state.
   *
   * This allows you to conditionally restrict the types available in the
   * "Create new" dropdown based on other field values in the document.
   *
   * **Important**: This only affects document creation, not which existing documents
   * appear in search results. To filter search results, use the `filter` option instead.
   *
   * @param context - Contains the current document, parent value, and field path
   * @param toTypes - Array of all types configured in the reference field's `to` property
   * @returns Array of type options that should be available for creation. Return the
   *          original `toTypes` array to allow all types, a filtered subset to restrict
   *          available types, or an empty array `[]` to hide the "Create new" button entirely.
   */
  creationTypeFilter?: ReferenceTypeFilter;
}
/** @public */
type ReferenceFilterOptions = ReferenceFilterResolverOptions | ReferenceFilterQueryOptions;
/** @internal */
declare function isReference(reference: unknown): reference is Reference;
/** @public */
interface EmptyProps {}
/** @public */
interface File {
  [key: string]: unknown;
  asset?: Reference;
}
/** @public */
interface Image {
  [key: string]: unknown;
  asset?: Reference;
  crop?: ImageCrop;
  hotspot?: ImageHotspot;
}
/** @public */
interface Asset extends SanityDocument {
  url: string;
  path: string;
  assetId: string;
  extension: string;
  mimeType: string;
  sha1hash: string;
  size: number;
  originalFilename?: string;
  label?: string;
  title?: string;
  description?: string;
  creditLine?: string;
  source?: AssetSourceSpec;
}
/** @public */
interface ImageAsset extends Asset {
  _type: 'sanity.imageAsset';
  metadata: ImageMetadata;
}
/** @public */
interface FileAsset extends Asset {
  _type: 'sanity.fileAsset';
  metadata: Record<string, unknown>;
}
/** @public */
interface ImageMetadata {
  [key: string]: unknown;
  _type: 'sanity.imageMetadata';
  dimensions: ImageDimensions;
  palette?: ImagePalette;
  lqip?: string;
  blurHash?: string;
  thumbHash?: string;
  hasAlpha: boolean;
  isOpaque: boolean;
}
/** @public */
interface ImageDimensions {
  _type: 'sanity.imageDimensions';
  height: number;
  width: number;
  aspectRatio: number;
}
/** @public */
interface ImageCrop {
  _type?: 'sanity.imageCrop';
  left: number;
  bottom: number;
  right: number;
  top: number;
}
/** @public */
interface ImageHotspot {
  _type?: 'sanity.imageHotspot';
  width: number;
  height: number;
  x: number;
  y: number;
}
/** @public */
interface ImagePalette {
  _type: 'sanity.imagePalette';
  darkMuted?: ImageSwatch;
  darkVibrant?: ImageSwatch;
  dominant?: ImageSwatch;
  lightMuted?: ImageSwatch;
  lightVibrant?: ImageSwatch;
  muted?: ImageSwatch;
  vibrant?: ImageSwatch;
}
/** @public */
interface ImageSwatch {
  _type: 'sanity.imagePaletteSwatch';
  background: string;
  foreground: string;
  population: number;
  title?: string;
}
/** @public */
type SwatchName = 'darkMuted' | 'darkVibrant' | 'dominant' | 'lightMuted' | 'lightVibrant' | 'muted' | 'vibrant';
/** @public */
interface AssetSourceSpec {
  id: string;
  name: string;
  url?: string;
}
/** @public */
type AssetFromSource = {
  kind: 'assetDocumentId' | 'file' | 'base64' | 'url';
  value: string | File;
  assetDocumentProps?: ImageAsset;
  mediaLibraryProps?: {
    mediaLibraryId: string;
    assetId: string;
    assetInstanceId: string;
  };
};
/** @public */
type AssetSourceComponentAction = 'select' | 'upload' | 'openInSource';
/** @public */
interface AssetSourceComponentProps {
  action?: AssetSourceComponentAction;
  assetSource: AssetSource;
  assetType?: 'file' | 'image' | 'sanity.video';
  accept: string;
  selectionType: 'single';
  dialogHeaderTitle?: React.ReactNode;
  selectedAssets: Asset[];
  onClose: () => void;
  onSelect: (assetFromSource: AssetFromSource[]) => void;
  onChangeAction?: (action: AssetSourceComponentAction) => void;
  schemaType?: ImageSchemaType | FileSchemaType;
  /** @beta */
  uploader?: AssetSourceUploader;
  /**
   * The asset to open in source. Only provided when action is 'openInSource'.
   * @beta
   */
  assetToOpen?: Asset;
}
/** @public */
type AssetMetadataType = 'location' | 'exif' | 'image' | 'palette' | 'lqip' | 'blurhash' | 'thumbhash' | 'none';
/** @beta */
type AssetSourceUploaderClass = new (...args: any[]) => AssetSourceUploader;
/**
 * The result of calling `AssetSource.openInSource`.
 * @beta
 */
type AssetSourceOpenInSourceResult = {
  type: 'url';
  url: string;
  target?: '_blank' | '_self';
} | {
  type: 'component';
} | false | undefined;
/** @public */
interface AssetSource {
  name: string;
  /** @deprecated provide `i18nKey` instead */
  title?: string;
  i18nKey?: string;
  component: ComponentType<AssetSourceComponentProps>;
  icon?: ComponentType;
  /** @beta */
  Uploader?: AssetSourceUploaderClass;
  /**
   * Resolve how to open an asset in its original source.
   *
   * This function is called for each AssetSource when determining if
   * "Open in Source" should be available. The plugin should check
   * `asset.source.name` to determine if it can handle this asset.
   *
   * Return values:
   * - `{ type: 'url', url: string }` - Open the URL (in new window by default)
   * - `{ type: 'component' }` - Render the asset source component with action='openInSource'
   * - `false` or `undefined` - This plugin cannot handle this asset
   *
   * @beta
   */
  openInSource?: (asset: Asset) => AssetSourceOpenInSourceResult;
}
/** @beta */
interface AssetSourceUploadFile {
  id: string;
  file: globalThis.File;
  progress: number;
  status: 'pending' | 'uploading' | 'complete' | 'error' | 'aborted' | 'alreadyExists';
  error?: Error;
  result?: unknown;
}
/** @beta */
interface AssetSourceUploader {
  upload(files: globalThis.File[], options?: {
    /**
     * The schema type of the field the asset is being uploaded to.
     * May be of interest to the uploader to read file and image options.
     */
    schemaType?: SchemaType;
    /**
     * The uploader may send patches directly to the field
     * Typed 'unknown' as we don't have patch definitions in sanity/types yet.
     */
    onChange?: (patch: unknown) => void;
  }): AssetSourceUploadFile[];
  /**
   * Abort the upload of a file
   */
  abort(file?: AssetSourceUploadFile): void;
  /**
   * Get the files that are currently being uploaded
   */
  getFiles(): AssetSourceUploadFile[];
  /**
   * Subscribe to upload events from the uploader
   */
  subscribe(subscriber: (event: AssetSourceUploadEvent) => void): () => void;
  /**
   * Update the status of a file. Will be emitted to subscribers.
   */
  updateFile(fileId: string, data: {
    progress?: number;
    status?: string;
    error?: Error;
  }): void;
  /**
   * Reset the uploader (clear files). Should be called by the uploader when all files are done.
   */
  reset(): void;
}
/**
 * Emitted when a file upload is progressing
 * @beta */
type AssetSourceUploadEventProgress = {
  type: 'progress';
  file: AssetSourceUploadFile;
  progress: number;
};
/**
 * Emitted when a file upload is changing status
 * @beta */
type AssetSourceUploadEventStatus = {
  type: 'status';
  file: AssetSourceUploadFile;
  status: AssetSourceUploadFile['status'];
};
/**
 * Emitted when all files are done, either successfully, aborted or with errors
 * @beta */
type AssetSourceUploadEventAllComplete = {
  type: 'all-complete';
  files: AssetSourceUploadFile[];
};
/**
 * Emitted when all files are done, either successfully, aborted or with errors
 * @beta */
type AssetSourceUploadEventError = {
  type: 'error';
  /**
   * Files errored
   */
  files: AssetSourceUploadFile[];
};
/**
 * Emitted when all files are done, either successfully, aborted or with errors
 * @beta */
type AssetSourceUploadEventAbort = {
  type: 'abort';
  /**
   * Files aborted
   */
  files: AssetSourceUploadFile[];
};
/** @beta */
type AssetSourceUploadEvent = AssetSourceUploadEventProgress | AssetSourceUploadEventStatus | AssetSourceUploadEventAllComplete | AssetSourceUploadEventError | AssetSourceUploadEventAbort;
/** @beta */
type AssetSourceUploadSubscriber = (event: AssetSourceUploadEvent) => void;
/** @public */
declare function isImage(value: unknown): value is Image;
/** @beta */
interface GlobalDocumentReferenceValue {
  _type: string;
  /** The reference to the document. This is a string of the form `a:b:c`,
   * where:
   * - `a` is the resource type, for example `dataset` or `media-library`
   * - `b` is the resource ID, for example data set name or media library ID
   * - `c` is the document ID */
  _ref: `${string}:${string}:${string}`;
  _key?: string;
  _weak?: boolean;
}
/** @beta */
interface WeakGlobalDocumentReferenceValue extends GlobalDocumentReferenceValue {
  _weak: true;
}
/** @beta */
type GlobalDocumentReferenceFilterSearchOptions = {
  filter?: string;
  params?: Record<string, unknown>;
  tag?: string;
};
/** @beta */
type GlobalDocumentReferenceFilterResolver = (options: {
  document: SanityDocument;
  parent?: Record<string, unknown> | Record<string, unknown>[];
  parentPath: Path;
}) => GlobalDocumentReferenceFilterSearchOptions | Promise<GlobalDocumentReferenceFilterSearchOptions>;
/** @beta */
interface GlobalDocumentReferenceType {
  type: string;
  title?: string;
  icon: ComponentType;
  preview: PreviewConfig;
  /** @deprecated Unused. It's only here for the type to be compatible with createSearchQuery.ts */
  __experimental_search: never;
}
/** @beta */
interface GlobalDocumentReferenceSchemaType extends Omit<ObjectSchemaType, 'options'> {
  jsonType: 'object';
  to: GlobalDocumentReferenceType[];
  resourceType: string;
  resourceId: string;
  studioUrl?: string | ((document: {
    id: string;
    type?: string;
  }) => string | null);
  weak?: boolean;
  options?: ReferenceFilterOptions;
}
/** @beta */
declare function isGlobalDocumentReference(reference: unknown): reference is GlobalDocumentReferenceValue;
/**
 * NOTE: These are query parameters, so they will eventually be encoded as strings.
 * However, since most/all query parameter encoders will accept numbers and encode
 * them as strings, we'll use `string| number` where applicable, as it makes it easier
 * to use in places that do calculations and such.
 *
 * @internal
 */
interface ImageUrlParams {
  'bg'?: string;
  'dpr'?: number | string;
  'w'?: number | string;
  'h'?: number | string;
  'q'?: number | string;
  'dl'?: string;
  'dlRaw'?: string;
  'fp-x'?: number | string;
  'fp-y'?: number | string;
  'max-w'?: number | string;
  'max-h'?: number | string;
  'min-w'?: number | string;
  'min-h'?: number | string;
  'blur'?: number | string;
  'sharp'?: number | string;
  'rect'?: string;
  'fm'?: ImageUrlFormat;
  'or'?: ImageUrlOrientation;
  'fit'?: ImageUrlFitMode;
  'crop'?: ImageUrlCropMode;
  'auto'?: ImageUrlAutoMode;
  'invert'?: 'true' | 'false';
  'quality'?: number | string;
  'flip'?: 'h' | 'v' | 'hv';
  'sat'?: number | string;
  'pad'?: number | string;
  'colorquant'?: number | string;
  'border'?: string;
}
/** @internal */
type ImageUrlFormat = 'jpg' | 'pjpg' | 'png' | 'webp';
/** @internal */
type ImageUrlFitMode = 'clip' | 'crop' | 'fill' | 'fillmax' | 'max' | 'scale' | 'min';
/** @internal */
type ImageUrlCropMode = 'top' | 'bottom' | 'left' | 'right' | 'center' | 'focalpoint' | 'entropy';
/** @internal */
type ImageUrlAutoMode = 'format';
/** @internal */
type ImageUrlOrientation = '0' | '90' | '180' | '270';
/**
 * @public
 */
type MediaLibraryAssetAspectSupportedFieldDefinitions = FieldDefinition<Exclude<IntrinsicTypeName, 'document' | 'image' | 'file' | 'reference' | 'crossDatasetReference'>>;
/**
 * @public
 */
type MediaLibraryAssetAspectDefinition = MediaLibraryAssetAspectSupportedFieldDefinitions & {
  assetType?: MediaLibraryAssetType | MediaLibraryAssetType[];
  public?: boolean;
};
/**
 * @public
 */
declare const MEDIA_LIBRARY_ASSET_ASPECT_TYPE_NAME = "sanity.asset.aspect";
/**
 * @public
 */
type MediaLibraryAssetAspectTypeName = typeof MEDIA_LIBRARY_ASSET_ASPECT_TYPE_NAME;
/**
 * @public
 */
type MediaLibraryAssetType = ImageAsset['_type'] | FileAsset['_type'];
/**
 * A document representing a Media Library asset aspect.
 *
 * Each aspect provides a schema describing custom data that can be assigned to assets.
 *
 * @public
 */
interface MediaLibraryAssetAspectDocument extends SanityDocumentLike {
  _type: MediaLibraryAssetAspectTypeName;
  /**
   * Asset types the aspect can be assigned to.
   *
   * If no `assetType` is defined, the aspect may be assigned to any asset type.
   */
  assetType?: MediaLibraryAssetType[];
  definition: FieldDefinition;
  public?: boolean;
}
/**
 * Check whether the provided value resembles a Media Library asset aspect document.
 *
 * Note: This function does not perform a comprehensive check.
 *
 * @see validateMediaLibraryAssetAspect
 *
 * @internal
 */
declare function isAssetAspect(maybeAssetAspect: unknown): maybeAssetAspect is MediaLibraryAssetAspectDocument;
/**
 * Define a Media Library asset aspect.
 *
 * Aspects can be deployed using the `sanity media deploy-aspect` CLI command.
 *
 * @public
 * @beta
 */
declare function defineAssetAspect(definition: MediaLibraryAssetAspectDefinition): MediaLibraryAssetAspectDocument;
/**
 * An entry in the transaction log
 *
 * @internal
 */
interface TransactionLogEvent {
  /**
   * ID of transaction
   */
  id: string;
  /**
   * ISO-formatted timestamp (zulu-time) of when the transaction happened
   */
  timestamp: string;
  /**
   * User ID of the user who performed the transaction
   */
  author: string;
  /**
   * Document IDs involved in this transaction
   */
  documentIDs: string[];
}
/**
 * An entry in the transaction log that includes the effects of the transaction.
 * Used when asking the transaction log to include effects in mendoza format,
 * eg `?effectFormat=mendoza`
 *
 * @internal
 */
interface TransactionLogEventWithEffects extends TransactionLogEvent {
  /**
   * Object of effects, where the key is the document ID affected and the value
   * is the effect pair, eg `{apply: MendozaPatch, revert: MendozaPatch}`
   */
  effects: Record<string, MendozaEffectPair | undefined>;
}
/**
 * An entry in the transaction log that includes the mutations that were performed.
 * Used when asking the transaction log not to exclude the mutations,
 * eg `excludeMutations=false`
 *
 * @internal
 */
interface TransactionLogEventWithMutations extends TransactionLogEvent {
  /**
   * Array of mutations that occurred in this transaction. Note that the transaction
   * log has an additional mutation type not typically seen in other APIs;
   * `createSquashed` ({@link CreateSquashedMutation}).
   */
  mutations: TransactionLogMutation[];
}
/**
 * Mutation type used when the document has passed the threshold of the
 * "history retention" - any transactions done prior to the threshold gets "squashed"
 * into a single "create" transaction.
 *
 * @internal
 */
interface CreateSquashedMutation {
  createSquashed: {
    /**
     * The user IDs of all the users who contributed to the document prior to the squashing
     */
    authors: string[];
    /**
     * User ID of the person who initially created the document
     */
    createdBy: string;
    /**
     * ISO-formatted timestamp (zulu-time) of when the document as initially created
     */
    createdAt: string;
    /**
     * The document as it exists after squashing has occurred
     */
    document: {
      _id: string;
      _type: string;
      [key: string]: unknown;
    };
  };
}
/**
 * A mutation that can occur in the transaction log, which includes the
 * {@link CreateSquashedMutation} mutation type.
 *
 * @internal
 */
type TransactionLogMutation = Mutation | CreateSquashedMutation;
/**
 * A mendoza patch. These are not human-readable patches, but are optimized to
 * take as little space as possible, while still being represented by plain JSON.
 * See {@link https://www.sanity.io/blog/mendoza}
 *
 * @internal
 */
type MendozaPatch = unknown[];
/**
 * A pair of mendoza patches that can either be _applied_ (to perform the effect),
 * or _reverted_ (to undo the effect). Requires the exact, previous version of the
 * document when applying - any difference might have unexpected consequences.
 *
 * @internal
 */
interface MendozaEffectPair {
  apply: MendozaPatch;
  revert: MendozaPatch;
}
/** @internal */
declare function isCreateSquashedMutation(mutation: Mutation | TransactionLogMutation): mutation is CreateSquashedMutation;
/** @internal */
type InsertPatch = {
  before: string;
  items: unknown[];
} | {
  after: string;
  items: unknown[];
} | {
  replace: string;
  items: unknown[];
};
/**
 * NOTE: this is actually incorrect/invalid, but implemented as-is for backwards compatibility
 *
 * @internal
 */
interface PatchOperations {
  set?: {
    [key: string]: unknown;
  };
  setIfMissing?: {
    [key: string]: unknown;
  };
  merge?: {
    [key: string]: unknown;
  };
  diffMatchPatch?: {
    [key: string]: string;
  };
  unset?: string[];
  inc?: {
    [key: string]: number;
  };
  dec?: {
    [key: string]: number;
  };
  insert?: InsertPatch;
  ifRevisionID?: string;
}
/** @internal */
type MutationSelection = {
  query: string;
  params?: Record<string, unknown>;
} | {
  id: string;
};
/** @internal */
type PatchMutationOperation = PatchOperations & MutationSelection;
/** @internal */
interface CreateMutation {
  create: {
    _id?: string;
    _type: string;
    [key: string]: unknown;
  };
}
/** @internal */
interface CreateOrReplaceMutation {
  createOrReplace: {
    _id: string;
    _type: string;
    [key: string]: unknown;
  };
}
/** @internal */
interface CreateIfNotExistsMutation {
  createIfNotExists: {
    _id: string;
    _type: string;
    [key: string]: unknown;
  };
}
/** @internal */
interface DeleteMutation {
  delete: MutationSelection;
}
/** @internal */
interface PatchMutation {
  patch: PatchMutationOperation;
}
/** @internal */
type Mutation = CreateMutation | CreateOrReplaceMutation | CreateIfNotExistsMutation | DeleteMutation | PatchMutation;
/** @internal */
type MutationOperationName = 'create' | 'createOrReplace' | 'createIfNotExists' | 'delete' | 'patch';
/** @internal */
interface SingleMutationResult {
  transactionId: string;
  documentId: string;
  results: {
    id: string;
  }[];
}
/** @internal */
interface MultipleMutationResult {
  transactionId: string;
  documentIds: string[];
  results: {
    id: string;
  }[];
}
/** @internal */
declare function isCreateMutation(mutation: Mutation | TransactionLogMutation): mutation is CreateMutation;
/** @internal */
declare function isCreateIfNotExistsMutation(mutation: Mutation | TransactionLogMutation): mutation is CreateIfNotExistsMutation;
/** @internal */
declare function isCreateOrReplaceMutation(mutation: Mutation | TransactionLogMutation): mutation is CreateOrReplaceMutation;
/** @internal */
declare function isDeleteMutation(mutation: Mutation | TransactionLogMutation): mutation is DeleteMutation;
/** @internal */
declare function isPatchMutation(mutation: Mutation | TransactionLogMutation): mutation is PatchMutation;
/** @alpha */
type PortableTextBlock = PortableTextTextBlock | PortableTextObject;
/** @alpha */
interface PortableTextTextBlock<TChild = PortableTextSpan | PortableTextObject> {
  _type: string;
  _key: string;
  children: TChild[];
  markDefs?: PortableTextObject[];
  listItem?: string;
  style?: string;
  level?: number;
}
/** @alpha */
interface PortableTextObject {
  _type: string;
  _key: string;
  [other: string]: unknown;
}
/** @alpha */
interface PortableTextSpan {
  _key: string;
  _type: 'span';
  text: string;
  marks?: string[];
}
/** @alpha */
type PortableTextChild = PortableTextObject | PortableTextSpan;
/** @alpha */
interface PortableTextListBlock extends PortableTextTextBlock {
  listItem: string;
  level: number;
}
/**
 * Assert that a given object is a portable-text text-block type object
 *
 * @remarks
 * * The `markDefs` and `style` property of a block is optional.
 * * Block types can be named, so expect anything of the _type property.
 *
 * @alpha
 */
declare function isPortableTextTextBlock<T = PortableTextSpan | PortableTextObject>(value: unknown): value is PortableTextTextBlock<T>;
/**
 * Assert that a given object is a portable-text span-type object
 *
 * @remarks
 * The `marks` property of a block is optional.
 *
 * @alpha
 */
declare function isPortableTextSpan(value: unknown): value is PortableTextSpan;
/**
 * Assert that a given object is a portable-text list-text-block-type object
 *
 * @remarks
 * Uses `isPortableTextTextBlock` and checks for `listItem` and `level`
 *
 * @see isPortableTextTextBlock
 *
 * @alpha
 */
declare function isPortableTextListBlock<T = PortableTextSpan | PortableTextObject>(value: unknown): value is PortableTextTextBlock<T>;
/**
 * @internal
 * Payload that will be passed by the comments backend to our notifications system to display the notification in dashboard.
 * */
interface StudioNotificationPayload extends DashboardNotificationPayload {
  applicationType: 'studio';
  applicationId: string | undefined;
  workspaceName: string | undefined;
  link: {
    type: 'url';
    url: string;
  };
}
/**
 * @internal
 * Payload that will be passed by canvas to our notifications system to display the notification in canvas.
 * */
interface CanvasNotificationPayload extends DashboardNotificationPayload {
  applicationType: 'canvas';
  link: {
    type: 'dashboard';
    path: string;
  };
}
/**
 * @internal
 * Payload notifications have to provide to the notification system in order to display correctly in dashboard
 */
interface DashboardNotificationPayload {
  version: '1.0.0';
  applicationType: string;
  createdAt: string;
  /**
   * The user who took the action which triggered the notification.
   */
  actor: User;
  title: PortableTextBlock[];
  body: PortableTextBlock[] | undefined;
  organizationId: string;
  applicationId?: string;
  workspaceName?: string;
  link: {
    type: 'url';
    url: string;
  } | {
    type: 'dashboard';
    path: string;
  };
}
/**
 * @internal
 */
declare function isSearchStrategy(maybeSearchStrategy: unknown): maybeSearchStrategy is SearchStrategy;
/** @internal */
interface UploadState {
  progress: number;
  /** @deprecated use createdAt instead */
  initiated?: string;
  /** @deprecated use updatedAt instead */
  updated?: string;
  createdAt: string;
  updatedAt: string;
  file: {
    name: string;
    type: string;
  };
  previewImage?: string;
}
export { ArrayActionName, ArrayDefinition, ArrayOfEntry, ArrayOfType, ArrayOptions, ArrayRule, ArraySchemaType, ArraySchemaTypeOf, Asset, AssetFromSource, AssetMetadataType, AssetSchemaTypeOptions, AssetSource, AssetSourceComponentAction, AssetSourceComponentProps, AssetSourceOpenInSourceResult, AssetSourceSpec, AssetSourceUploadEvent, AssetSourceUploadEventAbort, AssetSourceUploadEventAllComplete, AssetSourceUploadEventError, AssetSourceUploadEventProgress, AssetSourceUploadEventStatus, AssetSourceUploadFile, AssetSourceUploadSubscriber, AssetSourceUploader, AssetSourceUploaderClass, AutocompleteString, BaseSchemaDefinition, BaseSchemaType, BaseSchemaTypeOptions, BlockAnnotationDefinition, BlockChildrenObjectField, BlockDecoratorDefinition, BlockDefinition, BlockListDefinition, BlockListObjectField, BlockMarksDefinition, BlockOptions, BlockRule, BlockSchemaType, BlockStyleDefinition, BlockStyleObjectField, BooleanDefinition, BooleanOptions, BooleanRule, BooleanSchemaType, CanvasAppOptions, CanvasNotificationPayload, CollapseOptions, ConditionalIndexAccess, ConditionalProperty, ConditionalPropertyCallback, ConditionalPropertyCallbackContext, CreateIfNotExistsMutation, CreateMutation, CreateOrReplaceMutation, CreateSquashedMutation, CrossDatasetReferenceDefinition, CrossDatasetReferenceFilterResolver, CrossDatasetReferenceFilterSearchOptions, CrossDatasetReferenceSchemaType, CrossDatasetReferenceValue, CrossDatasetType, CurrentUser, CustomValidator, CustomValidatorResult, DashboardNotificationPayload, DateDefinition, DateOptions, DateRule, DatetimeDefinition, DatetimeOptions, DatetimeRule, DefineArrayMemberBase, DefineSchemaBase, DefineSchemaOptions, DefineSchemaType, DeleteMutation, DeprecatedProperty, DeprecatedSchemaType, DeprecationConfiguration, DocumentDefinition, DocumentOptions, DocumentRule, EmailDefinition, EmailOptions, EmailRule, EmptyProps, EnumListProps, FieldDefinition, FieldDefinitionBase, FieldGroup, FieldGroupDefinition, FieldReference, FieldRules, Fieldset, FieldsetDefinition, File, FileAsset, FileDefinition, FileOptions, FileRule, FileSchemaType, FileValue, FormNodeValidation, GeopointDefinition, GeopointOptions, GeopointRule, GeopointValue, GlobalDocumentReferenceDefinition, GlobalDocumentReferenceFilterResolver, GlobalDocumentReferenceFilterSearchOptions, GlobalDocumentReferenceSchemaType, GlobalDocumentReferenceType, GlobalDocumentReferenceValue, HotspotOptions, HotspotPreview, I18nTextRecord, I18nTitledListValue, Image, ImageAsset, ImageCrop, ImageDefinition, ImageDimensions, ImageHotspot, ImageMetadata, ImageMetadataType, ImageOptions, ImagePalette, ImageRule, ImageSchemaType, ImageSwatch, ImageUrlAutoMode, ImageUrlCropMode, ImageUrlFitMode, ImageUrlFormat, ImageUrlOrientation, ImageUrlParams, ImageValue, IndexTuple, InitialValueProperty, InitialValueResolver, InitialValueResolverContext, InlineFieldDefinition, type InsertMenuOptions, InsertPatch, IntrinsicArrayOfBase, IntrinsicArrayOfDefinition, IntrinsicBase, IntrinsicDefinitions, IntrinsicTypeName, KeyedObject, KeyedSegment, LocalizedValidationMessages, MEDIA_LIBRARY_ASSET_ASPECT_TYPE_NAME, MaybeAllowUnknownProps, MaybePreview, MediaAssetTypes, MediaLibraryAssetAspectDefinition, MediaLibraryAssetAspectDocument, MediaLibraryAssetAspectSupportedFieldDefinitions, MediaLibraryAssetAspectTypeName, MediaLibraryAssetType, MediaLibraryFilter, MediaLibraryOptions, MediaValidationValue, MediaValidator, MendozaEffectPair, MendozaPatch, MultiFieldSet, MultipleMutationResult, Mutation, MutationOperationName, MutationSelection, NarrowPreview, NumberDefinition, NumberOptions, NumberRule, NumberSchemaType, ObjectDefinition, ObjectField, ObjectFieldType, ObjectOptions, ObjectRule, ObjectSchemaType, ObjectSchemaTypeWithOptions, PatchMutation, PatchMutationOperation, PatchOperations, Path, PathSegment, PortableTextBlock, PortableTextChild, PortableTextListBlock, PortableTextObject, PortableTextSpan, PortableTextTextBlock, PrepareViewOptions, PreviewConfig, PreviewValue, Reference, ReferenceBaseOptions, ReferenceDefinition, ReferenceFilterOptions, ReferenceFilterQueryOptions, ReferenceFilterResolver, ReferenceFilterResolverContext, ReferenceFilterResolverOptions, ReferenceFilterSearchOptions, ReferenceOptions, ReferenceRule, ReferenceSchemaType, ReferenceTo, ReferenceTypeFilter, ReferenceTypeFilterContext, ReferenceTypeOption, ReferenceValue, Role, Rule, RuleBuilder, RuleClass, RuleDef, RuleSpec, RuleSpecConstraint, RuleTypeConstraint, SanityCreateOptions, SanityDocument, SanityDocumentLike, Schema, SchemaType, SchemaTypeDefinition, SchemaValidationError, SchemaValidationProblem, SchemaValidationProblemGroup, SchemaValidationProblemPath, SchemaValidationValue, SchemaValidationWarning, SearchConfiguration, SearchStrategy, SingleFieldSet, SingleMutationResult, Slug, SlugDefinition, SlugIsUniqueValidator, SlugOptions, SlugParent, SlugRule, SlugSchemaType, SlugSourceContext, SlugSourceFn, SlugValidationContext, SlugValue, SlugifierFn, SortOrdering, SortOrderingItem, SpanMarksObjectField, SpanSchemaType, SpanTextObjectField, StrictDefinition, StrictVersionLayeringOptions, StringDefinition, StringOptions, StringRule, StringSchemaType, StudioNotificationPayload, SwatchName, TextDefinition, TextOptions, TextRule, TextSchemaType, TitledListValue, TransactionLogEvent, TransactionLogEventWithEffects, TransactionLogEventWithMutations, TransactionLogMutation, TypeAliasDefinition, TypeReference, TypedObject, UploadState, UriValidationOptions, UrlDefinition, UrlOptions, UrlRule, User, ValidationBuilder, ValidationContext, ValidationError, ValidationErrorClass, ValidationErrorOptions, ValidationMarker, Validator, Validators, WeakCrossDatasetReferenceValue, WeakGlobalDocumentReferenceValue, WeakReference, WidenInitialValue, WidenValidation, defineArrayMember, defineAssetAspect, defineField, defineType, isArrayOfBlocksSchemaType, isArrayOfObjectsSchemaType, isArrayOfPrimitivesSchemaType, isArraySchemaType, isAssetAspect, isBlockChildrenObjectField, isBlockListObjectField, isBlockSchemaType, isBlockStyleObjectField, isBooleanSchemaType, isCreateIfNotExistsMutation, isCreateMutation, isCreateOrReplaceMutation, isCreateSquashedMutation, isCrossDatasetReference, isCrossDatasetReferenceSchemaType, isDateTimeSchemaType, isDeleteMutation, isDeprecatedSchemaType, isDeprecationConfiguration, isDocumentSchemaType, isFileSchemaType, isGlobalDocumentReference, isImage, isImageSchemaType, isIndexSegment, isIndexTuple, isKeySegment, isKeyedObject, isNumberSchemaType, isObjectSchemaType, isPatchMutation, isPortableTextListBlock, isPortableTextSpan, isPortableTextTextBlock, isPrimitiveSchemaType, isReference, isReferenceSchemaType, isSanityDocument, isSearchStrategy, isSlug, isSpanSchemaType, isStringSchemaType, isTitledListValue, isTypedObject, isValidationError, isValidationErrorMarker, isValidationInfo, isValidationInfoMarker, isValidationWarning, isValidationWarningMarker, searchStrategies, typed };