import {
  ComponentBuilder,
  ComponentViewBuilder,
  ConfirmDeleteDialogContainer,
  CrossDatasetIncomingReferenceDocumentPreview,
  DEFAULT_INTENT_HANDLER,
  DocumentBuilder,
  DocumentInspectorHeader,
  DocumentListBuilder,
  DocumentListItemBuilder,
  DocumentPane,
  DocumentPaneProviderWrapper,
  DocumentTypeListBuilder,
  FormViewBuilder,
  GenericListBuilder,
  GenericViewBuilder,
  HELP_URL,
  INCOMING_REFERENCES_ITEM_HEIGHT,
  INITIAL_STATE$1,
  IncomingReferenceDocument$1,
  IncomingReferencesListContainer,
  InitialValueTemplateItemBuilder,
  ListBuilder,
  ListItemBuilder,
  MenuItemBuilder,
  MenuItemGroupBuilder,
  Pane,
  PaneContainer,
  PaneContent,
  PaneLayout,
  SerializeError,
  StructureToolProvider,
  component,
  createStructureBuilder,
  defaultInitialValueTemplateItems,
  defaultIntentChecker,
  documentFromEditor,
  documentFromEditorWithInitialValue,
  form,
  getCrossDatasetIncomingReferences,
  getIncomingReferences,
  getOrderingMenuItem,
  getOrderingMenuItemsForSchemaType,
  getTypeNamesFromFilter,
  isDocumentListItem,
  maybeSerializeInitialValueTemplateItem,
  maybeSerializeMenuItem,
  maybeSerializeMenuItemGroup,
  maybeSerializeView,
  menuItemsFromInitialValueTemplateItems,
  shallowIntentChecker,
  structureLocaleNamespace,
  structureTool,
  useDocumentPane,
  useDocumentTitle,
  usePaneOptions,
  usePaneRouter,
  useStructureTool
} from "./chunk-I6XFQ6I4.js";
import "./chunk-EMYABH4X.js";
import {
  Button,
  CommandList,
  CreateButton,
  DEFAULT_MAX_FIELD_DEPTH,
  DEFAULT_STUDIO_CLIENT_OPTIONS,
  LoadingBlock,
  PaneRouterContext,
  PreviewCard,
  ReferenceAutocomplete$3,
  ReleaseTitle,
  SanityDefaultPreview,
  VersionInlineBadge,
  catchError,
  concat,
  createSearch,
  filter,
  getDraftId,
  getPreviewStateObservable$1,
  getPreviewValueWithFallback,
  getPublishedId,
  getReleaseIdFromReleaseDocumentId,
  getReleaseTone,
  getVersionFromId,
  isDraftId,
  isNonNullable$2,
  isPublishedId,
  isVersionId,
  map,
  of,
  scan,
  startCase_default,
  switchMap,
  tap,
  useActiveReleases,
  useClient,
  useDocumentPreviewStore,
  useObservable,
  useObservableEvent,
  useReferenceInputOptions,
  useRouter,
  useSchema,
  useSource,
  useTranslation,
  v4_default
} from "./chunk-AWVS7GJ4.js";
import {
  AddIcon,
  Box,
  Card,
  Flex,
  Grid,
  Stack,
  Text,
  useToast
} from "./chunk-D7NYSWPL.js";
import "./chunk-OF6A7363.js";
import {
  require_compiler_runtime
} from "./chunk-LVTF57EB.js";
import "./chunk-PMTGGN7Z.js";
import "./chunk-ELCPRM3E.js";
import "./chunk-5Y2BKJGR.js";
import {
  require_jsx_runtime
} from "./chunk-CTEYD6P7.js";
import {
  require_react
} from "./chunk-TZMYWIEJ.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/sanity/lib/structure.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_compiler_runtime = __toESM(require_compiler_runtime());
var import_react = __toESM(require_react());
function CrossDatasetIncomingReferenceType(t0) {
  const $ = (0, import_compiler_runtime.c)(41), {
    type,
    referenced,
    shouldRenderTitle
  } = t0, client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), documentPreviewStore = useDocumentPreviewStore();
  let t1;
  $[0] !== client || $[1] !== documentPreviewStore || $[2] !== referenced.id || $[3] !== type ? (t1 = getCrossDatasetIncomingReferences({
    documentId: referenced.id,
    client,
    type,
    documentPreviewStore
  }), $[0] = client, $[1] = documentPreviewStore, $[2] = referenced.id, $[3] = type, $[4] = t1) : t1 = $[4];
  const references$ = t1, {
    documents,
    loading
  } = useObservable(references$, INITIAL_STATE$1), schema = useSchema(), {
    t
  } = useTranslation(structureLocaleNamespace);
  let T0, T1, t10, t2, t3, t4, t5, t6, t7, t8, t9;
  if ($[5] !== documents || $[6] !== loading || $[7] !== schema || $[8] !== shouldRenderTitle || $[9] !== t || $[10] !== type) {
    t10 = /* @__PURE__ */ Symbol.for("react.early_return_sentinel");
    bb0: {
      const schemaType = schema.get(type.type);
      let t112;
      $[22] !== type ? (t112 = (document) => (0, import_jsx_runtime.jsx)(CrossDatasetIncomingReferenceDocumentPreview, { document, type }), $[22] = type, $[23] = t112) : t112 = $[23];
      const renderItem = t112;
      if (!schemaType) {
        t10 = null;
        break bb0;
      }
      if (loading) {
        let t122;
        $[24] !== t ? (t122 = t("incoming-references-input.types-loading"), $[24] = t, $[25] = t122) : t122 = $[25];
        let t13;
        $[26] !== t122 ? (t13 = (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true, title: t122 }), $[26] = t122, $[27] = t13) : t13 = $[27], t10 = t13;
        break bb0;
      }
      T1 = Stack, t7 = 2, t8 = 2, t9 = shouldRenderTitle && (0, import_jsx_runtime.jsx)(Box, { paddingY: 2, paddingX: 0, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", children: type.title || schemaType?.title }) }), T0 = Card, t2 = 2, t3 = 1, t4 = true, t5 = "default", t6 = documents && documents.length > 0 ? (0, import_jsx_runtime.jsx)(IncomingReferencesListContainer, { $itemCount: documents.length, children: (0, import_jsx_runtime.jsx)(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: t("incoming-references-input.list-label", {
        type: type.title || schemaType?.title
      }), canReceiveFocus: true, fixedHeight: true, getItemKey: (index) => documents[index].id, itemHeight: INCOMING_REFERENCES_ITEM_HEIGHT, items: documents, onlyShowSelectionWhenActive: true, overscan: 5, renderItem, wrapAround: false }) }) : (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsx)(Flex, { align: "center", justify: "center", padding: 2, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, muted: true, children: t("incoming-references-input.no-items") }) }) });
    }
    $[5] = documents, $[6] = loading, $[7] = schema, $[8] = shouldRenderTitle, $[9] = t, $[10] = type, $[11] = T0, $[12] = T1, $[13] = t10, $[14] = t2, $[15] = t3, $[16] = t4, $[17] = t5, $[18] = t6, $[19] = t7, $[20] = t8, $[21] = t9;
  } else
    T0 = $[11], T1 = $[12], t10 = $[13], t2 = $[14], t3 = $[15], t4 = $[16], t5 = $[17], t6 = $[18], t7 = $[19], t8 = $[20], t9 = $[21];
  if (t10 !== /* @__PURE__ */ Symbol.for("react.early_return_sentinel"))
    return t10;
  let t11;
  $[28] !== T0 || $[29] !== t2 || $[30] !== t3 || $[31] !== t4 || $[32] !== t5 || $[33] !== t6 ? (t11 = (0, import_jsx_runtime.jsx)(T0, { radius: t2, padding: t3, border: t4, tone: t5, children: t6 }), $[28] = T0, $[29] = t2, $[30] = t3, $[31] = t4, $[32] = t5, $[33] = t6, $[34] = t11) : t11 = $[34];
  let t12;
  return $[35] !== T1 || $[36] !== t11 || $[37] !== t7 || $[38] !== t8 || $[39] !== t9 ? (t12 = (0, import_jsx_runtime.jsxs)(T1, { space: t7, marginBottom: t8, children: [
    t9,
    t11
  ] }), $[35] = T1, $[36] = t11, $[37] = t7, $[38] = t8, $[39] = t9, $[40] = t12) : t12 = $[40], t12;
}
function CreateNewIncomingReference(t0) {
  const $ = (0, import_compiler_runtime.c)(21), {
    type,
    referenceToId,
    referenceToType,
    onCreateNewReference,
    fieldName,
    creationAllowed
  } = t0, {
    initialValueTemplateItems
  } = useReferenceInputOptions(), {
    navigate
  } = useRouter(), {
    routerPanesState,
    groupIndex
  } = usePaneRouter();
  let t1;
  $[0] !== fieldName || $[1] !== groupIndex || $[2] !== navigate || $[3] !== onCreateNewReference || $[4] !== referenceToId || $[5] !== referenceToType || $[6] !== routerPanesState || $[7] !== type ? (t1 = (option) => {
    const id = v4_default();
    navigate({
      panes: [...routerPanesState.slice(0, groupIndex + 1), [{
        id: getPublishedId(id),
        params: {
          type,
          template: option.template.id
        },
        payload: {
          reference: {
            _type: "reference",
            _ref: referenceToId,
            _weak: true,
            _strengthenOnPublish: {
              type: referenceToType
            }
          },
          from: {
            fieldName,
            type: referenceToType
          },
          __internal_isIncomingReferenceCreation: true
        }
      }]]
    }), onCreateNewReference(id);
  }, $[0] = fieldName, $[1] = groupIndex, $[2] = navigate, $[3] = onCreateNewReference, $[4] = referenceToId, $[5] = referenceToType, $[6] = routerPanesState, $[7] = type, $[8] = t1) : t1 = $[8];
  const handleCreate = t1;
  let t2;
  bb0: {
    if (!creationAllowed) {
      let t33;
      $[9] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t33 = [], $[9] = t33) : t33 = $[9], t2 = t33;
      break bb0;
    }
    let t32;
    if ($[10] !== creationAllowed || $[11] !== initialValueTemplateItems || $[12] !== type) {
      let t42;
      $[14] !== creationAllowed || $[15] !== type ? (t42 = (i) => {
        const typeMatch = type === i.template?.schemaType;
        return Array.isArray(creationAllowed) ? typeMatch && creationAllowed.includes(i.template.id) : typeMatch;
      }, $[14] = creationAllowed, $[15] = type, $[16] = t42) : t42 = $[16], t32 = (initialValueTemplateItems || []).filter(t42).map(_temp$2).filter(isNonNullable$2), $[10] = creationAllowed, $[11] = initialValueTemplateItems, $[12] = type, $[13] = t32;
    } else
      t32 = $[13];
    t2 = t32;
  }
  const createOptions = t2;
  if (!creationAllowed)
    return null;
  const t3 = `create-new-incoming-reference-${type}`;
  let t4;
  return $[17] !== createOptions || $[18] !== handleCreate || $[19] !== t3 ? (t4 = (0, import_jsx_runtime.jsx)(CreateButton, { id: t3, createOptions, onCreate: handleCreate }), $[17] = createOptions, $[18] = handleCreate, $[19] = t3, $[20] = t4) : t4 = $[20], t4;
}
function _temp$2(item) {
  return item.template?.schemaType ? {
    id: item.id,
    title: item.title || `${item.template.schemaType} from template ${item.template?.id}`,
    i18n: item.i18n,
    type: item.template.schemaType,
    icon: item.icon,
    template: {
      id: item.template?.id,
      params: item.parameters
    },
    permission: {
      granted: item.granted,
      reason: item.reason
    }
  } : void 0;
}
var getPerspective = (id) => isDraftId(id) ? ["drafts"] : isVersionId(id) ? [getVersionFromId(id)] : isPublishedId(id) ? ["published"] : ["raw"];
function LinkToExistingPreview(props) {
  const $ = (0, import_compiler_runtime.c)(37), {
    schemaType,
    value,
    onLinkToDocument
  } = props, {
    data: releases
  } = useActiveReleases(), {
    t
  } = useTranslation();
  let t0;
  $[0] !== props.documentPreviewStore || $[1] !== schemaType || $[2] !== value._id ? (t0 = getPreviewStateObservable$1(props.documentPreviewStore, schemaType, value._id, getPerspective(value._id)), $[0] = props.documentPreviewStore, $[1] = schemaType, $[2] = value._id, $[3] = t0) : t0 = $[3];
  const previewStateObservable = t0;
  let t1;
  $[4] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = {
    snapshot: null,
    isLoading: true,
    original: null
  }, $[4] = t1) : t1 = $[4];
  const {
    snapshot,
    original,
    isLoading
  } = useObservable(previewStateObservable, t1);
  let t2;
  if ($[5] !== releases || $[6] !== t || $[7] !== value._id) {
    bb0: {
      const id = value._id;
      if (isDraftId(id)) {
        let t32;
        $[9] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t32 = getReleaseTone("drafts"), $[9] = t32) : t32 = $[9];
        let t42;
        $[10] !== t ? (t42 = t("release.chip.draft"), $[10] = t, $[11] = t42) : t42 = $[11];
        let t52;
        $[12] !== t42 ? (t52 = {
          kind: "static",
          tone: t32,
          text: t42
        }, $[12] = t42, $[13] = t52) : t52 = $[13], t2 = t52;
        break bb0;
      }
      if (isPublishedId(id)) {
        let t32;
        $[14] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t32 = getReleaseTone("published"), $[14] = t32) : t32 = $[14];
        let t42;
        $[15] !== t ? (t42 = t("release.chip.published"), $[15] = t, $[16] = t42) : t42 = $[16];
        let t52;
        $[17] !== t42 ? (t52 = {
          kind: "static",
          tone: t32,
          text: t42
        }, $[17] = t42, $[18] = t52) : t52 = $[18], t2 = t52;
        break bb0;
      }
      if (isVersionId(id)) {
        let t32;
        $[19] !== id ? (t32 = getVersionFromId(id), $[19] = id, $[20] = t32) : t32 = $[20];
        const releaseId = t32;
        let t42;
        $[21] !== releaseId ? (t42 = (r) => getReleaseIdFromReleaseDocumentId(r._id) === releaseId, $[21] = releaseId, $[22] = t42) : t42 = $[22];
        const release = releases.find(t42);
        if (release) {
          t2 = {
            kind: "release",
            tone: getReleaseTone(release),
            releaseTitle: release.metadata.title,
            releaseFallback: release._id
          };
          break bb0;
        }
      }
      t2 = null;
    }
    $[5] = releases, $[6] = t, $[7] = value._id, $[8] = t2;
  } else
    t2 = $[8];
  const badgeProps = t2;
  if (!snapshot && !isLoading)
    return null;
  let t3;
  $[23] !== original || $[24] !== snapshot || $[25] !== value ? (t3 = getPreviewValueWithFallback({
    snapshot,
    original,
    fallback: value
  }), $[23] = original, $[24] = snapshot, $[25] = value, $[26] = t3) : t3 = $[26];
  let t4;
  $[27] !== badgeProps ? (t4 = badgeProps ? (0, import_jsx_runtime.jsx)(Text, { size: 0, children: badgeProps.kind === "release" ? (0, import_jsx_runtime.jsx)(ReleaseTitle, { title: badgeProps.releaseTitle, fallback: badgeProps.releaseFallback, children: (t52) => {
    const {
      displayTitle
    } = t52;
    return (0, import_jsx_runtime.jsx)(VersionInlineBadge, { $tone: badgeProps.tone, children: displayTitle });
  } }) : (0, import_jsx_runtime.jsx)(VersionInlineBadge, { $tone: badgeProps.tone, children: badgeProps.text }) }) : void 0, $[27] = badgeProps, $[28] = t4) : t4 = $[28];
  let t5;
  $[29] !== isLoading || $[30] !== schemaType.icon || $[31] !== t3 || $[32] !== t4 ? (t5 = (0, import_jsx_runtime.jsx)(SanityDefaultPreview, { ...t3, isPlaceholder: isLoading, icon: schemaType.icon, layout: "default", status: t4 }), $[29] = isLoading, $[30] = schemaType.icon, $[31] = t3, $[32] = t4, $[33] = t5) : t5 = $[33];
  let t6;
  return $[34] !== onLinkToDocument || $[35] !== t5 ? (t6 = (0, import_jsx_runtime.jsx)(PreviewCard, { __unstable_focusRing: true, onClick: onLinkToDocument, as: "button", radius: 2, children: t5 }), $[34] = onLinkToDocument, $[35] = t5, $[36] = t6) : t6 = $[36], t6;
}
var INITIAL_SEARCH_STATE = {
  hits: [],
  isLoading: false
};
var NO_FILTER = () => true;
var incomingReferenceSearch = (client, schemaType, searchStrategy) => {
  const search = createSearch([schemaType], client, {
    maxDepth: DEFAULT_MAX_FIELD_DEPTH,
    strategy: searchStrategy,
    tag: "search.incoming-reference"
  });
  return (textTerm) => search(textTerm, {
    perspective: "raw"
  }).pipe(map(({
    hits
  }) => hits.map(({
    hit
  }) => hit)), map((docs) => {
    const byId = /* @__PURE__ */ new Map();
    return docs.forEach((doc) => {
      if (isVersionId(doc._id)) {
        byId.set(doc._id, doc);
        return;
      }
      const publishedId = getPublishedId(doc._id), entry = byId.get(publishedId);
      entry ? isDraftId(doc._id) && isPublishedId(entry._id) && byId.set(publishedId, doc) : byId.set(publishedId, doc);
    }), Array.from(byId.values());
  }), map((collated) => collated.map((entry) => ({
    _id: entry._id,
    _type: entry._type
  }))), map((docs) => docs.slice(0, 100)));
};
function AddIncomingReference(t0) {
  const $ = (0, import_compiler_runtime.c)(52), {
    type,
    referenced,
    onCreateNewReference,
    onLinkDocument,
    fieldName,
    creationAllowed
  } = t0, {
    t
  } = useTranslation(structureLocaleNamespace), {
    push
  } = useToast(), schema = useSchema();
  let t1;
  $[0] !== schema || $[1] !== type ? (t1 = schema.get(type), $[0] = schema, $[1] = type, $[2] = t1) : t1 = $[2];
  const schemaType = t1, client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), source = useSource(), {
    strategy: searchStrategy
  } = source.search, documentPreviewStore = useDocumentPreviewStore();
  let t2;
  $[3] !== client || $[4] !== schemaType || $[5] !== searchStrategy ? (t2 = incomingReferenceSearch(client, schemaType, searchStrategy), $[3] = client, $[4] = schemaType, $[5] = searchStrategy, $[6] = t2) : t2 = $[6];
  const handleSearch = t2, [searchState, setSearchState] = (0, import_react.useState)(INITIAL_SEARCH_STATE);
  let t3;
  $[7] !== handleSearch || $[8] !== push || $[9] !== type ? (t3 = (inputValue$) => inputValue$.pipe(filter(isNonNullable$2), switchMap((searchString) => concat(of({
    isLoading: true,
    hits: []
  }), handleSearch(searchString).pipe(map((hits) => ({
    hits,
    searchString,
    isLoading: false
  })), catchError((error) => (push({
    title: "Reference search failed",
    description: error.message,
    status: "error",
    id: `reference-search-fail-${type}`
  }), console.error(error), of({
    hits: [],
    isLoading: false
  })))))), scan(_temp$1, INITIAL_SEARCH_STATE), tap(setSearchState)), $[7] = handleSearch, $[8] = push, $[9] = type, $[10] = t3) : t3 = $[10];
  const handleQueryChange = useObservableEvent(t3);
  let t4;
  $[11] !== searchState.hits ? (t4 = searchState.hits.map(_temp2), $[11] = searchState.hits, $[12] = t4) : t4 = $[12];
  const options = t4;
  let t5;
  $[13] !== handleQueryChange ? (t5 = () => {
    handleQueryChange("");
  }, $[13] = handleQueryChange, $[14] = t5) : t5 = $[14];
  const handleAutocompleteOpenButtonClick = t5;
  let t6;
  $[15] !== documentPreviewStore || $[16] !== onLinkDocument || $[17] !== schemaType ? (t6 = (option) => (0, import_jsx_runtime.jsx)(LinkToExistingPreview, { onLinkToDocument: () => onLinkDocument(option.value), documentPreviewStore, schemaType, value: option.hit }), $[15] = documentPreviewStore, $[16] = onLinkDocument, $[17] = schemaType, $[18] = t6) : t6 = $[18];
  const renderOption = t6;
  let t7;
  $[19] !== t || $[20] !== type ? (t7 = t("incoming-references-input.reference-from", {
    type
  }), $[19] = t, $[20] = type, $[21] = t7) : t7 = $[21];
  let t8;
  $[22] !== t7 ? (t8 = (0, import_jsx_runtime.jsx)(Box, { paddingY: 2, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", children: t7 }) }), $[22] = t7, $[23] = t8) : t8 = $[23];
  const t9 = creationAllowed ? 2 : 0;
  let t10;
  $[24] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t10 = {
    gridTemplateColumns: "1fr min-content"
  }, $[24] = t10) : t10 = $[24];
  const t11 = `${type}-autocomplete`;
  let t12;
  $[25] !== t ? (t12 = t("incoming-references-input.type-to-search"), $[25] = t, $[26] = t12) : t12 = $[26];
  let t13;
  $[27] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t13 = [], $[27] = t13) : t13 = $[27];
  let t14;
  $[28] !== handleAutocompleteOpenButtonClick ? (t14 = {
    onClick: handleAutocompleteOpenButtonClick
  }, $[28] = handleAutocompleteOpenButtonClick, $[29] = t14) : t14 = $[29];
  let t15;
  $[30] !== handleQueryChange || $[31] !== options || $[32] !== renderOption || $[33] !== searchState.isLoading || $[34] !== t11 || $[35] !== t12 || $[36] !== t14 ? (t15 = (0, import_jsx_runtime.jsx)(ReferenceAutocomplete$3, { id: t11, radius: 2, autoFocus: true, options, placeholder: t12, onQueryChange: handleQueryChange, filterOption: NO_FILTER, path: t13, renderOption, openButton: t14, referenceElement: null, loading: searchState.isLoading }), $[30] = handleQueryChange, $[31] = options, $[32] = renderOption, $[33] = searchState.isLoading, $[34] = t11, $[35] = t12, $[36] = t14, $[37] = t15) : t15 = $[37];
  let t16;
  $[38] !== creationAllowed || $[39] !== fieldName || $[40] !== onCreateNewReference || $[41] !== referenced.id || $[42] !== referenced.type || $[43] !== type ? (t16 = (0, import_jsx_runtime.jsx)(CreateNewIncomingReference, { type, referenceToId: referenced.id, referenceToType: referenced.type, creationAllowed, onCreateNewReference, fieldName }), $[38] = creationAllowed, $[39] = fieldName, $[40] = onCreateNewReference, $[41] = referenced.id, $[42] = referenced.type, $[43] = type, $[44] = t16) : t16 = $[44];
  let t17;
  $[45] !== t15 || $[46] !== t16 || $[47] !== t9 ? (t17 = (0, import_jsx_runtime.jsxs)(Grid, { gap: t9, style: t10, children: [
    t15,
    t16
  ] }), $[45] = t15, $[46] = t16, $[47] = t9, $[48] = t17) : t17 = $[48];
  let t18;
  return $[49] !== t17 || $[50] !== t8 ? (t18 = (0, import_jsx_runtime.jsxs)(Stack, { space: 2, padding: 2, children: [
    t8,
    t17
  ] }), $[49] = t17, $[50] = t8, $[51] = t18) : t18 = $[51], t18;
}
function _temp2(hit) {
  return {
    value: hit._id,
    hit
  };
}
function _temp$1(prevState, nextState) {
  return {
    ...prevState,
    ...nextState
  };
}
function IncomingReferencesType(t0) {
  const $ = (0, import_compiler_runtime.c)(69), {
    type,
    referenced,
    onLinkDocument,
    actions,
    shouldRenderTitle,
    fieldName,
    creationAllowed,
    filter: filter2,
    filterParams
  } = t0, documentPreviewStore = useDocumentPreviewStore(), {
    displayed
  } = useDocumentPane(), {
    getClient
  } = useSource(), displayedId = displayed?._id;
  let t1;
  $[0] !== displayedId || $[1] !== documentPreviewStore || $[2] !== filter2 || $[3] !== filterParams || $[4] !== getClient || $[5] !== type.type ? (t1 = getIncomingReferences({
    documentId: displayedId,
    documentPreviewStore,
    type: type.type,
    filter: filter2,
    filterParams,
    getClient
  }), $[0] = displayedId, $[1] = documentPreviewStore, $[2] = filter2, $[3] = filterParams, $[4] = getClient, $[5] = type.type, $[6] = t1) : t1 = $[6];
  const references$ = t1, {
    documents,
    loading
  } = useObservable(references$, INITIAL_STATE$1), schema = useSchema(), {
    t
  } = useTranslation(structureLocaleNamespace);
  let t2;
  $[7] !== schema || $[8] !== type.type ? (t2 = schema.get(type.type), $[7] = schema, $[8] = type.type, $[9] = t2) : t2 = $[9];
  const schemaType = t2, client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), [isAdding, setIsAdding] = (0, import_react.useState)(false), [newReferenceId, setNewReferenceId] = (0, import_react.useState)(null), {
    editState
  } = useDocumentPane(), toast = useToast();
  let t3;
  $[10] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t3 = () => {
    setIsAdding(_temp);
  }, $[10] = t3) : t3 = $[10];
  const handleAdd = t3, publishedExists = !!editState?.published;
  let t4;
  $[11] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t4 = async (documentId) => {
    setIsAdding(false), setNewReferenceId(documentId);
  }, $[11] = t4) : t4 = $[11];
  const handleCreateNewReference = t4;
  let t5;
  $[12] !== client || $[13] !== onLinkDocument || $[14] !== publishedExists || $[15] !== referenced.id || $[16] !== referenced.type || $[17] !== schemaType?.liveEdit || $[18] !== toast ? (t5 = async (documentId_0) => {
    setIsAdding(false), setNewReferenceId(documentId_0);
    const liveEdit = !!schemaType?.liveEdit, document = await client.fetch("*[_id == $id][0]", {
      id: documentId_0
    }), linkedDocument = onLinkDocument?.(document, {
      _type: "reference",
      _ref: getPublishedId(referenced.id),
      ...publishedExists ? {} : {
        _weak: true,
        _strengthenOnPublish: {
          type: referenced.type
        }
      }
    });
    if (!linkedDocument) {
      setNewReferenceId(null), toast.push({
        title: "Not possible to link to document",
        description: "The document you are trying to link cannot be linked to",
        status: "error"
      });
      return;
    }
    isPublishedId(documentId_0) && !liveEdit && (linkedDocument._id = getDraftId(documentId_0)), await client.createOrReplace(linkedDocument);
  }, $[12] = client, $[13] = onLinkDocument, $[14] = publishedExists, $[15] = referenced.id, $[16] = referenced.type, $[17] = schemaType?.liveEdit, $[18] = toast, $[19] = t5) : t5 = $[19];
  const handleLinkDocument = t5;
  let t6, t7;
  $[20] !== documents || $[21] !== newReferenceId ? (t6 = () => {
    documents.length > 0 && newReferenceId && documents.find((document_0) => getPublishedId(document_0._id) === getPublishedId(newReferenceId)) && setNewReferenceId(null);
  }, t7 = [documents, newReferenceId], $[20] = documents, $[21] = newReferenceId, $[22] = t6, $[23] = t7) : (t6 = $[22], t7 = $[23]), (0, import_react.useEffect)(t6, t7);
  let t8;
  $[24] !== actions || $[25] !== referenced.id ? (t8 = (document_1) => (0, import_jsx_runtime.jsx)(IncomingReferenceDocument$1, { document: document_1, referenceToId: referenced.id, actions }), $[24] = actions, $[25] = referenced.id, $[26] = t8) : t8 = $[26];
  const renderItem = t8;
  if (!schemaType)
    return null;
  if (loading) {
    let t92;
    $[27] !== t ? (t92 = t("incoming-references-input.types-loading"), $[27] = t, $[28] = t92) : t92 = $[28];
    let t102;
    return $[29] !== t92 ? (t102 = (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true, title: t92 }), $[29] = t92, $[30] = t102) : t102 = $[30], t102;
  }
  let t9;
  $[31] !== schemaType?.title || $[32] !== shouldRenderTitle || $[33] !== type.title ? (t9 = shouldRenderTitle && (0, import_jsx_runtime.jsx)(Box, { paddingY: 2, paddingX: 0, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", children: type.title || schemaType?.title }) }), $[31] = schemaType?.title, $[32] = shouldRenderTitle, $[33] = type.title, $[34] = t9) : t9 = $[34];
  let t10;
  $[35] !== documents || $[36] !== isAdding || $[37] !== newReferenceId || $[38] !== renderItem || $[39] !== schemaType?.title || $[40] !== t || $[41] !== type.title ? (t10 = documents.length > 0 ? (0, import_jsx_runtime.jsx)(IncomingReferencesListContainer, { $itemCount: documents.length, children: (0, import_jsx_runtime.jsx)(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: t("incoming-references-input.list-label", {
    type: type.title || schemaType?.title
  }), canReceiveFocus: true, fixedHeight: true, getItemKey: (index) => documents[index]._id, itemHeight: INCOMING_REFERENCES_ITEM_HEIGHT, items: documents, onlyShowSelectionWhenActive: true, overscan: 5, renderItem, wrapAround: false }) }) : (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsx)(Flex, { align: "center", justify: "center", padding: 2, hidden: isAdding || !!newReferenceId, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, muted: true, children: t("incoming-references-input.no-items") }) }) }), $[35] = documents, $[36] = isAdding, $[37] = newReferenceId, $[38] = renderItem, $[39] = schemaType?.title, $[40] = t, $[41] = type.title, $[42] = t10) : t10 = $[42];
  let t11;
  $[43] !== newReferenceId || $[44] !== schemaType ? (t11 = newReferenceId && (0, import_jsx_runtime.jsx)(SanityDefaultPreview, { icon: schemaType.icon, layout: "default", isPlaceholder: true }), $[43] = newReferenceId, $[44] = schemaType, $[45] = t11) : t11 = $[45];
  let t12;
  $[46] !== creationAllowed || $[47] !== fieldName || $[48] !== handleLinkDocument || $[49] !== isAdding || $[50] !== referenced || $[51] !== type.type ? (t12 = isAdding && (0, import_jsx_runtime.jsx)(AddIncomingReference, { type: type.type, referenced, onCreateNewReference: handleCreateNewReference, onLinkDocument: handleLinkDocument, creationAllowed, fieldName }), $[46] = creationAllowed, $[47] = fieldName, $[48] = handleLinkDocument, $[49] = isAdding, $[50] = referenced, $[51] = type.type, $[52] = t12) : t12 = $[52];
  let t13;
  $[53] !== t10 || $[54] !== t11 || $[55] !== t12 ? (t13 = (0, import_jsx_runtime.jsxs)(Card, { radius: 2, padding: 1, border: true, tone: "default", children: [
    t10,
    t11,
    t12
  ] }), $[53] = t10, $[54] = t11, $[55] = t12, $[56] = t13) : t13 = $[56];
  let t14;
  $[57] !== creationAllowed || $[58] !== fieldName || $[59] !== onLinkDocument || $[60] !== referenced.id || $[61] !== referenced.type || $[62] !== t || $[63] !== type.type ? (t14 = onLinkDocument ? (0, import_jsx_runtime.jsx)(Button, { size: "large", disabled: false, icon: AddIcon, mode: "ghost", onClick: handleAdd, text: t("incoming-references-input.add-reference-item") }) : (0, import_jsx_runtime.jsx)(CreateNewIncomingReference, { type: type.type, referenceToId: referenced.id, referenceToType: referenced.type, creationAllowed, onCreateNewReference: handleCreateNewReference, fieldName }), $[57] = creationAllowed, $[58] = fieldName, $[59] = onLinkDocument, $[60] = referenced.id, $[61] = referenced.type, $[62] = t, $[63] = type.type, $[64] = t14) : t14 = $[64];
  let t15;
  return $[65] !== t13 || $[66] !== t14 || $[67] !== t9 ? (t15 = (0, import_jsx_runtime.jsxs)(Stack, { space: 2, marginBottom: 2, children: [
    t9,
    t13,
    t14
  ] }), $[65] = t13, $[66] = t14, $[67] = t9, $[68] = t15) : t15 = $[68], t15;
}
function _temp(p) {
  return !p;
}
function isCrossDatasetIncomingReference(type) {
  return !!type.dataset;
}
function IncomingReferencesList(t0) {
  const $ = (0, import_compiler_runtime.c)(26), {
    types,
    onLinkDocument,
    actions,
    filter: filter2,
    filterParams,
    name,
    creationAllowed
  } = t0, {
    documentId,
    documentType
  } = useDocumentPane(), {
    t
  } = useTranslation(structureLocaleNamespace);
  if (!types || types?.length === 0) {
    let t12;
    $[0] !== t ? (t12 = t("incoming-references-input.types-not-defined"), $[0] = t, $[1] = t12) : t12 = $[1];
    let t22;
    return $[2] !== t12 ? (t22 = (0, import_jsx_runtime.jsx)(Card, { border: true, radius: 2, padding: 3, tone: "critical", children: (0, import_jsx_runtime.jsx)(Flex, { align: "center", justify: "center", children: (0, import_jsx_runtime.jsx)(Text, { size: 1, muted: true, children: t12 }) }) }), $[2] = t12, $[3] = t22) : t22 = $[3], t22;
  }
  let t1;
  if ($[4] !== actions || $[5] !== creationAllowed || $[6] !== documentId || $[7] !== documentType || $[8] !== filter2 || $[9] !== filterParams || $[10] !== name || $[11] !== onLinkDocument || $[12] !== types) {
    let t22;
    $[14] !== actions || $[15] !== creationAllowed || $[16] !== documentId || $[17] !== documentType || $[18] !== filter2 || $[19] !== filterParams || $[20] !== name || $[21] !== onLinkDocument || $[22] !== types.length ? (t22 = (type) => isCrossDatasetIncomingReference(type) ? (0, import_jsx_runtime.jsx)(CrossDatasetIncomingReferenceType, { type, referenced: {
      id: documentId,
      type: documentType
    }, shouldRenderTitle: types.length > 1 }, `${type.type}-${type.dataset || ""}`) : (0, import_jsx_runtime.jsx)(IncomingReferencesType, { type, referenced: {
      id: documentId,
      type: documentType
    }, onLinkDocument, actions, shouldRenderTitle: types.length > 1, fieldName: name, creationAllowed, filter: filter2, filterParams }, type.type), $[14] = actions, $[15] = creationAllowed, $[16] = documentId, $[17] = documentType, $[18] = filter2, $[19] = filterParams, $[20] = name, $[21] = onLinkDocument, $[22] = types.length, $[23] = t22) : t22 = $[23], t1 = types.map(t22), $[4] = actions, $[5] = creationAllowed, $[6] = documentId, $[7] = documentType, $[8] = filter2, $[9] = filterParams, $[10] = name, $[11] = onLinkDocument, $[12] = types, $[13] = t1;
  } else
    t1 = $[13];
  let t2;
  return $[24] !== t1 ? (t2 = (0, import_jsx_runtime.jsx)(Stack, { space: 3, children: t1 }), $[24] = t1, $[25] = t2) : t2 = $[25], t2;
}
function IncomingReferencesDecoration(props) {
  const $ = (0, import_compiler_runtime.c)(21), {
    onLinkDocument,
    actions,
    filter: filter2,
    filterParams,
    name,
    creationAllowed: t0,
    types,
    title,
    description
  } = props, creationAllowed = t0 === void 0 ? true : t0;
  let t1;
  $[0] !== name || $[1] !== title ? (t1 = title || startCase_default(name), $[0] = name, $[1] = title, $[2] = t1) : t1 = $[2];
  let t2;
  $[3] !== t1 ? (t2 = (0, import_jsx_runtime.jsx)(Flex, { align: "center", paddingY: 1, children: (0, import_jsx_runtime.jsx)(Text, { as: "label", weight: "medium", size: 1, children: t1 }) }), $[3] = t1, $[4] = t2) : t2 = $[4];
  let t3;
  $[5] !== description ? (t3 = description && (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: description }), $[5] = description, $[6] = t3) : t3 = $[6];
  let t4;
  $[7] !== t2 || $[8] !== t3 ? (t4 = (0, import_jsx_runtime.jsx)(Box, { paddingY: 2, children: (0, import_jsx_runtime.jsxs)(Stack, { space: 3, children: [
    t2,
    t3
  ] }) }), $[7] = t2, $[8] = t3, $[9] = t4) : t4 = $[9];
  let t5;
  $[10] !== actions || $[11] !== creationAllowed || $[12] !== filter2 || $[13] !== filterParams || $[14] !== name || $[15] !== onLinkDocument || $[16] !== types ? (t5 = (0, import_jsx_runtime.jsx)(IncomingReferencesList, { name, types, onLinkDocument, actions, filter: filter2, filterParams, creationAllowed }), $[10] = actions, $[11] = creationAllowed, $[12] = filter2, $[13] = filterParams, $[14] = name, $[15] = onLinkDocument, $[16] = types, $[17] = t5) : t5 = $[17];
  let t6;
  return $[18] !== t4 || $[19] !== t5 ? (t6 = (0, import_jsx_runtime.jsxs)(Stack, { space: 2, children: [
    t4,
    t5
  ] }), $[18] = t4, $[19] = t5, $[20] = t6) : t6 = $[20], t6;
}
function defineIncomingReferenceDecoration(options) {
  return {
    kind: "decoration",
    key: options.name,
    component: (0, import_jsx_runtime.jsx)(IncomingReferencesDecoration, { ...options })
  };
}
function isIncomingReferenceCreation(initialValue) {
  return typeof initialValue == "object" && initialValue !== null && "__internal_isIncomingReferenceCreation" in initialValue;
}
export {
  ComponentBuilder,
  ComponentViewBuilder,
  ConfirmDeleteDialogContainer as ConfirmDeleteDialog,
  DEFAULT_INTENT_HANDLER,
  DocumentBuilder,
  DocumentInspectorHeader,
  DocumentListBuilder,
  DocumentListItemBuilder,
  PaneContainer as DocumentListPane,
  DocumentPane,
  DocumentPaneProviderWrapper as DocumentPaneProvider,
  DocumentTypeListBuilder,
  FormViewBuilder,
  GenericListBuilder,
  GenericViewBuilder,
  HELP_URL,
  InitialValueTemplateItemBuilder,
  ListBuilder,
  ListItemBuilder,
  MenuItemBuilder,
  MenuItemGroupBuilder,
  Pane,
  PaneContent,
  PaneLayout,
  PaneRouterContext,
  SerializeError,
  StructureToolProvider,
  component,
  createStructureBuilder,
  defaultInitialValueTemplateItems,
  defaultIntentChecker,
  defineIncomingReferenceDecoration,
  documentFromEditor,
  documentFromEditorWithInitialValue,
  form,
  getOrderingMenuItem,
  getOrderingMenuItemsForSchemaType,
  getTypeNamesFromFilter,
  isDocumentListItem,
  isIncomingReferenceCreation,
  maybeSerializeInitialValueTemplateItem,
  maybeSerializeMenuItem,
  maybeSerializeMenuItemGroup,
  maybeSerializeView,
  menuItemsFromInitialValueTemplateItems,
  shallowIntentChecker,
  structureLocaleNamespace,
  structureTool,
  useDocumentPane,
  useDocumentTitle,
  usePaneOptions,
  usePaneRouter,
  useStructureTool
};
//# sourceMappingURL=sanity_structure.js.map
