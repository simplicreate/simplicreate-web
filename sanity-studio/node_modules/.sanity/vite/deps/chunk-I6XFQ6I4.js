import {
  JsonInspector
} from "./chunk-EMYABH4X.js";
import {
  AvatarSkeleton$1,
  BehaviorSubject,
  Button as Button2,
  COMMENTS_INSPECTOR_NAME,
  CapabilityGate,
  ChangeConnectorRoot,
  ChangeFieldWrapper,
  ChangeIndicatorsTracker,
  ChangeList,
  ChangesError,
  ChannelError,
  Chip,
  ClientError,
  CommandList,
  CommentsEnabledContext,
  CommentsEnabledProvider,
  CommentsProvider,
  ConfirmPopover,
  ContextMenuButton,
  CopyPasteProvider,
  CrossDatasetReferencePreview,
  DEFAULT_STUDIO_CLIENT_OPTIONS,
  Dialog as Dialog2,
  DocumentActionsStateContext,
  DocumentChangeContext,
  DocumentPaneContext,
  DocumentPreviewPresence,
  DocumentSheetListContext,
  DocumentStatus,
  DocumentStatusIndicator,
  EMPTY,
  EMPTY_ARRAY$z,
  EMPTY_OBJECT,
  ErrorActions,
  ErrorBoundary,
  Event$1,
  EventsContext,
  EventsProvider,
  FieldActionsProvider,
  FieldActionsResolver,
  Filters,
  FormBuilder,
  GetFormValueProvider,
  GetHookCollectionState,
  Hotkeys,
  InsufficientPermissionsMessage,
  IntentLink,
  IsLastPaneProvider,
  LATEST,
  LegacyLayerProvider,
  LoadingBlock,
  MenuButton,
  MenuGroup,
  MenuItem as MenuItem2,
  NEVER,
  NoChanges,
  PaneContext,
  PaneLayoutContext,
  PaneRouterContext,
  PerspectiveProvider,
  Popover as Popover2,
  PresenceOverlay,
  PreviewCard,
  QuickLRU,
  RELEASES_INTENT,
  ReferenceInputOptionsContext,
  ReferenceInputOptionsProvider,
  ReleaseAvatar,
  ReleaseAvatarIcon,
  ReleaseTitle,
  ReleasesNav,
  Resizable,
  ResolvedPanesContext,
  ReviewChangesContext,
  SanityDefaultPreview,
  ScrollContainer,
  SearchHeader,
  SearchProvider,
  ServerError,
  SingleDocReleaseProvider,
  SourceProvider,
  StateLink,
  StatusButton,
  StructureToolContext,
  Subject,
  TIMELINE_ITEM_I18N_KEY_MAPPING,
  Tab,
  TextWithTone,
  Tooltip,
  TooltipDelayGroupProvider,
  TooltipOfDisabled,
  Translate,
  UserAvatar,
  VersionChip$1,
  VersionInlineBadge,
  VirtualizerScrollInstanceProvider,
  addWeeks,
  asyncScheduler,
  camelCase_default,
  catchError,
  catchWithCount,
  collate,
  concat,
  createHookFromObservableFactory,
  createPatchChannel,
  createSWR,
  createSearch,
  debounce,
  debounceTime,
  decodeJsonParams,
  defer,
  defineEvent,
  defineLocaleResourceBundle,
  definePlugin,
  delay,
  diffInput,
  distinctUntilChanged,
  encodeJsonParams,
  exhaustMapWithTrailing,
  filter,
  find_default,
  firstValueFrom,
  format,
  formatRelativeLocalePublishDate,
  from,
  fromEvent,
  fromMutationPatches,
  fromPairs_default,
  fromString,
  generateHelpUrl,
  get,
  getConfigContextFromSource,
  getDocumentIdForCanvasLink,
  getDocumentVariantType,
  getDraftId,
  getPreviewPaths,
  getPreviewStateObservable$1,
  getPreviewValueWithFallback,
  getPublishedId,
  getReferencePaths,
  getReleaseIdFromReleaseDocumentId,
  getReleaseTone,
  getSanityCreateLinkMetadata,
  getSearchableTypes,
  getVersionFromId,
  getVersionId,
  getVersionInlineBadge,
  isAfter,
  isArray,
  isBefore,
  isCardinalityOneRelease,
  isCreateDocumentVersionEvent,
  isDeleteDocumentGroupEvent,
  isDeleteDocumentVersionEvent,
  isDeprecatedSchemaType,
  isDev,
  isDocumentLimitError,
  isDocumentSchemaType,
  isDraftId,
  isDraftPerspective,
  isEditDocumentVersionEvent,
  isEqual_default,
  isGoingToUnpublish,
  isHotkey,
  isIndexSegment,
  isKeySegment,
  isNewDocument,
  isNonNullable$2,
  isObjectSchemaType,
  isPausedCardinalityOneRelease,
  isPerspectiveWriteable,
  isPublishDocumentVersionEvent,
  isPublishedId,
  isPublishedPerspective,
  isRecord$4,
  isReferenceSchemaType,
  isReleaseDocument,
  isReleaseScheduledOrScheduling,
  isSanityCreateLinked,
  isSanityDefinedAction,
  isSanityDocument,
  isScheduleDocumentVersionEvent,
  isString,
  isSystemBundle,
  isSystemBundleName,
  isUnpublishDocumentEvent,
  isUnscheduleDocumentVersionEvent,
  isValidationError,
  isValidationErrorMarker,
  isValidationWarning,
  isVersionId,
  kebabCase_default,
  map,
  mapTo,
  merge,
  mergeMap,
  mergeMapArray,
  nanoid,
  negate_default,
  noop_default,
  observableCallback,
  of,
  omit_default,
  parse,
  partition,
  pathToString$1,
  prepareForPreview,
  require_react_fast_compare,
  require_shallow_equals,
  require_speakingurl,
  resizeObserver,
  resolveKeyedPath,
  route,
  scan,
  selectUpstreamVersion,
  share,
  shareReplay,
  startCase_default,
  startWith,
  switchMap,
  take,
  takeUntil,
  tap,
  throttleTime,
  throwError,
  timer,
  toPairs_default,
  toString,
  uniqBy_default,
  uniq_default,
  uniqueId_default,
  useActiveReleases,
  useActiveWorkspace,
  useArchivedReleases,
  useCanvasCompanionDoc,
  useClient,
  useCommentsEnabled,
  useConditionalToast,
  useConfigContextFromSource,
  useCopyPaste,
  useCurrentUser,
  useDateTimeFormat,
  useDocumentForm,
  useDocumentIdStack,
  useDocumentLimitsUpsellContext,
  useDocumentOperation,
  useDocumentOperationEvent,
  useDocumentPairPermissions,
  useDocumentPresence,
  useDocumentPreviewStore,
  useDocumentPreviewValues,
  useDocumentStore,
  useDocumentType,
  useDocumentVersionInfo,
  useDocumentVersionTypeSortedList,
  useDocumentVersions,
  useEditState,
  useEvents,
  useEventsStore,
  useFieldActions,
  useFilteredReleases,
  useGetDefaultPerspective,
  useGetI18nText,
  useGlobalCopyPasteElementHandler,
  useHistoryStore,
  useI18nText,
  useInitialValue,
  useIntentLink,
  useKeyValueStore,
  useListFormat,
  useManageFavorite,
  useMiddlewareComponents,
  useNavigateToCanvasDoc,
  useObservable,
  useObservableEvent,
  useOnlyHasVersions,
  usePausedScheduledDraft,
  usePerspective,
  useProjectId,
  useReconnectingToast,
  useRelativeTime,
  useRouter,
  useRouterState,
  useSanityCreateConfig,
  useScheduledDraftDocument,
  useSchema,
  useSearchMaxFieldDepth,
  useSearchState,
  useSetPerspective,
  useSingleDocRelease,
  useSource,
  useStudioUrl,
  useSyncState,
  useTelemetry,
  useTemplatePermissions,
  useTemplates,
  useTimelineSelector,
  useTimelineStore,
  useTranslation,
  useUnique,
  useUser,
  useValidationStatus,
  useValuePreview,
  useVersionOperations,
  useWorkspace,
  useZIndex,
  v4_default,
  withLatestFrom,
  wrap
} from "./chunk-AWVS7GJ4.js";
import {
  AddIcon,
  AnimatePresence,
  ArrowLeftIcon,
  ArrowRightIcon,
  AvatarStack,
  Badge,
  BoundaryElementProvider,
  Box,
  Button,
  Card,
  Checkbox,
  CheckmarkCircleIcon,
  CheckmarkIcon,
  ChevronDownIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
  ChevronUpIcon,
  CloseIcon,
  Code,
  CollapseIcon,
  ComposeSparklesIcon,
  Container,
  CopyIcon,
  Dialog,
  DialogProvider,
  DocumentIcon,
  DocumentRemoveIcon,
  DocumentsIcon,
  DoubleChevronLeftIcon,
  DoubleChevronRightIcon,
  EarthAmericasIcon,
  EditIcon,
  EllipsisHorizontalIcon,
  ErrorOutlineIcon,
  ExpandIcon,
  Flex,
  FolderIcon,
  Heading,
  InfoOutlineIcon,
  Inline,
  JsonIcon,
  LaunchIcon,
  Layer,
  LayerProvider,
  LinkIcon,
  LockIcon,
  MasterDetailIcon,
  Menu,
  MenuDivider,
  MenuItem,
  PauseIcon,
  Popover,
  PortalProvider,
  PublishIcon,
  ReadOnlyIcon,
  ResetIcon,
  RestoreIcon,
  RevertIcon,
  SearchIcon,
  Select,
  Skeleton,
  SortIcon,
  Spinner,
  SpinnerIcon,
  SplitVerticalIcon,
  Stack,
  StackCompactIcon,
  StackIcon,
  StarFilledIcon,
  StarIcon,
  SyncIcon,
  TabList,
  TabPanel,
  Text,
  TextInput,
  TextSkeleton,
  TransferIcon,
  TrashIcon,
  UnknownIcon,
  UnpublishIcon,
  WarningOutlineIcon,
  _raf2,
  at,
  focusFirstDescendant,
  getTheme_v2,
  lt,
  motion,
  rem,
  require_react_is,
  rgba,
  rt,
  useClickOutsideEvent,
  useElementRect,
  useGlobalKeyDown,
  useLayer,
  usePortal,
  useToast
} from "./chunk-D7NYSWPL.js";
import {
  require_compiler_runtime
} from "./chunk-LVTF57EB.js";
import {
  require_jsx_runtime
} from "./chunk-CTEYD6P7.js";
import {
  require_react
} from "./chunk-TZMYWIEJ.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/sanity/lib/_chunks-es/StructureToolProvider.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_compiler_runtime = __toESM(require_compiler_runtime(), 1);
var import_react = __toESM(require_react(), 1);
var import_react_is = __toESM(require_react_is(), 1);
var import_speakingurl = __toESM(require_speakingurl(), 1);
var structureLocaleNamespace = "structure";
var structureUsEnglishLocaleBundle = defineLocaleResourceBundle({
  locale: "en-US",
  namespace: structureLocaleNamespace,
  resources: () => import("./resources7-MIQ5PQBQ.js")
});
var IMPLICIT_SCHEMA_TYPE_FIELDS = ["_id", "_type", "_createdAt", "_updatedAt", "_rev"];
function joinReferences(schemaType, path, strict = false) {
  const [head, ...tail] = path;
  if (!("fields" in schemaType))
    return "";
  const schemaField = schemaType.fields.find((field) => field.name === head);
  if (!schemaField) {
    if (!IMPLICIT_SCHEMA_TYPE_FIELDS.includes(head)) {
      const errorMessage = `The current ordering config targeted the nonexistent field "${head}" on schema type "${schemaType.name}". It should be one of ${schemaType.fields.map((field) => field.name).join(", ")}`;
      if (strict)
        throw new Error(errorMessage);
      console.warn(errorMessage);
    }
    return "";
  }
  if ("to" in schemaField.type && schemaField.type.name === "reference") {
    const refTypes = schemaField.type.to;
    return `${head}->{${refTypes.map((refType) => joinReferences(refType, tail)).join(",")}}`;
  }
  const tailFields = tail.length > 0 && joinReferences(schemaField.type, tail), tailWrapper = tailFields ? `{${tailFields}}` : "";
  return tail.length > 0 ? `${head}${tailWrapper}` : head;
}
function getExtendedProjection(schemaType, orderBy, strict = false) {
  return orderBy.map((ordering) => joinReferences(schemaType, ordering.field.split("."), strict)).join(", ");
}
var SerializeError = class extends Error {
  constructor(message, parentPath, pathSegment, hint) {
    super(message), this.name = "SerializeError";
    const segment = typeof pathSegment > "u" ? "<unknown>" : `${pathSegment}`;
    this.path = (parentPath || []).concat(hint ? `${segment} (${hint})` : segment);
  }
  withHelpUrl(id) {
    return this.helpId = id, this;
  }
};
var HELP_URL = {
  ID_REQUIRED: "structure-node-id-required",
  TITLE_REQUIRED: "structure-title-required",
  FILTER_REQUIRED: "structure-filter-required",
  INVALID_LIST_ITEM: "structure-invalid-list-item",
  COMPONENT_REQUIRED: "structure-view-component-required",
  DOCUMENT_ID_REQUIRED: "structure-document-id-required",
  DOCUMENT_TYPE_REQUIRED: "structure-document-type-required",
  SCHEMA_TYPE_REQUIRED: "structure-schema-type-required",
  SCHEMA_TYPE_NOT_FOUND: "structure-schema-type-not-found",
  LIST_ITEMS_MUST_BE_ARRAY: "structure-list-items-must-be-array",
  QUERY_PROVIDED_FOR_FILTER: "structure-query-provided-for-filter",
  ACTION_OR_INTENT_REQUIRED: "structure-action-or-intent-required",
  LIST_ITEM_IDS_MUST_BE_UNIQUE: "structure-list-item-ids-must-be-unique",
  ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE: "structure-action-and-intent-mutually-exclusive",
  API_VERSION_REQUIRED_FOR_CUSTOM_FILTER: "structure-api-version-required-for-custom-filter"
};
var ORDER_BY_UPDATED_AT = {
  title: "Last edited",
  i18n: {
    title: {
      key: "menu-items.sort-by.last-edited",
      ns: structureLocaleNamespace
    }
  },
  name: "lastEditedDesc",
  by: [{
    field: "_updatedAt",
    direction: "desc"
  }]
};
var ORDER_BY_CREATED_AT = {
  title: "Created",
  i18n: {
    title: {
      key: "menu-items.sort-by.created",
      ns: structureLocaleNamespace
    }
  },
  name: "lastCreatedDesc",
  by: [{
    field: "_createdAt",
    direction: "desc"
  }]
};
var DEFAULT_SELECTED_ORDERING_OPTION = ORDER_BY_UPDATED_AT;
var DEFAULT_ORDERING_OPTIONS = [
  ORDER_BY_UPDATED_AT,
  // _updatedAt
  ORDER_BY_CREATED_AT
  // _createdAt
];
function maybeSerializeMenuItem(item, index, path) {
  return item instanceof MenuItemBuilder ? item.serialize({
    path,
    index
  }) : item;
}
var MenuItemBuilder = class _MenuItemBuilder {
  /** menu item option object. See {@link PartialMenuItem} */
  constructor(_context, spec) {
    this._context = _context, this.spec = spec || {};
  }
  /**
   * Set menu item id for tracking selected state.
   * Menu items with the same id will share selected state (like radio buttons).
   * Use with action 'setMenuItemState' to enable automatic selected state tracking.
   * @param id - unique identifier for the menu item
   * @returns menu item builder based on id provided. See {@link MenuItemBuilder}
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /**
   * Get menu item id
   * @returns menu item id. See {@link PartialMenuItem}
   */
  getId() {
    return this.spec.id;
  }
  /**
   * Set menu item action
   * @param action - menu item action. See {@link MenuItemActionType}
   * @returns menu item builder based on action provided. See {@link MenuItemBuilder}
   */
  action(action) {
    return this.clone({
      action
    });
  }
  /**
   * Get menu item action
   * @returns menu item builder action. See {@link PartialMenuItem}
   */
  getAction() {
    return this.spec.action;
  }
  /**
   * Set menu item intent
   * @param intent - menu item intent. See {@link Intent}
   * @returns menu item builder based on intent provided. See {@link MenuItemBuilder}
   */
  intent(intent) {
    return this.clone({
      intent
    });
  }
  /**
   * Get menu item intent
   * @returns menu item intent. See {@link PartialMenuItem}
   */
  getIntent() {
    return this.spec.intent;
  }
  /**
   * Set menu item title
   * @param title - menu item title
   * @returns menu item builder based on title provided. See {@link MenuItemBuilder}
   */
  title(title) {
    return this.clone({
      title
    });
  }
  /**
   * Get menu item title. Note that the `i18n` configuration will take
   * precedence and this title is left here for compatibility.
   * @returns menu item title
   */
  getTitle() {
    return this.spec.title;
  }
  /**
   * Set the i18n key and namespace used to populate the localized title.
   * @param i18n - object with i18n key and related namespace
   * @returns menu item builder based on i18n config provided. See {@link MenuItemBuilder}
   */
  i18n(i18n) {
    return this.clone({
      i18n
    });
  }
  /**
   * Get the i18n key and namespace used to populate the localized title.
   * @returns the i18n key and namespace used to populate the localized title.
   */
  getI18n() {
    return this.spec.i18n;
  }
  /**
   * Set menu item group
   * @param group - menu item group
   * @returns menu item builder based on group provided. See {@link MenuItemBuilder}
   */
  group(group) {
    return this.clone({
      group
    });
  }
  /**
   * Get menu item group
   * @returns menu item group. See {@link PartialMenuItem}
   */
  getGroup() {
    return this.spec.group;
  }
  /**
   * Set menu item icon
   * @param icon - menu item icon
   * @returns menu item builder based on icon provided. See {@link MenuItemBuilder}
   */
  icon(icon) {
    return this.clone({
      icon
    });
  }
  /**
   * Get menu item icon
   * @returns menu item icon. See {@link PartialMenuItem}
   */
  getIcon() {
    return this.spec.icon;
  }
  /**
   * Set menu item parameters
   * @param params - menu item parameters. See {@link MenuItemParamsType}
   * @returns menu item builder based on parameters provided. See {@link MenuItemBuilder}
   */
  params(params) {
    return this.clone({
      params
    });
  }
  /**
   * Get meny item parameters
   * @returns menu item parameters. See {@link PartialMenuItem}
   */
  getParams() {
    return this.spec.params;
  }
  /**
   * Set menu item to show as action
   * @param showAsAction - determine if menu item should show as action
   * @returns menu item builder based on if it should show as action. See {@link MenuItemBuilder}
   */
  showAsAction(showAsAction = true) {
    return this.clone({
      showAsAction: !!showAsAction
    });
  }
  /**
   * Check if menu item should show as action
   * @returns true if menu item should show as action, false if not. See {@link PartialMenuItem}
   */
  getShowAsAction() {
    return this.spec.showAsAction;
  }
  /** Serialize menu item builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns menu item node based on path provided in options. See {@link MenuItem}
   */
  serialize(options = {
    path: []
  }) {
    const {
      title,
      action,
      intent
    } = this.spec;
    if (!title) {
      const hint = typeof action == "string" ? `action: "${action}"` : void 0;
      throw new SerializeError("`title` is required for menu item", options.path, options.index, hint).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    if (!action && !intent)
      throw new SerializeError(`\`action\` or \`intent\` required for menu item with title ${this.spec.title}`, options.path, options.index, `"${title}"`).withHelpUrl(HELP_URL.ACTION_OR_INTENT_REQUIRED);
    if (intent && action)
      throw new SerializeError("cannot set both `action` AND `intent`", options.path, options.index, `"${title}"`).withHelpUrl(HELP_URL.ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE);
    return {
      ...this.spec,
      title
    };
  }
  /** Clone menu item builder
   * @param withSpec - menu item options. See {@link PartialMenuItem}
   * @returns menu item builder based on context and spec provided. See {@link MenuItemBuilder}
   */
  clone(withSpec) {
    const builder = new _MenuItemBuilder(this._context);
    return builder.spec = {
      ...this.spec,
      ...withSpec
    }, builder;
  }
};
function getOrderingMenuItem(context, {
  by,
  title,
  i18n
}, extendedProjection) {
  let builder = new MenuItemBuilder(context).group("sorting").title(context.i18n.t("default-menu-item.fallback-title", {
    // note this lives in the `studio` bundle because that one is loaded by default
    ns: "studio",
    replace: {
      title
    }
    // replaces the `{{title}}` option
  })).icon(SortIcon).action("setSortOrder").params({
    by,
    extendedProjection
  });
  return i18n && (builder = builder.i18n(i18n)), builder;
}
function getOrderingMenuItemsForSchemaType(context, typeName) {
  const {
    schema
  } = context, type = typeof typeName == "string" ? schema.get(typeName) : typeName;
  return !type || !("orderings" in type) ? [] : (type.orderings ? type.orderings.concat(DEFAULT_ORDERING_OPTIONS) : DEFAULT_ORDERING_OPTIONS).map((ordering) => getOrderingMenuItem(context, ordering, getExtendedProjection(type, ordering.by)));
}
function maybeSerializeMenuItemGroup(item, index, path) {
  return item instanceof MenuItemGroupBuilder ? item.serialize({
    path,
    index
  }) : item;
}
var MenuItemGroupBuilder = class _MenuItemGroupBuilder {
  /** Menu item group ID */
  /** Menu item group title */
  constructor(_context, spec) {
    this._context = _context, this._id = spec ? spec.id : "", this._title = spec ? spec.title : "", this._i18n = spec ? spec.i18n : void 0;
  }
  /**
   * Set menu item group ID
   * @param id - menu item group ID
   * @returns menu item group builder based on ID provided. See {@link MenuItemGroupBuilder}
   */
  id(id) {
    return new _MenuItemGroupBuilder(this._context, {
      id,
      title: this._title,
      i18n: this._i18n
    });
  }
  /**
   * Get menu item group ID
   * @returns menu item group ID
   */
  getId() {
    return this._id;
  }
  /**
   * Set menu item group title
   * @param title - menu item group title
   * @returns menu item group builder based on title provided. See {@link MenuItemGroupBuilder}
   */
  title(title) {
    return new _MenuItemGroupBuilder(this._context, {
      title,
      id: this._id,
      i18n: this._i18n
    });
  }
  /**
   * Get menu item group title
   * @returns menu item group title
   */
  getTitle() {
    return this._title;
  }
  /**
   * Set the i18n key and namespace used to populate the localized title.
   * @param i18n - object with i18n key and related namespace
   * @returns menu item group builder based on i18n info provided. See {@link MenuItemGroupBuilder}
   */
  i18n(i18n) {
    return new _MenuItemGroupBuilder(this._context, {
      i18n,
      id: this._id,
      title: this._title
    });
  }
  /**
   * Get the i18n key and namespace used to populate the localized title.
   * @returns the i18n key and namespace used to populate the localized title.
   */
  getI18n() {
    return this._i18n;
  }
  /**
   * Serialize menu item group builder
   * @param options - serialization options (path). See {@link SerializeOptions}
   * @returns menu item group based on path provided in options. See {@link MenuItemGroup}
   */
  serialize(options = {
    path: []
  }) {
    if (!this._id)
      throw new SerializeError("`id` is required for a menu item group", options.path, options.index, this._title).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!this._title)
      throw new SerializeError("`title` is required for a menu item group", options.path, this._id).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    return {
      id: this._id,
      title: this._title,
      i18n: this._i18n
    };
  }
};
var disallowedPattern = /([^A-Za-z0-9-_.])/;
function validateId(id, parentPath, pathSegment) {
  if (typeof id != "string")
    throw new SerializeError(`Structure node id must be of type string, got ${typeof id}`, parentPath, pathSegment);
  const [disallowedChar] = id.match(disallowedPattern) || [];
  if (disallowedChar)
    throw new SerializeError(`Structure node id cannot contain character "${disallowedChar}"`, parentPath, pathSegment);
  if (id.startsWith("__edit__"))
    throw new SerializeError("Structure node id cannot start with __edit__", parentPath, pathSegment);
  return id;
}
function getStructureNodeId(title, id) {
  if (id)
    return id;
  const camelCased = camelCase_default(title);
  return disallowedPattern.test(camelCased) ? camelCase_default((0, import_speakingurl.default)(title)) : camelCased;
}
var ComponentBuilder = class _ComponentBuilder {
  /** component builder option object */
  constructor(spec) {
    this.spec = {
      options: {},
      ...spec || {}
    };
  }
  /** Set Component ID
   * @param id - component ID
   * @returns component builder based on ID provided
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /** Get ID
   * @returns ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set Component title
   * @param title - component title
   * @returns component builder based on title provided (and ID)
   */
  title(title) {
    return this.clone({
      title,
      id: getStructureNodeId(title, this.spec.id)
    });
  }
  /** Get Component title
   * @returns title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({
      i18n
    });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set Component child
   * @param child - child component
   * @returns component builder based on child component provided
   */
  child(child) {
    return this.clone({
      child
    });
  }
  /** Get Component child
   * @returns child component
   */
  getChild() {
    return this.spec.child;
  }
  /** Set component
   * @param component - user built component
   * @returns component builder based on component provided
   */
  component(component2) {
    return this.clone({
      component: component2
    });
  }
  /** Get Component
   * @returns component
   */
  getComponent() {
    return this.spec.component;
  }
  /** Set Component options
   * @param options - component options
   * @returns component builder based on options provided
   */
  options(options) {
    return this.clone({
      options
    });
  }
  /** Get Component options
   * @returns component options
   */
  getOptions() {
    return this.spec.options || {};
  }
  /** Set Component menu items
   * @param menuItems - component menu items
   * @returns component builder based on menuItems provided
   */
  menuItems(menuItems) {
    return this.clone({
      menuItems
    });
  }
  /** Get Component menu items
   * @returns menu items
   */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set Component menu item groups
   * @param menuItemGroups - component menu item groups
   * @returns component builder based on menuItemGroups provided
   */
  menuItemGroups(menuItemGroups) {
    return this.clone({
      menuItemGroups
    });
  }
  /** Get Component menu item groups
   * @returns menu item groups
   */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  canHandleIntent(canHandleIntent) {
    return this.clone({
      canHandleIntent
    });
  }
  /** Serialize component
   * @param options - serialization options
   * @returns component object based on path provided in options
   *
   */
  serialize(options = {
    path: []
  }) {
    const {
      id,
      title,
      child,
      options: componentOptions,
      component: component2
    } = this.spec;
    if (!id)
      throw new SerializeError("`id` is required for `component` structure item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!component2)
      throw new SerializeError("`component` is required for `component` structure item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    return {
      id: validateId(id, options.path, options.index),
      title,
      type: "component",
      child,
      component: component2,
      canHandleIntent: this.spec.canHandleIntent,
      options: componentOptions || {},
      menuItems: (this.spec.menuItems || []).map((item, i) => maybeSerializeMenuItem(item, i, options.path)),
      menuItemGroups: (this.spec.menuItemGroups || []).map((item, i) => maybeSerializeMenuItemGroup(item, i, options.path))
    };
  }
  /** Clone component builder (allows for options overriding)
   * @param withSpec - component builder options
   * @returns cloned builder
   */
  clone(withSpec) {
    const builder = new _ComponentBuilder();
    return builder.spec = {
      ...this.spec,
      ...withSpec
    }, builder;
  }
};
var DividerBuilder = class _DividerBuilder {
  constructor(spec) {
    this.spec = {
      id: uniqueId_default("__divider__"),
      type: "divider",
      ...spec
    };
  }
  /** Set the title of the divider
   * @param title - the title of the divider
   * @returns divider builder based on title provided
   */
  title(title) {
    return this.clone({
      title
    });
  }
  /** Get the title of the divider
   * @returns the title of the divider
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns divider builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({
      i18n
    });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /** Serialize the divider
   * @returns the serialized divider
   */
  serialize() {
    return {
      ...this.spec
    };
  }
  /** Clone divider builder (allows for options overriding)
   * @param withSpec - divider builder options
   * @returns cloned builder
   */
  clone(withSpec) {
    const builder = new _DividerBuilder();
    return builder.spec = {
      ...this.spec,
      ...withSpec
    }, builder;
  }
};
async function resolveTypeForDocument(getClient, id) {
  return await getClient(DEFAULT_STUDIO_CLIENT_OPTIONS).fetch("*[sanity::versionOf($publishedId)][0]._type", {
    publishedId: getPublishedId(id)
  }, {
    tag: "structure.resolve-type"
  });
}
var GenericViewBuilder = class {
  /** Generic view option object */
  spec = {};
  /** Set generic view ID
   * @param id - generic view ID
   * @returns generic view builder based on ID provided.
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /** Get generic view ID
   * @returns generic view ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set generic view title
   * @param title - generic view title
   * @returns generic view builder based on title provided and (if provided) its ID.
   */
  title(title) {
    return this.clone({
      title,
      id: this.spec.id || kebabCase_default(title)
    });
  }
  /** Get generic view title
   * @returns generic view title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set generic view icon
   * @param icon - generic view icon
   * @returns generic view builder based on icon provided.
   */
  icon(icon) {
    return this.clone({
      icon
    });
  }
  /** Get generic view icon
   * @returns generic view icon
   */
  getIcon() {
    return this.spec.icon;
  }
  /** Serialize generic view
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns generic view object based on path provided in options. See {@link BaseView}
   */
  serialize(options = {
    path: []
  }) {
    const {
      id,
      title,
      icon
    } = this.spec;
    if (!id)
      throw new SerializeError("`id` is required for view item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!title)
      throw new SerializeError("`title` is required for view item", options.path, options.index).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    return {
      id: validateId(id, options.path, options.index),
      title,
      icon
    };
  }
  /** Clone generic view builder (allows for options overriding)
   * @param withSpec - Partial generic view builder options. See {@link BaseView}
   * @returns Generic view builder.
   */
};
function isSerializable(view) {
  return typeof view.serialize == "function";
}
function maybeSerializeView(item, index, path) {
  return isSerializable(item) ? item.serialize({
    path,
    index
  }) : item;
}
var isComponentSpec = (spec) => isRecord$4(spec) && spec.type === "component";
var ComponentViewBuilder = class _ComponentViewBuilder extends GenericViewBuilder {
  /** Partial Component view option object. See {@link ComponentView} */
  constructor(componentOrSpec) {
    const spec = isComponentSpec(componentOrSpec) ? {
      ...componentOrSpec
    } : {
      options: {}
    };
    super(), this.spec = spec;
    const userComponent = typeof componentOrSpec == "function" ? componentOrSpec : this.spec.component;
    userComponent && (this.spec = this.component(userComponent).spec);
  }
  /** Set view Component
   * @param component - component view component. See {@link UserViewComponent}
   * @returns component view builder based on component view provided. See {@link ComponentViewBuilder}
   */
  component(component2) {
    return this.clone({
      component: component2
    });
  }
  /** Get view Component
   * @returns Partial component view. See {@link ComponentView}
   */
  getComponent() {
    return this.spec.component;
  }
  /** Set view Component options
   * @param options - component view options
   * @returns component view builder based on options provided. See {@link ComponentViewBuilder}
   */
  options(options) {
    return this.clone({
      options
    });
  }
  /** Get view Component options
   * @returns component view options. See {@link ComponentView}
   */
  getOptions() {
    return this.spec.options || {};
  }
  /** Serialize view Component
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns component view based on path provided in options. See {@link ComponentView}
   *
   */
  serialize(options = {
    path: []
  }) {
    const base = super.serialize(options), component2 = this.spec.component;
    if (typeof component2 != "function")
      throw new SerializeError("`component` is required and must be a function for `component()` view item", options.path, options.index).withHelpUrl(HELP_URL.COMPONENT_REQUIRED);
    return {
      ...base,
      component: component2,
      options: this.spec.options || {},
      type: "component"
    };
  }
  /** Clone Component view builder (allows for options overriding)
   * @param withSpec - partial for component view option. See {@link ComponentView}
   * @returns component view builder. See {@link ComponentViewBuilder}
   */
  clone(withSpec) {
    const builder = new _ComponentViewBuilder();
    return builder.spec = {
      ...this.spec,
      ...withSpec
    }, builder;
  }
};
var FormViewBuilder = class _FormViewBuilder extends GenericViewBuilder {
  /** Document list options. See {@link FormView} */
  constructor(spec) {
    super(), this.spec = {
      id: "editor",
      title: "Editor",
      ...spec || {}
    };
  }
  /**
   * Serialize Form view builder
   * @param options - Serialize options. See {@link SerializeOptions}
   * @returns form view builder based on path provided in options. See {@link FormView}
   */
  serialize(options = {
    path: []
  }) {
    return {
      ...super.serialize(options),
      type: "form"
    };
  }
  /**
   * Clone Form view builder (allows for options overriding)
   * @param withSpec - Partial form view builder options. See {@link FormView}
   * @returns form view builder. See {@link FormViewBuilder}
   */
  clone(withSpec) {
    const builder = new _FormViewBuilder();
    return builder.spec = {
      ...this.spec,
      ...withSpec
    }, builder;
  }
};
var form = (spec) => new FormViewBuilder(spec);
var component = (componentOrSpec) => new ComponentViewBuilder(componentOrSpec);
var views = Object.freeze({
  __proto__: null,
  ComponentViewBuilder,
  FormViewBuilder,
  GenericViewBuilder,
  component,
  form,
  maybeSerializeView
});
var createDocumentChildResolver = ({
  resolveDocumentNode,
  getClient
}) => async (itemId, {
  params,
  path
}) => {
  let type = params.type;
  const parentPath = path.slice(0, path.length - 1), currentSegment = path[path.length - 1];
  if (type || (type = await resolveTypeForDocument(getClient, itemId)), !type)
    throw new SerializeError("Failed to resolve document, and no type provided in parameters.", parentPath, currentSegment);
  return resolveDocumentNode({
    documentId: itemId,
    schemaType: type
  });
};
var DocumentBuilder = class _DocumentBuilder {
  /** Component builder option object See {@link PartialDocumentNode} */
  constructor(_context, spec) {
    this._context = _context, this.spec = spec || {};
  }
  /** Set Document Builder ID
   * @param id - document builder ID
   * @returns document builder based on ID provided. See {@link DocumentBuilder}
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /** Get Document Builder ID
   * @returns document ID. See {@link PartialDocumentNode}
   */
  getId() {
    return this.spec.id;
  }
  /** Set Document title
   * @param title - document title
   * @returns document builder based on title provided (and ID). See {@link DocumentBuilder}
   */
  title(title) {
    return this.clone({
      title,
      id: getStructureNodeId(title, this.spec.id)
    });
  }
  /** Get Document title
   * @returns document title. See {@link PartialDocumentNode}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({
      i18n
    });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set Document child
   * @param child - document child
   * @returns document builder based on child provided. See {@link DocumentBuilder}
   */
  child(child) {
    return this.clone({
      child
    });
  }
  /** Get Document child
   * @returns document child. See {@link PartialDocumentNode}
   */
  getChild() {
    return this.spec.child;
  }
  /** Set Document ID
   * @param documentId - document ID
   * @returns document builder with document based on ID provided. See {@link DocumentBuilder}
   */
  documentId(documentId) {
    const paneId = this.spec.id || documentId;
    return this.clone({
      id: paneId,
      options: {
        ...this.spec.options,
        id: documentId
      }
    });
  }
  /** Get Document ID
   * @returns document ID. See {@link DocumentOptions}
   */
  getDocumentId() {
    return this.spec.options?.id;
  }
  /** Set Document Type
   * @param documentType - document type
   * @returns document builder with document based on type provided. See {@link DocumentBuilder}
   */
  schemaType(documentType) {
    return this.clone({
      options: {
        ...this.spec.options,
        type: typeof documentType == "string" ? documentType : documentType.name
      }
    });
  }
  /** Get Document Type
   * @returns document type. See {@link DocumentOptions}
   */
  getSchemaType() {
    return this.spec.options?.type;
  }
  /** Set Document Template
   * @param templateId - document template ID
   * @param parameters - document template parameters
   * @returns document builder with document based on template provided. See {@link DocumentBuilder}
   */
  initialValueTemplate(templateId, parameters) {
    return this.clone({
      options: {
        ...this.spec.options,
        template: templateId,
        templateParameters: parameters
      }
    });
  }
  /** Get Document Template
   * @returns document template. See {@link DocumentOptions}
   */
  getInitialValueTemplate() {
    return this.spec.options?.template;
  }
  /** Get Document's initial value Template parameters
   * @returns document template parameters. See {@link DocumentOptions}
   */
  getInitialValueTemplateParameters() {
    return this.spec.options?.templateParameters;
  }
  /** Set Document views
   * @param views - document views. See {@link ViewBuilder} and {@link View}
   * @returns document builder with document based on views provided. See {@link DocumentBuilder}
   */
  views(views2) {
    return this.clone({
      views: views2
    });
  }
  /** Get Document views
   * @returns document views. See {@link ViewBuilder} and {@link View}
   */
  getViews() {
    return this.spec.views || [];
  }
  /**
   * Set the view IDs to open as split panes by default when the document is opened.
   * Pass an array of view IDs that match the IDs defined in `views()`.
   * If specified with 2+ valid view IDs, the document will open in split-pane mode.
   *
   * @param viewIds - Array of view IDs to open as split panes
   * @returns document builder with defaultPanes config. See {@link DocumentBuilder}
   *
   * @example
   * ```ts
   * S.document()
   *   .schemaType('article')
   *   .views([
   *     S.view.form().id('editor'),
   *     S.view.component(PreviewPane).id('preview').title('Preview')
   *   ])
   *   .defaultPanes(['editor', 'preview'])  // Opens both as split panes
   * ```
   */
  defaultPanes(viewIds) {
    return this.clone({
      defaultPanes: viewIds
    });
  }
  /** Serialize Document builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document node based on path, index and hint provided in options. See {@link DocumentNode}
   */
  serialize({
    path = [],
    index,
    hint
  } = {
    path: []
  }) {
    const urlId = path[index || path.length - 1], id = this.spec.id || urlId && `${urlId}` || "", options = {
      id,
      type: void 0,
      template: void 0,
      templateParameters: void 0,
      ...this.spec.options
    };
    if (typeof id != "string" || !id)
      throw new SerializeError("`id` is required for document nodes", path, index, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!options || !options.id)
      throw new SerializeError("document id (`id`) is required for document nodes", path, id, hint).withHelpUrl(HELP_URL.DOCUMENT_ID_REQUIRED);
    if (!options || !options.type)
      throw new SerializeError("document type (`schemaType`) is required for document nodes", path, id, hint);
    const views2 = (this.spec.views && this.spec.views.length > 0 ? this.spec.views : [form()]).map((item, i) => maybeSerializeView(item, i, path)), viewIds = views2.map((view) => view.id), dupes = uniq_default(viewIds.filter((viewId, i) => viewIds.includes(viewId, i + 1)));
    if (dupes.length > 0)
      throw new SerializeError(`document node has views with duplicate IDs: ${dupes.join(",  ")}`, path, id, hint);
    let defaultPanes;
    if (this.spec.defaultPanes && this.spec.defaultPanes.length > 0) {
      const validViewIds = this.spec.defaultPanes.filter((windowId) => viewIds.includes(windowId)), invalidViewIds = this.spec.defaultPanes.filter((windowId) => !viewIds.includes(windowId));
      invalidViewIds.length > 0 && console.warn(`DefaultPanes contains invalid view IDs that don't match any defined views: ${invalidViewIds.join(", ")}. Valid view IDs are: ${viewIds.join(", ")}`), validViewIds.length >= 2 && (defaultPanes = validViewIds);
    }
    return {
      ...this.spec,
      child: this.spec.child || createDocumentChildResolver(this._context),
      id: validateId(id, path, index),
      type: "document",
      options: getDocumentOptions(options),
      views: views2,
      defaultPanes
    };
  }
  /** Clone Document builder
   * @param withSpec - partial document node specification used to extend the cloned builder. See {@link PartialDocumentNode}
   * @returns document builder based on context and spec provided. See {@link DocumentBuilder}
   */
  clone(withSpec = {}) {
    const builder = new _DocumentBuilder(this._context), options = {
      ...this.spec.options,
      ...withSpec.options
    };
    return builder.spec = {
      ...this.spec,
      ...withSpec,
      options
    }, builder;
  }
};
function getDocumentOptions(spec) {
  const opts = {
    id: spec.id || "",
    type: spec.type || "*"
  };
  return spec.template && (opts.template = spec.template), spec.templateParameters && (opts.templateParameters = spec.templateParameters), opts;
}
function documentFromEditor(context, spec) {
  let doc = spec?.type ? (
    // Use user-defined document fragment as base if possible
    context.resolveDocumentNode({
      schemaType: spec.type
    })
  ) : (
    // Fall back to plain old document builder
    new DocumentBuilder(context)
  );
  if (!spec) return doc;
  const {
    id,
    type,
    template,
    templateParameters
  } = spec.options;
  return doc = doc.id(spec.id).documentId(id), type && (doc = doc.schemaType(type)), template && (doc = doc.initialValueTemplate(template, templateParameters)), spec.child && (doc = doc.child(spec.child)), doc;
}
function documentFromEditorWithInitialValue({
  resolveDocumentNode,
  templates
}, templateId, parameters) {
  const template = templates.find((t2) => t2.id === templateId);
  if (!template)
    throw new Error(`Template with ID "${templateId}" not defined`);
  return resolveDocumentNode({
    schemaType: template.schemaType
  }).initialValueTemplate(templateId, parameters);
}
var InitialValueTemplateItemBuilder = class _InitialValueTemplateItemBuilder {
  /** Initial Value template item option object. See {@link InitialValueTemplateItem} */
  constructor(_context, spec) {
    this._context = _context, this.spec = spec || {};
  }
  /** Set initial value template item builder ID
   * @param id - initial value template item ID
   * @returns initial value template item based on ID provided. See {@link InitialValueTemplateItemBuilder}
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /** Get initial value template item builder ID
   * @returns initial value template item ID. See {@link InitialValueTemplateItem}
   */
  getId() {
    return this.spec.id;
  }
  /** Set initial value template item title
   * @param title - initial value template item title
   * @returns initial value template item based on title provided. See {@link InitialValueTemplateItemBuilder}
   */
  title(title) {
    return this.clone({
      title
    });
  }
  /** Get initial value template item title
   * @returns initial value template item title. See {@link InitialValueTemplateItem}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set initial value template item description
   * @param description - initial value template item description
   * @returns initial value template item builder based on description provided. See {@link InitialValueTemplateItemBuilder}
   */
  description(description) {
    return this.clone({
      description
    });
  }
  /** Get initial value template item description
   * @returns initial value template item description. See {@link InitialValueTemplateItem}
   */
  getDescription() {
    return this.spec.description;
  }
  /** Set initial value template ID
   * @param templateId - initial value template item template ID
   * @returns initial value template item based builder on template ID provided. See {@link InitialValueTemplateItemBuilder}
   */
  templateId(templateId) {
    const paneId = this.spec.id || templateId;
    return this.clone({
      id: paneId,
      templateId
    });
  }
  /** Get initial value template item template ID
   * @returns initial value template item ID. See {@link InitialValueTemplateItem}
   */
  getTemplateId() {
    return this.spec.templateId;
  }
  /** Get initial value template item template parameters
   * @param parameters - initial value template item parameters
   * @returns initial value template item builder based on parameters provided. See {@link InitialValueTemplateItemBuilder}
   */
  parameters(parameters) {
    return this.clone({
      parameters
    });
  }
  /** Get initial value template item template parameters
   * @returns initial value template item parameters. See {@link InitialValueTemplateItem}
   */
  getParameters() {
    return this.spec.parameters;
  }
  /** Serialize initial value template item
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns initial value template item object based on the path, index and hint provided in options. See {@link InitialValueTemplateItem}
   */
  serialize({
    path = [],
    index,
    hint
  } = {
    path: []
  }) {
    if (typeof this.spec.id != "string" || !this.spec.id)
      throw new SerializeError("`id` is required for initial value template item nodes", path, index, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!this.spec.templateId)
      throw new SerializeError("template id (`templateId`) is required for initial value template item nodes", path, this.spec.id, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    const template = this._context.templates.find((t2) => t2.id === this.spec.templateId);
    if (!template)
      throw new SerializeError("template id (`templateId`) is required for initial value template item nodes", path, this.spec.id, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    return {
      id: this.spec.id,
      templateId: this.spec.id,
      schemaType: template.schemaType,
      type: "initialValueTemplateItem",
      description: this.spec.description || template.description,
      title: this.spec.title || template.title,
      subtitle: this.spec.subtitle,
      icon: this.spec.icon || template.icon,
      initialDocumentId: this.spec.initialDocumentId,
      parameters: this.spec.parameters
    };
  }
  /** Clone generic view builder (allows for options overriding)
   * @param withSpec - initial value template item builder options. See {@link InitialValueTemplateItemBuilder}
   * @returns initial value template item builder based on the context and options provided. See {@link InitialValueTemplateItemBuilder}
   */
  clone(withSpec = {}) {
    const builder = new _InitialValueTemplateItemBuilder(this._context);
    return builder.spec = {
      ...this.spec,
      ...withSpec
    }, builder;
  }
};
function defaultInitialValueTemplateItems(context) {
  const {
    schema,
    getStructureBuilder,
    templates
  } = context, typeNames = schema.getTypeNames();
  return templates.filter((tpl) => !tpl.parameters?.length).sort((a, b) => typeNames.indexOf(a.schemaType) - typeNames.indexOf(b.schemaType)).map((tpl) => getStructureBuilder().initialValueTemplateItem(tpl.id));
}
function maybeSerializeInitialValueTemplateItem(item, index, path) {
  return item instanceof InitialValueTemplateItemBuilder ? item.serialize({
    path,
    index
  }) : item;
}
function menuItemsFromInitialValueTemplateItems(context, templateItems) {
  const {
    schema,
    templates
  } = context;
  return templateItems.map((item) => {
    const template = templates.find((t2) => t2.id === item.templateId), title = item.title || template?.title || "Create", params = {};
    template && template.schemaType && (params.type = template.schemaType), item.templateId && (params.template = item.templateId);
    const intentParams = item.parameters ? [params, item.parameters] : params, schemaType = template && schema.get(template.schemaType), i18n = item.i18n || template?.i18n;
    let builder = new MenuItemBuilder(context).title(title).icon(template && template.icon || schemaType?.icon || AddIcon).intent({
      type: "create",
      params: intentParams
    });
    return i18n && (builder = builder.i18n(i18n)), builder.serialize();
  });
}
var DEFAULT_INTENT_HANDLER = /* @__PURE__ */ Symbol("Document type list canHandleIntent");
var defaultIntentChecker = (intentName, params, {
  pane: pane2
}) => {
  const isEdit = intentName === "edit", isCreate = intentName === "create", typedSpec = pane2, paneFilter = typedSpec.options?.filter || "", paneParams = typedSpec.options?.params || {}, typeNames = typedSpec.schemaTypeName ? [typedSpec.schemaTypeName] : getTypeNamesFromFilter(paneFilter, paneParams), initialValueTemplates = typedSpec.initialValueTemplates || [];
  return isCreate && params.template ? initialValueTemplates.some((tpl) => tpl.templateId === params.template) : isEdit && params.id && typeNames.includes(params.type) || isCreate && typeNames.includes(params.type);
};
defaultIntentChecker.identity = DEFAULT_INTENT_HANDLER;
var layoutOptions = ["default", "card", "media", "detail", "block"];
function noChildResolver() {
}
var shallowIntentChecker = (intentName, params, {
  pane: pane2,
  index
}) => index <= 1 && defaultIntentChecker(intentName, params, {
  pane: pane2
});
var GenericListBuilder = class {
  /** Check if initial value templates are set */
  initialValueTemplatesSpecified = false;
  /** Generic list option object */
  spec = {};
  /** Set generic list ID
   * @param id - generic list ID
   * @returns generic list builder based on ID provided.
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /** Get generic list ID
   * @returns generic list ID
   */
  getId() {
    return this.spec.id;
  }
  /** Set generic list title
   * @param title - generic list title
   * @returns generic list builder based on title and ID provided.
   */
  title(title) {
    return this.clone({
      title,
      id: getStructureNodeId(title, this.spec.id)
    });
  }
  /** Get generic list title
   * @returns generic list title
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({
      i18n
    });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set generic list layout
   * @param defaultLayout - generic list layout key.
   * @returns generic list builder based on layout provided.
   */
  defaultLayout(defaultLayout) {
    return this.clone({
      defaultLayout
    });
  }
  /** Get generic list layout
   * @returns generic list layout
   */
  getDefaultLayout() {
    return this.spec.defaultLayout;
  }
  /** Set generic list menu items
   * @param menuItems - generic list menu items. See {@link MenuItem} and {@link MenuItemBuilder}
   * @returns generic list builder based on menu items provided.
   */
  menuItems(menuItems) {
    return this.clone({
      menuItems
    });
  }
  /** Get generic list menu items
   * @returns generic list menu items
   */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set generic list menu item groups
   * @param menuItemGroups - generic list menu item groups. See {@link MenuItemGroup} and {@link MenuItemGroupBuilder}
   * @returns generic list builder based on menu item groups provided.
   */
  menuItemGroups(menuItemGroups) {
    return this.clone({
      menuItemGroups
    });
  }
  /** Get generic list menu item groups
   * @returns generic list menu item groups
   */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  /** Set generic list child
   * @param child - generic list child. See {@link Child}
   * @returns generic list builder based on child provided (clone).
   */
  child(child) {
    return this.clone({
      child
    });
  }
  /** Get generic list child
   * @returns generic list child
   */
  getChild() {
    return this.spec.child;
  }
  /** Set generic list can handle intent
   * @param canHandleIntent - generic list intent checker. See {@link IntentChecker}
   * @returns generic list builder based on can handle intent provided.
   */
  canHandleIntent(canHandleIntent) {
    return this.clone({
      canHandleIntent
    });
  }
  /** Get generic list can handle intent
   * @returns generic list can handle intent
   */
  getCanHandleIntent() {
    return this.spec.canHandleIntent;
  }
  /** Set generic list display options
   * @param enabled - allow / disallow for showing icons
   * @returns generic list builder based on display options (showIcons) provided.
   */
  showIcons(enabled = true) {
    return this.clone({
      displayOptions: {
        ...this.spec.displayOptions,
        showIcons: enabled
      }
    });
  }
  /** Get generic list display options
   * @returns generic list display options (specifically showIcons)
   */
  getShowIcons() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcons : void 0;
  }
  /** Set generic list initial value templates
   * @param templates - generic list initial value templates. See {@link InitialValueTemplateItemBuilder}
   * @returns generic list builder based on templates provided.
   */
  initialValueTemplates(templates) {
    return this.initialValueTemplatesSpecified = true, this.clone({
      initialValueTemplates: Array.isArray(templates) ? templates : [templates]
    });
  }
  /** Get generic list initial value templates
   * @returns generic list initial value templates
   */
  getInitialValueTemplates() {
    return this.spec.initialValueTemplates;
  }
  /** Serialize generic list
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns generic list object based on path provided in options. See {@link GenericList}
   */
  serialize(options = {
    path: []
  }) {
    const id = this.spec.id || "", path = options.path, defaultLayout = this.spec.defaultLayout;
    if (defaultLayout && !layoutOptions.includes(defaultLayout))
      throw new SerializeError(`\`layout\` must be one of ${layoutOptions.map((item) => `"${item}"`).join(", ")}`, path, id || options.index, this.spec.title);
    const initialValueTemplates = (this.spec.initialValueTemplates || []).map((item, i) => maybeSerializeInitialValueTemplateItem(item, i, path));
    return {
      id: validateId(id, options.path, id || options.index),
      title: this.spec.title,
      i18n: this.spec.i18n,
      type: "genericList",
      defaultLayout,
      child: this.spec.child || noChildResolver,
      canHandleIntent: this.spec.canHandleIntent || shallowIntentChecker,
      displayOptions: this.spec.displayOptions,
      initialValueTemplates,
      menuItems: (this.spec.menuItems || []).map((item, i) => maybeSerializeMenuItem(item, i, path)),
      menuItemGroups: (this.spec.menuItemGroups || []).map((item, i) => maybeSerializeMenuItemGroup(item, i, path))
    };
  }
  /** Clone generic list builder (allows for options overriding)
   * @param _withSpec - generic list options.
   * @returns generic list builder.
   */
};
var validateFilter = (spec, options) => {
  const filter2 = spec.options?.filter.trim() || "";
  if (["*", "{"].includes(filter2[0]))
    throw new SerializeError(`\`filter\` cannot start with \`${filter2[0]}\` - looks like you are providing a query, not a filter`, options.path, spec.id, spec.title).withHelpUrl(HELP_URL.QUERY_PROVIDED_FOR_FILTER);
  return filter2;
};
var createDocumentChildResolverForItem = (context) => (itemId, options) => {
  const parentItem = options.parent, template = options.params?.template ? context.templates.find((tpl) => tpl.id === options.params.template) : void 0, type = template ? template.schemaType : parentItem.schemaTypeName || resolveTypeForDocument(context.getClient, itemId);
  return Promise.resolve(type).then((schemaType) => schemaType ? context.resolveDocumentNode({
    schemaType,
    documentId: itemId
  }) : new DocumentBuilder(context).id("editor").documentId(itemId).schemaType(""));
};
var DocumentListBuilder = class _DocumentListBuilder extends GenericListBuilder {
  /** Document list options. See {@link PartialDocumentList} */
  constructor(_context, spec) {
    super(), this._context = _context, this.spec = spec || {}, this.initialValueTemplatesSpecified = !!spec?.initialValueTemplates;
  }
  /** Set API version
   * @param apiVersion - API version
   * @returns document list builder based on the options and API version provided. See {@link DocumentListBuilder}
   */
  apiVersion(apiVersion) {
    return this.clone({
      options: {
        ...this.spec.options || {
          filter: ""
        },
        apiVersion
      }
    });
  }
  /** Get API version
   * @returns API version
   */
  getApiVersion() {
    return this.spec.options?.apiVersion;
  }
  /** Set Document list filter
   * @param filter - GROQ-filter used to determine which documents to display. Do not support joins, since they operate on individual documents, and will ignore order-clauses and projections. See {@link https://www.sanity.io/docs/realtime-updates}
   * @returns document list builder based on the options and filter provided. See {@link DocumentListBuilder}
   */
  filter(filter2) {
    return this.clone({
      options: {
        ...this.spec.options,
        filter: filter2
      }
    });
  }
  /** Get Document list filter
   * @returns filter
   */
  getFilter() {
    return this.spec.options?.filter;
  }
  /** Set Document list schema type name
   * @param type - schema type name.
   * @returns document list builder based on the schema type name provided. See {@link DocumentListBuilder}
   */
  schemaType(type) {
    const schemaTypeName = typeof type == "string" ? type : type.name;
    return this.clone({
      schemaTypeName
    });
  }
  /** Get Document list schema type name
   * @returns schema type name
   */
  getSchemaType() {
    return this.spec.schemaTypeName;
  }
  /** Set Document list options' parameters
   * @param params - parameters
   * @returns document list builder based on the options provided. See {@link DocumentListBuilder}
   */
  params(params) {
    return this.clone({
      options: {
        ...this.spec.options || {
          filter: ""
        },
        params
      }
    });
  }
  /** Get Document list options' parameters
   * @returns options
   */
  getParams() {
    return this.spec.options?.params;
  }
  /** Set Document list default ordering
   * @param ordering - default sort ordering array. See {@link SortOrderingItem}
   * @returns document list builder based on ordering provided. See {@link DocumentListBuilder}
   */
  defaultOrdering(ordering) {
    if (!Array.isArray(ordering))
      throw new Error("`defaultOrdering` must be an array of order clauses");
    return this.clone({
      options: {
        ...this.spec.options || {
          filter: ""
        },
        defaultOrdering: ordering
      }
    });
  }
  /** Get Document list default ordering
   * @returns default ordering. See {@link SortOrderingItem}
   */
  getDefaultOrdering() {
    return this.spec.options?.defaultOrdering;
  }
  /** Serialize Document list
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document list object based on path provided in options. See {@link DocumentList}
   */
  serialize(options = {
    path: []
  }) {
    if (typeof this.spec.id != "string" || !this.spec.id)
      throw new SerializeError("`id` is required for document lists", options.path, options.index, this.spec.title).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!this.spec.options || !this.spec.options.filter)
      throw new SerializeError("`filter` is required for document lists", options.path, this.spec.id, this.spec.title).withHelpUrl(HELP_URL.FILTER_REQUIRED);
    return this.spec.options?.filter !== "_type == $type" && this.spec.options.filter && !this.spec.options.apiVersion && console.warn(`No apiVersion specified for document type list with custom filter: \`${this.spec.options.filter}\`. This will be required in the future. See %s for more info.`, generateHelpUrl(HELP_URL.API_VERSION_REQUIRED_FOR_CUSTOM_FILTER)), {
      ...super.serialize(options),
      type: "documentList",
      schemaTypeName: this.spec.schemaTypeName,
      child: this.spec.child || createDocumentChildResolverForItem(this._context),
      options: {
        ...this.spec.options,
        // @todo: make specifying .apiVersion required when using custom (non-simple) filters in v4
        apiVersion: this.spec.options.apiVersion || DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion,
        filter: validateFilter(this.spec, options)
      }
    };
  }
  /** Clone Document list builder (allows for options overriding)
   * @param withSpec - override document list spec. See {@link PartialDocumentList}
   * @returns document list builder. See {@link DocumentListBuilder}
   */
  clone(withSpec) {
    const builder = new _DocumentListBuilder(this._context);
    return builder.spec = {
      ...this.spec,
      ...withSpec
    }, this.initialValueTemplatesSpecified || (builder.spec.initialValueTemplates = inferInitialValueTemplates(this._context, builder.spec)), builder.spec.schemaTypeName || (builder.spec.schemaTypeName = inferTypeName(builder.spec)), builder;
  }
  /** Get Document list spec
   * @returns document list spec. See {@link PartialDocumentList}
   */
  getSpec() {
    return this.spec;
  }
};
function inferInitialValueTemplates(context, spec) {
  const {
    document: document2
  } = context, {
    schemaTypeName,
    options
  } = spec, {
    filter: filter2,
    params
  } = options || {
    filter: "",
    params: {}
  }, typeNames = schemaTypeName ? [schemaTypeName] : Array.from(new Set(getTypeNamesFromFilter(filter2, params)));
  if (typeNames.length !== 0)
    return typeNames.flatMap((schemaType) => document2.resolveNewDocumentOptions({
      type: "structure",
      schemaType
    })).map((option) => ({
      ...option,
      icon: AddIcon
    }));
}
function inferTypeName(spec) {
  const {
    options
  } = spec, {
    filter: filter2,
    params
  } = options || {
    filter: "",
    params: {}
  }, typeNames = getTypeNamesFromFilter(filter2, params);
  return typeNames.length === 1 ? typeNames[0] : void 0;
}
function getTypeNamesFromFilter(filter2, params = {}) {
  let typeNames = getTypeNamesFromEqualityFilter(filter2, params);
  return typeNames.length === 0 && (typeNames = getTypeNamesFromInTypesFilter(filter2, params)), typeNames;
}
function getTypeNamesFromEqualityFilter(filter2, params = {}) {
  const pattern = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type/g, matches = [];
  let match;
  for (; (match = pattern.exec(filter2)) !== null; )
    matches.push(match[1] || match[2]);
  return matches.map((candidate) => ((candidate[0] === "$" ? params[candidate.slice(1)] : candidate) || "").trim().replace(/^["']|["']$/g, "")).filter(Boolean);
}
function getTypeNamesFromInTypesFilter(filter2, params = {}) {
  const pattern = /\b_type\s+in\s+\[(.*?)\]/, matches = filter2.match(pattern);
  return matches ? matches[1].split(/,\s*/).map((match) => match.trim().replace(/^["']+|["']+$/g, "")).map((item) => item[0] === "$" ? params[item.slice(1)] : item).filter(Boolean) : [];
}
var getArgType = (thing) => thing instanceof ListBuilder ? "ListBuilder" : isPromise(thing) ? "Promise" : Array.isArray(thing) ? "array" : typeof thing;
var isListItem = (item) => item.type === "listItem";
var defaultCanHandleIntent = (intentName, params, context) => (context.pane.items || []).filter(isDocumentListItem).some((item) => item.schemaType.name === params.type && item._id === params.id) || shallowIntentChecker(intentName, params, context);
var resolveChildForItem = (itemId, options) => {
  const target = (options.parent.items.filter(isListItem).find((item) => item.id === itemId) || {
    child: void 0
  }).child;
  return !target || typeof target != "function" ? target : typeof target == "function" ? target(itemId, options) : target;
};
function maybeSerializeListItem(item, index, path) {
  if (item instanceof ListItemBuilder)
    return item.serialize({
      path,
      index
    });
  if (item instanceof DividerBuilder)
    return item.serialize();
  const listItem = item;
  if (listItem && listItem.type === "divider")
    return item;
  if (!listItem || listItem.type !== "listItem") {
    const gotWhat = listItem && listItem.type || getArgType(listItem), helpText = gotWhat === "array" ? " - did you forget to spread (...moreItems)?" : "";
    throw new SerializeError(`List items must be of type "listItem", got "${gotWhat}"${helpText}`, path, index).withHelpUrl(HELP_URL.INVALID_LIST_ITEM);
  }
  return item;
}
function isPromise(thing) {
  return isRecord$4(thing) && typeof thing.then == "function";
}
var ListBuilder = class _ListBuilder extends GenericListBuilder {
  /** buildable list option object. See {@link BuildableList} */
  constructor(_context, spec) {
    super(), this._context = _context, this.spec = spec || {}, this.initialValueTemplatesSpecified = !!(spec && spec.initialValueTemplates);
  }
  /**
   * Set list builder based on items provided
   * @param items - list items. See {@link ListItemBuilder}, {@link ListItem} and {@link Divider}
   * @returns list builder based on items provided. See {@link ListBuilder}
   */
  items(items) {
    return this.clone({
      items
    });
  }
  /** Get list builder items
   * @returns list items. See {@link BuildableList}
   */
  getItems() {
    return this.spec.items;
  }
  /** Serialize list builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns list based on path in options. See {@link List}
   */
  serialize(options = {
    path: []
  }) {
    const id = this.spec.id;
    if (typeof id != "string" || !id)
      throw new SerializeError("`id` is required for lists", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    const items = typeof this.spec.items > "u" ? [] : this.spec.items;
    if (!Array.isArray(items))
      throw new SerializeError("`items` must be an array of items", options.path, options.index).withHelpUrl(HELP_URL.LIST_ITEMS_MUST_BE_ARRAY);
    const path = (options.path || []).concat(id), serializedItems = items.map((item, index) => maybeSerializeListItem(item, index, path)), dupes = serializedItems.filter((val, i) => find_default(serializedItems, {
      id: val.id
    }, i + 1));
    if (dupes.length > 0) {
      const dupeIds = dupes.map((item) => item.id).slice(0, 5), dupeDesc = dupes.length > 5 ? `${dupeIds.join(", ")}...` : dupeIds.join(", ");
      throw new SerializeError(`List items with same ID found (${dupeDesc})`, options.path, options.index).withHelpUrl(HELP_URL.LIST_ITEM_IDS_MUST_BE_UNIQUE);
    }
    return {
      ...super.serialize(options),
      type: "list",
      canHandleIntent: this.spec.canHandleIntent || defaultCanHandleIntent,
      child: this.spec.child || resolveChildForItem,
      items: serializedItems
    };
  }
  /**
   * Clone list builder and return new list builder based on context and spec provided
   * @param withSpec - list options. See {@link BuildableList}
   * @returns new list builder based on context and spec provided. See {@link ListBuilder}
   */
  clone(withSpec) {
    const builder = new _ListBuilder(this._context);
    return builder.spec = {
      ...this.spec,
      ...withSpec
    }, builder;
  }
};
var ListItemBuilder = class _ListItemBuilder {
  /** List item option object. See {@link PartialListItem} */
  constructor(_context, spec) {
    this._context = _context, this.spec = spec || {};
  }
  /**
   * Set list item ID
   * @returns list item builder based on ID provided. See {@link ListItemBuilder}
   */
  id(id) {
    return this.clone({
      id
    });
  }
  /**
   * Get list item ID
   * @returns list item ID. See {@link PartialListItem}
   */
  getId() {
    return this.spec.id;
  }
  /**
   * Set list item title
   * @returns list item builder based on title provided. See {@link ListItemBuilder}
   */
  title(title) {
    return this.clone({
      title,
      id: getStructureNodeId(title, this.spec.id)
    });
  }
  /**
   * Get list item title
   * @returns list item title. See {@link PartialListItem}
   */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n) {
    return this.clone({
      i18n
    });
  }
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n() {
    return this.spec.i18n;
  }
  /**
   * Set list item icon
   * @returns list item builder based on icon provided. See {@link ListItemBuilder}
   */
  icon(icon) {
    return this.clone({
      icon
    });
  }
  /**
   * Set if list item should show icon
   * @returns list item builder based on showIcon provided. See {@link ListItemBuilder}
   */
  showIcon(enabled = true) {
    return this.clone({
      displayOptions: {
        ...this.spec.displayOptions,
        showIcon: enabled
      }
    });
  }
  /**
   * Check if list item should show icon
   * @returns true if it should show the icon, false if not, undefined if not set
   */
  getShowIcon() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcon : void 0;
  }
  /**
   *Get list item icon
   * @returns list item icon. See {@link PartialListItem}
   */
  getIcon() {
    return this.spec.icon;
  }
  /**
   * Set list item child
   * @param child - list item child. See {@link UnserializedListItemChild}
   * @returns list item builder based on child provided. See {@link ListItemBuilder}
   */
  child(child) {
    return this.clone({
      child
    });
  }
  /**
   * Get list item child
   * @returns list item child. See {@link PartialListItem}
   */
  getChild() {
    return this.spec.child;
  }
  /**
   * Set list item schema type
   * @param schemaType - list item schema type. See {@link SchemaType}
   * @returns list item builder based on schema type provided. See {@link ListItemBuilder}
   */
  schemaType(schemaType) {
    return this.clone({
      schemaType
    });
  }
  /**
   * Get list item schema type
   * @returns list item schema type. See {@link PartialListItem}
   */
  getSchemaType() {
    const schemaType = this.spec.schemaType;
    return typeof schemaType == "string" ? this._context.schema.get(schemaType) : this.spec.schemaType;
  }
  /** Serialize list item builder
   * @param options - serialization options. See {@link ListItemSerializeOptions}
   * @returns list item node based on path provided in options. See {@link ListItem}
   */
  serialize(options = {
    path: []
  }) {
    const {
      id,
      title,
      child
    } = this.spec;
    if (typeof id != "string" || !id)
      throw new SerializeError("`id` is required for list items", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    if (!options.titleIsOptional && (typeof title != "string" || !title))
      throw new SerializeError("`title` is required for list items", options.path, id).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    let schemaType = this.spec.schemaType;
    if (typeof schemaType == "string") {
      const type = this._context.schema.get(schemaType);
      if (!type)
        throw new SerializeError(`Could not find type "${schemaType}" in schema`, options.path, id).withHelpUrl(HELP_URL.SCHEMA_TYPE_NOT_FOUND);
      schemaType = type;
    }
    const serializeOptions = {
      path: options.path.concat(id),
      hint: "child"
    };
    let listChild = child instanceof ComponentBuilder || child instanceof DocumentListBuilder || child instanceof DocumentBuilder || child instanceof ListBuilder ? child.serialize(serializeOptions) : child;
    if (typeof listChild == "function") {
      const originalChild = listChild;
      listChild = (itemId, childOptions) => originalChild(itemId, {
        ...childOptions,
        serializeOptions
      });
    }
    return {
      ...this.spec,
      id: validateId(id, options.path, options.index),
      schemaType,
      child: listChild,
      title,
      type: "listItem"
    };
  }
  /** Clone list item builder
   * @param withSpec - partial list item options. See {@link PartialListItem}
   * @returns list item builder based on context and spec provided. See {@link ListItemBuilder}
   */
  clone(withSpec) {
    const builder = new _ListItemBuilder(this._context);
    return builder.spec = {
      ...this.spec,
      ...withSpec
    }, builder;
  }
};
var createDefaultChildResolver = (context, spec) => (documentId) => {
  const schemaType = spec.schemaType && (typeof spec.schemaType == "string" ? spec.schemaType : spec.schemaType.name);
  return schemaType ? context.resolveDocumentNode({
    schemaType,
    documentId
  }) : new DocumentBuilder(context).id("documentEditor").documentId(documentId);
};
var DocumentListItemBuilder = class _DocumentListItemBuilder extends ListItemBuilder {
  /** Document list options. See {@link PartialDocumentListItem} */
  constructor(_context, spec) {
    super(_context, spec), this._context = _context, this.spec = spec || {};
  }
  /**
   * Serialize document list item
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document list item object based on path provided in options. See {@link DocumentListItem}
   */
  serialize(options = {
    path: []
  }) {
    const spec = super.serialize({
      ...options,
      titleIsOptional: true
    });
    if (!spec.schemaType)
      throw new SerializeError("`schemaType` is required for document list items", options.path, options.index).withHelpUrl(HELP_URL.SCHEMA_TYPE_REQUIRED);
    const child = spec.child || createDefaultChildResolver(this._context, spec);
    return {
      ...spec,
      child,
      schemaType: spec.schemaType,
      _id: spec.id
    };
  }
  /** Clone Document list item builder (allows for options overriding)
   * @param withSpec - Document list item builder options. See {@link PartialDocumentListItem}
   * @returns document list item builder. See {@link DocumentListItemBuilder}
   */
  clone(withSpec) {
    const builder = new _DocumentListItemBuilder(this._context);
    return builder.spec = {
      ...this.spec,
      ...withSpec
    }, builder;
  }
};
function isDocumentListItem(item) {
  return isRecord$4(item) && typeof item.schemaType < "u" && typeof item._id == "string";
}
var DocumentTypeListBuilder = class _DocumentTypeListBuilder extends DocumentListBuilder {
  /** Document list options. See {@link PartialDocumentList} */
  constructor(_context, spec) {
    super(_context), this._context = _context, this.spec = spec || {};
  }
  /**
   * Set Document type list child
   * @param child - Child component. See {@link Child}
   * @returns document type list builder based on child component provided without default intent handler. See {@link DocumentTypeListBuilder}
   */
  child(child) {
    return this.cloneWithoutDefaultIntentHandler({
      child
    });
  }
  /** Clone Document type list builder (allows for options overriding)
   * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
   * @returns document type list builder. See {@link DocumentTypeListBuilder}
   */
  clone(withSpec) {
    const parent = super.clone(withSpec), builder = new _DocumentTypeListBuilder(this._context);
    return builder.spec = {
      ...this.spec,
      ...parent.getSpec(),
      ...withSpec
    }, builder;
  }
  /** Clone Document type list builder (allows for options overriding) and remove default intent handler
   * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
   * @returns document type list builder without default intent handler. See {@link DocumentTypeListBuilder}
   */
  cloneWithoutDefaultIntentHandler(withSpec) {
    const parent = super.clone(withSpec), builder = new _DocumentTypeListBuilder(this._context), canHandleIntent = this.spec.canHandleIntent, override = canHandleIntent && canHandleIntent.identity === DEFAULT_INTENT_HANDLER ? {
      canHandleIntent: void 0
    } : {};
    return builder.spec = {
      ...parent.getSpec(),
      ...this.spec,
      ...withSpec,
      ...override
    }, builder;
  }
};
var BUNDLED_DOC_TYPES = ["sanity.imageAsset", "sanity.fileAsset"];
function isBundledDocType(typeName) {
  return BUNDLED_DOC_TYPES.includes(typeName);
}
function isDocumentType(schemaType) {
  return schemaType.type?.name === "document";
}
function isList(collection) {
  return collection.type === "list";
}
function getDocumentTypes({
  schema
}) {
  return schema.getTypeNames().filter((n2) => {
    const schemaType = schema.get(n2);
    return schemaType && isDocumentType(schemaType);
  }).filter((n2) => !isBundledDocType(n2));
}
function getDocumentTypeListItems(context) {
  return getDocumentTypes(context).map((typeName) => getDocumentTypeListItem(context, typeName));
}
function getDocumentTypeListItem(context, typeName) {
  const {
    schema
  } = context, type = schema.get(typeName);
  if (!type)
    throw new Error(`Schema type with name "${typeName}" not found`);
  const title = type.title || startCase_default(typeName);
  return new ListItemBuilder(context).id(typeName).title(title).schemaType(type).child((id, childContext) => {
    const parent = childContext.parent, parentItem = isList(parent) ? parent.items.find((item) => item.id === id) : null;
    let list = getDocumentTypeList(context, typeName);
    return parentItem && parentItem.title && (list = list.title(parentItem.title)), list;
  });
}
function getDocumentTypeList(context, typeNameOrSpec) {
  const {
    schema,
    resolveDocumentNode
  } = context, schemaType = typeof typeNameOrSpec == "string" ? typeNameOrSpec : typeNameOrSpec.schemaType, typeName = typeof schemaType == "string" ? schemaType : schemaType.name, spec = typeof typeNameOrSpec == "string" ? {} : typeNameOrSpec, type = schema.get(typeName);
  if (!type)
    throw new Error(`Schema type with name "${typeName}" not found`);
  const title = type.title || startCase_default(typeName);
  return new DocumentTypeListBuilder(context).id(spec.id || typeName).title(spec.title || title).filter("_type == $type").params({
    type: typeName
  }).schemaType(type).defaultOrdering(DEFAULT_SELECTED_ORDERING_OPTION.by).menuItemGroups(spec.menuItemGroups || [{
    id: "sorting",
    title: "Sort",
    i18n: {
      title: {
        key: "menu-item-groups.actions-group",
        ns: structureLocaleNamespace
      }
    }
  }, {
    id: "layout",
    title: "Layout",
    i18n: {
      title: {
        key: "menu-item-groups.layout-group",
        ns: structureLocaleNamespace
      }
    }
  }, {
    id: "actions",
    title: "Actions",
    i18n: {
      title: {
        key: "menu-item-groups.sorting-group",
        ns: structureLocaleNamespace
      }
    }
  }]).child(spec.child || ((documentId) => resolveDocumentNode({
    schemaType: typeName,
    documentId
  }))).canHandleIntent(spec.canHandleIntent || defaultIntentChecker).menuItems(spec.menuItems || [
    // Create new (from action button) will be added in serialization step of GenericList
    // Sort by <Y>
    ...getOrderingMenuItemsForSchemaType(context, type),
    // Display as <Z>
    new MenuItemBuilder(context).group("layout").i18n({
      title: {
        key: "menu-items.layout.compact-view",
        ns: structureLocaleNamespace
      }
    }).title("Compact view").icon(StackCompactIcon).action("setLayout").params({
      layout: "default"
    }),
    new MenuItemBuilder(context).group("layout").i18n({
      title: {
        key: "menu-items.layout.detailed-view",
        ns: structureLocaleNamespace
      }
    }).title("Detailed view").icon(StackIcon).action("setLayout").params({
      layout: "detail"
    })
    // Create new (from menu) will be added in serialization step of GenericList
  ]);
}
function hasIcon(schemaType) {
  return !schemaType || typeof schemaType == "string" ? false : !!schemaType.icon;
}
function getDefaultStructure(context) {
  const items = getDocumentTypeListItems(context);
  return new ListBuilder(context).id("__root__").title("Content").i18n({
    title: {
      key: "default-definition.content-title",
      ns: structureLocaleNamespace
    }
  }).items(items).showIcons(items.some((item) => hasIcon(item.getSchemaType())));
}
function createStructureBuilder({
  defaultDocumentNode,
  source,
  perspectiveStack
}) {
  const configContext = getConfigContextFromSource(source), context = {
    ...source,
    getStructureBuilder: () => structureBuilder,
    resolveDocumentNode: (options) => {
      let builder = defaultDocumentNode?.(structureBuilder, {
        ...options,
        ...configContext
      }) || new DocumentBuilder(context);
      return builder.getId() || (builder = builder.id("documentEditor")), options.documentId && (builder = builder.documentId(getPublishedId(options.documentId))), builder.schemaType(options.schemaType);
    },
    perspectiveStack
  }, structureBuilder = {
    defaults: () => getDefaultStructure(context),
    documentTypeList: (...args) => getDocumentTypeList(context, ...args),
    documentTypeListItem: (...args) => getDocumentTypeListItem(context, ...args),
    documentTypeListItems: (...args) => getDocumentTypeListItems(context, ...args),
    document: (...args) => new DocumentBuilder(context, ...args),
    documentWithInitialValueTemplate: (...args) => documentFromEditorWithInitialValue(context, ...args),
    defaultDocument: context.resolveDocumentNode,
    list: (...args) => new ListBuilder(context, ...args),
    listItem: (...args) => new ListItemBuilder(context, ...args),
    menuItem: (...args) => new MenuItemBuilder(context, ...args),
    menuItemGroup: (...args) => new MenuItemGroupBuilder(context, ...args),
    menuItemsFromInitialValueTemplateItems: (...args) => menuItemsFromInitialValueTemplateItems(context, ...args),
    documentList: (...args) => new DocumentListBuilder(context, ...args),
    documentListItem: (...args) => new DocumentListItemBuilder(context, ...args),
    orderingMenuItem: (...args) => getOrderingMenuItem(context, ...args),
    orderingMenuItemsForType: (...args) => getOrderingMenuItemsForSchemaType(context, ...args),
    editor: (...args) => documentFromEditor(context, ...args),
    defaultInitialValueTemplateItems: (...args) => defaultInitialValueTemplateItems(context, ...args),
    initialValueTemplateItem: (templateId, parameters) => new InitialValueTemplateItemBuilder(context, {
      id: templateId,
      parameters,
      templateId
    }),
    component: (spec) => (0, import_react_is.isValidElementType)(spec) ? new ComponentBuilder().component(spec) : new ComponentBuilder(spec),
    divider: (spec) => new DividerBuilder(spec),
    view: views,
    context
  };
  return structureBuilder;
}
function StructureToolProvider(t0) {
  const $ = (0, import_compiler_runtime.c)(26), {
    defaultDocumentNode,
    structure: resolveStructure,
    children
  } = t0, [layoutCollapsed, setLayoutCollapsed] = (0, import_react.useState)(false), source = useSource(), configContext = useConfigContextFromSource(source), documentStore = useDocumentStore(), {
    perspectiveStack
  } = usePerspective();
  let t1;
  $[0] !== defaultDocumentNode || $[1] !== perspectiveStack || $[2] !== source ? (t1 = createStructureBuilder({
    defaultDocumentNode,
    source,
    perspectiveStack
  }), $[0] = defaultDocumentNode, $[1] = perspectiveStack, $[2] = source, $[3] = t1) : t1 = $[3];
  const S = t1;
  let t2;
  bb0: {
    if (resolveStructure) {
      let t33;
      $[4] !== S || $[5] !== configContext || $[6] !== documentStore || $[7] !== perspectiveStack || $[8] !== resolveStructure ? (t33 = resolveStructure(S, {
        ...configContext,
        documentStore,
        perspectiveStack
      }), $[4] = S, $[5] = configContext, $[6] = documentStore, $[7] = perspectiveStack, $[8] = resolveStructure, $[9] = t33) : t33 = $[9], t2 = t33;
      break bb0;
    }
    let t32;
    $[10] !== S ? (t32 = S.defaults(), $[10] = S, $[11] = t32) : t32 = $[11], t2 = t32;
  }
  const rootPaneNode = t2, t3 = !layoutCollapsed, t4 = !layoutCollapsed, t5 = !layoutCollapsed, t6 = !layoutCollapsed;
  let t7;
  $[12] !== layoutCollapsed || $[13] !== t3 || $[14] !== t4 || $[15] !== t5 || $[16] !== t6 ? (t7 = {
    backButton: layoutCollapsed,
    resizablePanes: t3,
    reviewChanges: t4,
    splitPanes: t5,
    splitViews: t6
  }, $[12] = layoutCollapsed, $[13] = t3, $[14] = t4, $[15] = t5, $[16] = t6, $[17] = t7) : t7 = $[17];
  const features = t7;
  let t8;
  $[18] !== S.context || $[19] !== features || $[20] !== layoutCollapsed || $[21] !== rootPaneNode ? (t8 = {
    features,
    layoutCollapsed,
    setLayoutCollapsed,
    rootPaneNode,
    structureContext: S.context
  }, $[18] = S.context, $[19] = features, $[20] = layoutCollapsed, $[21] = rootPaneNode, $[22] = t8) : t8 = $[22];
  const structureTool2 = t8;
  let t9;
  return $[23] !== children || $[24] !== structureTool2 ? (t9 = (0, import_jsx_runtime.jsx)(StructureToolContext.Provider, { value: structureTool2, children }), $[23] = children, $[24] = structureTool2, $[25] = t9) : t9 = $[25], t9;
}

// node_modules/sanity/lib/_chunks-es/pane.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_compiler_runtime2 = __toESM(require_compiler_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_shallow_equals = __toESM(require_shallow_equals(), 1);

// node_modules/scrollmirror/dist/ScrollMirror.modern.js
var e = () => new Promise((e2) => {
  requestAnimationFrame(() => e2());
});
var t = ({ clientWidth: e2, clientHeight: t2, scrollWidth: o2, scrollHeight: r2 }) => r2 > t2 || o2 > e2;
var o = (e2) => {
  const t2 = window.getComputedStyle(e2).overflow;
  return t2.includes("auto") || t2.includes("scroll");
};
var r = (e2) => {
  if (null == e2) return { x: 0, y: 0 };
  const { scrollTop: t2, scrollHeight: o2, clientHeight: r2, scrollLeft: n2, scrollWidth: l2, clientWidth: s2 } = e2, i = o2 - r2;
  return { x: n2 ? n2 / Math.max(1e-5, l2 - s2) : 0, y: t2 ? t2 / Math.max(1e-5, i) : 0 };
};
function n() {
  return n = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var o2 = arguments[t2];
      for (var r2 in o2) ({}).hasOwnProperty.call(o2, r2) && (e2[r2] = o2[r2]);
    }
    return e2;
  }, n.apply(null, arguments);
}
function l(e2) {
  return e2.matches("body *") ? e2 : window;
}
var s = class {
  constructor(l2, s2 = {}) {
    var i, c3 = this;
    this.elements = void 0, this.defaults = { vertical: true, horizontal: true, debug: true }, this.options = void 0, this.paused = false, this.logger = void 0, this.handleScroll = async function(t2) {
      if (c3.paused) return;
      if (!t2.currentTarget) return;
      const o2 = c3.getScrollContainer(t2.currentTarget);
      await e(), c3.mirrorScrollPositions(r(o2), o2);
    }, this.elements = [...l2].filter(Boolean).map((e2) => this.getScrollContainer(e2)), this.elements = [...new Set(this.elements)], this.options = n({}, this.defaults, s2), this.options.debug && (this.logger = (i = "[scroll-mirror]", { log: (...e2) => console.log(i, ...e2), warn: (...e2) => console.warn(i, ...e2), error: (...e2) => console.error(i, ...e2) }), (function(e2, r2) {
      if (e2.length < 1) null == r2 || r2.warn("No elements provided.");
      else {
        e2.length < 2 && (null == r2 || r2.warn("Only one element provided.", e2)), e2.some((e3) => !e3) && (null == r2 || r2.error("Some elements are not defined.", e2));
        for (const n2 of e2) n2 instanceof HTMLElement && !t(n2) && (null == r2 || r2.warn("Element doesn't have overflow:", n2)), n2 instanceof HTMLElement && n2.matches("body *") && !o(n2) && (null == r2 || r2.warn('No "overflow: auto;" or "overflow: scroll;" set on element:', n2));
      }
    })(this.elements, this.logger)), this.elements.forEach((e2) => this.addScrollHandler(e2)), this.elements.includes(document.documentElement) && this.mirrorScrollPositions(r(document.documentElement), document.documentElement);
  }
  pause() {
    this.paused = true;
  }
  resume() {
    this.paused = false;
  }
  destroy() {
    this.elements.forEach((e2) => this.removeScrollHandler(e2));
  }
  addScrollHandler(e2) {
    this.removeScrollHandler(e2), l(e2).addEventListener("scroll", this.handleScroll, { passive: true });
  }
  removeScrollHandler(e2) {
    l(e2).removeEventListener("scroll", this.handleScroll);
  }
  getScrollContainer(e2) {
    return e2 instanceof HTMLElement && e2.matches("body *") ? e2 : document.documentElement;
  }
  mirrorScrollPositions(e2, t2 = void 0) {
    this.elements.forEach((o2) => {
      t2 !== o2 && (this.removeScrollHandler(o2), this.setScrollPosition(e2, o2), window.requestAnimationFrame(() => {
        this.addScrollHandler(o2);
      }));
    });
  }
  setScrollPosition(e2, t2) {
    const { vertical: o2, horizontal: r2 } = this.options, n2 = t2.scrollWidth - t2.clientWidth, l2 = t2.scrollHeight - t2.clientHeight;
    o2 && l2 && t2.scrollTo({ top: l2 * e2.y, behavior: "instant" }), r2 && n2 && t2.scrollTo({ left: n2 * e2.x, behavior: "instant" });
  }
  get progress() {
    const e2 = this.elements.find((e3) => t(e3));
    return r(e2);
  }
  set progress(e2) {
    "number" == typeof e2 && (e2 = { x: e2, y: e2 });
    const t2 = n({}, this.progress, e2);
    (function(e3, t3) {
      let o2 = true;
      for (const [r2, n2] of Object.entries(e3)) ("number" != typeof n2 || n2 < 0 || n2 > 1) && (null == t3 || t3.error(`progress.${r2} must be a number between 0-1`), o2 = false);
      return o2;
    })(t2, this.logger) && this.mirrorScrollPositions(t2);
  }
};

// node_modules/sanity/lib/_chunks-es/pane.js
var import_react_fast_compare = __toESM(require_react_fast_compare(), 1);

// node_modules/@tanstack/react-table/build/lib/index.mjs
var React = __toESM(require_react(), 1);

// node_modules/@tanstack/table-core/build/lib/index.mjs
function createColumnHelper() {
  return {
    accessor: (accessor, column) => {
      return typeof accessor === "function" ? {
        ...column,
        accessorFn: accessor
      } : {
        ...column,
        accessorKey: accessor
      };
    },
    display: (column) => column,
    group: (column) => column
  };
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function makeStateUpdater(key, instance) {
  return (updater) => {
    instance.setState((old) => {
      return {
        ...old,
        [key]: functionalUpdate(updater, old[key])
      };
    });
  };
}
function isFunction(d) {
  return d instanceof Function;
}
function isNumberArray(d) {
  return Array.isArray(d) && d.every((val) => typeof val === "number");
}
function flattenBy(arr, getChildren) {
  const flat = [];
  const recurse = (subArr) => {
    subArr.forEach((item) => {
      flat.push(item);
      const children = getChildren(item);
      if (children != null && children.length) {
        recurse(children);
      }
    });
  };
  recurse(arr);
  return flat;
}
function memo(getDeps, fn, opts) {
  let deps = [];
  let result;
  return (depArgs) => {
    let depTime;
    if (opts.key && opts.debug) depTime = Date.now();
    const newDeps = getDeps(depArgs);
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && opts.debug) resultTime = Date.now();
    result = fn(...newDeps);
    opts == null || opts.onChange == null || opts.onChange(result);
    if (opts.key && opts.debug) {
      if (opts != null && opts.debug()) {
        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
        const resultFpsPercentage = resultEndTime / 16;
        const pad = (str, num) => {
          str = String(str);
          while (str.length < num) {
            str = " " + str;
          }
          return str;
        };
        console.info(`%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);
      }
    }
    return result;
  };
}
function getMemoOptions(tableOptions, debugLevel, key, onChange) {
  return {
    debug: () => {
      var _tableOptions$debugAl;
      return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];
    },
    key,
    onChange
  };
}
function createCell(table, row, column, columnId) {
  const getRenderValue = () => {
    var _cell$getValue;
    return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;
  };
  const cell = {
    id: `${row.id}_${column.id}`,
    row,
    column,
    getValue: () => row.getValue(columnId),
    renderValue: getRenderValue,
    getContext: memo(() => [table, column, row, cell], (table2, column2, row2, cell2) => ({
      table: table2,
      column: column2,
      row: row2,
      cell: cell2,
      getValue: cell2.getValue,
      renderValue: cell2.renderValue
    }), getMemoOptions(table.options, "debugCells", "cell.getContext"))
  };
  table._features.forEach((feature) => {
    feature.createCell == null || feature.createCell(cell, column, row, table);
  }, {});
  return cell;
}
function createColumn(table, columnDef, depth, parent) {
  var _ref, _resolvedColumnDef$id;
  const defaultColumn = table._getDefaultColumnDef();
  const resolvedColumnDef = {
    ...defaultColumn,
    ...columnDef
  };
  const accessorKey = resolvedColumnDef.accessorKey;
  let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? typeof String.prototype.replaceAll === "function" ? accessorKey.replaceAll(".", "_") : accessorKey.replace(/\./g, "_") : void 0) != null ? _ref : typeof resolvedColumnDef.header === "string" ? resolvedColumnDef.header : void 0;
  let accessorFn;
  if (resolvedColumnDef.accessorFn) {
    accessorFn = resolvedColumnDef.accessorFn;
  } else if (accessorKey) {
    if (accessorKey.includes(".")) {
      accessorFn = (originalRow) => {
        let result = originalRow;
        for (const key of accessorKey.split(".")) {
          var _result;
          result = (_result = result) == null ? void 0 : _result[key];
          if (result === void 0) {
            console.warn(`"${key}" in deeply nested key "${accessorKey}" returned undefined.`);
          }
        }
        return result;
      };
    } else {
      accessorFn = (originalRow) => originalRow[resolvedColumnDef.accessorKey];
    }
  }
  if (!id) {
    if (true) {
      throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);
    }
    throw new Error();
  }
  let column = {
    id: `${String(id)}`,
    accessorFn,
    parent,
    depth,
    columnDef: resolvedColumnDef,
    columns: [],
    getFlatColumns: memo(() => [true], () => {
      var _column$columns;
      return [column, ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d) => d.getFlatColumns())];
    }, getMemoOptions(table.options, "debugColumns", "column.getFlatColumns")),
    getLeafColumns: memo(() => [table._getOrderColumnsFn()], (orderColumns2) => {
      var _column$columns2;
      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {
        let leafColumns = column.columns.flatMap((column2) => column2.getLeafColumns());
        return orderColumns2(leafColumns);
      }
      return [column];
    }, getMemoOptions(table.options, "debugColumns", "column.getLeafColumns"))
  };
  for (const feature of table._features) {
    feature.createColumn == null || feature.createColumn(column, table);
  }
  return column;
}
var debug = "debugHeaders";
function createHeader(table, column, options) {
  var _options$id;
  const id = (_options$id = options.id) != null ? _options$id : column.id;
  let header = {
    id,
    column,
    index: options.index,
    isPlaceholder: !!options.isPlaceholder,
    placeholderId: options.placeholderId,
    depth: options.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const leafHeaders = [];
      const recurseHeader = (h) => {
        if (h.subHeaders && h.subHeaders.length) {
          h.subHeaders.map(recurseHeader);
        }
        leafHeaders.push(h);
      };
      recurseHeader(header);
      return leafHeaders;
    },
    getContext: () => ({
      table,
      header,
      column
    })
  };
  table._features.forEach((feature) => {
    feature.createHeader == null || feature.createHeader(header, table);
  });
  return header;
}
var Headers = {
  createTable: (table) => {
    table.getHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
      var _left$map$filter, _right$map$filter;
      const leftColumns = (_left$map$filter = left == null ? void 0 : left.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];
      const rightColumns = (_right$map$filter = right == null ? void 0 : right.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];
      const centerColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
      const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);
      return headerGroups;
    }, getMemoOptions(table.options, debug, "getHeaderGroups"));
    table.getCenterHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
      leafColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
      return buildHeaderGroups(allColumns, leafColumns, table, "center");
    }, getMemoOptions(table.options, debug, "getCenterHeaderGroups"));
    table.getLeftHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left) => {
      var _left$map$filter2;
      const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, "left");
    }, getMemoOptions(table.options, debug, "getLeftHeaderGroups"));
    table.getRightHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right) => {
      var _right$map$filter2;
      const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, "right");
    }, getMemoOptions(table.options, debug, "getRightHeaderGroups"));
    table.getFooterGroups = memo(() => [table.getHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getFooterGroups"));
    table.getLeftFooterGroups = memo(() => [table.getLeftHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getLeftFooterGroups"));
    table.getCenterFooterGroups = memo(() => [table.getCenterHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getCenterFooterGroups"));
    table.getRightFooterGroups = memo(() => [table.getRightHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getRightFooterGroups"));
    table.getFlatHeaders = memo(() => [table.getHeaderGroups()], (headerGroups) => {
      return headerGroups.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getFlatHeaders"));
    table.getLeftFlatHeaders = memo(() => [table.getLeftHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getLeftFlatHeaders"));
    table.getCenterFlatHeaders = memo(() => [table.getCenterHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getCenterFlatHeaders"));
    table.getRightFlatHeaders = memo(() => [table.getRightHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getRightFlatHeaders"));
    table.getCenterLeafHeaders = memo(() => [table.getCenterFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders;
        return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);
      });
    }, getMemoOptions(table.options, debug, "getCenterLeafHeaders"));
    table.getLeftLeafHeaders = memo(() => [table.getLeftFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders2;
        return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);
      });
    }, getMemoOptions(table.options, debug, "getLeftLeafHeaders"));
    table.getRightLeafHeaders = memo(() => [table.getRightFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders3;
        return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);
      });
    }, getMemoOptions(table.options, debug, "getRightLeafHeaders"));
    table.getLeafHeaders = memo(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left, center, right) => {
      var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;
      return [...(_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [], ...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [], ...(_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []].map((header) => {
        return header.getLeafHeaders();
      }).flat();
    }, getMemoOptions(table.options, debug, "getLeafHeaders"));
  }
};
function buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {
  var _headerGroups$0$heade, _headerGroups$;
  let maxDepth = 0;
  const findMaxDepth = function(columns, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    maxDepth = Math.max(maxDepth, depth);
    columns.filter((column) => column.getIsVisible()).forEach((column) => {
      var _column$columns;
      if ((_column$columns = column.columns) != null && _column$columns.length) {
        findMaxDepth(column.columns, depth + 1);
      }
    }, 0);
  };
  findMaxDepth(allColumns);
  let headerGroups = [];
  const createHeaderGroup = (headersToGroup, depth) => {
    const headerGroup = {
      depth,
      id: [headerFamily, `${depth}`].filter(Boolean).join("_"),
      headers: []
    };
    const pendingParentHeaders = [];
    headersToGroup.forEach((headerToGroup) => {
      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];
      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;
      let column;
      let isPlaceholder = false;
      if (isLeafHeader && headerToGroup.column.parent) {
        column = headerToGroup.column.parent;
      } else {
        column = headerToGroup.column;
        isPlaceholder = true;
      }
      if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {
        latestPendingParentHeader.subHeaders.push(headerToGroup);
      } else {
        const header = createHeader(table, column, {
          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join("_"),
          isPlaceholder,
          placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d) => d.column === column).length}` : void 0,
          depth,
          index: pendingParentHeaders.length
        });
        header.subHeaders.push(headerToGroup);
        pendingParentHeaders.push(header);
      }
      headerGroup.headers.push(headerToGroup);
      headerToGroup.headerGroup = headerGroup;
    });
    headerGroups.push(headerGroup);
    if (depth > 0) {
      createHeaderGroup(pendingParentHeaders, depth - 1);
    }
  };
  const bottomHeaders = columnsToGroup.map((column, index) => createHeader(table, column, {
    depth: maxDepth,
    index
  }));
  createHeaderGroup(bottomHeaders, maxDepth - 1);
  headerGroups.reverse();
  const recurseHeadersForSpans = (headers) => {
    const filteredHeaders = headers.filter((header) => header.column.getIsVisible());
    return filteredHeaders.map((header) => {
      let colSpan = 0;
      let rowSpan = 0;
      let childRowSpans = [0];
      if (header.subHeaders && header.subHeaders.length) {
        childRowSpans = [];
        recurseHeadersForSpans(header.subHeaders).forEach((_ref) => {
          let {
            colSpan: childColSpan,
            rowSpan: childRowSpan
          } = _ref;
          colSpan += childColSpan;
          childRowSpans.push(childRowSpan);
        });
      } else {
        colSpan = 1;
      }
      const minChildRowSpan = Math.min(...childRowSpans);
      rowSpan = rowSpan + minChildRowSpan;
      header.colSpan = colSpan;
      header.rowSpan = rowSpan;
      return {
        colSpan,
        rowSpan
      };
    });
  };
  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);
  return headerGroups;
}
var createRow = (table, id, original, rowIndex, depth, subRows, parentId) => {
  let row = {
    id,
    index: rowIndex,
    original,
    depth,
    parentId,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: (columnId) => {
      if (row._valuesCache.hasOwnProperty(columnId)) {
        return row._valuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return void 0;
      }
      row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);
      return row._valuesCache[columnId];
    },
    getUniqueValues: (columnId) => {
      if (row._uniqueValuesCache.hasOwnProperty(columnId)) {
        return row._uniqueValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return void 0;
      }
      if (!column.columnDef.getUniqueValues) {
        row._uniqueValuesCache[columnId] = [row.getValue(columnId)];
        return row._uniqueValuesCache[columnId];
      }
      row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);
      return row._uniqueValuesCache[columnId];
    },
    renderValue: (columnId) => {
      var _row$getValue;
      return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;
    },
    subRows: subRows != null ? subRows : [],
    getLeafRows: () => flattenBy(row.subRows, (d) => d.subRows),
    getParentRow: () => row.parentId ? table.getRow(row.parentId, true) : void 0,
    getParentRows: () => {
      let parentRows = [];
      let currentRow = row;
      while (true) {
        const parentRow = currentRow.getParentRow();
        if (!parentRow) break;
        parentRows.push(parentRow);
        currentRow = parentRow;
      }
      return parentRows.reverse();
    },
    getAllCells: memo(() => [table.getAllLeafColumns()], (leafColumns) => {
      return leafColumns.map((column) => {
        return createCell(table, row, column, column.id);
      });
    }, getMemoOptions(table.options, "debugRows", "getAllCells")),
    _getAllCellsByColumnId: memo(() => [row.getAllCells()], (allCells) => {
      return allCells.reduce((acc, cell) => {
        acc[cell.column.id] = cell;
        return acc;
      }, {});
    }, getMemoOptions(table.options, "debugRows", "getAllCellsByColumnId"))
  };
  for (let i = 0; i < table._features.length; i++) {
    const feature = table._features[i];
    feature == null || feature.createRow == null || feature.createRow(row, table);
  }
  return row;
};
var ColumnFaceting = {
  createColumn: (column, table) => {
    column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);
    column.getFacetedRowModel = () => {
      if (!column._getFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return column._getFacetedRowModel();
    };
    column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);
    column.getFacetedUniqueValues = () => {
      if (!column._getFacetedUniqueValues) {
        return /* @__PURE__ */ new Map();
      }
      return column._getFacetedUniqueValues();
    };
    column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);
    column.getFacetedMinMaxValues = () => {
      if (!column._getFacetedMinMaxValues) {
        return void 0;
      }
      return column._getFacetedMinMaxValues();
    };
  }
};
var includesString = (row, columnId, filterValue) => {
  var _filterValue$toString, _row$getValue;
  const search = filterValue == null || (_filterValue$toString = filterValue.toString()) == null ? void 0 : _filterValue$toString.toLowerCase();
  return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));
};
includesString.autoRemove = (val) => testFalsey(val);
var includesStringSensitive = (row, columnId, filterValue) => {
  var _row$getValue2;
  return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));
};
includesStringSensitive.autoRemove = (val) => testFalsey(val);
var equalsString = (row, columnId, filterValue) => {
  var _row$getValue3;
  return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());
};
equalsString.autoRemove = (val) => testFalsey(val);
var arrIncludes = (row, columnId, filterValue) => {
  var _row$getValue4;
  return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);
};
arrIncludes.autoRemove = (val) => testFalsey(val);
var arrIncludesAll = (row, columnId, filterValue) => {
  return !filterValue.some((val) => {
    var _row$getValue5;
    return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));
  });
};
arrIncludesAll.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var arrIncludesSome = (row, columnId, filterValue) => {
  return filterValue.some((val) => {
    var _row$getValue6;
    return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);
  });
};
arrIncludesSome.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var equals = (row, columnId, filterValue) => {
  return row.getValue(columnId) === filterValue;
};
equals.autoRemove = (val) => testFalsey(val);
var weakEquals = (row, columnId, filterValue) => {
  return row.getValue(columnId) == filterValue;
};
weakEquals.autoRemove = (val) => testFalsey(val);
var inNumberRange = (row, columnId, filterValue) => {
  let [min2, max2] = filterValue;
  const rowValue = row.getValue(columnId);
  return rowValue >= min2 && rowValue <= max2;
};
inNumberRange.resolveFilterValue = (val) => {
  let [unsafeMin, unsafeMax] = val;
  let parsedMin = typeof unsafeMin !== "number" ? parseFloat(unsafeMin) : unsafeMin;
  let parsedMax = typeof unsafeMax !== "number" ? parseFloat(unsafeMax) : unsafeMax;
  let min2 = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;
  let max2 = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;
  if (min2 > max2) {
    const temp = min2;
    min2 = max2;
    max2 = temp;
  }
  return [min2, max2];
};
inNumberRange.autoRemove = (val) => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);
var filterFns = {
  includesString,
  includesStringSensitive,
  equalsString,
  arrIncludes,
  arrIncludesAll,
  arrIncludesSome,
  equals,
  weakEquals,
  inNumberRange
};
function testFalsey(val) {
  return val === void 0 || val === null || val === "";
}
var ColumnFiltering = {
  getDefaultColumnDef: () => {
    return {
      filterFn: "auto"
    };
  },
  getInitialState: (state2) => {
    return {
      columnFilters: [],
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnFiltersChange: makeStateUpdater("columnFilters", table),
      filterFromLeafRows: false,
      maxLeafRowFilterDepth: 100
    };
  },
  createColumn: (column, table) => {
    column.getAutoFilterFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === "string") {
        return filterFns.includesString;
      }
      if (typeof value === "number") {
        return filterFns.inNumberRange;
      }
      if (typeof value === "boolean") {
        return filterFns.equals;
      }
      if (value !== null && typeof value === "object") {
        return filterFns.equals;
      }
      if (Array.isArray(value)) {
        return filterFns.arrIncludes;
      }
      return filterFns.weakEquals;
    };
    column.getFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === "auto" ? column.getAutoFilterFn() : (
        // @ts-ignore
        (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn]
      );
    };
    column.getCanFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2;
      return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;
    };
    column.getIsFiltered = () => column.getFilterIndex() > -1;
    column.getFilterValue = () => {
      var _table$getState$colum;
      return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d) => d.id === column.id)) == null ? void 0 : _table$getState$colum.value;
    };
    column.getFilterIndex = () => {
      var _table$getState$colum2, _table$getState$colum3;
      return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d) => d.id === column.id)) != null ? _table$getState$colum2 : -1;
    };
    column.setFilterValue = (value) => {
      table.setColumnFilters((old) => {
        const filterFn = column.getFilterFn();
        const previousFilter = old == null ? void 0 : old.find((d) => d.id === column.id);
        const newFilter = functionalUpdate(value, previousFilter ? previousFilter.value : void 0);
        if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {
          var _old$filter;
          return (_old$filter = old == null ? void 0 : old.filter((d) => d.id !== column.id)) != null ? _old$filter : [];
        }
        const newFilterObj = {
          id: column.id,
          value: newFilter
        };
        if (previousFilter) {
          var _old$map;
          return (_old$map = old == null ? void 0 : old.map((d) => {
            if (d.id === column.id) {
              return newFilterObj;
            }
            return d;
          })) != null ? _old$map : [];
        }
        if (old != null && old.length) {
          return [...old, newFilterObj];
        }
        return [newFilterObj];
      });
    };
  },
  createRow: (row, _table) => {
    row.columnFilters = {};
    row.columnFiltersMeta = {};
  },
  createTable: (table) => {
    table.setColumnFilters = (updater) => {
      const leafColumns = table.getAllLeafColumns();
      const updateFn = (old) => {
        var _functionalUpdate;
        return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter2) => {
          const column = leafColumns.find((d) => d.id === filter2.id);
          if (column) {
            const filterFn = column.getFilterFn();
            if (shouldAutoRemoveFilter(filterFn, filter2.value, column)) {
              return false;
            }
          }
          return true;
        });
      };
      table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);
    };
    table.resetColumnFilters = (defaultState) => {
      var _table$initialState$c, _table$initialState;
      table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);
    };
    table.getPreFilteredRowModel = () => table.getCoreRowModel();
    table.getFilteredRowModel = () => {
      if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {
        table._getFilteredRowModel = table.options.getFilteredRowModel(table);
      }
      if (table.options.manualFiltering || !table._getFilteredRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getFilteredRowModel();
    };
  }
};
function shouldAutoRemoveFilter(filterFn, value, column) {
  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === "undefined" || typeof value === "string" && !value;
}
var sum = (columnId, _leafRows, childRows) => {
  return childRows.reduce((sum2, next) => {
    const nextValue = next.getValue(columnId);
    return sum2 + (typeof nextValue === "number" ? nextValue : 0);
  }, 0);
};
var min = (columnId, _leafRows, childRows) => {
  let min2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
      min2 = value;
    }
  });
  return min2;
};
var max = (columnId, _leafRows, childRows) => {
  let max2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
      max2 = value;
    }
  });
  return max2;
};
var extent = (columnId, _leafRows, childRows) => {
  let min2;
  let max2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null) {
      if (min2 === void 0) {
        if (value >= value) min2 = max2 = value;
      } else {
        if (min2 > value) min2 = value;
        if (max2 < value) max2 = value;
      }
    }
  });
  return [min2, max2];
};
var mean = (columnId, leafRows) => {
  let count2 = 0;
  let sum2 = 0;
  leafRows.forEach((row) => {
    let value = row.getValue(columnId);
    if (value != null && (value = +value) >= value) {
      ++count2, sum2 += value;
    }
  });
  if (count2) return sum2 / count2;
  return;
};
var median = (columnId, leafRows) => {
  if (!leafRows.length) {
    return;
  }
  const values = leafRows.map((row) => row.getValue(columnId));
  if (!isNumberArray(values)) {
    return;
  }
  if (values.length === 1) {
    return values[0];
  }
  const mid = Math.floor(values.length / 2);
  const nums = values.sort((a, b) => a - b);
  return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;
};
var unique = (columnId, leafRows) => {
  return Array.from(new Set(leafRows.map((d) => d.getValue(columnId))).values());
};
var uniqueCount = (columnId, leafRows) => {
  return new Set(leafRows.map((d) => d.getValue(columnId))).size;
};
var count = (_columnId, leafRows) => {
  return leafRows.length;
};
var aggregationFns = {
  sum,
  min,
  max,
  extent,
  mean,
  median,
  unique,
  uniqueCount,
  count
};
var ColumnGrouping = {
  getDefaultColumnDef: () => {
    return {
      aggregatedCell: (props) => {
        var _toString, _props$getValue;
        return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;
      },
      aggregationFn: "auto"
    };
  },
  getInitialState: (state2) => {
    return {
      grouping: [],
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onGroupingChange: makeStateUpdater("grouping", table),
      groupedColumnMode: "reorder"
    };
  },
  createColumn: (column, table) => {
    column.toggleGrouping = () => {
      table.setGrouping((old) => {
        if (old != null && old.includes(column.id)) {
          return old.filter((d) => d !== column.id);
        }
        return [...old != null ? old : [], column.id];
      });
    };
    column.getCanGroup = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGrouping) != null ? _table$options$enable : true) && (!!column.accessorFn || !!column.columnDef.getGroupingValue);
    };
    column.getIsGrouped = () => {
      var _table$getState$group;
      return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);
    };
    column.getGroupedIndex = () => {
      var _table$getState$group2;
      return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);
    };
    column.getToggleGroupingHandler = () => {
      const canGroup = column.getCanGroup();
      return () => {
        if (!canGroup) return;
        column.toggleGrouping();
      };
    };
    column.getAutoAggregationFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === "number") {
        return aggregationFns.sum;
      }
      if (Object.prototype.toString.call(value) === "[object Date]") {
        return aggregationFns.extent;
      }
    };
    column.getAggregationFn = () => {
      var _table$options$aggreg, _table$options$aggreg2;
      if (!column) {
        throw new Error();
      }
      return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === "auto" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];
    };
  },
  createTable: (table) => {
    table.setGrouping = (updater) => table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);
    table.resetGrouping = (defaultState) => {
      var _table$initialState$g, _table$initialState;
      table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);
    };
    table.getPreGroupedRowModel = () => table.getFilteredRowModel();
    table.getGroupedRowModel = () => {
      if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {
        table._getGroupedRowModel = table.options.getGroupedRowModel(table);
      }
      if (table.options.manualGrouping || !table._getGroupedRowModel) {
        return table.getPreGroupedRowModel();
      }
      return table._getGroupedRowModel();
    };
  },
  createRow: (row, table) => {
    row.getIsGrouped = () => !!row.groupingColumnId;
    row.getGroupingValue = (columnId) => {
      if (row._groupingValuesCache.hasOwnProperty(columnId)) {
        return row._groupingValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.columnDef.getGroupingValue)) {
        return row.getValue(columnId);
      }
      row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);
      return row._groupingValuesCache[columnId];
    };
    row._groupingValuesCache = {};
  },
  createCell: (cell, column, row, table) => {
    cell.getIsGrouped = () => column.getIsGrouped() && column.id === row.groupingColumnId;
    cell.getIsPlaceholder = () => !cell.getIsGrouped() && column.getIsGrouped();
    cell.getIsAggregated = () => {
      var _row$subRows;
      return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
  }
};
function orderColumns(leafColumns, grouping, groupedColumnMode) {
  if (!(grouping != null && grouping.length) || !groupedColumnMode) {
    return leafColumns;
  }
  const nonGroupingColumns = leafColumns.filter((col) => !grouping.includes(col.id));
  if (groupedColumnMode === "remove") {
    return nonGroupingColumns;
  }
  const groupingColumns = grouping.map((g) => leafColumns.find((col) => col.id === g)).filter(Boolean);
  return [...groupingColumns, ...nonGroupingColumns];
}
var ColumnOrdering = {
  getInitialState: (state2) => {
    return {
      columnOrder: [],
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnOrderChange: makeStateUpdater("columnOrder", table)
    };
  },
  createColumn: (column, table) => {
    column.getIndex = memo((position) => [_getVisibleLeafColumns(table, position)], (columns) => columns.findIndex((d) => d.id === column.id), getMemoOptions(table.options, "debugColumns", "getIndex"));
    column.getIsFirstColumn = (position) => {
      var _columns$;
      const columns = _getVisibleLeafColumns(table, position);
      return ((_columns$ = columns[0]) == null ? void 0 : _columns$.id) === column.id;
    };
    column.getIsLastColumn = (position) => {
      var _columns;
      const columns = _getVisibleLeafColumns(table, position);
      return ((_columns = columns[columns.length - 1]) == null ? void 0 : _columns.id) === column.id;
    };
  },
  createTable: (table) => {
    table.setColumnOrder = (updater) => table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);
    table.resetColumnOrder = (defaultState) => {
      var _table$initialState$c;
      table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);
    };
    table._getOrderColumnsFn = memo(() => [table.getState().columnOrder, table.getState().grouping, table.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => (columns) => {
      let orderedColumns = [];
      if (!(columnOrder != null && columnOrder.length)) {
        orderedColumns = columns;
      } else {
        const columnOrderCopy = [...columnOrder];
        const columnsCopy = [...columns];
        while (columnsCopy.length && columnOrderCopy.length) {
          const targetColumnId = columnOrderCopy.shift();
          const foundIndex = columnsCopy.findIndex((d) => d.id === targetColumnId);
          if (foundIndex > -1) {
            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);
          }
        }
        orderedColumns = [...orderedColumns, ...columnsCopy];
      }
      return orderColumns(orderedColumns, grouping, groupedColumnMode);
    }, getMemoOptions(table.options, "debugTable", "_getOrderColumnsFn"));
  }
};
var getDefaultColumnPinningState = () => ({
  left: [],
  right: []
});
var ColumnPinning = {
  getInitialState: (state2) => {
    return {
      columnPinning: getDefaultColumnPinningState(),
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnPinningChange: makeStateUpdater("columnPinning", table)
    };
  },
  createColumn: (column, table) => {
    column.pin = (position) => {
      const columnIds = column.getLeafColumns().map((d) => d.id).filter(Boolean);
      table.setColumnPinning((old) => {
        var _old$left3, _old$right3;
        if (position === "right") {
          var _old$left, _old$right;
          return {
            left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d) => !(columnIds != null && columnIds.includes(d))),
            right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d) => !(columnIds != null && columnIds.includes(d))), ...columnIds]
          };
        }
        if (position === "left") {
          var _old$left2, _old$right2;
          return {
            left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d) => !(columnIds != null && columnIds.includes(d))), ...columnIds],
            right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d) => !(columnIds != null && columnIds.includes(d)))
          };
        }
        return {
          left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d) => !(columnIds != null && columnIds.includes(d))),
          right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d) => !(columnIds != null && columnIds.includes(d)))
        };
      });
    };
    column.getCanPin = () => {
      const leafColumns = column.getLeafColumns();
      return leafColumns.some((d) => {
        var _d$columnDef$enablePi, _ref, _table$options$enable;
        return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);
      });
    };
    column.getIsPinned = () => {
      const leafColumnIds = column.getLeafColumns().map((d) => d.id);
      const {
        left,
        right
      } = table.getState().columnPinning;
      const isLeft = leafColumnIds.some((d) => left == null ? void 0 : left.includes(d));
      const isRight = leafColumnIds.some((d) => right == null ? void 0 : right.includes(d));
      return isLeft ? "left" : isRight ? "right" : false;
    };
    column.getPinnedIndex = () => {
      var _table$getState$colum, _table$getState$colum2;
      const position = column.getIsPinned();
      return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;
    };
  },
  createRow: (row, table) => {
    row.getCenterVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allCells, left, right) => {
      const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
      return allCells.filter((d) => !leftAndRight.includes(d.column.id));
    }, getMemoOptions(table.options, "debugRows", "getCenterVisibleCells"));
    row.getLeftVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left], (allCells, left) => {
      const cells = (left != null ? left : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d) => ({
        ...d,
        position: "left"
      }));
      return cells;
    }, getMemoOptions(table.options, "debugRows", "getLeftVisibleCells"));
    row.getRightVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right) => {
      const cells = (right != null ? right : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d) => ({
        ...d,
        position: "right"
      }));
      return cells;
    }, getMemoOptions(table.options, "debugRows", "getRightVisibleCells"));
  },
  createTable: (table) => {
    table.setColumnPinning = (updater) => table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);
    table.resetColumnPinning = (defaultState) => {
      var _table$initialState$c, _table$initialState;
      return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());
    };
    table.getIsSomeColumnsPinned = (position) => {
      var _pinningState$positio;
      const pinningState = table.getState().columnPinning;
      if (!position) {
        var _pinningState$left, _pinningState$right;
        return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));
      }
      return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
    };
    table.getLeftLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left) => {
      return (left != null ? left : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, "debugColumns", "getLeftLeafColumns"));
    table.getRightLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right) => {
      return (right != null ? right : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, "debugColumns", "getRightLeafColumns"));
    table.getCenterLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, left, right) => {
      const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
      return allColumns.filter((d) => !leftAndRight.includes(d.id));
    }, getMemoOptions(table.options, "debugColumns", "getCenterLeafColumns"));
  }
};
function safelyAccessDocument(_document) {
  return _document || (typeof document !== "undefined" ? document : null);
}
var defaultColumnSizing = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
};
var getDefaultColumnSizingInfoState = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: false,
  columnSizingStart: []
});
var ColumnSizing = {
  getDefaultColumnDef: () => {
    return defaultColumnSizing;
  },
  getInitialState: (state2) => {
    return {
      columnSizing: {},
      columnSizingInfo: getDefaultColumnSizingInfoState(),
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      columnResizeMode: "onEnd",
      columnResizeDirection: "ltr",
      onColumnSizingChange: makeStateUpdater("columnSizing", table),
      onColumnSizingInfoChange: makeStateUpdater("columnSizingInfo", table)
    };
  },
  createColumn: (column, table) => {
    column.getSize = () => {
      var _column$columnDef$min, _ref, _column$columnDef$max;
      const columnSize = table.getState().columnSizing[column.id];
      return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);
    };
    column.getStart = memo((position) => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(0, column.getIndex(position)).reduce((sum2, column2) => sum2 + column2.getSize(), 0), getMemoOptions(table.options, "debugColumns", "getStart"));
    column.getAfter = memo((position) => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(column.getIndex(position) + 1).reduce((sum2, column2) => sum2 + column2.getSize(), 0), getMemoOptions(table.options, "debugColumns", "getAfter"));
    column.resetSize = () => {
      table.setColumnSizing((_ref2) => {
        let {
          [column.id]: _,
          ...rest
        } = _ref2;
        return rest;
      });
    };
    column.getCanResize = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);
    };
    column.getIsResizing = () => {
      return table.getState().columnSizingInfo.isResizingColumn === column.id;
    };
  },
  createHeader: (header, table) => {
    header.getSize = () => {
      let sum2 = 0;
      const recurse = (header2) => {
        if (header2.subHeaders.length) {
          header2.subHeaders.forEach(recurse);
        } else {
          var _header$column$getSiz;
          sum2 += (_header$column$getSiz = header2.column.getSize()) != null ? _header$column$getSiz : 0;
        }
      };
      recurse(header);
      return sum2;
    };
    header.getStart = () => {
      if (header.index > 0) {
        const prevSiblingHeader = header.headerGroup.headers[header.index - 1];
        return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();
      }
      return 0;
    };
    header.getResizeHandler = (_contextDocument) => {
      const column = table.getColumn(header.column.id);
      const canResize = column == null ? void 0 : column.getCanResize();
      return (e2) => {
        if (!column || !canResize) {
          return;
        }
        e2.persist == null || e2.persist();
        if (isTouchStartEvent(e2)) {
          if (e2.touches && e2.touches.length > 1) {
            return;
          }
        }
        const startSize = header.getSize();
        const columnSizingStart = header ? header.getLeafHeaders().map((d) => [d.column.id, d.column.getSize()]) : [[column.id, column.getSize()]];
        const clientX = isTouchStartEvent(e2) ? Math.round(e2.touches[0].clientX) : e2.clientX;
        const newColumnSizing = {};
        const updateOffset = (eventType, clientXPos) => {
          if (typeof clientXPos !== "number") {
            return;
          }
          table.setColumnSizingInfo((old) => {
            var _old$startOffset, _old$startSize;
            const deltaDirection = table.options.columnResizeDirection === "rtl" ? -1 : 1;
            const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;
            const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);
            old.columnSizingStart.forEach((_ref3) => {
              let [columnId, headerSize] = _ref3;
              newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;
            });
            return {
              ...old,
              deltaOffset,
              deltaPercentage
            };
          });
          if (table.options.columnResizeMode === "onChange" || eventType === "end") {
            table.setColumnSizing((old) => ({
              ...old,
              ...newColumnSizing
            }));
          }
        };
        const onMove = (clientXPos) => updateOffset("move", clientXPos);
        const onEnd = (clientXPos) => {
          updateOffset("end", clientXPos);
          table.setColumnSizingInfo((old) => ({
            ...old,
            isResizingColumn: false,
            startOffset: null,
            startSize: null,
            deltaOffset: null,
            deltaPercentage: null,
            columnSizingStart: []
          }));
        };
        const contextDocument = safelyAccessDocument(_contextDocument);
        const mouseEvents = {
          moveHandler: (e3) => onMove(e3.clientX),
          upHandler: (e3) => {
            contextDocument == null || contextDocument.removeEventListener("mousemove", mouseEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener("mouseup", mouseEvents.upHandler);
            onEnd(e3.clientX);
          }
        };
        const touchEvents = {
          moveHandler: (e3) => {
            if (e3.cancelable) {
              e3.preventDefault();
              e3.stopPropagation();
            }
            onMove(e3.touches[0].clientX);
            return false;
          },
          upHandler: (e3) => {
            var _e$touches$;
            contextDocument == null || contextDocument.removeEventListener("touchmove", touchEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener("touchend", touchEvents.upHandler);
            if (e3.cancelable) {
              e3.preventDefault();
              e3.stopPropagation();
            }
            onEnd((_e$touches$ = e3.touches[0]) == null ? void 0 : _e$touches$.clientX);
          }
        };
        const passiveIfSupported = passiveEventSupported() ? {
          passive: false
        } : false;
        if (isTouchStartEvent(e2)) {
          contextDocument == null || contextDocument.addEventListener("touchmove", touchEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener("touchend", touchEvents.upHandler, passiveIfSupported);
        } else {
          contextDocument == null || contextDocument.addEventListener("mousemove", mouseEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener("mouseup", mouseEvents.upHandler, passiveIfSupported);
        }
        table.setColumnSizingInfo((old) => ({
          ...old,
          startOffset: clientX,
          startSize,
          deltaOffset: 0,
          deltaPercentage: 0,
          columnSizingStart,
          isResizingColumn: column.id
        }));
      };
    };
  },
  createTable: (table) => {
    table.setColumnSizing = (updater) => table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);
    table.setColumnSizingInfo = (updater) => table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);
    table.resetColumnSizing = (defaultState) => {
      var _table$initialState$c;
      table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});
    };
    table.resetHeaderSizeInfo = (defaultState) => {
      var _table$initialState$c2;
      table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());
    };
    table.getTotalSize = () => {
      var _table$getHeaderGroup, _table$getHeaderGroup2;
      return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getHeaderGroup : 0;
    };
    table.getLeftTotalSize = () => {
      var _table$getLeftHeaderG, _table$getLeftHeaderG2;
      return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getLeftHeaderG : 0;
    };
    table.getCenterTotalSize = () => {
      var _table$getCenterHeade, _table$getCenterHeade2;
      return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getCenterHeade : 0;
    };
    table.getRightTotalSize = () => {
      var _table$getRightHeader, _table$getRightHeader2;
      return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getRightHeader : 0;
    };
  }
};
var passiveSupported = null;
function passiveEventSupported() {
  if (typeof passiveSupported === "boolean") return passiveSupported;
  let supported = false;
  try {
    const options = {
      get passive() {
        supported = true;
        return false;
      }
    };
    const noop = () => {
    };
    window.addEventListener("test", noop, options);
    window.removeEventListener("test", noop);
  } catch (err) {
    supported = false;
  }
  passiveSupported = supported;
  return passiveSupported;
}
function isTouchStartEvent(e2) {
  return e2.type === "touchstart";
}
var ColumnVisibility = {
  getInitialState: (state2) => {
    return {
      columnVisibility: {},
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnVisibilityChange: makeStateUpdater("columnVisibility", table)
    };
  },
  createColumn: (column, table) => {
    column.toggleVisibility = (value) => {
      if (column.getCanHide()) {
        table.setColumnVisibility((old) => ({
          ...old,
          [column.id]: value != null ? value : !column.getIsVisible()
        }));
      }
    };
    column.getIsVisible = () => {
      var _ref, _table$getState$colum;
      const childColumns = column.columns;
      return (_ref = childColumns.length ? childColumns.some((c3) => c3.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column.id]) != null ? _ref : true;
    };
    column.getCanHide = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);
    };
    column.getToggleVisibilityHandler = () => {
      return (e2) => {
        column.toggleVisibility == null || column.toggleVisibility(e2.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row._getAllVisibleCells = memo(() => [row.getAllCells(), table.getState().columnVisibility], (cells) => {
      return cells.filter((cell) => cell.column.getIsVisible());
    }, getMemoOptions(table.options, "debugRows", "_getAllVisibleCells"));
    row.getVisibleCells = memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], getMemoOptions(table.options, "debugRows", "getVisibleCells"));
  },
  createTable: (table) => {
    const makeVisibleColumnsMethod = (key, getColumns) => {
      return memo(() => [getColumns(), getColumns().filter((d) => d.getIsVisible()).map((d) => d.id).join("_")], (columns) => {
        return columns.filter((d) => d.getIsVisible == null ? void 0 : d.getIsVisible());
      }, getMemoOptions(table.options, "debugColumns", key));
    };
    table.getVisibleFlatColumns = makeVisibleColumnsMethod("getVisibleFlatColumns", () => table.getAllFlatColumns());
    table.getVisibleLeafColumns = makeVisibleColumnsMethod("getVisibleLeafColumns", () => table.getAllLeafColumns());
    table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod("getLeftVisibleLeafColumns", () => table.getLeftLeafColumns());
    table.getRightVisibleLeafColumns = makeVisibleColumnsMethod("getRightVisibleLeafColumns", () => table.getRightLeafColumns());
    table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod("getCenterVisibleLeafColumns", () => table.getCenterLeafColumns());
    table.setColumnVisibility = (updater) => table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);
    table.resetColumnVisibility = (defaultState) => {
      var _table$initialState$c;
      table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});
    };
    table.toggleAllColumnsVisible = (value) => {
      var _value;
      value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();
      table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column) => ({
        ...obj,
        [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value
      }), {}));
    };
    table.getIsAllColumnsVisible = () => !table.getAllLeafColumns().some((column) => !(column.getIsVisible != null && column.getIsVisible()));
    table.getIsSomeColumnsVisible = () => table.getAllLeafColumns().some((column) => column.getIsVisible == null ? void 0 : column.getIsVisible());
    table.getToggleAllColumnsVisibilityHandler = () => {
      return (e2) => {
        var _target;
        table.toggleAllColumnsVisible((_target = e2.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
function _getVisibleLeafColumns(table, position) {
  return !position ? table.getVisibleLeafColumns() : position === "center" ? table.getCenterVisibleLeafColumns() : position === "left" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();
}
var GlobalFaceting = {
  createTable: (table) => {
    table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, "__global__");
    table.getGlobalFacetedRowModel = () => {
      if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getGlobalFacetedRowModel();
    };
    table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, "__global__");
    table.getGlobalFacetedUniqueValues = () => {
      if (!table._getGlobalFacetedUniqueValues) {
        return /* @__PURE__ */ new Map();
      }
      return table._getGlobalFacetedUniqueValues();
    };
    table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, "__global__");
    table.getGlobalFacetedMinMaxValues = () => {
      if (!table._getGlobalFacetedMinMaxValues) {
        return;
      }
      return table._getGlobalFacetedMinMaxValues();
    };
  }
};
var GlobalFiltering = {
  getInitialState: (state2) => {
    return {
      globalFilter: void 0,
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onGlobalFilterChange: makeStateUpdater("globalFilter", table),
      globalFilterFn: "auto",
      getColumnCanGlobalFilter: (column) => {
        var _table$getCoreRowMode;
        const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();
        return typeof value === "string" || typeof value === "number";
      }
    };
  },
  createColumn: (column, table) => {
    column.getCanGlobalFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2, _table$options$getCol;
      return ((_column$columnDef$ena = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGlobalFilter) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;
    };
  },
  createTable: (table) => {
    table.getGlobalAutoFilterFn = () => {
      return filterFns.includesString;
    };
    table.getGlobalFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      const {
        globalFilterFn
      } = table.options;
      return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === "auto" ? table.getGlobalAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[globalFilterFn]) != null ? _table$options$filter : filterFns[globalFilterFn];
    };
    table.setGlobalFilter = (updater) => {
      table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);
    };
    table.resetGlobalFilter = (defaultState) => {
      table.setGlobalFilter(defaultState ? void 0 : table.initialState.globalFilter);
    };
  }
};
var RowExpanding = {
  getInitialState: (state2) => {
    return {
      expanded: {},
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onExpandedChange: makeStateUpdater("expanded", table),
      paginateExpandedRows: true
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    table._autoResetExpanded = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {
        if (queued) return;
        queued = true;
        table._queue(() => {
          table.resetExpanded();
          queued = false;
        });
      }
    };
    table.setExpanded = (updater) => table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);
    table.toggleAllRowsExpanded = (expanded) => {
      if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {
        table.setExpanded(true);
      } else {
        table.setExpanded({});
      }
    };
    table.resetExpanded = (defaultState) => {
      var _table$initialState$e, _table$initialState;
      table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});
    };
    table.getCanSomeRowsExpand = () => {
      return table.getPrePaginationRowModel().flatRows.some((row) => row.getCanExpand());
    };
    table.getToggleAllRowsExpandedHandler = () => {
      return (e2) => {
        e2.persist == null || e2.persist();
        table.toggleAllRowsExpanded();
      };
    };
    table.getIsSomeRowsExpanded = () => {
      const expanded = table.getState().expanded;
      return expanded === true || Object.values(expanded).some(Boolean);
    };
    table.getIsAllRowsExpanded = () => {
      const expanded = table.getState().expanded;
      if (typeof expanded === "boolean") {
        return expanded === true;
      }
      if (!Object.keys(expanded).length) {
        return false;
      }
      if (table.getRowModel().flatRows.some((row) => !row.getIsExpanded())) {
        return false;
      }
      return true;
    };
    table.getExpandedDepth = () => {
      let maxDepth = 0;
      const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);
      rowIds.forEach((id) => {
        const splitId = id.split(".");
        maxDepth = Math.max(maxDepth, splitId.length);
      });
      return maxDepth;
    };
    table.getPreExpandedRowModel = () => table.getSortedRowModel();
    table.getExpandedRowModel = () => {
      if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {
        table._getExpandedRowModel = table.options.getExpandedRowModel(table);
      }
      if (table.options.manualExpanding || !table._getExpandedRowModel) {
        return table.getPreExpandedRowModel();
      }
      return table._getExpandedRowModel();
    };
  },
  createRow: (row, table) => {
    row.toggleExpanded = (expanded) => {
      table.setExpanded((old) => {
        var _expanded;
        const exists = old === true ? true : !!(old != null && old[row.id]);
        let oldExpanded = {};
        if (old === true) {
          Object.keys(table.getRowModel().rowsById).forEach((rowId) => {
            oldExpanded[rowId] = true;
          });
        } else {
          oldExpanded = old;
        }
        expanded = (_expanded = expanded) != null ? _expanded : !exists;
        if (!exists && expanded) {
          return {
            ...oldExpanded,
            [row.id]: true
          };
        }
        if (exists && !expanded) {
          const {
            [row.id]: _,
            ...rest
          } = oldExpanded;
          return rest;
        }
        return old;
      });
    };
    row.getIsExpanded = () => {
      var _table$options$getIsR;
      const expanded = table.getState().expanded;
      return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));
    };
    row.getCanExpand = () => {
      var _table$options$getRow, _table$options$enable, _row$subRows;
      return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
    row.getIsAllParentsExpanded = () => {
      let isFullyExpanded = true;
      let currentRow = row;
      while (isFullyExpanded && currentRow.parentId) {
        currentRow = table.getRow(currentRow.parentId, true);
        isFullyExpanded = currentRow.getIsExpanded();
      }
      return isFullyExpanded;
    };
    row.getToggleExpandedHandler = () => {
      const canExpand = row.getCanExpand();
      return () => {
        if (!canExpand) return;
        row.toggleExpanded();
      };
    };
  }
};
var defaultPageIndex = 0;
var defaultPageSize = 10;
var getDefaultPaginationState = () => ({
  pageIndex: defaultPageIndex,
  pageSize: defaultPageSize
});
var RowPagination = {
  getInitialState: (state2) => {
    return {
      ...state2,
      pagination: {
        ...getDefaultPaginationState(),
        ...state2 == null ? void 0 : state2.pagination
      }
    };
  },
  getDefaultOptions: (table) => {
    return {
      onPaginationChange: makeStateUpdater("pagination", table)
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    table._autoResetPageIndex = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {
        if (queued) return;
        queued = true;
        table._queue(() => {
          table.resetPageIndex();
          queued = false;
        });
      }
    };
    table.setPagination = (updater) => {
      const safeUpdater = (old) => {
        let newState = functionalUpdate(updater, old);
        return newState;
      };
      return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);
    };
    table.resetPagination = (defaultState) => {
      var _table$initialState$p;
      table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());
    };
    table.setPageIndex = (updater) => {
      table.setPagination((old) => {
        let pageIndex = functionalUpdate(updater, old.pageIndex);
        const maxPageIndex = typeof table.options.pageCount === "undefined" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;
        pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));
        return {
          ...old,
          pageIndex
        };
      });
    };
    table.resetPageIndex = (defaultState) => {
      var _table$initialState$p2, _table$initialState;
      table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);
    };
    table.resetPageSize = (defaultState) => {
      var _table$initialState$p3, _table$initialState2;
      table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);
    };
    table.setPageSize = (updater) => {
      table.setPagination((old) => {
        const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));
        const topRowIndex = old.pageSize * old.pageIndex;
        const pageIndex = Math.floor(topRowIndex / pageSize);
        return {
          ...old,
          pageIndex,
          pageSize
        };
      });
    };
    table.setPageCount = (updater) => table.setPagination((old) => {
      var _table$options$pageCo;
      let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);
      if (typeof newPageCount === "number") {
        newPageCount = Math.max(-1, newPageCount);
      }
      return {
        ...old,
        pageCount: newPageCount
      };
    });
    table.getPageOptions = memo(() => [table.getPageCount()], (pageCount) => {
      let pageOptions = [];
      if (pageCount && pageCount > 0) {
        pageOptions = [...new Array(pageCount)].fill(null).map((_, i) => i);
      }
      return pageOptions;
    }, getMemoOptions(table.options, "debugTable", "getPageOptions"));
    table.getCanPreviousPage = () => table.getState().pagination.pageIndex > 0;
    table.getCanNextPage = () => {
      const {
        pageIndex
      } = table.getState().pagination;
      const pageCount = table.getPageCount();
      if (pageCount === -1) {
        return true;
      }
      if (pageCount === 0) {
        return false;
      }
      return pageIndex < pageCount - 1;
    };
    table.previousPage = () => {
      return table.setPageIndex((old) => old - 1);
    };
    table.nextPage = () => {
      return table.setPageIndex((old) => {
        return old + 1;
      });
    };
    table.firstPage = () => {
      return table.setPageIndex(0);
    };
    table.lastPage = () => {
      return table.setPageIndex(table.getPageCount() - 1);
    };
    table.getPrePaginationRowModel = () => table.getExpandedRowModel();
    table.getPaginationRowModel = () => {
      if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {
        table._getPaginationRowModel = table.options.getPaginationRowModel(table);
      }
      if (table.options.manualPagination || !table._getPaginationRowModel) {
        return table.getPrePaginationRowModel();
      }
      return table._getPaginationRowModel();
    };
    table.getPageCount = () => {
      var _table$options$pageCo2;
      return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);
    };
    table.getRowCount = () => {
      var _table$options$rowCou;
      return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;
    };
  }
};
var getDefaultRowPinningState = () => ({
  top: [],
  bottom: []
});
var RowPinning = {
  getInitialState: (state2) => {
    return {
      rowPinning: getDefaultRowPinningState(),
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onRowPinningChange: makeStateUpdater("rowPinning", table)
    };
  },
  createRow: (row, table) => {
    row.pin = (position, includeLeafRows, includeParentRows) => {
      const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref) => {
        let {
          id
        } = _ref;
        return id;
      }) : [];
      const parentRowIds = includeParentRows ? row.getParentRows().map((_ref2) => {
        let {
          id
        } = _ref2;
        return id;
      }) : [];
      const rowIds = /* @__PURE__ */ new Set([...parentRowIds, row.id, ...leafRowIds]);
      table.setRowPinning((old) => {
        var _old$top3, _old$bottom3;
        if (position === "bottom") {
          var _old$top, _old$bottom;
          return {
            top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d) => !(rowIds != null && rowIds.has(d))),
            bottom: [...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d) => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)]
          };
        }
        if (position === "top") {
          var _old$top2, _old$bottom2;
          return {
            top: [...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d) => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)],
            bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d) => !(rowIds != null && rowIds.has(d)))
          };
        }
        return {
          top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d) => !(rowIds != null && rowIds.has(d))),
          bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d) => !(rowIds != null && rowIds.has(d)))
        };
      });
    };
    row.getCanPin = () => {
      var _ref3;
      const {
        enableRowPinning,
        enablePinning
      } = table.options;
      if (typeof enableRowPinning === "function") {
        return enableRowPinning(row);
      }
      return (_ref3 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref3 : true;
    };
    row.getIsPinned = () => {
      const rowIds = [row.id];
      const {
        top,
        bottom
      } = table.getState().rowPinning;
      const isTop = rowIds.some((d) => top == null ? void 0 : top.includes(d));
      const isBottom = rowIds.some((d) => bottom == null ? void 0 : bottom.includes(d));
      return isTop ? "top" : isBottom ? "bottom" : false;
    };
    row.getPinnedIndex = () => {
      var _ref4, _visiblePinnedRowIds$;
      const position = row.getIsPinned();
      if (!position) return -1;
      const visiblePinnedRowIds = (_ref4 = position === "top" ? table.getTopRows() : table.getBottomRows()) == null ? void 0 : _ref4.map((_ref5) => {
        let {
          id
        } = _ref5;
        return id;
      });
      return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;
    };
  },
  createTable: (table) => {
    table.setRowPinning = (updater) => table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);
    table.resetRowPinning = (defaultState) => {
      var _table$initialState$r, _table$initialState;
      return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());
    };
    table.getIsSomeRowsPinned = (position) => {
      var _pinningState$positio;
      const pinningState = table.getState().rowPinning;
      if (!position) {
        var _pinningState$top, _pinningState$bottom;
        return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));
      }
      return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
    };
    table._getPinnedRows = (visibleRows, pinnedRowIds, position) => {
      var _table$options$keepPi;
      const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? (
        //get all rows that are pinned even if they would not be otherwise visible
        //account for expanded parent rows, but not pagination or filtering
        (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => {
          const row = table.getRow(rowId, true);
          return row.getIsAllParentsExpanded() ? row : null;
        })
      ) : (
        //else get only visible rows that are pinned
        (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => visibleRows.find((row) => row.id === rowId))
      );
      return rows.filter(Boolean).map((d) => ({
        ...d,
        position
      }));
    };
    table.getTopRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top], (allRows, topPinnedRowIds) => table._getPinnedRows(allRows, topPinnedRowIds, "top"), getMemoOptions(table.options, "debugRows", "getTopRows"));
    table.getBottomRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.bottom], (allRows, bottomPinnedRowIds) => table._getPinnedRows(allRows, bottomPinnedRowIds, "bottom"), getMemoOptions(table.options, "debugRows", "getBottomRows"));
    table.getCenterRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top, table.getState().rowPinning.bottom], (allRows, top, bottom) => {
      const topAndBottom = /* @__PURE__ */ new Set([...top != null ? top : [], ...bottom != null ? bottom : []]);
      return allRows.filter((d) => !topAndBottom.has(d.id));
    }, getMemoOptions(table.options, "debugRows", "getCenterRows"));
  }
};
var RowSelection = {
  getInitialState: (state2) => {
    return {
      rowSelection: {},
      ...state2
    };
  },
  getDefaultOptions: (table) => {
    return {
      onRowSelectionChange: makeStateUpdater("rowSelection", table),
      enableRowSelection: true,
      enableMultiRowSelection: true,
      enableSubRowSelection: true
      // enableGroupingRowSelection: false,
      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,
      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,
    };
  },
  createTable: (table) => {
    table.setRowSelection = (updater) => table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);
    table.resetRowSelection = (defaultState) => {
      var _table$initialState$r;
      return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});
    };
    table.toggleAllRowsSelected = (value) => {
      table.setRowSelection((old) => {
        value = typeof value !== "undefined" ? value : !table.getIsAllRowsSelected();
        const rowSelection = {
          ...old
        };
        const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;
        if (value) {
          preGroupedFlatRows.forEach((row) => {
            if (!row.getCanSelect()) {
              return;
            }
            rowSelection[row.id] = true;
          });
        } else {
          preGroupedFlatRows.forEach((row) => {
            delete rowSelection[row.id];
          });
        }
        return rowSelection;
      });
    };
    table.toggleAllPageRowsSelected = (value) => table.setRowSelection((old) => {
      const resolvedValue = typeof value !== "undefined" ? value : !table.getIsAllPageRowsSelected();
      const rowSelection = {
        ...old
      };
      table.getRowModel().rows.forEach((row) => {
        mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);
      });
      return rowSelection;
    });
    table.getPreSelectedRowModel = () => table.getCoreRowModel();
    table.getSelectedRowModel = memo(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getSelectedRowModel"));
    table.getFilteredSelectedRowModel = memo(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getFilteredSelectedRowModel"));
    table.getGroupedSelectedRowModel = memo(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getGroupedSelectedRowModel"));
    table.getIsAllRowsSelected = () => {
      const preGroupedFlatRows = table.getFilteredRowModel().flatRows;
      const {
        rowSelection
      } = table.getState();
      let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);
      if (isAllRowsSelected) {
        if (preGroupedFlatRows.some((row) => row.getCanSelect() && !rowSelection[row.id])) {
          isAllRowsSelected = false;
        }
      }
      return isAllRowsSelected;
    };
    table.getIsAllPageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row) => row.getCanSelect());
      const {
        rowSelection
      } = table.getState();
      let isAllPageRowsSelected = !!paginationFlatRows.length;
      if (isAllPageRowsSelected && paginationFlatRows.some((row) => !rowSelection[row.id])) {
        isAllPageRowsSelected = false;
      }
      return isAllPageRowsSelected;
    };
    table.getIsSomeRowsSelected = () => {
      var _table$getState$rowSe;
      const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;
      return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;
    };
    table.getIsSomePageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows;
      return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row) => row.getCanSelect()).some((d) => d.getIsSelected() || d.getIsSomeSelected());
    };
    table.getToggleAllRowsSelectedHandler = () => {
      return (e2) => {
        table.toggleAllRowsSelected(e2.target.checked);
      };
    };
    table.getToggleAllPageRowsSelectedHandler = () => {
      return (e2) => {
        table.toggleAllPageRowsSelected(e2.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row.toggleSelected = (value, opts) => {
      const isSelected = row.getIsSelected();
      table.setRowSelection((old) => {
        var _opts$selectChildren;
        value = typeof value !== "undefined" ? value : !isSelected;
        if (row.getCanSelect() && isSelected === value) {
          return old;
        }
        const selectedRowIds = {
          ...old
        };
        mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);
        return selectedRowIds;
      });
    };
    row.getIsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isRowSelected(row, rowSelection);
    };
    row.getIsSomeSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === "some";
    };
    row.getIsAllSubRowsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === "all";
    };
    row.getCanSelect = () => {
      var _table$options$enable;
      if (typeof table.options.enableRowSelection === "function") {
        return table.options.enableRowSelection(row);
      }
      return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;
    };
    row.getCanSelectSubRows = () => {
      var _table$options$enable2;
      if (typeof table.options.enableSubRowSelection === "function") {
        return table.options.enableSubRowSelection(row);
      }
      return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;
    };
    row.getCanMultiSelect = () => {
      var _table$options$enable3;
      if (typeof table.options.enableMultiRowSelection === "function") {
        return table.options.enableMultiRowSelection(row);
      }
      return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;
    };
    row.getToggleSelectedHandler = () => {
      const canSelect = row.getCanSelect();
      return (e2) => {
        var _target;
        if (!canSelect) return;
        row.toggleSelected((_target = e2.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
var mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table) => {
  var _row$subRows;
  const row = table.getRow(id, true);
  if (value) {
    if (!row.getCanMultiSelect()) {
      Object.keys(selectedRowIds).forEach((key) => delete selectedRowIds[key]);
    }
    if (row.getCanSelect()) {
      selectedRowIds[id] = true;
    }
  } else {
    delete selectedRowIds[id];
  }
  if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {
    row.subRows.forEach((row2) => mutateRowIsSelected(selectedRowIds, row2.id, value, includeChildren, table));
  }
};
function selectRowsFn(table, rowModel) {
  const rowSelection = table.getState().rowSelection;
  const newSelectedFlatRows = [];
  const newSelectedRowsById = {};
  const recurseRows = function(rows, depth) {
    return rows.map((row) => {
      var _row$subRows2;
      const isSelected = isRowSelected(row, rowSelection);
      if (isSelected) {
        newSelectedFlatRows.push(row);
        newSelectedRowsById[row.id] = row;
      }
      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {
        row = {
          ...row,
          subRows: recurseRows(row.subRows)
        };
      }
      if (isSelected) {
        return row;
      }
    }).filter(Boolean);
  };
  return {
    rows: recurseRows(rowModel.rows),
    flatRows: newSelectedFlatRows,
    rowsById: newSelectedRowsById
  };
}
function isRowSelected(row, selection) {
  var _selection$row$id;
  return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;
}
function isSubRowSelected(row, selection, table) {
  var _row$subRows3;
  if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;
  let allChildrenSelected = true;
  let someSelected = false;
  row.subRows.forEach((subRow) => {
    if (someSelected && !allChildrenSelected) {
      return;
    }
    if (subRow.getCanSelect()) {
      if (isRowSelected(subRow, selection)) {
        someSelected = true;
      } else {
        allChildrenSelected = false;
      }
    }
    if (subRow.subRows && subRow.subRows.length) {
      const subRowChildrenSelected = isSubRowSelected(subRow, selection);
      if (subRowChildrenSelected === "all") {
        someSelected = true;
      } else if (subRowChildrenSelected === "some") {
        someSelected = true;
        allChildrenSelected = false;
      } else {
        allChildrenSelected = false;
      }
    }
  });
  return allChildrenSelected ? "all" : someSelected ? "some" : false;
}
var reSplitAlphaNumeric = /([0-9]+)/gm;
var alphanumeric = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString2(rowA.getValue(columnId)).toLowerCase(), toString2(rowB.getValue(columnId)).toLowerCase());
};
var alphanumericCaseSensitive = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString2(rowA.getValue(columnId)), toString2(rowB.getValue(columnId)));
};
var text = (rowA, rowB, columnId) => {
  return compareBasic(toString2(rowA.getValue(columnId)).toLowerCase(), toString2(rowB.getValue(columnId)).toLowerCase());
};
var textCaseSensitive = (rowA, rowB, columnId) => {
  return compareBasic(toString2(rowA.getValue(columnId)), toString2(rowB.getValue(columnId)));
};
var datetime = (rowA, rowB, columnId) => {
  const a = rowA.getValue(columnId);
  const b = rowB.getValue(columnId);
  return a > b ? 1 : a < b ? -1 : 0;
};
var basic = (rowA, rowB, columnId) => {
  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));
};
function compareBasic(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
function toString2(a) {
  if (typeof a === "number") {
    if (isNaN(a) || a === Infinity || a === -Infinity) {
      return "";
    }
    return String(a);
  }
  if (typeof a === "string") {
    return a;
  }
  return "";
}
function compareAlphanumeric(aStr, bStr) {
  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);
  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);
  while (a.length && b.length) {
    const aa = a.shift();
    const bb = b.shift();
    const an = parseInt(aa, 10);
    const bn = parseInt(bb, 10);
    const combo = [an, bn].sort();
    if (isNaN(combo[0])) {
      if (aa > bb) {
        return 1;
      }
      if (bb > aa) {
        return -1;
      }
      continue;
    }
    if (isNaN(combo[1])) {
      return isNaN(an) ? -1 : 1;
    }
    if (an > bn) {
      return 1;
    }
    if (bn > an) {
      return -1;
    }
  }
  return a.length - b.length;
}
var sortingFns = {
  alphanumeric,
  alphanumericCaseSensitive,
  text,
  textCaseSensitive,
  datetime,
  basic
};
var RowSorting = {
  getInitialState: (state2) => {
    return {
      sorting: [],
      ...state2
    };
  },
  getDefaultColumnDef: () => {
    return {
      sortingFn: "auto",
      sortUndefined: 1
    };
  },
  getDefaultOptions: (table) => {
    return {
      onSortingChange: makeStateUpdater("sorting", table),
      isMultiSortEvent: (e2) => {
        return e2.shiftKey;
      }
    };
  },
  createColumn: (column, table) => {
    column.getAutoSortingFn = () => {
      const firstRows = table.getFilteredRowModel().flatRows.slice(10);
      let isString2 = false;
      for (const row of firstRows) {
        const value = row == null ? void 0 : row.getValue(column.id);
        if (Object.prototype.toString.call(value) === "[object Date]") {
          return sortingFns.datetime;
        }
        if (typeof value === "string") {
          isString2 = true;
          if (value.split(reSplitAlphaNumeric).length > 1) {
            return sortingFns.alphanumeric;
          }
        }
      }
      if (isString2) {
        return sortingFns.text;
      }
      return sortingFns.basic;
    };
    column.getAutoSortDir = () => {
      const firstRow = table.getFilteredRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === "string") {
        return "asc";
      }
      return "desc";
    };
    column.getSortingFn = () => {
      var _table$options$sortin, _table$options$sortin2;
      if (!column) {
        throw new Error();
      }
      return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === "auto" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];
    };
    column.toggleSorting = (desc, multi) => {
      const nextSortingOrder = column.getNextSortingOrder();
      const hasManualValue = typeof desc !== "undefined" && desc !== null;
      table.setSorting((old) => {
        const existingSorting = old == null ? void 0 : old.find((d) => d.id === column.id);
        const existingIndex = old == null ? void 0 : old.findIndex((d) => d.id === column.id);
        let newSorting = [];
        let sortAction;
        let nextDesc = hasManualValue ? desc : nextSortingOrder === "desc";
        if (old != null && old.length && column.getCanMultiSort() && multi) {
          if (existingSorting) {
            sortAction = "toggle";
          } else {
            sortAction = "add";
          }
        } else {
          if (old != null && old.length && existingIndex !== old.length - 1) {
            sortAction = "replace";
          } else if (existingSorting) {
            sortAction = "toggle";
          } else {
            sortAction = "replace";
          }
        }
        if (sortAction === "toggle") {
          if (!hasManualValue) {
            if (!nextSortingOrder) {
              sortAction = "remove";
            }
          }
        }
        if (sortAction === "add") {
          var _table$options$maxMul;
          newSorting = [...old, {
            id: column.id,
            desc: nextDesc
          }];
          newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));
        } else if (sortAction === "toggle") {
          newSorting = old.map((d) => {
            if (d.id === column.id) {
              return {
                ...d,
                desc: nextDesc
              };
            }
            return d;
          });
        } else if (sortAction === "remove") {
          newSorting = old.filter((d) => d.id !== column.id);
        } else {
          newSorting = [{
            id: column.id,
            desc: nextDesc
          }];
        }
        return newSorting;
      });
    };
    column.getFirstSortDir = () => {
      var _ref, _column$columnDef$sor;
      const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === "desc";
      return sortDescFirst ? "desc" : "asc";
    };
    column.getNextSortingOrder = (multi) => {
      var _table$options$enable, _table$options$enable2;
      const firstSortDirection = column.getFirstSortDir();
      const isSorted = column.getIsSorted();
      if (!isSorted) {
        return firstSortDirection;
      }
      if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general
      (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true)) {
        return false;
      }
      return isSorted === "desc" ? "asc" : "desc";
    };
    column.getCanSort = () => {
      var _column$columnDef$ena, _table$options$enable3;
      return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;
    };
    column.getCanMultiSort = () => {
      var _ref2, _column$columnDef$ena2;
      return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;
    };
    column.getIsSorted = () => {
      var _table$getState$sorti;
      const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d) => d.id === column.id);
      return !columnSort ? false : columnSort.desc ? "desc" : "asc";
    };
    column.getSortIndex = () => {
      var _table$getState$sorti2, _table$getState$sorti3;
      return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d) => d.id === column.id)) != null ? _table$getState$sorti2 : -1;
    };
    column.clearSorting = () => {
      table.setSorting((old) => old != null && old.length ? old.filter((d) => d.id !== column.id) : []);
    };
    column.getToggleSortingHandler = () => {
      const canSort = column.getCanSort();
      return (e2) => {
        if (!canSort) return;
        e2.persist == null || e2.persist();
        column.toggleSorting == null || column.toggleSorting(void 0, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e2) : false);
      };
    };
  },
  createTable: (table) => {
    table.setSorting = (updater) => table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);
    table.resetSorting = (defaultState) => {
      var _table$initialState$s, _table$initialState;
      table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);
    };
    table.getPreSortedRowModel = () => table.getGroupedRowModel();
    table.getSortedRowModel = () => {
      if (!table._getSortedRowModel && table.options.getSortedRowModel) {
        table._getSortedRowModel = table.options.getSortedRowModel(table);
      }
      if (table.options.manualSorting || !table._getSortedRowModel) {
        return table.getPreSortedRowModel();
      }
      return table._getSortedRowModel();
    };
  }
};
var builtInFeatures = [
  Headers,
  ColumnVisibility,
  ColumnOrdering,
  ColumnPinning,
  ColumnFaceting,
  ColumnFiltering,
  GlobalFaceting,
  //depends on ColumnFaceting
  GlobalFiltering,
  //depends on ColumnFiltering
  RowSorting,
  ColumnGrouping,
  //depends on RowSorting
  RowExpanding,
  RowPagination,
  RowPinning,
  RowSelection,
  ColumnSizing
];
function createTable(options) {
  var _options$_features, _options$initialState;
  if (options.debugAll || options.debugTable) {
    console.info("Creating Table Instance...");
  }
  const _features = [...builtInFeatures, ...(_options$_features = options._features) != null ? _options$_features : []];
  let table = {
    _features
  };
  const defaultOptions = table._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));
  }, {});
  const mergeOptions = (options2) => {
    if (table.options.mergeOptions) {
      return table.options.mergeOptions(defaultOptions, options2);
    }
    return {
      ...defaultOptions,
      ...options2
    };
  };
  const coreInitialState = {};
  let initialState = {
    ...coreInitialState,
    ...(_options$initialState = options.initialState) != null ? _options$initialState : {}
  };
  table._features.forEach((feature) => {
    var _feature$getInitialSt;
    initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;
  });
  const queued = [];
  let queuedTimeout = false;
  const coreInstance = {
    _features,
    options: {
      ...defaultOptions,
      ...options
    },
    initialState,
    _queue: (cb) => {
      queued.push(cb);
      if (!queuedTimeout) {
        queuedTimeout = true;
        Promise.resolve().then(() => {
          while (queued.length) {
            queued.shift()();
          }
          queuedTimeout = false;
        }).catch((error) => setTimeout(() => {
          throw error;
        }));
      }
    },
    reset: () => {
      table.setState(table.initialState);
    },
    setOptions: (updater) => {
      const newOptions = functionalUpdate(updater, table.options);
      table.options = mergeOptions(newOptions);
    },
    getState: () => {
      return table.options.state;
    },
    setState: (updater) => {
      table.options.onStateChange == null || table.options.onStateChange(updater);
    },
    _getRowId: (row, index, parent) => {
      var _table$options$getRow;
      return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [parent.id, index].join(".") : index}`;
    },
    getCoreRowModel: () => {
      if (!table._getCoreRowModel) {
        table._getCoreRowModel = table.options.getCoreRowModel(table);
      }
      return table._getCoreRowModel();
    },
    // The final calls start at the bottom of the model,
    // expanded rows, which then work their way up
    getRowModel: () => {
      return table.getPaginationRowModel();
    },
    //in next version, we should just pass in the row model as the optional 2nd arg
    getRow: (id, searchAll) => {
      let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id];
      if (!row) {
        row = table.getCoreRowModel().rowsById[id];
        if (!row) {
          if (true) {
            throw new Error(`getRow could not find row with ID: ${id}`);
          }
          throw new Error();
        }
      }
      return row;
    },
    _getDefaultColumnDef: memo(() => [table.options.defaultColumn], (defaultColumn) => {
      var _defaultColumn;
      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};
      return {
        header: (props) => {
          const resolvedColumnDef = props.header.column.columnDef;
          if (resolvedColumnDef.accessorKey) {
            return resolvedColumnDef.accessorKey;
          }
          if (resolvedColumnDef.accessorFn) {
            return resolvedColumnDef.id;
          }
          return null;
        },
        // footer: props => props.header.column.id,
        cell: (props) => {
          var _props$renderValue$to, _props$renderValue;
          return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;
        },
        ...table._features.reduce((obj, feature) => {
          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());
        }, {}),
        ...defaultColumn
      };
    }, getMemoOptions(options, "debugColumns", "_getDefaultColumnDef")),
    _getColumnDefs: () => table.options.columns,
    getAllColumns: memo(() => [table._getColumnDefs()], (columnDefs) => {
      const recurseColumns = function(columnDefs2, parent, depth) {
        if (depth === void 0) {
          depth = 0;
        }
        return columnDefs2.map((columnDef) => {
          const column = createColumn(table, columnDef, depth, parent);
          const groupingColumnDef = columnDef;
          column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];
          return column;
        });
      };
      return recurseColumns(columnDefs);
    }, getMemoOptions(options, "debugColumns", "getAllColumns")),
    getAllFlatColumns: memo(() => [table.getAllColumns()], (allColumns) => {
      return allColumns.flatMap((column) => {
        return column.getFlatColumns();
      });
    }, getMemoOptions(options, "debugColumns", "getAllFlatColumns")),
    _getAllFlatColumnsById: memo(() => [table.getAllFlatColumns()], (flatColumns2) => {
      return flatColumns2.reduce((acc, column) => {
        acc[column.id] = column;
        return acc;
      }, {});
    }, getMemoOptions(options, "debugColumns", "getAllFlatColumnsById")),
    getAllLeafColumns: memo(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns2) => {
      let leafColumns = allColumns.flatMap((column) => column.getLeafColumns());
      return orderColumns2(leafColumns);
    }, getMemoOptions(options, "debugColumns", "getAllLeafColumns")),
    getColumn: (columnId) => {
      const column = table._getAllFlatColumnsById()[columnId];
      if (!column) {
        console.error(`[Table] Column with id '${columnId}' does not exist.`);
      }
      return column;
    }
  };
  Object.assign(table, coreInstance);
  for (let index = 0; index < table._features.length; index++) {
    const feature = table._features[index];
    feature == null || feature.createTable == null || feature.createTable(table);
  }
  return table;
}
function getCoreRowModel() {
  return (table) => memo(() => [table.options.data], (data) => {
    const rowModel = {
      rows: [],
      flatRows: [],
      rowsById: {}
    };
    const accessRows = function(originalRows, depth, parentRow) {
      if (depth === void 0) {
        depth = 0;
      }
      const rows = [];
      for (let i = 0; i < originalRows.length; i++) {
        const row = createRow(table, table._getRowId(originalRows[i], i, parentRow), originalRows[i], i, depth, void 0, parentRow == null ? void 0 : parentRow.id);
        rowModel.flatRows.push(row);
        rowModel.rowsById[row.id] = row;
        rows.push(row);
        if (table.options.getSubRows) {
          var _row$originalSubRows;
          row.originalSubRows = table.options.getSubRows(originalRows[i], i);
          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {
            row.subRows = accessRows(row.originalSubRows, depth + 1, row);
          }
        }
      }
      return rows;
    };
    rowModel.rows = accessRows(data);
    return rowModel;
  }, getMemoOptions(table.options, "debugTable", "getRowModel", () => table._autoResetPageIndex()));
}
function expandRows(rowModel) {
  const expandedRows = [];
  const handleRow = (row) => {
    var _row$subRows;
    expandedRows.push(row);
    if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {
      row.subRows.forEach(handleRow);
    }
  };
  rowModel.rows.forEach(handleRow);
  return {
    rows: expandedRows,
    flatRows: rowModel.flatRows,
    rowsById: rowModel.rowsById
  };
}
function filterRows(rows, filterRowImpl, table) {
  if (table.options.filterFromLeafRows) {
    return filterRowModelFromLeafs(rows, filterRowImpl, table);
  }
  return filterRowModelFromRoot(rows, filterRowImpl, table);
}
function filterRowModelFromLeafs(rowsToFilter, filterRow, table) {
  var _table$options$maxLea;
  const newFilteredFlatRows = [];
  const newFilteredRowsById = {};
  const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;
  const recurseFilterRows = function(rowsToFilter2, depth) {
    if (depth === void 0) {
      depth = 0;
    }
    const rows = [];
    for (let i = 0; i < rowsToFilter2.length; i++) {
      var _row$subRows;
      let row = rowsToFilter2[i];
      const newRow = createRow(table, row.id, row.original, row.index, row.depth, void 0, row.parentId);
      newRow.columnFilters = row.columnFilters;
      if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {
        newRow.subRows = recurseFilterRows(row.subRows, depth + 1);
        row = newRow;
        if (filterRow(row) && !newRow.subRows.length) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredFlatRows.push(row);
          continue;
        }
        if (filterRow(row) || newRow.subRows.length) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredFlatRows.push(row);
          continue;
        }
      } else {
        row = newRow;
        if (filterRow(row)) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredFlatRows.push(row);
        }
      }
    }
    return rows;
  };
  return {
    rows: recurseFilterRows(rowsToFilter),
    flatRows: newFilteredFlatRows,
    rowsById: newFilteredRowsById
  };
}
function filterRowModelFromRoot(rowsToFilter, filterRow, table) {
  var _table$options$maxLea2;
  const newFilteredFlatRows = [];
  const newFilteredRowsById = {};
  const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;
  const recurseFilterRows = function(rowsToFilter2, depth) {
    if (depth === void 0) {
      depth = 0;
    }
    const rows = [];
    for (let i = 0; i < rowsToFilter2.length; i++) {
      let row = rowsToFilter2[i];
      const pass = filterRow(row);
      if (pass) {
        var _row$subRows2;
        if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {
          const newRow = createRow(table, row.id, row.original, row.index, row.depth, void 0, row.parentId);
          newRow.subRows = recurseFilterRows(row.subRows, depth + 1);
          row = newRow;
        }
        rows.push(row);
        newFilteredFlatRows.push(row);
        newFilteredRowsById[row.id] = row;
      }
    }
    return rows;
  };
  return {
    rows: recurseFilterRows(rowsToFilter),
    flatRows: newFilteredFlatRows,
    rowsById: newFilteredRowsById
  };
}
function getFilteredRowModel() {
  return (table) => memo(() => [table.getPreFilteredRowModel(), table.getState().columnFilters, table.getState().globalFilter], (rowModel, columnFilters, globalFilter) => {
    if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {
      for (let i = 0; i < rowModel.flatRows.length; i++) {
        rowModel.flatRows[i].columnFilters = {};
        rowModel.flatRows[i].columnFiltersMeta = {};
      }
      return rowModel;
    }
    const resolvedColumnFilters = [];
    const resolvedGlobalFilters = [];
    (columnFilters != null ? columnFilters : []).forEach((d) => {
      var _filterFn$resolveFilt;
      const column = table.getColumn(d.id);
      if (!column) {
        return;
      }
      const filterFn = column.getFilterFn();
      if (!filterFn) {
        if (true) {
          console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);
        }
        return;
      }
      resolvedColumnFilters.push({
        id: d.id,
        filterFn,
        resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value
      });
    });
    const filterableIds = (columnFilters != null ? columnFilters : []).map((d) => d.id);
    const globalFilterFn = table.getGlobalFilterFn();
    const globallyFilterableColumns = table.getAllLeafColumns().filter((column) => column.getCanGlobalFilter());
    if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {
      filterableIds.push("__global__");
      globallyFilterableColumns.forEach((column) => {
        var _globalFilterFn$resol;
        resolvedGlobalFilters.push({
          id: column.id,
          filterFn: globalFilterFn,
          resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter
        });
      });
    }
    let currentColumnFilter;
    let currentGlobalFilter;
    for (let j = 0; j < rowModel.flatRows.length; j++) {
      const row = rowModel.flatRows[j];
      row.columnFilters = {};
      if (resolvedColumnFilters.length) {
        for (let i = 0; i < resolvedColumnFilters.length; i++) {
          currentColumnFilter = resolvedColumnFilters[i];
          const id = currentColumnFilter.id;
          row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, (filterMeta) => {
            row.columnFiltersMeta[id] = filterMeta;
          });
        }
      }
      if (resolvedGlobalFilters.length) {
        for (let i = 0; i < resolvedGlobalFilters.length; i++) {
          currentGlobalFilter = resolvedGlobalFilters[i];
          const id = currentGlobalFilter.id;
          if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, (filterMeta) => {
            row.columnFiltersMeta[id] = filterMeta;
          })) {
            row.columnFilters.__global__ = true;
            break;
          }
        }
        if (row.columnFilters.__global__ !== true) {
          row.columnFilters.__global__ = false;
        }
      }
    }
    const filterRowsImpl = (row) => {
      for (let i = 0; i < filterableIds.length; i++) {
        if (row.columnFilters[filterableIds[i]] === false) {
          return false;
        }
      }
      return true;
    };
    return filterRows(rowModel.rows, filterRowsImpl, table);
  }, getMemoOptions(table.options, "debugTable", "getFilteredRowModel", () => table._autoResetPageIndex()));
}
function getPaginationRowModel(opts) {
  return (table) => memo(() => [table.getState().pagination, table.getPrePaginationRowModel(), table.options.paginateExpandedRows ? void 0 : table.getState().expanded], (pagination, rowModel) => {
    if (!rowModel.rows.length) {
      return rowModel;
    }
    const {
      pageSize,
      pageIndex
    } = pagination;
    let {
      rows,
      flatRows,
      rowsById
    } = rowModel;
    const pageStart = pageSize * pageIndex;
    const pageEnd = pageStart + pageSize;
    rows = rows.slice(pageStart, pageEnd);
    let paginatedRowModel;
    if (!table.options.paginateExpandedRows) {
      paginatedRowModel = expandRows({
        rows,
        flatRows,
        rowsById
      });
    } else {
      paginatedRowModel = {
        rows,
        flatRows,
        rowsById
      };
    }
    paginatedRowModel.flatRows = [];
    const handleRow = (row) => {
      paginatedRowModel.flatRows.push(row);
      if (row.subRows.length) {
        row.subRows.forEach(handleRow);
      }
    };
    paginatedRowModel.rows.forEach(handleRow);
    return paginatedRowModel;
  }, getMemoOptions(table.options, "debugTable", "getPaginationRowModel"));
}

// node_modules/@tanstack/react-table/build/lib/index.mjs
function flexRender(Comp, props) {
  return !Comp ? null : isReactComponent(Comp) ? React.createElement(Comp, props) : Comp;
}
function isReactComponent(component2) {
  return isClassComponent(component2) || typeof component2 === "function" || isExoticComponent(component2);
}
function isClassComponent(component2) {
  return typeof component2 === "function" && (() => {
    const proto = Object.getPrototypeOf(component2);
    return proto.prototype && proto.prototype.isReactComponent;
  })();
}
function isExoticComponent(component2) {
  return typeof component2 === "object" && typeof component2.$$typeof === "symbol" && ["react.memo", "react.forward_ref"].includes(component2.$$typeof.description);
}
function useReactTable(options) {
  const resolvedOptions = {
    state: {},
    // Dummy state
    onStateChange: () => {
    },
    // noop
    renderFallbackValue: null,
    ...options
  };
  const [tableRef] = React.useState(() => ({
    current: createTable(resolvedOptions)
  }));
  const [state2, setState] = React.useState(() => tableRef.current.initialState);
  tableRef.current.setOptions((prev) => ({
    ...prev,
    ...options,
    state: {
      ...state2,
      ...options.state
    },
    // Similarly, we'll maintain both our internal state and any user-provided
    // state.
    onStateChange: (updater) => {
      setState(updater);
      options.onStateChange == null || options.onStateChange(updater);
    }
  }));
  return tableRef.current;
}

// node_modules/sanity/lib/_chunks-es/pane.js
function useCreatePathSyncChannel() {
  const $ = (0, import_compiler_runtime2.c)(1);
  let t0;
  return $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = new Subject(), $[0] = t0) : t0 = $[0], t0;
}
var DIFF_VIEW_SEARCH_PARAMETER = "diffView";
var DIFF_VIEW_PREVIOUS_DOCUMENT_SEARCH_PARAMETER = "previousDocument";
var DIFF_VIEW_NEXT_DOCUMENT_SEARCH_PARAMETER = "nextDocument";
var DIFF_SEARCH_PARAM_DELIMITER = ",";
function useDiffViewRouter() {
  const $ = (0, import_compiler_runtime2.c)(9), {
    navigate,
    state: routerState
  } = useRouter();
  let t0;
  $[0] !== navigate || $[1] !== routerState ? (t0 = (t12) => {
    const {
      mode,
      previousDocument,
      nextDocument
    } = t12, next = {
      ...fromPairs_default(routerState._searchParams),
      ...mode ? {
        [DIFF_VIEW_SEARCH_PARAMETER]: mode
      } : {},
      ...previousDocument ? {
        [DIFF_VIEW_PREVIOUS_DOCUMENT_SEARCH_PARAMETER]: [previousDocument.type, previousDocument.id].join(DIFF_SEARCH_PARAM_DELIMITER)
      } : {},
      ...nextDocument ? {
        [DIFF_VIEW_NEXT_DOCUMENT_SEARCH_PARAMETER]: [nextDocument.type, nextDocument.id].join(DIFF_SEARCH_PARAM_DELIMITER)
      } : {}
    };
    navigate({
      ...routerState,
      _searchParams: toPairs_default(next)
    });
  }, $[0] = navigate, $[1] = routerState, $[2] = t0) : t0 = $[2];
  const navigateDiffView = t0;
  let t1;
  $[3] !== navigate || $[4] !== routerState ? (t1 = () => {
    navigate({
      ...routerState,
      _searchParams: (routerState._searchParams ?? []).filter(_temp$O)
    });
  }, $[3] = navigate, $[4] = routerState, $[5] = t1) : t1 = $[5];
  const exitDiffView = t1;
  let t2;
  return $[6] !== exitDiffView || $[7] !== navigateDiffView ? (t2 = {
    navigateDiffView,
    exitDiffView
  }, $[6] = exitDiffView, $[7] = navigateDiffView, $[8] = t2) : t2 = $[8], t2;
}
function _temp$O(t0) {
  const [key] = t0;
  return ![DIFF_VIEW_SEARCH_PARAMETER, DIFF_VIEW_PREVIOUS_DOCUMENT_SEARCH_PARAMETER, DIFF_VIEW_NEXT_DOCUMENT_SEARCH_PARAMETER].includes(key);
}
var diffViewModes = ["version"];
function isDiffViewMode(maybeDiffViewMode) {
  return diffViewModes.includes(maybeDiffViewMode);
}
function useDiffViewState(t0) {
  const $ = (0, import_compiler_runtime2.c)(22);
  let t1;
  $[0] !== t0 ? (t1 = t0 === void 0 ? {} : t0, $[0] = t0, $[1] = t1) : t1 = $[1];
  const {
    onParamsError
  } = t1, {
    state: routerState
  } = useRouter();
  let nextDocument, previousDocument, t2;
  if ($[2] !== routerState._searchParams) {
    const searchParams = new URLSearchParams(routerState._searchParams);
    previousDocument = searchParams.get(DIFF_VIEW_PREVIOUS_DOCUMENT_SEARCH_PARAMETER), nextDocument = searchParams.get(DIFF_VIEW_NEXT_DOCUMENT_SEARCH_PARAMETER), t2 = searchParams.get(DIFF_VIEW_SEARCH_PARAMETER), $[2] = routerState._searchParams, $[3] = nextDocument, $[4] = previousDocument, $[5] = t2;
  } else
    nextDocument = $[3], previousDocument = $[4], t2 = $[5];
  const mode = t2, anyParamSet = [previousDocument, nextDocument, mode].some(_temp$N), t3 = previousDocument ?? "", t4 = nextDocument ?? "", t5 = mode ?? "";
  let t6;
  $[6] !== t3 || $[7] !== t4 || $[8] !== t5 ? (t6 = parseParams({
    previousDocument: t3,
    nextDocument: t4,
    mode: t5
  }), $[6] = t3, $[7] = t4, $[8] = t5, $[9] = t6) : t6 = $[9];
  const params = t6;
  let t7;
  $[10] !== anyParamSet || $[11] !== onParamsError || $[12] !== params.errors || $[13] !== params.result ? (t7 = () => {
    params.result === "error" && anyParamSet && onParamsError?.(params.errors);
  }, $[10] = anyParamSet, $[11] = onParamsError, $[12] = params.errors, $[13] = params.result, $[14] = t7) : t7 = $[14];
  let t8;
  if ($[15] !== anyParamSet || $[16] !== onParamsError || $[17] !== params ? (t8 = [anyParamSet, onParamsError, params], $[15] = anyParamSet, $[16] = onParamsError, $[17] = params, $[18] = t8) : t8 = $[18], (0, import_react2.useEffect)(t7, t8), params.result === "error") {
    let t92;
    return $[19] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t92 = {
      isActive: false
    }, $[19] = t92) : t92 = $[19], t92;
  }
  let t9;
  return $[20] !== params.params ? (t9 = {
    state: "ready",
    isActive: true,
    ...params.params
  }, $[20] = params.params, $[21] = t9) : t9 = $[21], t9;
}
function _temp$N(param) {
  return param !== null;
}
function parseParams({
  previousDocument,
  nextDocument,
  mode
}) {
  const errors = [], [previousDocumentType, previousDocumentId] = previousDocument.split(DIFF_SEARCH_PARAM_DELIMITER).filter(Boolean), [nextDocumentType, nextDocumentId] = nextDocument.split(DIFF_SEARCH_PARAM_DELIMITER).filter(Boolean);
  return isDiffViewMode(mode) || errors.push(["invalidModeParam", mode]), (typeof previousDocumentType > "u" || typeof previousDocumentId > "u") && errors.push(["invalidPreviousDocumentParam", previousDocument]), (typeof nextDocumentType > "u" || typeof nextDocumentId > "u") && errors.push(["invalidNextDocumentParam", nextDocument]), errors.length !== 0 ? {
    result: "error",
    errors
  } : {
    result: "success",
    params: {
      mode,
      documents: {
        previous: {
          type: previousDocumentType,
          id: previousDocumentId
        },
        next: {
          type: nextDocumentType,
          id: nextDocumentId
        }
      }
    }
  };
}
function useScrollMirror(elements) {
  const $ = (0, import_compiler_runtime2.c)(3);
  let t0, t1;
  $[0] !== elements ? (t0 = () => {
    const existentElements = elements.filter(_temp$M);
    if (existentElements.length === 0)
      return;
    const scrollMirror = new s(existentElements);
    return () => scrollMirror.destroy();
  }, t1 = [elements], $[0] = elements, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), (0, import_react2.useEffect)(t0, t1);
}
function _temp$M(element) {
  return element !== null;
}
function findRelease(documentId, releases) {
  return isPublishedId(documentId) ? "published" : isDraftId(documentId) ? "draft" : releases.find(({
    _id
  }) => getReleaseIdFromReleaseDocumentId(_id) === getVersionFromId(documentId)) ?? getVersionFromId(documentId);
}
var VersionModeHeaderLayout = at.header.withConfig({
  displayName: "VersionModeHeaderLayout",
  componentId: "sc-w17umd-0"
})`display:grid;grid-area:header;grid-template-columns:1fr min-content 1fr;border-block-end:1px solid var(--card-border-color);`;
var VersionModeHeaderLayoutSection = at.div.withConfig({
  displayName: "VersionModeHeaderLayoutSection",
  componentId: "sc-w17umd-1"
})`display:flex;justify-content:space-between;align-items:center;`;
var VersionModeHeader = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(48), {
    documentId,
    state: state2
  } = t0, {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[0] !== documentId ? (t1 = {
    documentId
  }, $[0] = documentId, $[1] = t1) : t1 = $[1];
  const {
    data: documentVersions
  } = useDocumentVersions(t1), {
    exitDiffView,
    navigateDiffView
  } = useDiffViewRouter(), {
    documents
  } = useDiffViewState(), activeReleases = useActiveReleases();
  let t22;
  $[2] !== documentVersions ? (t22 = documentVersions.flatMap(_temp$L), $[2] = documentVersions, $[3] = t22) : t22 = $[3];
  const releasesIds = t22;
  let t3;
  if ($[4] !== activeReleases.data || $[5] !== releasesIds) {
    let t42;
    $[7] !== releasesIds ? (t42 = (release) => {
      const releaseId = getReleaseIdFromReleaseDocumentId(release._id);
      return typeof releaseId < "u" && releasesIds.includes(releaseId);
    }, $[7] = releasesIds, $[8] = t42) : t42 = $[8], t3 = activeReleases.data.filter(t42), $[4] = activeReleases.data, $[5] = releasesIds, $[6] = t3;
  } else
    t3 = $[6];
  const releases = t3;
  let t4;
  $[9] !== activeReleases ? (t4 = fetchingState(activeReleases), $[9] = activeReleases, $[10] = t4) : t4 = $[10];
  const releasesState = t4;
  let t5;
  $[11] !== documents || $[12] !== navigateDiffView ? (t5 = (selectedDocumentId) => {
    typeof documents?.previous < "u" && navigateDiffView({
      previousDocument: {
        ...documents.previous,
        id: selectedDocumentId
      }
    });
  }, $[11] = documents, $[12] = navigateDiffView, $[13] = t5) : t5 = $[13];
  const onSelectPreviousRelease = t5;
  let t6;
  $[14] !== documents || $[15] !== navigateDiffView ? (t6 = (selectedDocumentId_0) => {
    typeof documents?.next < "u" && navigateDiffView({
      nextDocument: {
        ...documents.next,
        id: selectedDocumentId_0
      }
    });
  }, $[14] = documents, $[15] = navigateDiffView, $[16] = t6) : t6 = $[16];
  const onSelectNextRelease = t6;
  let t7;
  $[17] !== t2 ? (t7 = t2("compare-versions.title"), $[17] = t2, $[18] = t7) : t7 = $[18];
  let t8;
  $[19] !== t7 ? (t8 = (0, import_jsx_runtime2.jsx)(Box, { padding: 4, children: (0, import_jsx_runtime2.jsx)(Text, { as: "h1", size: 1, muted: true, children: t7 }) }), $[19] = t7, $[20] = t8) : t8 = $[20];
  let t9;
  $[21] !== documentId || $[22] !== documents || $[23] !== onSelectPreviousRelease || $[24] !== releases || $[25] !== releasesState || $[26] !== state2 ? (t9 = typeof documents?.previous < "u" && (0, import_jsx_runtime2.jsx)(VersionMenu, { releases, releasesState, onSelectRelease: onSelectPreviousRelease, role: "previous", documentId, state: state2, document: documents.previous }), $[21] = documentId, $[22] = documents, $[23] = onSelectPreviousRelease, $[24] = releases, $[25] = releasesState, $[26] = state2, $[27] = t9) : t9 = $[27];
  let t10;
  $[28] !== t8 || $[29] !== t9 ? (t10 = (0, import_jsx_runtime2.jsxs)(VersionModeHeaderLayoutSection, { children: [
    t8,
    t9
  ] }), $[28] = t8, $[29] = t9, $[30] = t10) : t10 = $[30];
  let t11;
  $[31] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t11 = (0, import_jsx_runtime2.jsx)(Flex, { align: "center", paddingX: 3, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(TransferIcon, {}) }) }), $[31] = t11) : t11 = $[31];
  let t12;
  $[32] !== documentId || $[33] !== documents || $[34] !== onSelectNextRelease || $[35] !== releases || $[36] !== releasesState || $[37] !== state2 ? (t12 = typeof documents?.next < "u" && (0, import_jsx_runtime2.jsx)(VersionMenu, { releases, releasesState, onSelectRelease: onSelectNextRelease, role: "next", documentId, state: state2, document: documents.next }), $[32] = documentId, $[33] = documents, $[34] = onSelectNextRelease, $[35] = releases, $[36] = releasesState, $[37] = state2, $[38] = t12) : t12 = $[38];
  let t13;
  $[39] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t13 = {
    justifySelf: "end"
  }, $[39] = t13) : t13 = $[39];
  let t14;
  $[40] !== exitDiffView ? (t14 = (0, import_jsx_runtime2.jsx)(Box, { padding: 3, style: t13, children: (0, import_jsx_runtime2.jsx)(Button, { icon: CloseIcon, mode: "bleed", onClick: exitDiffView, padding: 2 }) }), $[40] = exitDiffView, $[41] = t14) : t14 = $[41];
  let t15;
  $[42] !== t12 || $[43] !== t14 ? (t15 = (0, import_jsx_runtime2.jsxs)(VersionModeHeaderLayoutSection, { children: [
    t12,
    t14
  ] }), $[42] = t12, $[43] = t14, $[44] = t15) : t15 = $[44];
  let t16;
  return $[45] !== t10 || $[46] !== t15 ? (t16 = (0, import_jsx_runtime2.jsxs)(VersionModeHeaderLayout, { children: [
    t10,
    t11,
    t15
  ] }), $[45] = t10, $[46] = t15, $[47] = t16) : t16 = $[47], t16;
};
var VersionMenu = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(46), {
    releases: t1,
    releasesState,
    onSelectRelease,
    role,
    documentId,
    document: document2
  } = t0;
  let t2;
  $[0] !== t1 ? (t2 = t1 === void 0 ? [] : t1, $[0] = t1, $[1] = t2) : t2 = $[1];
  const releases = t2;
  let t3;
  $[2] !== document2.id ? (t3 = getPublishedId(document2.id), $[2] = document2.id, $[3] = t3) : t3 = $[3];
  const {
    published,
    draft
  } = useEditState(t3, document2.type);
  let t4;
  $[4] !== document2.id || $[5] !== releases ? (t4 = findRelease(document2.id, releases), $[4] = document2.id, $[5] = releases, $[6] = t4) : t4 = $[6];
  const selected = t4, {
    t: tStructure
  } = useTranslation(structureLocaleNamespace), {
    t: tCore
  } = useTranslation(), {
    document: t5
  } = useWorkspace(), {
    drafts: t6
  } = t5, {
    enabled: isDraftModelEnabled
  } = t6;
  if (releasesState === "error") {
    let t72;
    $[7] !== tStructure ? (t72 = tStructure("compare-version.error.loadReleases.title"), $[7] = tStructure, $[8] = t72) : t72 = $[8];
    let t82;
    return $[9] !== t72 ? (t82 = (0, import_jsx_runtime2.jsx)(Badge, { tone: "critical", radius: 3, children: t72 }), $[9] = t72, $[10] = t82) : t82 = $[10], t82;
  }
  let t7;
  $[11] !== releasesState || $[12] !== selected || $[13] !== tCore || $[14] !== tStructure ? (t7 = getMenuButtonProps({
    selected,
    tCore,
    tStructure,
    releasesState
  }), $[11] = releasesState, $[12] = selected, $[13] = tCore, $[14] = tStructure, $[15] = t7) : t7 = $[15];
  let t8;
  $[16] !== t7 ? (t8 = (0, import_jsx_runtime2.jsx)(Button, { type: "button", mode: "bleed", padding: 2, paddingRight: 3, radius: "full", selected: true, ...t7 }), $[16] = t7, $[17] = t8) : t8 = $[17];
  let t9;
  $[18] !== documentId || $[19] !== onSelectRelease || $[20] !== published || $[21] !== selected ? (t9 = published && (0, import_jsx_runtime2.jsx)(VersionMenuItem, { type: "published", onSelect: onSelectRelease, isSelected: selected === "published", documentId }), $[18] = documentId, $[19] = onSelectRelease, $[20] = published, $[21] = selected, $[22] = t9) : t9 = $[22];
  let t10;
  $[23] !== documentId || $[24] !== draft || $[25] !== isDraftModelEnabled || $[26] !== onSelectRelease || $[27] !== selected ? (t10 = isDraftModelEnabled && draft && (0, import_jsx_runtime2.jsx)(VersionMenuItem, { type: "draft", onSelect: onSelectRelease, isSelected: selected === "draft", documentId }), $[23] = documentId, $[24] = draft, $[25] = isDraftModelEnabled, $[26] = onSelectRelease, $[27] = selected, $[28] = t10) : t10 = $[28];
  let t11;
  if ($[29] !== documentId || $[30] !== onSelectRelease || $[31] !== releases || $[32] !== selected) {
    let t122;
    $[34] !== documentId || $[35] !== onSelectRelease || $[36] !== selected ? (t122 = (release) => (0, import_jsx_runtime2.jsx)(VersionMenuItem, { release, onSelect: onSelectRelease, isSelected: typeof selected != "string" && selected?._id === release._id, documentId }, release._id), $[34] = documentId, $[35] = onSelectRelease, $[36] = selected, $[37] = t122) : t122 = $[37], t11 = releases.map(t122), $[29] = documentId, $[30] = onSelectRelease, $[31] = releases, $[32] = selected, $[33] = t11;
  } else
    t11 = $[33];
  let t12;
  $[38] !== t10 || $[39] !== t11 || $[40] !== t9 ? (t12 = (0, import_jsx_runtime2.jsxs)(Menu, { children: [
    t9,
    t10,
    t11
  ] }), $[38] = t10, $[39] = t11, $[40] = t9, $[41] = t12) : t12 = $[41];
  let t13;
  return $[42] !== role || $[43] !== t12 || $[44] !== t8 ? (t13 = (0, import_jsx_runtime2.jsx)(MenuButton, { id: role, button: t8, menu: t12 }), $[42] = role, $[43] = t12, $[44] = t8, $[45] = t13) : t13 = $[45], t13;
};
var VersionMenuItem = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(53), {
    type,
    release,
    onSelect,
    isSelected,
    documentId
  } = t0, {
    t: tCore
  } = useTranslation(), {
    t: tStructure
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[0] !== documentId || $[1] !== onSelect || $[2] !== release || $[3] !== type ? (t1 = () => {
    if (type === "draft") {
      onSelect(getDraftId(documentId));
      return;
    }
    if (type === "published") {
      onSelect(getPublishedId(documentId));
      return;
    }
    typeof release?._id < "u" && onSelect(getVersionId(documentId, getReleaseIdFromReleaseDocumentId(release._id)));
  }, $[0] = documentId, $[1] = onSelect, $[2] = release, $[3] = type, $[4] = t1) : t1 = $[4];
  const onClick = t1;
  if (type) {
    const tone = type === "published" ? "positive" : "caution";
    let t22;
    $[5] !== tone ? (t22 = (0, import_jsx_runtime2.jsx)(ReleaseAvatar, { padding: 2, tone }), $[5] = tone, $[6] = t22) : t22 = $[6];
    let t32;
    $[7] !== type ? (t32 = ["compare-versions.status", type], $[7] = type, $[8] = t32) : t32 = $[8];
    const t42 = t32.join(".");
    let t52;
    $[9] !== t42 || $[10] !== tStructure ? (t52 = tStructure(t42), $[9] = t42, $[10] = tStructure, $[11] = t52) : t52 = $[11];
    let t62;
    $[12] !== t52 ? (t62 = (0, import_jsx_runtime2.jsx)(Box, { paddingY: 2, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: t52 }) }), $[12] = t52, $[13] = t62) : t62 = $[13];
    let t72;
    $[14] !== t22 || $[15] !== t62 ? (t72 = (0, import_jsx_runtime2.jsxs)(Flex, { gap: 1, children: [
      t22,
      t62
    ] }), $[14] = t22, $[15] = t62, $[16] = t72) : t72 = $[16];
    let t82;
    return $[17] !== isSelected || $[18] !== onClick || $[19] !== t72 ? (t82 = (0, import_jsx_runtime2.jsx)(MenuItem, { padding: 1, paddingRight: 3, onClick, pressed: isSelected, children: t72 }), $[17] = isSelected, $[18] = onClick, $[19] = t72, $[20] = t82) : t82 = $[20], t82;
  }
  let t2;
  $[21] !== release ? (t2 = release ? getReleaseTone(release) : "neutral", $[21] = release, $[22] = t2) : t2 = $[22];
  const tone_0 = t2;
  let t3;
  $[23] !== tone_0 ? (t3 = (0, import_jsx_runtime2.jsx)(ReleaseAvatar, { padding: 2, tone: tone_0 }), $[23] = tone_0, $[24] = t3) : t3 = $[24];
  let t4;
  $[25] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t4 = {
    minWidth: 0
  }, $[25] = t4) : t4 = $[25];
  const t5 = release.metadata.title;
  let t6;
  $[26] !== tCore ? (t6 = tCore("release.placeholder-untitled-release"), $[26] = tCore, $[27] = t6) : t6 = $[27];
  let t7;
  $[28] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t7 = {
    size: 1,
    weight: "medium"
  }, $[28] = t7) : t7 = $[28];
  let t8;
  $[29] !== release.metadata.title || $[30] !== t6 ? (t8 = (0, import_jsx_runtime2.jsx)(ReleaseTitle, { title: t5, fallback: t6, textProps: t7 }), $[29] = release.metadata.title, $[30] = t6, $[31] = t8) : t8 = $[31];
  let t9;
  $[32] !== release.metadata.releaseType || $[33] !== tCore ? (t9 = ["asap", "undecided"].includes(release.metadata.releaseType) && (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: tCore(`release.type.${release.metadata.releaseType}`) }), $[32] = release.metadata.releaseType, $[33] = tCore, $[34] = t9) : t9 = $[34];
  let t10;
  $[35] !== release ? (t10 = release.metadata.releaseType === "scheduled" && (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: formatRelativeLocalePublishDate(release) }), $[35] = release, $[36] = t10) : t10 = $[36];
  let t11;
  $[37] !== t10 || $[38] !== t8 || $[39] !== t9 ? (t11 = (0, import_jsx_runtime2.jsxs)(Stack, { flex: 1, paddingY: 2, paddingRight: 2, space: 2, style: t4, children: [
    t8,
    t9,
    t10
  ] }), $[37] = t10, $[38] = t8, $[39] = t9, $[40] = t11) : t11 = $[40];
  let t12;
  $[41] !== release ? (t12 = isReleaseScheduledOrScheduling(release) && (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(LockIcon, {}) }) }), $[41] = release, $[42] = t12) : t12 = $[42];
  let t13;
  $[43] !== t12 ? (t13 = (0, import_jsx_runtime2.jsx)(Flex, { flex: "none", children: t12 }), $[43] = t12, $[44] = t13) : t13 = $[44];
  let t14;
  $[45] !== t11 || $[46] !== t13 || $[47] !== t3 ? (t14 = (0, import_jsx_runtime2.jsxs)(Flex, { gap: 1, children: [
    t3,
    t11,
    t13
  ] }), $[45] = t11, $[46] = t13, $[47] = t3, $[48] = t14) : t14 = $[48];
  let t15;
  return $[49] !== isSelected || $[50] !== onClick || $[51] !== t14 ? (t15 = (0, import_jsx_runtime2.jsx)(MenuItem, { padding: 1, paddingRight: 3, onClick, pressed: isSelected, children: t14 }), $[49] = isSelected, $[50] = onClick, $[51] = t14, $[52] = t15) : t15 = $[52], t15;
};
function getMenuButtonProps({
  selected,
  tCore,
  tStructure,
  releasesState
}) {
  if (releasesState === "pending")
    return {
      text: tCore("common.loading"),
      tone: "neutral",
      disabled: true
    };
  if (isReleaseDocument(selected)) {
    const tone = selected ? getReleaseTone(selected) : "neutral";
    return {
      text: selected?.metadata.title || tCore("release.placeholder-untitled-release"),
      icon: (0, import_jsx_runtime2.jsx)(ReleaseAvatar, { padding: 1, tone }),
      iconRight: selected && isReleaseScheduledOrScheduling(selected) ? (0, import_jsx_runtime2.jsx)(LockIcon, {}) : void 0,
      tone
    };
  }
  if (isSystemBundleName(selected)) {
    const tone = selected === "published" ? "positive" : "caution";
    return {
      text: tStructure(["compare-versions.status", selected].join(".")),
      icon: (0, import_jsx_runtime2.jsx)(ReleaseAvatar, { padding: 1, tone }),
      tone
    };
  }
  return {
    text: selected,
    icon: (0, import_jsx_runtime2.jsx)(ReleaseAvatar, { padding: 1, tone: "neutral" }),
    tone: "neutral"
  };
}
function fetchingState({
  loading,
  error
}) {
  return loading ? "pending" : typeof error < "u" ? "error" : "ready";
}
function _temp$L(id) {
  return getVersionFromId(id) ?? [];
}
var DialogLayout = at.div.withConfig({
  displayName: "DialogLayout",
  componentId: "sc-x0jh85-0"
})`--offset-block:40px;display:grid;height:calc(100vh - var(--offset-block));min-height:0;overflow:hidden;grid-template-areas:'header header' 'previous-document next-document';grid-template-columns:1fr 1fr;grid-template-rows:min-content minmax(0,1fr);`;
function pickDocumentLayoutComponent(plugin) {
  return plugin.document?.components?.unstable_layout;
}
function usePathSyncChannel(t0) {
  const $ = (0, import_compiler_runtime2.c)(11), {
    syncChannel,
    id
  } = t0;
  let t1;
  $[0] !== id || $[1] !== syncChannel ? (t1 = (state2) => syncChannel.next({
    ...state2,
    source: id
  }), $[0] = id, $[1] = syncChannel, $[2] = t1) : t1 = $[2];
  const push = t1;
  let t2;
  if ($[3] !== id || $[4] !== syncChannel) {
    let t32;
    $[6] !== id ? (t32 = (t4) => {
      const {
        source
      } = t4;
      return source !== id;
    }, $[6] = id, $[7] = t32) : t32 = $[7], t2 = syncChannel.pipe(distinctUntilChanged(_temp$K), filter(t32), map(_temp2$j)), $[3] = id, $[4] = syncChannel, $[5] = t2;
  } else
    t2 = $[5];
  const path = t2;
  let t3;
  return $[8] !== path || $[9] !== push ? (t3 = {
    path,
    push
  }, $[8] = path, $[9] = push, $[10] = t3) : t3 = $[10], t3;
}
function _temp2$j(state_0) {
  return state_0.path;
}
function _temp$K(previous, next) {
  return (0, import_react_fast_compare.default)(previous.path, next.path);
}
var Scroller$5 = at.div.withConfig({
  displayName: "Scroller",
  componentId: "sc-16z7cpf-0"
})`position:relative;height:100%;overflow:auto;scroll-behavior:smooth;scrollbar-width:var(--scrollbar-width);overscroll-behavior:contain;will-change:scroll-position;`;
var DiffViewPaneLayout = at(Card).withConfig({
  displayName: "DiffViewPaneLayout",
  componentId: "sc-1856b20-0"
})`position:relative;grid-area:var(--grid-area);`;
var Container2 = at(Container).withConfig({
  displayName: "Container",
  componentId: "sc-1856b20-1"
})`width:auto;`;
var DiffViewPane = (0, import_react2.forwardRef)(function(t0, ref) {
  const $ = (0, import_compiler_runtime2.c)(36), {
    role,
    documentType,
    documentId,
    scrollElement,
    syncChannel,
    compareDocument
  } = t0, containerElement = (0, import_react2.useRef)(null), [portalElement, setPortalElement] = (0, import_react2.useState)(null), [boundaryElement, setBoundaryElement] = (0, import_react2.useState)(null);
  let t1;
  $[0] !== compareDocument || $[1] !== documentId || $[2] !== documentType || $[3] !== role || $[4] !== scrollElement || $[5] !== syncChannel ? (t1 = () => (0, import_jsx_runtime2.jsx)(DiffViewDocument, { compareDocument, documentId, documentType, role, scrollElement, syncChannel }), $[0] = compareDocument, $[1] = documentId, $[2] = documentType, $[3] = role, $[4] = scrollElement, $[5] = syncChannel, $[6] = t1) : t1 = $[6];
  const t2 = t1;
  let t3;
  $[7] !== t2 ? (t3 = {
    pick: pickDocumentLayoutComponent,
    defaultComponent: t2
  }, $[7] = t2, $[8] = t3) : t3 = $[8];
  const DocumentLayout2 = useMiddlewareComponents(t3);
  let t4;
  $[9] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t4 = {
    isInteractive: false,
    onOpenReviewChanges: noop_default,
    onSetFocus: noop_default,
    isReviewChangesOpen: false
  }, $[9] = t4) : t4 = $[9];
  const t5 = `${role}-document`;
  let t6;
  $[10] !== t5 ? (t6 = {
    "--grid-area": t5
  }, $[10] = t5, $[11] = t6) : t6 = $[11];
  const t7 = t6, t8 = role === "next", t9 = role !== "next" && "none";
  let t10;
  $[12] !== t9 ? (t10 = {
    "--scrollbar-width": t9
  }, $[12] = t9, $[13] = t10) : t10 = $[13];
  const t11 = t10;
  let t12;
  $[14] !== DocumentLayout2 || $[15] !== documentId || $[16] !== documentType ? (t12 = (0, import_jsx_runtime2.jsx)(DialogProvider, { position: "absolute", children: (0, import_jsx_runtime2.jsx)(Container2, { ref: containerElement, padding: 4, width: 1, children: (0, import_jsx_runtime2.jsx)(DocumentLayout2, { documentId, documentType }) }) }), $[14] = DocumentLayout2, $[15] = documentId, $[16] = documentType, $[17] = t12) : t12 = $[17];
  let t13;
  $[18] !== portalElement || $[19] !== t12 ? (t13 = (0, import_jsx_runtime2.jsx)(PortalProvider, { element: portalElement, children: t12 }), $[18] = portalElement, $[19] = t12, $[20] = t13) : t13 = $[20];
  let t14;
  $[21] !== ref || $[22] !== t11 || $[23] !== t13 ? (t14 = (0, import_jsx_runtime2.jsx)(Scroller$5, { ref, style: t11, children: t13 }), $[21] = ref, $[22] = t11, $[23] = t13, $[24] = t14) : t14 = $[24];
  let t15;
  $[25] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t15 = (0, import_jsx_runtime2.jsx)("div", { "data-testid": "diffView-document-panel-portal", ref: setPortalElement }), $[25] = t15) : t15 = $[25];
  let t16;
  $[26] !== t14 || $[27] !== t7 || $[28] !== t8 ? (t16 = (0, import_jsx_runtime2.jsxs)(DiffViewPaneLayout, { ref: setBoundaryElement, style: t7, borderLeft: t8, children: [
    t14,
    t15
  ] }), $[26] = t14, $[27] = t7, $[28] = t8, $[29] = t16) : t16 = $[29];
  let t17;
  $[30] !== boundaryElement || $[31] !== t16 ? (t17 = (0, import_jsx_runtime2.jsx)(BoundaryElementProvider, { element: boundaryElement, children: t16 }), $[30] = boundaryElement, $[31] = t16, $[32] = t17) : t17 = $[32];
  let t18;
  return $[33] !== scrollElement || $[34] !== t17 ? (t18 = (0, import_jsx_runtime2.jsx)(ReviewChangesContext.Provider, { value: t4, children: (0, import_jsx_runtime2.jsx)(ChangeIndicatorsTracker, { children: (0, import_jsx_runtime2.jsx)(VirtualizerScrollInstanceProvider, { scrollElement, containerElement, children: t17 }) }) }), $[33] = scrollElement, $[34] = t17, $[35] = t18) : t18 = $[35], t18;
});
var DiffViewDocument = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(52), {
    role,
    documentType,
    documentId,
    syncChannel,
    compareDocument
  } = t0;
  let t1;
  $[0] !== compareDocument ? (t1 = {
    compareDocument
  }, $[0] = compareDocument, $[1] = t1) : t1 = $[1];
  const compareValue = useCompareValue(t1), {
    data: releases
  } = useActiveReleases(), [patchChannel] = (0, import_react2.useState)(_temp$J);
  let t2;
  $[2] !== documentId || $[3] !== releases ? (t2 = findRelease(documentId, releases), $[2] = documentId, $[3] = releases, $[4] = t2) : t2 = $[4];
  const perspective = t2;
  let t3;
  $[5] !== documentId ? (t3 = getPublishedId(documentId), $[5] = documentId, $[6] = t3) : t3 = $[6];
  let t4;
  $[7] !== documentId ? (t4 = perspectiveName(documentId), $[7] = documentId, $[8] = t4) : t4 = $[8];
  let t5;
  $[9] !== documentId ? (t5 = getVersionFromId(documentId), $[9] = documentId, $[10] = t5) : t5 = $[10];
  let t6;
  $[11] !== compareValue || $[12] !== documentType || $[13] !== t3 || $[14] !== t4 || $[15] !== t5 ? (t6 = {
    documentId: t3,
    documentType,
    selectedPerspectiveName: t4,
    releaseId: t5,
    comparisonValue: compareValue,
    displayInlineChanges: true
  }, $[11] = compareValue, $[12] = documentType, $[13] = t3, $[14] = t4, $[15] = t5, $[16] = t6) : t6 = $[16];
  const {
    formState,
    onChange,
    onFocus,
    onBlur,
    onSetActiveFieldGroup,
    onSetCollapsedFieldSet,
    onSetCollapsedPath,
    collapsedFieldSets,
    ready,
    collapsedPaths,
    schemaType,
    value,
    onProgrammaticFocus,
    openPath,
    onPathOpen: onPathOpenFromForm
  } = useDocumentForm(t6), isLoading = formState === null || !ready;
  let t7;
  $[17] !== role || $[18] !== syncChannel ? (t7 = {
    id: role,
    syncChannel
  }, $[17] = role, $[18] = syncChannel, $[19] = t7) : t7 = $[19];
  const pathSyncChannel = usePathSyncChannel(t7);
  let t8;
  $[20] !== onPathOpenFromForm || $[21] !== pathSyncChannel || $[22] !== role ? (t8 = (path) => {
    onPathOpenFromForm(path), pathSyncChannel.push({
      source: role,
      path
    });
  }, $[20] = onPathOpenFromForm, $[21] = pathSyncChannel, $[22] = role, $[23] = t8) : t8 = $[23];
  const onPathOpen = t8;
  let t9;
  $[24] !== onPathOpenFromForm || $[25] !== onProgrammaticFocus || $[26] !== pathSyncChannel.path ? (t9 = () => {
    const subscription = pathSyncChannel.path.subscribe((path_0) => {
      onPathOpenFromForm(path_0), onProgrammaticFocus(path_0);
    });
    return () => subscription.unsubscribe();
  }, $[24] = onPathOpenFromForm, $[25] = onProgrammaticFocus, $[26] = pathSyncChannel.path, $[27] = t9) : t9 = $[27];
  let t10;
  $[28] !== onPathOpenFromForm || $[29] !== onProgrammaticFocus || $[30] !== pathSyncChannel.path || $[31] !== role ? (t10 = [onPathOpenFromForm, onProgrammaticFocus, pathSyncChannel.path, role], $[28] = onPathOpenFromForm, $[29] = onProgrammaticFocus, $[30] = pathSyncChannel.path, $[31] = role, $[32] = t10) : t10 = $[32], (0, import_react2.useEffect)(t9, t10);
  let t11;
  return $[33] !== collapsedFieldSets || $[34] !== collapsedPaths || $[35] !== compareValue || $[36] !== formState || $[37] !== isLoading || $[38] !== onBlur || $[39] !== onChange || $[40] !== onFocus || $[41] !== onPathOpen || $[42] !== onSetActiveFieldGroup || $[43] !== onSetCollapsedFieldSet || $[44] !== onSetCollapsedPath || $[45] !== openPath || $[46] !== patchChannel || $[47] !== perspective || $[48] !== role || $[49] !== schemaType || $[50] !== value ? (t11 = isLoading ? (0, import_jsx_runtime2.jsx)(LoadingBlock, { showText: true }) : (0, import_jsx_runtime2.jsx)(CommentsEnabledContext.Provider, { value: {
    enabled: false,
    mode: null
  }, children: (0, import_jsx_runtime2.jsx)(FormBuilder, { __internal_patchChannel: patchChannel, id: `diffView-pane-${role}`, onChange, onPathFocus: onFocus, onPathOpen, onPathBlur: onBlur, onFieldGroupSelect: onSetActiveFieldGroup, onSetFieldSetCollapsed: onSetCollapsedFieldSet, onSetPathCollapsed: onSetCollapsedPath, collapsedPaths, collapsedFieldSets, focusPath: formState.focusPath, openPath, changed: formState.changed, focused: formState.focused, groups: formState.groups, validation: formState.validation, members: formState.members, perspective: sanitizeBundleName(perspective), hasUpstreamVersion: formState.hasUpstreamVersion, presence: formState.presence, schemaType, value, compareValue }) }), $[33] = collapsedFieldSets, $[34] = collapsedPaths, $[35] = compareValue, $[36] = formState, $[37] = isLoading, $[38] = onBlur, $[39] = onChange, $[40] = onFocus, $[41] = onPathOpen, $[42] = onSetActiveFieldGroup, $[43] = onSetCollapsedFieldSet, $[44] = onSetCollapsedPath, $[45] = openPath, $[46] = patchChannel, $[47] = perspective, $[48] = role, $[49] = schemaType, $[50] = value, $[51] = t11) : t11 = $[51], t11;
};
function perspectiveName(documentId) {
  if (isVersionId(documentId))
    return getVersionFromId(documentId);
  if (isPublishedId(documentId))
    return "published";
}
function useCompareValue(t0) {
  const $ = (0, import_compiler_runtime2.c)(4), {
    compareDocument
  } = t0;
  let t1;
  $[0] !== compareDocument.id ? (t1 = getPublishedId(compareDocument.id), $[0] = compareDocument.id, $[1] = t1) : t1 = $[1];
  const t2 = compareDocument.type;
  let t3;
  $[2] !== compareDocument.id ? (t3 = getVersionFromId(compareDocument.id), $[2] = compareDocument.id, $[3] = t3) : t3 = $[3];
  const compareDocumentEditState = useEditState(t1, t2, "low", t3);
  let t4;
  bb0: {
    if (isVersionId(compareDocument.id)) {
      t4 = compareDocumentEditState.version ?? void 0;
      break bb0;
    }
    if (isDraftId(compareDocument.id)) {
      t4 = compareDocumentEditState.draft ?? void 0;
      break bb0;
    }
    if (isPublishedId(compareDocument.id)) {
      t4 = compareDocumentEditState.published ?? void 0;
      break bb0;
    }
    t4 = void 0;
  }
  return t4;
}
function sanitizeBundleName(bundle) {
  return bundle === "draft" ? "drafts" : bundle;
}
function _temp$J() {
  return createPatchChannel();
}
var Link = at.a.withConfig({
  displayName: "Link",
  componentId: "sc-ihhvnj-0"
})`flex:1;text-decoration:none;color:inherit;`;
var EditReferenceLinkComponent = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(6), {
    children,
    documentId: _documentId,
    documentType
  } = t0;
  let t1;
  $[0] !== _documentId || $[1] !== documentType ? (t1 = {
    intent: "edit",
    params: {
      id: _documentId,
      type: documentType
    }
  }, $[0] = _documentId, $[1] = documentType, $[2] = t1) : t1 = $[2];
  const {
    href
  } = useIntentLink(t1);
  let t2;
  return $[3] !== children || $[4] !== href ? (t2 = (0, import_jsx_runtime2.jsx)(Link, { href, target: "_blank", rel: "noopener noreferrer", children }), $[3] = children, $[4] = href, $[5] = t2) : t2 = $[5], t2;
};
var DiffView = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(24), {
    documentId
  } = t0, {
    documents,
    state: state2,
    mode
  } = useDiffViewState(), {
    exitDiffView
  } = useDiffViewRouter(), syncChannel = useCreatePathSyncChannel(), [previousPaneElement, setPreviousPaneElement] = (0, import_react2.useState)(null), [nextPaneElement, setNextPaneElement] = (0, import_react2.useState)(null), referenceInputOptionsContext = (0, import_react2.useContext)(ReferenceInputOptionsContext);
  let t1;
  $[0] !== referenceInputOptionsContext ? (t1 = {
    ...referenceInputOptionsContext,
    disableNew: true,
    EditReferenceLinkComponent
  }, $[0] = referenceInputOptionsContext, $[1] = t1) : t1 = $[1];
  const diffViewReferenceInputOptionsContext = t1;
  let t2;
  $[2] !== nextPaneElement || $[3] !== previousPaneElement ? (t2 = [previousPaneElement, nextPaneElement], $[2] = nextPaneElement, $[3] = previousPaneElement, $[4] = t2) : t2 = $[4], useScrollMirror(t2);
  let t3;
  $[5] !== documentId || $[6] !== mode || $[7] !== state2 ? (t3 = mode === "version" && (0, import_jsx_runtime2.jsx)(VersionModeHeader, { documentId, state: state2 }), $[5] = documentId, $[6] = mode, $[7] = state2, $[8] = t3) : t3 = $[8];
  let t4;
  $[9] !== documents || $[10] !== nextPaneElement || $[11] !== previousPaneElement || $[12] !== state2 || $[13] !== syncChannel ? (t4 = state2 === "ready" && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    (0, import_jsx_runtime2.jsx)(DiffViewPane, { documentType: documents.previous.type, documentId: documents.previous.id, role: "previous", ref: setPreviousPaneElement, scrollElement: previousPaneElement, syncChannel, compareDocument: documents.previous }),
    (0, import_jsx_runtime2.jsx)(DiffViewPane, { documentType: documents.next.type, documentId: documents.next.id, role: "next", ref: setNextPaneElement, scrollElement: nextPaneElement, syncChannel, compareDocument: documents.previous })
  ] }), $[9] = documents, $[10] = nextPaneElement, $[11] = previousPaneElement, $[12] = state2, $[13] = syncChannel, $[14] = t4) : t4 = $[14];
  let t5;
  $[15] !== t3 || $[16] !== t4 ? (t5 = (0, import_jsx_runtime2.jsxs)(DialogLayout, { children: [
    t3,
    t4
  ] }), $[15] = t3, $[16] = t4, $[17] = t5) : t5 = $[17];
  let t6;
  $[18] !== exitDiffView || $[19] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(Dialog2, { id: "diffView", width: "auto", onClose: exitDiffView, padding: false, __unstable_hideCloseButton: true, children: t5 }), $[18] = exitDiffView, $[19] = t5, $[20] = t6) : t6 = $[20];
  let t7;
  return $[21] !== diffViewReferenceInputOptionsContext || $[22] !== t6 ? (t7 = (0, import_jsx_runtime2.jsx)(ReferenceInputOptionsContext.Provider, { value: diffViewReferenceInputOptionsContext, children: t6 }), $[21] = diffViewReferenceInputOptionsContext, $[22] = t6, $[23] = t7) : t7 = $[23], t7;
};
var DiffViewDocumentLayout = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(9), {
    children,
    documentId
  } = t0, toast = useToast(), {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[0] !== t2 || $[1] !== toast ? (t1 = {
    onParamsError: (errors) => {
      toast.push({
        id: "diffViewParamsParsingError",
        status: "error",
        title: t2("compare-version.error.invalidParams.title"),
        description: (0, import_jsx_runtime2.jsx)("ul", { children: errors.map((t222) => {
          const [error, input] = t222;
          return (0, import_jsx_runtime2.jsx)("li", { children: t2(`compare-version.error.${error}`, {
            input
          }) }, error);
        }) })
      });
    }
  }, $[0] = t2, $[1] = toast, $[2] = t1) : t1 = $[2];
  const {
    isActive
  } = useDiffViewState(t1);
  let t22;
  $[3] !== documentId || $[4] !== isActive ? (t22 = isActive && (0, import_jsx_runtime2.jsx)(DiffView, { documentId }), $[3] = documentId, $[4] = isActive, $[5] = t22) : t22 = $[5];
  let t3;
  return $[6] !== children || $[7] !== t22 ? (t3 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    children,
    t22
  ] }), $[6] = children, $[7] = t22, $[8] = t3) : t3 = $[8], t3;
};
var PANE_DEBUG = false;
var PANE_COLLAPSED_WIDTH = 51;
var PANE_DEFAULT_MIN_WIDTH = 204;
function usePaneLayout() {
  const pane2 = (0, import_react2.useContext)(PaneLayoutContext);
  if (!pane2)
    throw new Error("PaneLayout: missing context value");
  return pane2;
}
var Root$a = at(Layer).withConfig({
  displayName: "Root",
  componentId: "sc-k0eo57-0"
})`position:relative;width:1px;min-width:1px;&:before{content:'';display:block;position:absolute;top:0;left:0;bottom:0;width:1px;background-color:var(--card-border-color);}&:not([data-disabled]){cursor:ew-resize;width:9px;min-width:9px;margin:0 -4px;&:before{left:4px;}&:after{content:'';display:block;position:absolute;top:0;left:0;width:9px;bottom:0;background-color:var(--card-border-color);opacity:0;transition:opacity 150ms;}&[data-dragging]:after,&:hover:after{opacity:0.2;}}`;
function PaneDivider(t0) {
  const $ = (0, import_compiler_runtime2.c)(7), {
    disabled,
    element
  } = t0, {
    resize
  } = usePaneLayout(), [dragging, setDragging] = (0, import_react2.useState)(false);
  let t1;
  $[0] !== element || $[1] !== resize ? (t1 = (event) => {
    if (!element)
      return;
    setDragging(true), event.preventDefault();
    const startX = event.pageX;
    resize("start", element, 0);
    const handleMouseMove = (e2) => {
      e2.preventDefault();
      const deltaX = e2.pageX - startX;
      resize("move", element, deltaX);
    }, handleMouseUp = (e_0) => {
      e_0.preventDefault(), setDragging(false), window.removeEventListener("mousemove", handleMouseMove), window.removeEventListener("mouseup", handleMouseUp), resize("end", element, 0);
    };
    window.addEventListener("mousemove", handleMouseMove), window.addEventListener("mouseup", handleMouseUp);
  }, $[0] = element, $[1] = resize, $[2] = t1) : t1 = $[2];
  const handleMouseDown = t1, t2 = disabled ? "" : void 0, t3 = dragging ? "" : void 0;
  let t4;
  return $[3] !== handleMouseDown || $[4] !== t2 || $[5] !== t3 ? (t4 = (0, import_jsx_runtime2.jsx)(Root$a, { "data-disabled": t2, "data-dragging": t3, onMouseDown: handleMouseDown }), $[3] = handleMouseDown, $[4] = t2, $[5] = t3, $[6] = t4) : t4 = $[6], t4;
}
var Root$9 = at(Card).withConfig({
  displayName: "Root",
  componentId: "sc-o2std4-0"
})`outline:none;box-shadow:1px 0 0 var(--card-border-color);`;
var Pane = (0, import_react2.forwardRef)(function(props, forwardedRef) {
  const $ = (0, import_compiler_runtime2.c)(86);
  let children, currentMaxWidthProp, currentMinWidthProp, id, maxWidthProp, minWidthProp, restProps, t0, t1;
  $[0] !== props ? ({
    children,
    currentMinWidth: currentMinWidthProp,
    currentMaxWidth: currentMaxWidthProp,
    flex: t0,
    id,
    minWidth: minWidthProp,
    maxWidth: maxWidthProp,
    selected: t1,
    ...restProps
  } = props, $[0] = props, $[1] = children, $[2] = currentMaxWidthProp, $[3] = currentMinWidthProp, $[4] = id, $[5] = maxWidthProp, $[6] = minWidthProp, $[7] = restProps, $[8] = t0, $[9] = t1) : (children = $[1], currentMaxWidthProp = $[2], currentMinWidthProp = $[3], id = $[4], maxWidthProp = $[5], minWidthProp = $[6], restProps = $[7], t0 = $[8], t1 = $[9]);
  const flexProp = t0 === void 0 ? 1 : t0, selected = t1 === void 0 ? false : t1, [rootElement, setRootElement] = (0, import_react2.useState)(null), {
    collapse,
    collapsed: layoutCollapsed,
    expand,
    expandedElement,
    mount,
    panes
  } = usePaneLayout();
  let pane2, t2;
  if ($[10] !== panes || $[11] !== rootElement) {
    let t32;
    $[14] !== rootElement ? (t32 = (p) => p.element === rootElement, $[14] = rootElement, $[15] = t32) : t32 = $[15], pane2 = panes.find(t32), t2 = pane2 && panes.indexOf(pane2), $[10] = panes, $[11] = rootElement, $[12] = pane2, $[13] = t2;
  } else
    pane2 = $[12], t2 = $[13];
  const paneIndex = t2, nextPane = typeof paneIndex == "number" ? panes[paneIndex + 1] : void 0, isLast = paneIndex === panes.length - 1, expanded = expandedElement === rootElement, collapsed = layoutCollapsed ? false : pane2?.collapsed || false, nextCollapsed = nextPane?.collapsed || false, ref = (0, import_react2.useRef)(null), flex = pane2?.flex ?? flexProp, currentMinWidth = pane2?.currentMinWidth ?? currentMinWidthProp, currentMaxWidth = pane2?.currentMaxWidth ?? currentMaxWidthProp;
  let t3;
  $[16] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t3 = () => ref.current, $[16] = t3) : t3 = $[16], (0, import_react2.useImperativeHandle)(forwardedRef, t3);
  let t4;
  $[17] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t4 = (refValue) => {
    setRootElement(refValue), ref.current = refValue;
  }, $[17] = t4) : t4 = $[17];
  const setRef = t4;
  let t5, t6;
  $[18] !== currentMaxWidthProp || $[19] !== currentMinWidthProp || $[20] !== flexProp || $[21] !== id || $[22] !== maxWidthProp || $[23] !== minWidthProp || $[24] !== mount || $[25] !== rootElement ? (t5 = () => {
    if (rootElement)
      return mount(rootElement, {
        currentMinWidth: currentMinWidthProp,
        currentMaxWidth: currentMaxWidthProp,
        flex: flexProp,
        id,
        minWidth: minWidthProp,
        maxWidth: maxWidthProp
      });
  }, t6 = [currentMinWidthProp, currentMaxWidthProp, flexProp, id, minWidthProp, maxWidthProp, mount, rootElement], $[18] = currentMaxWidthProp, $[19] = currentMinWidthProp, $[20] = flexProp, $[21] = id, $[22] = maxWidthProp, $[23] = minWidthProp, $[24] = mount, $[25] = rootElement, $[26] = t5, $[27] = t6) : (t5 = $[26], t6 = $[27]), (0, import_react2.useLayoutEffect)(t5, t6);
  let t7;
  $[28] !== collapse || $[29] !== rootElement ? (t7 = () => {
    rootElement && collapse(rootElement);
  }, $[28] = collapse, $[29] = rootElement, $[30] = t7) : t7 = $[30];
  const handleCollapse = t7;
  let t8;
  $[31] !== expand || $[32] !== rootElement ? (t8 = () => {
    rootElement && expand(rootElement);
  }, $[31] = expand, $[32] = rootElement, $[33] = t8) : t8 = $[33];
  const handleExpand = t8, t9 = layoutCollapsed ? false : collapsed;
  let t10;
  $[34] !== handleCollapse || $[35] !== handleExpand || $[36] !== isLast || $[37] !== paneIndex || $[38] !== rootElement || $[39] !== t9 ? (t10 = {
    collapse: handleCollapse,
    collapsed: t9,
    expand: handleExpand,
    index: paneIndex,
    isLast,
    rootElement
  }, $[34] = handleCollapse, $[35] = handleExpand, $[36] = isLast, $[37] = paneIndex, $[38] = rootElement, $[39] = t9, $[40] = t10) : t10 = $[40];
  const contextValue = t10;
  let t11;
  bb0: {
    if (layoutCollapsed) {
      t11 = void 0;
      break bb0;
    }
    if (collapsed) {
      t11 = PANE_COLLAPSED_WIDTH;
      break bb0;
    }
    if (currentMinWidth === 0) {
      t11 = minWidthProp || PANE_DEFAULT_MIN_WIDTH;
      break bb0;
    }
    if (isLast) {
      t11 = minWidthProp || PANE_DEFAULT_MIN_WIDTH;
      break bb0;
    }
    t11 = currentMinWidth || minWidthProp || PANE_DEFAULT_MIN_WIDTH;
  }
  const minWidth = t11;
  let t12;
  bb1: {
    if (collapsed) {
      t12 = PANE_COLLAPSED_WIDTH;
      break bb1;
    }
    if (layoutCollapsed && isLast) {
      t12 = void 0;
      break bb1;
    }
    if (isLast) {
      if (maxWidthProp) {
        t12 = currentMaxWidth ?? maxWidthProp;
        break bb1;
      }
      t12 = void 0;
      break bb1;
    }
    t12 = currentMaxWidth ?? maxWidthProp;
  }
  const maxWidth = t12, hidden = layoutCollapsed && !isLast;
  let t13;
  $[41] !== collapsed || $[42] !== isLast || $[43] !== layoutCollapsed || $[44] !== nextCollapsed || $[45] !== rootElement ? (t13 = !isLast && !layoutCollapsed && (0, import_jsx_runtime2.jsx)(LegacyLayerProvider, { zOffset: "paneResizer", children: (0, import_jsx_runtime2.jsx)(PaneDivider, { disabled: collapsed || nextCollapsed, element: rootElement }) }), $[41] = collapsed, $[42] = isLast, $[43] = layoutCollapsed, $[44] = nextCollapsed, $[45] = rootElement, $[46] = t13) : t13 = $[46];
  const divider = t13, t14 = maxWidth === 1 / 0 ? void 0 : maxWidth;
  let t15;
  $[47] !== flex || $[48] !== minWidth || $[49] !== t14 ? (t15 = {
    flex,
    minWidth,
    maxWidth: t14
  }, $[47] = flex, $[48] = minWidth, $[49] = t14, $[50] = t15) : t15 = $[50];
  const style = t15, t16 = layoutCollapsed ? void 0 : "hidden", t17 = collapsed ? "" : void 0, t18 = selected ? "" : void 0;
  let t19;
  $[51] !== collapsed || $[52] !== currentMaxWidth || $[53] !== currentMinWidth || $[54] !== expanded || $[55] !== flex || $[56] !== maxWidth || $[57] !== minWidth || $[58] !== paneIndex ? (t19 = PANE_DEBUG, $[51] = collapsed, $[52] = currentMaxWidth, $[53] = currentMinWidth, $[54] = expanded, $[55] = flex, $[56] = maxWidth, $[57] = minWidth, $[58] = paneIndex, $[59] = t19) : t19 = $[59];
  let t20;
  $[60] !== children || $[61] !== hidden ? (t20 = !hidden && (0, import_jsx_runtime2.jsx)(Flex, { direction: "column", height: "fill", children }), $[60] = children, $[61] = hidden, $[62] = t20) : t20 = $[62];
  let t21;
  $[63] !== rootElement || $[64] !== t20 ? (t21 = (0, import_jsx_runtime2.jsx)(BoundaryElementProvider, { element: rootElement, children: t20 }), $[63] = rootElement, $[64] = t20, $[65] = t21) : t21 = $[65];
  let t22;
  $[66] !== hidden || $[67] !== id || $[68] !== paneIndex || $[69] !== restProps || $[70] !== style || $[71] !== t16 || $[72] !== t17 || $[73] !== t18 || $[74] !== t19 || $[75] !== t21 ? (t22 = (0, import_jsx_runtime2.jsxs)(Root$9, { "data-testid": "pane", "data-ui": "Pane", tone: "inherit", hidden, id, overflow: t16, ...restProps, "data-pane-collapsed": t17, "data-pane-index": paneIndex, "data-pane-selected": t18, ref: setRef, style, children: [
    t19,
    t21
  ] }), $[66] = hidden, $[67] = id, $[68] = paneIndex, $[69] = restProps, $[70] = style, $[71] = t16, $[72] = t17, $[73] = t18, $[74] = t19, $[75] = t21, $[76] = t22) : t22 = $[76];
  let t23;
  $[77] !== isLast || $[78] !== t22 ? (t23 = (0, import_jsx_runtime2.jsx)(IsLastPaneProvider, { isLastPane: isLast, children: t22 }), $[77] = isLast, $[78] = t22, $[79] = t23) : t23 = $[79];
  let t24;
  $[80] !== contextValue || $[81] !== t23 ? (t24 = (0, import_jsx_runtime2.jsx)(LegacyLayerProvider, { zOffset: "pane", children: (0, import_jsx_runtime2.jsx)(PaneContext.Provider, { value: contextValue, children: t23 }) }), $[80] = contextValue, $[81] = t23, $[82] = t24) : t24 = $[82];
  let t25;
  return $[83] !== divider || $[84] !== t24 ? (t25 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    t24,
    divider
  ] }), $[83] = divider, $[84] = t24, $[85] = t25) : t25 = $[85], t25;
});
var Root$8 = at(Card).withConfig({
  displayName: "Root",
  componentId: "sc-ok1xda-0"
})`position:relative;outline:none;`;
Root$8.displayName = "PaneContent__root";
function usePane() {
  const pane2 = (0, import_react2.useContext)(PaneContext);
  if (!pane2)
    throw new Error("Pane: missing context value");
  return pane2;
}
var PaneContent = (0, import_react2.forwardRef)(function(props, ref) {
  const $ = (0, import_compiler_runtime2.c)(14);
  let as, children, overflow, padding, restProps;
  $[0] !== props ? ({
    as,
    children,
    overflow,
    padding,
    ...restProps
  } = props, $[0] = props, $[1] = as, $[2] = children, $[3] = overflow, $[4] = padding, $[5] = restProps) : (as = $[1], children = $[2], overflow = $[3], padding = $[4], restProps = $[5]);
  const {
    collapsed
  } = usePane(), {
    collapsed: layoutCollapsed
  } = usePaneLayout(), t0 = layoutCollapsed ? void 0 : overflow;
  let t1;
  return $[6] !== as || $[7] !== children || $[8] !== collapsed || $[9] !== padding || $[10] !== ref || $[11] !== restProps || $[12] !== t0 ? (t1 = (0, import_jsx_runtime2.jsx)(Root$8, { "data-testid": "pane-content", forwardedAs: as, ...restProps, flex: 1, hidden: collapsed, overflow: t0, padding, ref, tone: "inherit", children }), $[6] = as, $[7] = children, $[8] = collapsed, $[9] = padding, $[10] = ref, $[11] = restProps, $[12] = t0, $[13] = t1) : t1 = $[13], t1;
});
function toLowerCaseNoSpaces(str) {
  return str ? str.toLocaleLowerCase().replaceAll(" ", "") : "";
}
var MENU_GROUP_POPOVER_PROPS = {
  constrainSize: true,
  placement: "left-start",
  portal: true
};
function PaneMenuButtonItem(props) {
  const $ = (0, import_compiler_runtime2.c)(35), {
    disabled,
    isAfterGroup,
    node
  } = props, getI18nText = useGetI18nText("i18n" in node ? node : void 0);
  if (node.type === "divider") {
    let t02;
    return $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t02 = (0, import_jsx_runtime2.jsx)(MenuDivider, {}), $[0] = t02) : t02 = $[0], t02;
  }
  let t0;
  $[1] !== getI18nText || $[2] !== node ? (t0 = getI18nText(node), $[1] = getI18nText, $[2] = node, $[3] = t0) : t0 = $[3];
  const {
    title
  } = t0;
  if (node.type === "group") {
    if (node.children.length === 0)
      return null;
    if (node.expanded) {
      let t13;
      $[4] !== isAfterGroup ? (t13 = isAfterGroup && (0, import_jsx_runtime2.jsx)(MenuDivider, {}), $[4] = isAfterGroup, $[5] = t13) : t13 = $[5];
      let t23;
      $[6] !== disabled || $[7] !== node.children || $[8] !== node.disabled ? (t23 = node.children.map((child, childIndex) => (0, import_jsx_runtime2.jsx)(PaneMenuButtonItem, { disabled: disabled || !!node.disabled, isAfterGroup: node.children[childIndex - 1]?.type === "group", node: child }, child.key)), $[6] = disabled, $[7] = node.children, $[8] = node.disabled, $[9] = t23) : t23 = $[9];
      let t33;
      return $[10] !== t13 || $[11] !== t23 ? (t33 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
        t13,
        t23
      ] }), $[10] = t13, $[11] = t23, $[12] = t33) : t33 = $[12], t33;
    }
    let t12;
    $[13] !== isAfterGroup ? (t12 = isAfterGroup && (0, import_jsx_runtime2.jsx)(MenuDivider, {}), $[13] = isAfterGroup, $[14] = t12) : t12 = $[14];
    const t22 = node.icon;
    let t32;
    $[15] !== disabled || $[16] !== node.children || $[17] !== node.disabled ? (t32 = node.children.map((child_0, childIndex_0) => (0, import_jsx_runtime2.jsx)(PaneMenuButtonItem, { disabled: disabled || !!node.disabled, isAfterGroup: node.children[childIndex_0 - 1]?.type === "group", node: child_0 }, child_0.key)), $[15] = disabled, $[16] = node.children, $[17] = node.disabled, $[18] = t32) : t32 = $[18];
    let t4;
    $[19] !== disabled || $[20] !== node.icon || $[21] !== t32 || $[22] !== title ? (t4 = (0, import_jsx_runtime2.jsx)(MenuGroup, { disabled, icon: t22, popover: MENU_GROUP_POPOVER_PROPS, text: title, children: t32 }), $[19] = disabled, $[20] = node.icon, $[21] = t32, $[22] = title, $[23] = t4) : t4 = $[23];
    let t5;
    return $[24] !== t12 || $[25] !== t4 ? (t5 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t12,
      t4
    ] }), $[24] = t12, $[25] = t4, $[26] = t5) : t5 = $[26], t5;
  }
  let t1;
  $[27] !== isAfterGroup ? (t1 = isAfterGroup && (0, import_jsx_runtime2.jsx)(MenuDivider, {}), $[27] = isAfterGroup, $[28] = t1) : t1 = $[28];
  let t2;
  $[29] !== disabled || $[30] !== node ? (t2 = (0, import_jsx_runtime2.jsx)(PaneContextMenuItemResolver, { disabled, node }), $[29] = disabled, $[30] = node, $[31] = t2) : t2 = $[31];
  let t3;
  return $[32] !== t1 || $[33] !== t2 ? (t3 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    t1,
    t2
  ] }), $[32] = t1, $[33] = t2, $[34] = t3) : t3 = $[34], t3;
}
function PaneContextMenuItemResolver(props) {
  const $ = (0, import_compiler_runtime2.c)(5), {
    node
  } = props;
  if (node.intent) {
    let t02;
    return $[0] !== node.intent || $[1] !== props ? (t02 = (0, import_jsx_runtime2.jsx)(PaneContextIntentMenuItem, { ...props, intent: node.intent }), $[0] = node.intent, $[1] = props, $[2] = t02) : t02 = $[2], t02;
  }
  let t0;
  return $[3] !== props ? (t0 = (0, import_jsx_runtime2.jsx)(PaneContextMenuItem, { ...props }), $[3] = props, $[4] = t0) : t0 = $[4], t0;
}
function PaneContextMenuItem(props) {
  const $ = (0, import_compiler_runtime2.c)(19), {
    disabled,
    node
  } = props;
  let t0;
  $[0] !== node.disabled ? (t0 = typeof node.disabled == "object" && (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: node.disabled.reason }), $[0] = node.disabled, $[1] = t0) : t0 = $[1];
  const tooltipContent = t0, {
    title
  } = useI18nText(node), showSelectionIndicator = node.selected && !node.hideSelectionIndicator, t1 = disabled || !!node.disabled;
  let t2;
  $[2] !== node.hotkey ? (t2 = node.hotkey?.split("+"), $[2] = node.hotkey, $[3] = t2) : t2 = $[3];
  const t3 = node.icon, t4 = node.iconRight || showSelectionIndicator && CheckmarkIcon, t5 = node.onAction, t6 = node.tone;
  let t7;
  $[4] !== node.title ? (t7 = toLowerCaseNoSpaces(node.title), $[4] = node.title, $[5] = t7) : t7 = $[5];
  const t8 = `action-${t7}`;
  let t9;
  $[6] !== node.icon || $[7] !== node.onAction || $[8] !== node.tone || $[9] !== showSelectionIndicator || $[10] !== t1 || $[11] !== t2 || $[12] !== t4 || $[13] !== t8 || $[14] !== title ? (t9 = (0, import_jsx_runtime2.jsx)(MenuItem2, { disabled: t1, hotkeys: t2, icon: t3, iconRight: t4, onClick: t5, pressed: showSelectionIndicator, text: title, tone: t6, "data-testid": t8 }), $[6] = node.icon, $[7] = node.onAction, $[8] = node.tone, $[9] = showSelectionIndicator, $[10] = t1, $[11] = t2, $[12] = t4, $[13] = t8, $[14] = title, $[15] = t9) : t9 = $[15];
  let t10;
  return $[16] !== t9 || $[17] !== tooltipContent ? (t10 = (0, import_jsx_runtime2.jsx)(TooltipOfDisabled, { content: tooltipContent, placement: "left", children: t9 }), $[16] = t9, $[17] = tooltipContent, $[18] = t10) : t10 = $[18], t10;
}
function PaneContextIntentMenuItem(props) {
  const $ = (0, import_compiler_runtime2.c)(23), {
    disabled,
    intent,
    node
  } = props;
  let t0;
  $[0] !== node.disabled ? (t0 = typeof node.disabled == "object" && (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: node.disabled.reason }), $[0] = node.disabled, $[1] = t0) : t0 = $[1];
  const tooltipContent = t0;
  let t1;
  $[2] !== intent.params || $[3] !== intent.type ? (t1 = {
    intent: intent.type,
    params: intent.params
  }, $[2] = intent.params, $[3] = intent.type, $[4] = t1) : t1 = $[4];
  const intentLink = useIntentLink(t1);
  let t2;
  $[5] !== intentLink || $[6] !== node ? (t2 = (event) => {
    intentLink.onClick(event), node.onAction();
  }, $[5] = intentLink, $[6] = node, $[7] = t2) : t2 = $[7];
  const handleClick = t2, {
    title
  } = useI18nText(node), showSelectionIndicator = node.selected && !node.hideSelectionIndicator, t3 = disabled || !!node.disabled;
  let t4;
  $[8] !== node.hotkey ? (t4 = node.hotkey?.split("+"), $[8] = node.hotkey, $[9] = t4) : t4 = $[9];
  const t5 = showSelectionIndicator ? CheckmarkIcon : void 0;
  let t6;
  $[10] !== handleClick || $[11] !== intentLink.href || $[12] !== node.icon || $[13] !== node.tone || $[14] !== showSelectionIndicator || $[15] !== t3 || $[16] !== t4 || $[17] !== t5 || $[18] !== title ? (t6 = (0, import_jsx_runtime2.jsx)(MenuItem2, { as: "a", disabled: t3, hotkeys: t4, href: intentLink.href, icon: node.icon, iconRight: t5, onClick: handleClick, pressed: showSelectionIndicator, text: title, tone: node.tone }), $[10] = handleClick, $[11] = intentLink.href, $[12] = node.icon, $[13] = node.tone, $[14] = showSelectionIndicator, $[15] = t3, $[16] = t4, $[17] = t5, $[18] = title, $[19] = t6) : t6 = $[19];
  let t7;
  return $[20] !== t6 || $[21] !== tooltipContent ? (t7 = (0, import_jsx_runtime2.jsx)(TooltipOfDisabled, { content: tooltipContent, placement: "left", children: t6 }), $[20] = t6, $[21] = tooltipContent, $[22] = t7) : t7 = $[22], t7;
}
var CONTEXT_MENU_POPOVER_PROPS = {
  constrainSize: true,
  placement: "bottom",
  portal: true
};
function nodesHasTone(nodes, tone) {
  return nodes.some((node) => node.type === "item" && node.tone === tone || node.type === "group" && nodesHasTone(node.children, tone));
}
function PaneContextMenuButton(props) {
  const $ = (0, import_compiler_runtime2.c)(13), {
    nodes,
    actionsNodes
  } = props, id = (0, import_react2.useId)(), hasCritical = nodesHasTone(nodes, "critical"), hasCaution = nodesHasTone(nodes, "caution"), t0 = hasCritical ? "critical" : hasCaution ? "caution" : void 0;
  let t1;
  $[0] !== t0 ? (t1 = (0, import_jsx_runtime2.jsx)(ContextMenuButton, { tone: t0, "data-testid": "pane-context-menu-button" }), $[0] = t0, $[1] = t1) : t1 = $[1];
  let t2;
  $[2] !== actionsNodes ? (t2 = actionsNodes && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    actionsNodes,
    (0, import_jsx_runtime2.jsx)(MenuDivider, {})
  ] }), $[2] = actionsNodes, $[3] = t2) : t2 = $[3];
  let t3;
  $[4] !== nodes ? (t3 = nodes.map((node, nodeIndex) => {
    const isAfterGroup = nodes[nodeIndex - 1]?.type === "group";
    return (0, import_jsx_runtime2.jsx)(PaneMenuButtonItem, { isAfterGroup, node }, node.key);
  }), $[4] = nodes, $[5] = t3) : t3 = $[5];
  let t4;
  $[6] !== t2 || $[7] !== t3 ? (t4 = (0, import_jsx_runtime2.jsxs)(Menu, { children: [
    t2,
    t3
  ] }), $[6] = t2, $[7] = t3, $[8] = t4) : t4 = $[8];
  let t5;
  return $[9] !== id || $[10] !== t1 || $[11] !== t4 ? (t5 = (0, import_jsx_runtime2.jsx)(MenuButton, { button: t1, id, menu: t4, popover: CONTEXT_MENU_POPOVER_PROPS }), $[9] = id, $[10] = t1, $[11] = t4, $[12] = t5) : t5 = $[12], t5;
}
var Root$7 = at(Layer).withConfig({
  displayName: "Root",
  componentId: "sc-rwc61s-0"
})`position:sticky;bottom:0;`;
var RootCard = at(Card).withConfig({
  displayName: "RootCard",
  componentId: "sc-rwc61s-1"
})`padding-bottom:env(safe-area-inset-bottom);`;
var PaneFooter = (0, import_react2.forwardRef)(function(props, ref) {
  const $ = (0, import_compiler_runtime2.c)(7), {
    children,
    padding
  } = props, {
    collapsed
  } = usePane();
  let t0;
  $[0] !== children || $[1] !== padding ? (t0 = (0, import_jsx_runtime2.jsx)(RootCard, { tone: "inherit", children: (0, import_jsx_runtime2.jsx)(Box, { padding, children }) }), $[0] = children, $[1] = padding, $[2] = t0) : t0 = $[2];
  let t1;
  return $[3] !== collapsed || $[4] !== ref || $[5] !== t0 ? (t1 = (0, import_jsx_runtime2.jsx)(LegacyLayerProvider, { zOffset: "paneFooter", children: (0, import_jsx_runtime2.jsx)(Root$7, { "data-testid": "pane-footer", hidden: collapsed, ref, children: t0 }) }), $[3] = collapsed, $[4] = ref, $[5] = t0, $[6] = t1) : t1 = $[6], t1;
});
var Root$6 = at(Layer).withConfig({
  displayName: "Root",
  componentId: "sc-2mpzxb-0"
})(({
  $border
}) => rt`
    line-height: 0;
    position: sticky;
    top: 0;

    &:not([data-collapsed]):after {
      content: '';
      display: block;
      position: absolute;
      left: 0;
      right: 0;
      bottom: -1px;
      border-bottom: 1px solid ${$border ? "var(--card-border-color)" : "transparent"};
      opacity: 1;
    }
  `);
var Layout = at(Flex).withConfig({
  displayName: "Layout",
  componentId: "sc-2mpzxb-1"
})`transform-origin:calc(51px / 2);[data-collapsed] > div > &{transform:rotate(90deg);}`;
var TitleCard = at(Card).withConfig({
  displayName: "TitleCard",
  componentId: "sc-2mpzxb-2"
})(({
  theme
}) => {
  const {
    fg,
    bg
  } = theme.sanity.color.card.enabled;
  return rt`
    background-color: ${bg};

    [data-ui='Text'] {
      color: ${fg};
    }
  `;
});
var TitleTextSkeleton = at(TextSkeleton).withConfig({
  displayName: "TitleTextSkeleton",
  componentId: "sc-2mpzxb-3"
})`width:66%;max-width:175px;`;
var TitleText = at(Text).withConfig({
  displayName: "TitleText",
  componentId: "sc-2mpzxb-4"
})`cursor:default;outline:none;`;
var PaneHeader$1 = (0, import_react2.forwardRef)(function(props, ref) {
  const $ = (0, import_compiler_runtime2.c)(48), {
    actions,
    backButton,
    border,
    contentAfter,
    loading,
    subActions,
    tabs,
    tabIndex,
    title,
    appendTitle
  } = props, {
    collapse,
    collapsed,
    expand,
    rootElement: paneElement
  } = usePane(), paneRect = useElementRect(paneElement || null), t0 = collapsed ? paneRect?.height || window.innerHeight : void 0;
  let t1;
  $[0] !== t0 ? (t1 = {
    width: t0
  }, $[0] = t0, $[1] = t1) : t1 = $[1];
  const layoutStyle = t1;
  let t2;
  $[2] !== collapse || $[3] !== collapsed ? (t2 = () => {
    collapsed || collapse();
  }, $[2] = collapse, $[3] = collapsed, $[4] = t2) : t2 = $[4];
  const handleTitleClick = t2;
  let t3;
  $[5] !== collapsed || $[6] !== expand ? (t3 = () => {
    collapsed && expand();
  }, $[5] = collapsed, $[6] = expand, $[7] = t3) : t3 = $[7];
  const handleLayoutClick = t3, showTabsOrSubActions = !!(!collapsed && (tabs || subActions)), t4 = collapsed ? "" : void 0, t5 = collapsed ? "" : void 0;
  let t6;
  $[8] !== backButton ? (t6 = backButton && (0, import_jsx_runtime2.jsx)(Box, { flex: "none", children: backButton }), $[8] = backButton, $[9] = t6) : t6 = $[9];
  const t7 = backButton ? 1 : 2;
  let t8;
  $[10] !== loading ? (t8 = loading && (0, import_jsx_runtime2.jsx)(Box, { children: (0, import_jsx_runtime2.jsx)(TitleTextSkeleton, { animated: true, radius: 1, size: 1 }) }), $[10] = loading, $[11] = t8) : t8 = $[11];
  let t9;
  $[12] !== appendTitle || $[13] !== loading || $[14] !== title ? (t9 = !loading && (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 1, children: [
    (0, import_jsx_runtime2.jsx)(TitleText, { size: 1, textOverflow: "ellipsis", weight: "semibold", children: title }),
    appendTitle
  ] }), $[12] = appendTitle, $[13] = loading, $[14] = title, $[15] = t9) : t9 = $[15];
  let t10;
  $[16] !== handleTitleClick || $[17] !== t7 || $[18] !== t8 || $[19] !== t9 || $[20] !== tabIndex ? (t10 = (0, import_jsx_runtime2.jsxs)(TitleCard, { __unstable_focusRing: true, flex: 1, onClick: handleTitleClick, paddingLeft: t7, padding: 2, tabIndex, children: [
    t8,
    t9
  ] }), $[16] = handleTitleClick, $[17] = t7, $[18] = t8, $[19] = t9, $[20] = tabIndex, $[21] = t10) : t10 = $[21];
  let t11;
  $[22] !== actions || $[23] !== collapsed ? (t11 = actions && (0, import_jsx_runtime2.jsx)(Box, { hidden: collapsed, children: (0, import_jsx_runtime2.jsx)(LegacyLayerProvider, { zOffset: "paneHeader", children: actions }) }), $[22] = actions, $[23] = collapsed, $[24] = t11) : t11 = $[24];
  let t12;
  $[25] !== t10 || $[26] !== t11 || $[27] !== t6 ? (t12 = (0, import_jsx_runtime2.jsxs)(Flex, { align: "flex-start", gap: 3, children: [
    t6,
    t10,
    t11
  ] }), $[25] = t10, $[26] = t11, $[27] = t6, $[28] = t12) : t12 = $[28];
  let t13;
  $[29] !== collapsed || $[30] !== showTabsOrSubActions || $[31] !== subActions || $[32] !== tabs ? (t13 = showTabsOrSubActions && (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", hidden: collapsed, overflow: "auto", children: [
    (0, import_jsx_runtime2.jsx)(Box, { flex: 1, marginRight: subActions ? 3 : 0, children: tabs }),
    subActions
  ] }), $[29] = collapsed, $[30] = showTabsOrSubActions, $[31] = subActions, $[32] = tabs, $[33] = t13) : t13 = $[33];
  let t14;
  $[34] !== handleLayoutClick || $[35] !== layoutStyle || $[36] !== t12 || $[37] !== t13 ? (t14 = (0, import_jsx_runtime2.jsxs)(Layout, { direction: "column", gap: 3, onClick: handleLayoutClick, padding: 3, sizing: "border", style: layoutStyle, children: [
    t12,
    t13
  ] }), $[34] = handleLayoutClick, $[35] = layoutStyle, $[36] = t12, $[37] = t13, $[38] = t14) : t14 = $[38];
  const t15 = !collapsed && contentAfter;
  let t16;
  $[39] !== t14 || $[40] !== t15 || $[41] !== t5 ? (t16 = (0, import_jsx_runtime2.jsx)(LegacyLayerProvider, { zOffset: "paneHeader", children: (0, import_jsx_runtime2.jsxs)(Card, { "data-collapsed": t5, tone: "inherit", children: [
    t14,
    t15
  ] }) }), $[39] = t14, $[40] = t15, $[41] = t5, $[42] = t16) : t16 = $[42];
  let t17;
  return $[43] !== border || $[44] !== ref || $[45] !== t16 || $[46] !== t4 ? (t17 = (0, import_jsx_runtime2.jsx)(LayerProvider, { zOffset: 100, children: (0, import_jsx_runtime2.jsx)(Root$6, { $border: border, "data-collapsed": t4, "data-testid": "pane-header", ref, children: t16 }) }), $[43] = border, $[44] = ref, $[45] = t16, $[46] = t4, $[47] = t17) : t17 = $[47], t17;
});
function getDisabledReason$1(node) {
  if (!node.disabled)
    return {
      disabledReason: void 0,
      ariaLabel: void 0,
      isDisabled: false
    };
  const disabledReason = typeof node.disabled == "object" ? node.disabled.reason : void 0, ariaLabel = typeof node.disabled == "object" && typeof node.disabled?.reason == "string" ? node.disabled.reason : "This is disabled";
  return {
    disabledReason,
    ariaLabel,
    isDisabled: !!node.disabled
  };
}
function PaneHeaderActionButton(props) {
  const $ = (0, import_compiler_runtime2.c)(4), {
    node
  } = props;
  if (node.type === "item") {
    let t0;
    return $[0] !== node ? (t0 = (0, import_jsx_runtime2.jsx)(PaneHeaderMenuItemActionButton, { node }), $[0] = node, $[1] = t0) : t0 = $[1], t0;
  }
  if (node.type === "group") {
    let t0;
    return $[2] !== node ? (t0 = (0, import_jsx_runtime2.jsx)(PaneHeaderMenuGroupActionButton, { node }), $[2] = node, $[3] = t0) : t0 = $[3], t0;
  }
  return console.warn('unknown menu node (expected `type: "item" | "group"`):', node), null;
}
function PaneHeaderMenuItemActionButton(props) {
  const $ = (0, import_compiler_runtime2.c)(23), {
    node
  } = props, {
    title
  } = useI18nText(node), {
    t: t2
  } = useTranslation();
  if (node.intent) {
    let t02;
    return $[0] !== node.intent || $[1] !== props ? (t02 = (0, import_jsx_runtime2.jsx)(PaneHeaderActionIntentButton, { ...props, intent: node.intent }), $[0] = node.intent, $[1] = props, $[2] = t02) : t02 = $[2], t02;
  }
  let t0;
  $[3] !== node ? (t0 = getDisabledReason$1(node), $[3] = node, $[4] = t0) : t0 = $[4];
  const {
    disabledReason,
    ariaLabel,
    isDisabled
  } = t0;
  let t1;
  $[5] !== ariaLabel || $[6] !== t2 || $[7] !== title ? (t1 = ariaLabel || title || t2("status-button.aria-label"), $[5] = ariaLabel, $[6] = t2, $[7] = title, $[8] = t1) : t1 = $[8];
  let t22;
  $[9] !== isDisabled || $[10] !== node.hotkey ? (t22 = !isDisabled && node.hotkey ? node.hotkey.split("+") : void 0, $[9] = isDisabled, $[10] = node.hotkey, $[11] = t22) : t22 = $[11];
  const t3 = isDisabled ? disabledReason : title;
  let t4;
  $[12] !== t22 || $[13] !== t3 ? (t4 = {
    hotkeys: t22,
    content: t3
  }, $[12] = t22, $[13] = t3, $[14] = t4) : t4 = $[14];
  let t5;
  return $[15] !== isDisabled || $[16] !== node.icon || $[17] !== node.onAction || $[18] !== node.selected || $[19] !== node.tone || $[20] !== t1 || $[21] !== t4 ? (t5 = (0, import_jsx_runtime2.jsx)(StatusButton, { disabled: isDisabled, icon: node.icon, onClick: node.onAction, selected: node.selected, tone: node.tone, "aria-label": t1, tooltipProps: t4 }), $[15] = isDisabled, $[16] = node.icon, $[17] = node.onAction, $[18] = node.selected, $[19] = node.tone, $[20] = t1, $[21] = t4, $[22] = t5) : t5 = $[22], t5;
}
function PaneHeaderActionIntentButton(props) {
  const $ = (0, import_compiler_runtime2.c)(27), {
    intent,
    node
  } = props;
  let t0;
  $[0] !== intent.params || $[1] !== intent.type ? (t0 = {
    intent: intent.type,
    params: intent.params
  }, $[0] = intent.params, $[1] = intent.type, $[2] = t0) : t0 = $[2];
  const intentLink = useIntentLink(t0), {
    t: t2
  } = useTranslation();
  let t1;
  $[3] !== intentLink || $[4] !== node ? (t1 = (event) => {
    intentLink.onClick(event), node.onAction();
  }, $[3] = intentLink, $[4] = node, $[5] = t1) : t1 = $[5];
  const handleClick = t1;
  let t22;
  $[6] !== node ? (t22 = getDisabledReason$1(node), $[6] = node, $[7] = t22) : t22 = $[7];
  const {
    disabledReason,
    ariaLabel,
    isDisabled
  } = t22;
  let t3;
  $[8] !== ariaLabel || $[9] !== node.title || $[10] !== t2 ? (t3 = ariaLabel || node.title || t2("status-button.aria-label"), $[8] = ariaLabel, $[9] = node.title, $[10] = t2, $[11] = t3) : t3 = $[11];
  let t4;
  $[12] !== isDisabled || $[13] !== node.hotkey ? (t4 = !isDisabled && node.hotkey ? node.hotkey.split("+") : void 0, $[12] = isDisabled, $[13] = node.hotkey, $[14] = t4) : t4 = $[14];
  const t5 = isDisabled ? disabledReason : node.title;
  let t6;
  $[15] !== t4 || $[16] !== t5 ? (t6 = {
    hotkeys: t4,
    content: t5,
    placement: "bottom",
    portal: true
  }, $[15] = t4, $[16] = t5, $[17] = t6) : t6 = $[17];
  let t7;
  return $[18] !== handleClick || $[19] !== intentLink.href || $[20] !== isDisabled || $[21] !== node.icon || $[22] !== node.selected || $[23] !== node.tone || $[24] !== t3 || $[25] !== t6 ? (t7 = (0, import_jsx_runtime2.jsx)(StatusButton, { forwardedAs: "a", disabled: isDisabled, href: intentLink.href, icon: node.icon, onClick: handleClick, selected: node.selected, tone: node.tone, "aria-label": t3, tooltipProps: t6 }), $[18] = handleClick, $[19] = intentLink.href, $[20] = isDisabled, $[21] = node.icon, $[22] = node.selected, $[23] = node.tone, $[24] = t3, $[25] = t6, $[26] = t7) : t7 = $[26], t7;
}
function PaneHeaderMenuGroupActionButton(props) {
  const $ = (0, import_compiler_runtime2.c)(16), {
    node
  } = props, {
    title
  } = useI18nText(node), t0 = !!node.disabled, t1 = node.icon ?? UnknownIcon;
  let t2;
  $[0] !== node.title ? (t2 = {
    content: node.title,
    portal: true
  }, $[0] = node.title, $[1] = t2) : t2 = $[1];
  let t3;
  $[2] !== t0 || $[3] !== t1 || $[4] !== t2 || $[5] !== title ? (t3 = (0, import_jsx_runtime2.jsx)(Button2, { disabled: t0, icon: t1, label: title, mode: "bleed", tooltipProps: t2 }), $[2] = t0, $[3] = t1, $[4] = t2, $[5] = title, $[6] = t3) : t3 = $[6];
  const t4 = (0, import_react2.useId)();
  let t5;
  $[7] !== node.children || $[8] !== node.disabled ? (t5 = node.children.map((child, idx) => (0, import_jsx_runtime2.jsx)(PaneMenuButtonItem, { disabled: !!node.disabled, isAfterGroup: node.children[idx - 1]?.type === "group", node: child }, child.key)), $[7] = node.children, $[8] = node.disabled, $[9] = t5) : t5 = $[9];
  let t6;
  $[10] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(Menu, { children: t5 }), $[10] = t5, $[11] = t6) : t6 = $[11];
  let t7;
  return $[12] !== t3 || $[13] !== t4 || $[14] !== t6 ? (t7 = (0, import_jsx_runtime2.jsx)(MenuButton, { button: t3, id: t4, menu: t6 }), $[12] = t3, $[13] = t4, $[14] = t6, $[15] = t7) : t7 = $[15], t7;
}
var Root$5 = at(Card).withConfig({
  displayName: "Root",
  componentId: "sc-9fi7st-0"
})`transition:opacity 200ms;position:relative;z-index:1;padding-left:env(safe-area-inset-left);padding-right:env(safe-area-inset-right);opacity:0;&:not([hidden]){display:flex;}&:not([data-collapsed]){overflow:auto;}&[data-mounted]{opacity:1;}&[data-resizing]{pointer-events:none;}`;
function _calcPaneResize(cache, left, right, deltaX) {
  const sum2 = {
    flex: cache.left.flex + cache.right.flex,
    width: cache.left.width + cache.right.width
  }, leftMinWidth = left.minWidth ?? PANE_DEFAULT_MIN_WIDTH, rightMinWidth = right.minWidth ?? PANE_DEFAULT_MIN_WIDTH, leftMaxWidth = Math.min(left.maxWidth || 1 / 0, sum2.width - rightMinWidth), rightMaxWidth = Math.min(right.maxWidth || 1 / 0, sum2.width - leftMinWidth);
  let minDeltaX = leftMinWidth - cache.left.width;
  const rightMinDeltaX = cache.right.width - rightMaxWidth;
  minDeltaX < rightMinDeltaX && (minDeltaX = rightMinDeltaX);
  let maxDeltaX = cache.right.width - rightMinWidth;
  const leftMaxDeltaX = leftMaxWidth - cache.left.width;
  maxDeltaX > leftMaxDeltaX && (maxDeltaX = leftMaxDeltaX);
  const _deltaX = Math.min(Math.max(deltaX, minDeltaX), maxDeltaX), leftW = cache.left.width + _deltaX, rightW = cache.right.width - _deltaX, leftFlex = leftW / sum2.width * sum2.flex, rightFlex = rightW / sum2.width * sum2.flex;
  return {
    leftFlex,
    leftW,
    rightFlex,
    rightW
  };
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e2 = el;
  for (; e2 !== rootElement; ) {
    const parentElement = e2.parentElement;
    if (!parentElement) return path;
    const index = Array.from(parentElement.childNodes).indexOf(e2);
    if (path.unshift(index), parentElement === rootElement)
      return path;
    e2 = parentElement;
  }
  return path;
}
var EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  const map2 = /* @__PURE__ */ new WeakMap();
  for (const element of elements)
    map2.set(element, _getDOMPath(rootElement, element));
  const _sortByElementPath = (a, b) => {
    const _a = map2.get(a) || EMPTY_PATH, _b = map2.get(b) || EMPTY_PATH, len = Math.max(_a.length, _b.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a[i] || -1, bIndex = _b[i] || -1;
      if (aIndex !== bIndex)
        return aIndex - bIndex;
    }
    return 0;
  };
  elements.sort(_sortByElementPath);
}
function createPaneLayoutController() {
  const observers = [], elements = [], optionsMap = /* @__PURE__ */ new WeakMap(), userCollapsedElementSet = /* @__PURE__ */ new Set(), cache = {};
  let rootElement = null, rootWidth = 0, expandedElement = null, maximizedElement = null, resizeDataMap = /* @__PURE__ */ new Map(), resizing = false;
  function collapse(element) {
    userCollapsedElementSet.add(element), expandedElement === element && (expandedElement = null), _notifyObservers();
  }
  function expand(element) {
    userCollapsedElementSet.delete(element), expandedElement = element, _notifyObservers();
  }
  function maximize(element) {
    maximizedElement = element, _notifyObservers();
  }
  function mount(element, options) {
    return optionsMap.set(element, {
      ...options,
      original: options
    }), elements.push(element), rootElement && _sortElements(rootElement, elements), expand(element), () => {
      const idx = elements.indexOf(element);
      idx > -1 && elements.splice(idx, 1), optionsMap.delete(element), maximizedElement === element && (maximizedElement = null), _notifyObservers();
    };
  }
  function resize(type, leftElement, deltaX) {
    const leftIndex = elements.indexOf(leftElement), leftOptions = optionsMap.get(leftElement);
    if (!leftOptions) return;
    const rightElement = elements[leftIndex + 1], rightOptions = optionsMap.get(rightElement);
    if (rightOptions) {
      if (type === "start" && (resizing = true, cache.left = {
        element: leftElement,
        flex: leftOptions.flex || 1,
        width: leftElement.offsetWidth
      }, cache.right = {
        element: rightElement,
        flex: rightOptions.flex || 1,
        width: rightElement.offsetWidth
      }, _notifyObservers()), type === "move" && cache.left && cache.right) {
        resizeDataMap = /* @__PURE__ */ new Map();
        const {
          leftW,
          rightW,
          leftFlex,
          rightFlex
        } = _calcPaneResize(cache, leftOptions, rightOptions, deltaX);
        resizeDataMap.set(leftElement, {
          flex: leftFlex,
          width: leftW
        }), resizeDataMap.set(rightElement, {
          flex: rightFlex,
          width: rightW
        }), _notifyObservers();
      }
      if (type === "end") {
        resizing = false;
        const leftResizeData = resizeDataMap.get(leftElement), rightResizeData = resizeDataMap.get(rightElement);
        optionsMap.set(leftElement, {
          ...leftOptions,
          currentMinWidth: 0,
          currentMaxWidth: leftOptions.maxWidth ?? 1 / 0,
          flex: leftResizeData?.flex ?? leftOptions.flex
        }), optionsMap.set(rightElement, {
          ...rightOptions,
          currentMinWidth: 0,
          currentMaxWidth: leftOptions.maxWidth ?? 1 / 0,
          flex: rightResizeData?.flex ?? rightOptions.flex
        }), resizeDataMap = /* @__PURE__ */ new Map(), delete cache.left, delete cache.right, _notifyObservers();
      }
    }
  }
  function setRootElement(nextRootElement) {
    rootElement = nextRootElement;
  }
  function setRootWidth(nextRootWidth) {
    rootWidth = nextRootWidth, _notifyObservers();
  }
  function subscribe(observer) {
    return observers.push(observer), () => {
      const idx = observers.push(observer);
      idx > -1 && observers.splice(idx, 1);
    };
  }
  return {
    collapse,
    expand,
    maximize,
    mount,
    resize,
    setRootElement,
    setRootWidth,
    subscribe
  };
  function _notifyObservers() {
    if (!rootWidth) return;
    const _elements = [];
    for (const element of elements)
      element !== expandedElement && _elements.unshift(element);
    expandedElement && _elements.unshift(expandedElement);
    const dataMap = /* @__PURE__ */ new WeakMap(), len = _elements.length, lastElement = _elements[0], collapsedWidth = (len - 1) * PANE_COLLAPSED_WIDTH;
    let remaingWidth = rootWidth - collapsedWidth;
    for (const element of _elements) {
      const options = optionsMap.get(element);
      if (!options)
        continue;
      const minWidth = options.currentMinWidth || options.minWidth || PANE_DEFAULT_MIN_WIDTH, isLast = element === lastElement, userCollapsed = userCollapsedElementSet.has(element), sizeCollapsed = minWidth > remaingWidth, collapsed = isLast ? false : userCollapsed || sizeCollapsed, resizeData = resizeDataMap.get(element);
      dataMap.set(element, {
        element,
        collapsed,
        currentMinWidth: resizeData?.width ?? options.currentMinWidth,
        currentMaxWidth: resizeData?.width ?? options.currentMaxWidth,
        flex: resizeData?.flex ?? options.flex ?? 1,
        maximized: element === maximizedElement
      }), collapsed ? remaingWidth -= PANE_COLLAPSED_WIDTH : remaingWidth -= minWidth - PANE_COLLAPSED_WIDTH;
    }
    const panes = [];
    for (const element of elements) {
      const data = dataMap.get(element);
      data && panes.push(data);
    }
    for (const observer of observers)
      observer({
        expandedElement: expandedElement || elements[elements.length - 1] || null,
        panes,
        resizing
      });
  }
}
function PaneLayout(props) {
  const $ = (0, import_compiler_runtime2.c)(41);
  let children, minWidth, onCollapse, onExpand, restProps;
  $[0] !== props ? ({
    children,
    minWidth,
    onCollapse,
    onExpand,
    ...restProps
  } = props, $[0] = props, $[1] = children, $[2] = minWidth, $[3] = onCollapse, $[4] = onExpand, $[5] = restProps) : (children = $[1], minWidth = $[2], onCollapse = $[3], onExpand = $[4], restProps = $[5]);
  const [controller] = (0, import_react2.useState)(_temp$I), [rootElement, setRootElement] = (0, import_react2.useState)(null), width = useElementRect(rootElement)?.width || 0, collapsed = width === void 0 || !minWidth ? void 0 : width < minWidth;
  let t0;
  $[6] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    expandedElement: null,
    panes: [],
    resizing: false
  }, $[6] = t0) : t0 = $[6];
  const [state2, setState] = (0, import_react2.useState)(t0);
  let t1, t2;
  $[7] !== controller || $[8] !== rootElement ? (t1 = () => controller.setRootElement(rootElement), t2 = [controller, rootElement], $[7] = controller, $[8] = rootElement, $[9] = t1, $[10] = t2) : (t1 = $[9], t2 = $[10]), (0, import_react2.useEffect)(t1, t2);
  let t3, t4;
  $[11] !== controller || $[12] !== width ? (t3 = () => controller.setRootWidth(width), t4 = [controller, width], $[11] = controller, $[12] = width, $[13] = t3, $[14] = t4) : (t3 = $[13], t4 = $[14]), (0, import_react2.useEffect)(t3, t4);
  let t5, t6;
  $[15] !== controller ? (t5 = () => controller.subscribe(setState), t6 = [controller], $[15] = controller, $[16] = t5, $[17] = t6) : (t5 = $[16], t6 = $[17]), (0, import_react2.useEffect)(t5, t6);
  let t7, t8;
  $[18] !== collapsed || $[19] !== onCollapse || $[20] !== onExpand ? (t7 = () => {
    collapsed !== void 0 && (collapsed && onCollapse && onCollapse(), !collapsed && onExpand && onExpand());
  }, t8 = [collapsed, onCollapse, onExpand], $[18] = collapsed, $[19] = onCollapse, $[20] = onExpand, $[21] = t7, $[22] = t8) : (t7 = $[21], t8 = $[22]), (0, import_react2.useEffect)(t7, t8);
  let t9;
  $[23] !== collapsed || $[24] !== controller.collapse || $[25] !== controller.expand || $[26] !== controller.mount || $[27] !== controller.resize || $[28] !== state2.expandedElement || $[29] !== state2.panes || $[30] !== state2.resizing ? (t9 = {
    collapse: controller.collapse,
    collapsed,
    expand: controller.expand,
    expandedElement: state2.expandedElement,
    mount: controller.mount,
    panes: state2.panes,
    resize: controller.resize,
    resizing: state2.resizing
  }, $[23] = collapsed, $[24] = controller.collapse, $[25] = controller.expand, $[26] = controller.mount, $[27] = controller.resize, $[28] = state2.expandedElement, $[29] = state2.panes, $[30] = state2.resizing, $[31] = t9) : t9 = $[31];
  const paneLayout = t9, t10 = collapsed ? "" : void 0, t11 = state2.resizing ? "" : void 0, t12 = width ? "" : void 0;
  let t13;
  $[32] !== children || $[33] !== restProps || $[34] !== t10 || $[35] !== t11 || $[36] !== t12 ? (t13 = (0, import_jsx_runtime2.jsx)(Root$5, { "data-ui": "PaneLayout", ...restProps, "data-collapsed": t10, "data-resizing": t11, "data-mounted": t12, ref: setRootElement, children }), $[32] = children, $[33] = restProps, $[34] = t10, $[35] = t11, $[36] = t12, $[37] = t13) : t13 = $[37];
  let t14;
  return $[38] !== paneLayout || $[39] !== t13 ? (t14 = (0, import_jsx_runtime2.jsx)(PaneLayoutContext.Provider, { value: paneLayout, children: t13 }), $[38] = paneLayout, $[39] = t13, $[40] = t14) : t14 = $[40], t14;
}
function _temp$I() {
  return createPaneLayoutController();
}
function ErrorPane(props) {
  const $ = (0, import_compiler_runtime2.c)(12), {
    children,
    currentMinWidth,
    flex,
    minWidth,
    paneKey,
    title: t0,
    tone: t1
  } = props, title = t0 === void 0 ? "Error" : t0, tone = t1 === void 0 ? "critical" : t1;
  let t2;
  $[0] !== title ? (t2 = (0, import_jsx_runtime2.jsx)(PaneHeader$1, { title }), $[0] = title, $[1] = t2) : t2 = $[1];
  let t3;
  $[2] !== children ? (t3 = (0, import_jsx_runtime2.jsx)(PaneContent, { overflow: "auto", children: (0, import_jsx_runtime2.jsx)(Box, { paddingX: 4, paddingY: 5, children }) }), $[2] = children, $[3] = t3) : t3 = $[3];
  let t4;
  return $[4] !== currentMinWidth || $[5] !== flex || $[6] !== minWidth || $[7] !== paneKey || $[8] !== t2 || $[9] !== t3 || $[10] !== tone ? (t4 = (0, import_jsx_runtime2.jsxs)(Pane, { currentMinWidth, flex, id: paneKey, minWidth, tone, children: [
    t2,
    t3
  ] }), $[4] = currentMinWidth, $[5] = flex, $[6] = minWidth, $[7] = paneKey, $[8] = t2, $[9] = t3, $[10] = tone, $[11] = t4) : t4 = $[11], t4;
}
function Delay(t0) {
  const $ = (0, import_compiler_runtime2.c)(6), {
    children,
    ms: t1
  } = t0, ms = t1 === void 0 ? 0 : t1, [ready, setReady] = (0, import_react2.useState)(ms <= 0);
  let t2, t3;
  if ($[0] !== ms ? (t2 = () => {
    if (ms <= 0)
      return;
    const timeoutId = setTimeout(() => setReady(true), ms);
    return () => {
      clearTimeout(timeoutId);
    };
  }, t3 = [ms], $[0] = ms, $[1] = t2, $[2] = t3) : (t2 = $[1], t3 = $[2]), (0, import_react2.useEffect)(t2, t3), !ready || !children) {
    let t42;
    return $[3] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t42 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {}), $[3] = t42) : t42 = $[3], t42;
  }
  let t4;
  return $[4] !== children ? (t4 = typeof children == "function" ? children() : children, $[4] = children, $[5] = t4) : t4 = $[5], t4;
}
function getWaitMessages(path) {
  const thresholds = [{
    ms: 300,
    messageKey: "panes.resolving.default-message"
  }, {
    ms: 5e3,
    messageKey: "panes.resolving.slow-resolve-message"
  }];
  if (isDev) {
    const message = ["Check console for errors?", "Is your observable/promise resolving?", path.length > 0 ? `Structure path: ${path.join("  ")}` : ""];
    thresholds.push({
      ms: 1e4,
      message: message.join(`
`)
    });
  }
  const src = of(null);
  return merge(...thresholds.map((threshold) => src.pipe(mapTo("messageKey" in threshold ? {
    messageKey: threshold.messageKey
  } : {
    message: threshold.message
  }), delay(threshold.ms))));
}
var DEFAULT_MESSAGE_KEY = "panes.resolving.default-message";
var Content$2 = at(Flex).withConfig({
  displayName: "Content",
  componentId: "sc-1viiodb-0"
})`opacity:0;transition:opacity 200ms;&[data-mounted]{opacity:1;}`;
var LoadingPane = (0, import_react2.memo)((props) => {
  const $ = (0, import_compiler_runtime2.c)(28), {
    delay: t0,
    flex,
    message: t1,
    minWidth,
    paneKey,
    path,
    selected,
    title,
    tone
  } = props, delay2 = t0 === void 0 ? 300 : t0, messageProp = t1 === void 0 ? getWaitMessages : t1, {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t22;
  bb0: {
    if (typeof messageProp == "function") {
      let t32;
      $[0] !== messageProp || $[1] !== path ? (t32 = messageProp(path ? path.split(";") : []), $[0] = messageProp, $[1] = path, $[2] = t32) : t32 = $[2], t22 = t32;
      break bb0;
    }
    t22 = messageProp;
  }
  const resolvedMessage = t22;
  let t3;
  $[3] !== resolvedMessage || $[4] !== t2 ? (t3 = () => typeof resolvedMessage == "string" ? resolvedMessage : t2(DEFAULT_MESSAGE_KEY), $[3] = resolvedMessage, $[4] = t2, $[5] = t3) : t3 = $[5];
  const [currentMessage, setCurrentMessage] = (0, import_react2.useState)(t3);
  let t4, t5;
  $[6] !== resolvedMessage || $[7] !== t2 ? (t4 = () => {
    if (typeof resolvedMessage != "object" || typeof resolvedMessage.subscribe != "function")
      return;
    const sub = resolvedMessage.subscribe((message) => {
      setCurrentMessage("messageKey" in message ? t2(message.messageKey) : message.message);
    });
    return () => sub.unsubscribe();
  }, t5 = [resolvedMessage, t2], $[6] = resolvedMessage, $[7] = t2, $[8] = t4, $[9] = t5) : (t4 = $[8], t5 = $[9]), (0, import_react2.useEffect)(t4, t5);
  const [contentElement, setContentElement] = (0, import_react2.useState)(null), [mounted, setMounted] = (0, import_react2.useState)(false);
  let t6, t7;
  $[10] !== contentElement ? (t6 = () => {
    if (contentElement)
      return _raf2(() => setMounted(true));
  }, t7 = [contentElement], $[10] = contentElement, $[11] = t6, $[12] = t7) : (t6 = $[11], t7 = $[12]), (0, import_react2.useEffect)(t6, t7);
  const t8 = mounted ? "" : void 0, t9 = title || currentMessage;
  let t10;
  $[13] !== t9 ? (t10 = (0, import_jsx_runtime2.jsx)(LoadingBlock, { showText: true, title: t9 }), $[13] = t9, $[14] = t10) : t10 = $[14];
  let t11;
  $[15] !== t10 || $[16] !== t8 ? (t11 = (0, import_jsx_runtime2.jsx)(Content$2, { align: "center", "data-mounted": t8, direction: "column", height: "fill", justify: "center", ref: setContentElement, children: t10 }), $[15] = t10, $[16] = t8, $[17] = t11) : t11 = $[17];
  const content = t11;
  let t12;
  $[18] !== content || $[19] !== delay2 ? (t12 = (0, import_jsx_runtime2.jsx)(PaneContent, { children: content }), $[18] = content, $[19] = delay2, $[20] = t12) : t12 = $[20];
  let t13;
  return $[21] !== flex || $[22] !== minWidth || $[23] !== paneKey || $[24] !== selected || $[25] !== t12 || $[26] !== tone ? (t13 = (0, import_jsx_runtime2.jsx)(Pane, { flex, id: paneKey, minWidth, selected, tone, children: t12 }), $[21] = flex, $[22] = minWidth, $[23] = paneKey, $[24] = selected, $[25] = t12, $[26] = tone, $[27] = t13) : t13 = $[27], t13;
});
LoadingPane.displayName = "Memo(LoadingPane)";
function useDocumentPane() {
  const documentPane = (0, import_react2.useContext)(DocumentPaneContext);
  if (!documentPane)
    throw new Error("DocumentPane: missing context value");
  return documentPane;
}
function CommentsWrapper(props) {
  const $ = (0, import_compiler_runtime2.c)(8), {
    children,
    documentId,
    documentType
  } = props;
  let t0;
  $[0] !== children || $[1] !== documentId || $[2] !== documentType ? (t0 = (0, import_jsx_runtime2.jsx)(CommentsProviderWrapper, { documentId, documentType, children }), $[0] = children, $[1] = documentId, $[2] = documentType, $[3] = t0) : t0 = $[3];
  let t1;
  return $[4] !== documentId || $[5] !== documentType || $[6] !== t0 ? (t1 = (0, import_jsx_runtime2.jsx)(CommentsEnabledProvider, { documentId, documentType, children: t0 }), $[4] = documentId, $[5] = documentType, $[6] = t0, $[7] = t1) : t1 = $[7], t1;
}
function CommentsProviderWrapper(props) {
  const $ = (0, import_compiler_runtime2.c)(28), {
    children,
    documentId,
    documentType
  } = props, {
    enabled
  } = useCommentsEnabled(), {
    connectionState,
    onPathOpen,
    inspector,
    openInspector
  } = useDocumentPane(), {
    selectedReleaseId
  } = usePerspective(), {
    params,
    setParams
  } = usePaneRouter(), {
    resolveIntentLink
  } = useRouter(), selectedCommentId = params?.comment, scheduledDraft = params?.scheduledDraft, paramsRef = (0, import_react2.useRef)(params);
  let t0, t1;
  $[0] !== params ? (t0 = () => {
    paramsRef.current = params;
  }, t1 = [params], $[0] = params, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), (0, import_react2.useLayoutEffect)(t0, t1);
  let t2;
  $[3] !== documentId || $[4] !== documentType || $[5] !== resolveIntentLink || $[6] !== scheduledDraft || $[7] !== selectedReleaseId ? (t2 = (commentId) => {
    const searchParams = selectedReleaseId && !scheduledDraft ? [["perspective", selectedReleaseId]] : [], intentLink = resolveIntentLink("edit", {
      id: documentId,
      type: documentType,
      inspect: COMMENTS_INSPECTOR_NAME,
      comment: commentId,
      ...scheduledDraft ? {
        scheduledDraft
      } : {}
    }, searchParams);
    return `${window.location.origin}${intentLink}`;
  }, $[3] = documentId, $[4] = documentType, $[5] = resolveIntentLink, $[6] = scheduledDraft, $[7] = selectedReleaseId, $[8] = t2) : t2 = $[8];
  const getCommentLink = t2;
  let t3;
  $[9] !== setParams ? (t3 = () => {
    setParams({
      ...paramsRef.current,
      comment: void 0
    });
  }, $[9] = setParams, $[10] = t3) : t3 = $[10];
  const handleClearSelectedComment = t3;
  let t4;
  $[11] !== inspector?.name || $[12] !== openInspector ? (t4 = () => {
    inspector?.name !== COMMENTS_INSPECTOR_NAME && openInspector(COMMENTS_INSPECTOR_NAME);
  }, $[11] = inspector?.name, $[12] = openInspector, $[13] = t4) : t4 = $[13];
  const handleOpenCommentsInspector = t4;
  if (!enabled) {
    let t52;
    return $[14] !== children ? (t52 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children }), $[14] = children, $[15] = t52) : t52 = $[15], t52;
  }
  const t5 = inspector?.name === COMMENTS_INSPECTOR_NAME, t6 = connectionState === "connecting";
  let t7;
  return $[16] !== children || $[17] !== documentId || $[18] !== documentType || $[19] !== getCommentLink || $[20] !== handleClearSelectedComment || $[21] !== handleOpenCommentsInspector || $[22] !== onPathOpen || $[23] !== selectedCommentId || $[24] !== selectedReleaseId || $[25] !== t5 || $[26] !== t6 ? (t7 = (0, import_jsx_runtime2.jsx)(CommentsProvider, { documentId, documentType, getCommentLink, isCommentsOpen: t5, isConnecting: t6, onClearSelectedComment: handleClearSelectedComment, onCommentsOpen: handleOpenCommentsInspector, onPathOpen, selectedCommentId, sortOrder: "desc", type: "field", releaseId: selectedReleaseId, children }), $[16] = children, $[17] = documentId, $[18] = documentType, $[19] = getCommentLink, $[20] = handleClearSelectedComment, $[21] = handleOpenCommentsInspector, $[22] = onPathOpen, $[23] = selectedCommentId, $[24] = selectedReleaseId, $[25] = t5, $[26] = t6, $[27] = t7) : t7 = $[27], t7;
}
function DocumentActionsProvider(props) {
  const $ = (0, import_compiler_runtime2.c)(20), {
    children
  } = props, {
    data: activeReleases
  } = useActiveReleases(), {
    actions,
    editState,
    isInitialValueLoading,
    revisionId
  } = useDocumentPane(), onCompleteRef = (0, import_react2.useRef)(null);
  let t0;
  if ($[0] !== activeReleases || $[1] !== editState?.release) {
    let t12;
    $[3] !== editState?.release ? (t12 = (candidate) => candidate === editState?.release, $[3] = editState?.release, $[4] = t12) : t12 = $[4], t0 = activeReleases.map(_temp$H).find(t12), $[0] = activeReleases, $[1] = editState?.release, $[2] = t0;
  } else
    t0 = $[2];
  const matchingReleaseName = t0;
  let t1;
  $[5] !== editState || $[6] !== isInitialValueLoading || $[7] !== matchingReleaseName || $[8] !== revisionId ? (t1 = editState ? {
    ...editState,
    release: matchingReleaseName,
    revision: revisionId || void 0,
    initialValueResolved: !isInitialValueLoading
  } : null, $[5] = editState, $[6] = isInitialValueLoading, $[7] = matchingReleaseName, $[8] = revisionId, $[9] = t1) : t1 = $[9];
  const actionProps = t1;
  if (!actionProps)
    return null;
  let t2;
  $[10] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t2 = () => onCompleteRef.current?.(), $[10] = t2) : t2 = $[10];
  let t3;
  $[11] !== actionProps ? (t3 = {
    ...actionProps,
    onComplete: t2
  }, $[11] = actionProps, $[12] = t3) : t3 = $[12];
  const t4 = actions || EMPTY_ARRAY$z;
  let t5;
  $[13] !== actionProps || $[14] !== children ? (t5 = (t62) => {
    const {
      states
    } = t62;
    return (0, import_jsx_runtime2.jsx)(ActionsGuardWrapper, { states, actionProps, children });
  }, $[13] = actionProps, $[14] = children, $[15] = t5) : t5 = $[15];
  let t6;
  return $[16] !== t3 || $[17] !== t4 || $[18] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(GetHookCollectionState, { args: t3, hooks: t4, resetRef: onCompleteRef, children: t5 }), $[16] = t3, $[17] = t4, $[18] = t5, $[19] = t6) : t6 = $[19], t6;
}
function _temp$H(r2) {
  return getReleaseIdFromReleaseDocumentId(r2._id);
}
var SUPPORTED_LINKED_TO_CANVAS_ACTIONS = ["delete", "duplicate", "publish", "unpublish", "unlinkFromCanvas", "editInCanvas", "linkToCanvas", "schedule", "discardVersion", "unpublishVersion"];
function ActionsGuardWrapper(props) {
  const $ = (0, import_compiler_runtime2.c)(9), {
    states,
    children,
    actionProps
  } = props, {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t0;
  $[0] !== actionProps ? (t0 = getDocumentIdForCanvasLink(actionProps), $[0] = actionProps, $[1] = t0) : t0 = $[1];
  const {
    isLinked
  } = useCanvasCompanionDoc(t0);
  let t1;
  $[2] !== isLinked || $[3] !== states || $[4] !== t2 ? (t1 = isLinked ? states.map((s2) => !s2.action || !SUPPORTED_LINKED_TO_CANVAS_ACTIONS.includes(s2.action) ? {
    ...s2,
    disabled: true,
    title: t2("action.disabled-by-canvas.tooltip")
  } : s2) : states, $[2] = isLinked, $[3] = states, $[4] = t2, $[5] = t1) : t1 = $[5];
  let t22;
  return $[6] !== children || $[7] !== t1 ? (t22 = (0, import_jsx_runtime2.jsx)(DocumentActionsStateContext.Provider, { value: t1, children }), $[6] = children, $[7] = t1, $[8] = t22) : t22 = $[8], t22;
}
function useStructureTool() {
  const structureTool2 = (0, import_react2.useContext)(StructureToolContext);
  if (!structureTool2)
    throw new Error("StructureTool: missing context value");
  return structureTool2;
}
var DOCUMENT_PANEL_MIN_WIDTH = 320;
var DOCUMENT_PANEL_INITIAL_MIN_WIDTH = 600;
var DOCUMENT_INSPECTOR_MIN_WIDTH = 320;
var DOCUMENT_INSPECTOR_MAX_WIDTH = 540;
var EMPTY_PARAMS$2 = {};
var INSPECT_ACTION_PREFIX = "inspect:";
var DEFAULT_MENU_ITEM_GROUPS = [{
  id: "inspectors"
}, {
  id: "links"
}];
var HISTORY_INSPECTOR_NAME = "sanity/structure/history";
var VALIDATION_INSPECTOR_NAME = "sanity/structure/validation";
var INCOMING_REFERENCES_INSPECTOR_NAME = "sanity/structure/incoming-references";
function DocumentInspectorMenuItemsResolver(props) {
  const $ = (0, import_compiler_runtime2.c)(22), {
    documentId,
    documentType,
    inspectors: inspectors2,
    onMenuItems
  } = props, len = inspectors2.length;
  let t0;
  $[0] !== len ? (t0 = () => Array.from(new Array(len)), $[0] = len, $[1] = t0) : t0 = $[1];
  const [menuItems, setMenuItems] = (0, import_react2.useState)(t0);
  let t1, t2;
  $[2] !== len || $[3] !== menuItems ? (t1 = () => {
    if (menuItems.length !== len) {
      const newFieldActions = Array.from(new Array(len));
      for (let i = 0; i < len; i++)
        newFieldActions[i] = menuItems[i];
      setMenuItems(newFieldActions);
    }
  }, t2 = [len, menuItems], $[2] = len, $[3] = menuItems, $[4] = t1, $[5] = t2) : (t1 = $[4], t2 = $[5]), (0, import_react2.useEffect)(t1, t2);
  let t3;
  $[6] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t3 = (index, node) => {
    setMenuItems((prev) => {
      const next = [...prev];
      return next[index] = node, next;
    });
  }, $[6] = t3) : t3 = $[6];
  const setMenuItem = t3;
  let t4, t5;
  $[7] !== menuItems || $[8] !== onMenuItems ? (t4 = () => {
    onMenuItems(menuItems.filter(Boolean));
  }, t5 = [menuItems, onMenuItems], $[7] = menuItems, $[8] = onMenuItems, $[9] = t4, $[10] = t5) : (t4 = $[9], t5 = $[10]), (0, import_react2.useEffect)(t4, t5);
  let t6;
  if ($[11] !== documentId || $[12] !== documentType || $[13] !== inspectors2) {
    let t72;
    $[15] !== documentId || $[16] !== documentType ? (t72 = (inspector, index_0) => inspector.useMenuItem ? [defineInspectorMenuItemComponent({
      documentId,
      documentType,
      index: index_0,
      setMenuItem,
      useMenuItem: inspector.useMenuItem
    }), inspector.name] : [_temp$G, ""], $[15] = documentId, $[16] = documentType, $[17] = t72) : t72 = $[17], t6 = inspectors2.map(t72), $[11] = documentId, $[12] = documentType, $[13] = inspectors2, $[14] = t6;
  } else
    t6 = $[14];
  const InspectorMenuItems = t6;
  let t7;
  $[18] !== InspectorMenuItems ? (t7 = InspectorMenuItems.map(_temp2$i), $[18] = InspectorMenuItems, $[19] = t7) : t7 = $[19];
  let t8;
  return $[20] !== t7 ? (t8 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: t7 }), $[20] = t7, $[21] = t8) : t8 = $[21], t8;
}
function _temp2$i(t0) {
  const [InspectorMenuItem, key] = t0;
  return key && (0, import_jsx_runtime2.jsx)(InspectorMenuItem, {}, key);
}
function _temp$G() {
  return null;
}
DocumentInspectorMenuItemsResolver.displayName = "DocumentInspectorMenuItemsResolver";
function defineInspectorMenuItemComponent({
  documentId,
  documentType,
  index,
  setMenuItem,
  useMenuItem: useMenuItem2
}) {
  return (0, import_react2.memo)(function() {
    const $ = (0, import_compiler_runtime2.c)(4);
    let t0;
    $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = {
      documentId,
      documentType
    }, $[0] = t0) : t0 = $[0];
    const menuItem = useMenuItem2(t0), node = useUnique(menuItem);
    let t1, t2;
    return $[1] !== node ? (t1 = () => {
      setMenuItem(index, node);
    }, t2 = [node], $[1] = node, $[2] = t1, $[3] = t2) : (t1 = $[2], t2 = $[3]), (0, import_react2.useEffect)(t1, t2), null;
  });
}
function useDocumentTitle() {
  const $ = (0, import_compiler_runtime2.c)(22), {
    connectionState,
    schemaType,
    editState,
    isDeleted,
    lastRevisionDocument
  } = useDocumentPane(), {
    selectedPerspectiveName
  } = usePerspective(), {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t0;
  bb0: {
    if (isDeleted) {
      t0 = lastRevisionDocument;
      break bb0;
    }
    if (selectedPerspectiveName && isPublishedPerspective(selectedPerspectiveName)) {
      t0 = editState?.published;
      break bb0;
    }
    t0 = editState?.version || editState?.draft || editState?.published;
  }
  const documentValue = t0, subscribed = !!documentValue;
  let t1;
  bb1: {
    if (isDeleted && lastRevisionDocument && schemaType)
      try {
        let t32;
        $[0] !== lastRevisionDocument || $[1] !== schemaType ? (t32 = prepareForPreview(lastRevisionDocument, schemaType), $[0] = lastRevisionDocument, $[1] = schemaType, $[2] = t32) : t32 = $[2], t1 = t32;
        break bb1;
      } catch (t222) {
        console.warn("Failed to prepare preview for deleted document:", t222), t1 = null;
        break bb1;
      }
    t1 = null;
  }
  const deletedDocumentPreview = t1, t22 = subscribed && !isDeleted;
  let t3;
  $[3] !== documentValue || $[4] !== schemaType || $[5] !== t22 ? (t3 = {
    enabled: t22,
    schemaType,
    value: documentValue
  }, $[3] = documentValue, $[4] = schemaType, $[5] = t22, $[6] = t3) : t3 = $[6];
  const {
    error: error_0,
    value
  } = useValuePreview(t3);
  if (connectionState === "connecting" && !subscribed) {
    let t42;
    return $[7] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t42 = {
      error: void 0,
      title: void 0
    }, $[7] = t42) : t42 = $[7], t42;
  }
  if (isDeleted && deletedDocumentPreview) {
    let t42;
    return $[8] !== deletedDocumentPreview.title ? (t42 = {
      error: void 0,
      title: deletedDocumentPreview.title
    }, $[8] = deletedDocumentPreview.title, $[9] = t42) : t42 = $[9], t42;
  }
  if (!value && !isDeleted) {
    const t42 = schemaType?.title || schemaType?.name;
    let t52;
    $[10] !== t2 || $[11] !== t42 ? (t52 = t2("panes.document-header-title.new.text", {
      schemaType: t42
    }), $[10] = t2, $[11] = t42, $[12] = t52) : t52 = $[12];
    let t6;
    return $[13] !== t52 ? (t6 = {
      error: void 0,
      title: t52
    }, $[13] = t52, $[14] = t6) : t6 = $[14], t6;
  }
  if (error_0) {
    let t42;
    $[15] !== error_0.message || $[16] !== t2 ? (t42 = t2("panes.document-list-pane.error.text", {
      error: error_0.message
    }), $[15] = error_0.message, $[16] = t2, $[17] = t42) : t42 = $[17];
    let t52;
    return $[18] !== t42 ? (t52 = {
      error: t42,
      title: void 0
    }, $[18] = t42, $[19] = t52) : t52 = $[19], t52;
  }
  const t4 = value?.title;
  let t5;
  return $[20] !== t4 ? (t5 = {
    error: void 0,
    title: t4
  }, $[20] = t4, $[21] = t5) : t5 = $[21], t5;
}
var IGNORE_OPS = ["patch", "commit"];
var DocumentOperationResults = (0, import_react2.memo)(function() {
  const $ = (0, import_compiler_runtime2.c)(13), {
    push: pushToast
  } = useToast(), {
    documentId,
    documentType,
    value: documentPaneValue
  } = useDocumentPane(), documentTitleInfo = useDocumentTitle(), titleError = documentTitleInfo.error, event = useDocumentOperationEvent(documentId, documentType), prevEvent = (0, import_react2.useRef)(event), paneRouter = usePaneRouter(), {
    t: t2
  } = useTranslation(structureLocaleNamespace), {
    handleOpenDialog
  } = useDocumentLimitsUpsellContext();
  let t0;
  bb0: {
    if (!documentTitleInfo.title && !titleError && !IGNORE_OPS.includes(event?.op) && typeof documentPaneValue.title == "string" && event?.type === "success") {
      t0 = documentPaneValue.title;
      break bb0;
    }
    t0 = documentTitleInfo.title;
  }
  const title = t0;
  let t1;
  $[0] !== t2 || $[1] !== title ? (t1 = title || t2("panes.document-operation-results.operation-undefined-title"), $[0] = t2, $[1] = title, $[2] = t1) : t1 = $[2];
  const documentTitleBase = t1;
  let t22;
  $[3] !== documentTitleBase ? (t22 = documentTitleBase.length > 25 ? `${documentTitleBase.slice(0, 25)}...` : documentTitleBase, $[3] = documentTitleBase, $[4] = t22) : t22 = $[4];
  const documentTitle = t22;
  let t3, t4;
  return $[5] !== documentTitle || $[6] !== event || $[7] !== handleOpenDialog || $[8] !== paneRouter || $[9] !== pushToast || $[10] !== t2 ? (t3 = () => {
    if (!event || event === prevEvent.current)
      return;
    let cleanupId;
    if (event.type === "error") {
      if (isDocumentLimitError(event.error)) {
        handleOpenDialog("document_action");
        return;
      }
      pushToast({
        closable: true,
        duration: 3e4,
        status: "error",
        title: t2("panes.document-operation-results.operation-error", {
          context: event.op
        }),
        description: (0, import_jsx_runtime2.jsxs)("details", { children: [
          (0, import_jsx_runtime2.jsx)("summary", { children: t2("panes.document-operation-results.error.summary.title") }),
          event.error.message
        ] })
      });
    }
    return event.type === "success" && !IGNORE_OPS.includes(event.op) && pushToast({
      closable: true,
      status: "success",
      title: (0, import_jsx_runtime2.jsx)(Translate, { context: event.op, i18nKey: "panes.document-operation-results.operation-success", t: t2, values: {
        op: event.op,
        title: documentTitle
      }, components: {
        Strong: "strong"
      } })
    }), event.type === "success" && event.op === "delete" && (cleanupId = setTimeout(() => paneRouter.closeCurrentAndAfter(), 0)), prevEvent.current = event, () => clearTimeout(cleanupId);
  }, t4 = [event, paneRouter, pushToast, t2, documentTitle, handleOpenDialog], $[5] = documentTitle, $[6] = event, $[7] = handleOpenDialog, $[8] = paneRouter, $[9] = pushToast, $[10] = t2, $[11] = t3, $[12] = t4) : (t3 = $[11], t4 = $[12]), (0, import_react2.useEffect)(t3, t4), null;
});
var isLiveEditEnabled = (schemaType) => schemaType.liveEdit === true;
function hasObsoleteDraft({
  editState,
  workspace,
  schemaType
}) {
  if (!editState?.ready)
    return {
      result: void 0
    };
  const draftExists = editState.draft !== null, {
    document: {
      drafts: {
        enabled: isDraftModelEnabled
      }
    }
  } = workspace;
  return draftExists ? isDraftModelEnabled ? isLiveEditEnabled(schemaType) ? {
    result: true,
    reason: "LIVE_EDIT_ACTIVE"
  } : {
    result: false
  } : {
    result: true,
    reason: "DRAFT_MODEL_INACTIVE"
  } : {
    result: false
  };
}
function mustChooseNewDocumentDestination({
  isSelectedPerspectiveWriteable,
  editState
}) {
  return isNewDocument(editState) && !isSelectedPerspectiveWriteable.result;
}
var Root$4 = at(Card).withConfig({
  displayName: "Root",
  componentId: "sc-1anmotz-0"
})({
  position: "relative",
  zIndex: "1",
  lineHeight: "0"
});
function DocumentInspectorHeader(props) {
  const $ = (0, import_compiler_runtime2.c)(25);
  let children, closeButtonLabel, forwardedAs, onClose, restProps, title;
  $[0] !== props ? ({
    as: forwardedAs,
    children,
    closeButtonLabel,
    onClose,
    title,
    ...restProps
  } = props, $[0] = props, $[1] = children, $[2] = closeButtonLabel, $[3] = forwardedAs, $[4] = onClose, $[5] = restProps, $[6] = title) : (children = $[1], closeButtonLabel = $[2], forwardedAs = $[3], onClose = $[4], restProps = $[5], title = $[6]);
  const {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t0;
  $[7] !== title ? (t0 = (0, import_jsx_runtime2.jsx)(Box, { flex: 1, padding: 3, children: (0, import_jsx_runtime2.jsx)(Text, { as: "h1", size: 1, weight: "medium", children: title }) }), $[7] = title, $[8] = t0) : t0 = $[8];
  let t1;
  $[9] !== t2 ? (t1 = t2("document-inspector.close-button.tooltip"), $[9] = t2, $[10] = t1) : t1 = $[10];
  let t22;
  $[11] !== t1 ? (t22 = {
    content: t1
  }, $[11] = t1, $[12] = t22) : t22 = $[12];
  let t3;
  $[13] !== closeButtonLabel || $[14] !== onClose || $[15] !== t22 ? (t3 = (0, import_jsx_runtime2.jsx)(Box, { flex: "none", padding: 1, children: (0, import_jsx_runtime2.jsx)(Button2, { "aria-label": closeButtonLabel, icon: CloseIcon, mode: "bleed", onClick: onClose, tooltipProps: t22 }) }), $[13] = closeButtonLabel, $[14] = onClose, $[15] = t22, $[16] = t3) : t3 = $[16];
  let t4;
  $[17] !== t0 || $[18] !== t3 ? (t4 = (0, import_jsx_runtime2.jsxs)(Flex, { padding: 2, children: [
    t0,
    t3
  ] }), $[17] = t0, $[18] = t3, $[19] = t4) : t4 = $[19];
  let t5;
  return $[20] !== children || $[21] !== forwardedAs || $[22] !== restProps || $[23] !== t4 ? (t5 = (0, import_jsx_runtime2.jsxs)(Root$4, { ...restProps, as: forwardedAs, children: [
    t4,
    children
  ] }), $[20] = children, $[21] = forwardedAs, $[22] = restProps, $[23] = t4, $[24] = t5) : t5 = $[24], t5;
}
function DocumentInspectorPanel(props) {
  const $ = (0, import_compiler_runtime2.c)(14), {
    documentId,
    documentType,
    flex
  } = props, {
    collapsed
  } = usePane(), {
    closeInspector,
    inspector
  } = useDocumentPane(), {
    features
  } = useStructureTool();
  let t0;
  $[0] !== closeInspector || $[1] !== inspector ? (t0 = () => {
    inspector && closeInspector(inspector.name);
  }, $[0] = closeInspector, $[1] = inspector, $[2] = t0) : t0 = $[2];
  const handleClose = t0;
  if (collapsed || !inspector)
    return null;
  const Component = inspector.component;
  let t1;
  $[3] !== Component || $[4] !== documentId || $[5] !== documentType || $[6] !== handleClose ? (t1 = (0, import_jsx_runtime2.jsx)(Component, { onClose: handleClose, documentId, documentType }), $[3] = Component, $[4] = documentId, $[5] = documentType, $[6] = handleClose, $[7] = t1) : t1 = $[7];
  const element = t1;
  if (features.resizablePanes) {
    let t22;
    return $[8] !== element || $[9] !== flex ? (t22 = (0, import_jsx_runtime2.jsx)(Resizable, { as: "aside", "data-ui": "DocumentInspectorPanel", flex, resizerPosition: "left", maxWidth: DOCUMENT_INSPECTOR_MAX_WIDTH, minWidth: DOCUMENT_INSPECTOR_MIN_WIDTH, children: element }), $[8] = element, $[9] = flex, $[10] = t22) : t22 = $[10], t22;
  }
  let t2;
  return $[11] !== element || $[12] !== flex ? (t2 = (0, import_jsx_runtime2.jsx)(Box, { as: "aside", "data-ui": "DocumentInspectorPanel", flex, children: element }), $[11] = element, $[12] = flex, $[13] = t2) : t2 = $[13], t2;
}
var STRUCTURE_TOOL_NAMESPACE = "studio.structure-tool";
function useStructureToolSetting(namespace, key, defaultValue) {
  const $ = (0, import_compiler_runtime2.c)(16), keyValueStore = useKeyValueStore();
  let t0;
  $[0] !== key || $[1] !== namespace ? (t0 = [STRUCTURE_TOOL_NAMESPACE, namespace, key].filter(Boolean), $[0] = key, $[1] = namespace, $[2] = t0) : t0 = $[2];
  const keyValueStoreKey = t0.join(".");
  let t1;
  if ($[3] !== defaultValue || $[4] !== keyValueStore || $[5] !== keyValueStoreKey) {
    let t22;
    $[7] !== defaultValue ? (t22 = (value) => value === null ? defaultValue : value, $[7] = defaultValue, $[8] = t22) : t22 = $[8], t1 = keyValueStore.getKey(keyValueStoreKey).pipe(map(t22)), $[3] = defaultValue, $[4] = keyValueStore, $[5] = keyValueStoreKey, $[6] = t1;
  } else
    t1 = $[6];
  const value_0 = useObservable(t1, defaultValue);
  let t2;
  $[9] !== keyValueStore || $[10] !== keyValueStoreKey || $[11] !== value_0 ? (t2 = async (newValue) => {
    newValue !== value_0 && await keyValueStore.setKey(keyValueStoreKey, newValue);
  }, $[9] = keyValueStore, $[10] = keyValueStoreKey, $[11] = value_0, $[12] = t2) : t2 = $[12];
  const set = t2;
  let t3;
  return $[13] !== set || $[14] !== value_0 ? (t3 = [value_0, set], $[13] = set, $[14] = value_0, $[15] = t3) : t3 = $[15], t3;
}
var VIEW_MODE_PARSED = {
  id: "parsed",
  title: "document-inspector.view-mode.parsed"
};
var VIEW_MODE_RAW = {
  id: "raw",
  title: "document-inspector.view-mode.raw-json"
};
var VIEW_MODES = [VIEW_MODE_PARSED, VIEW_MODE_RAW];
var lru = new QuickLRU({
  maxSize: 1e3
});
function isExpanded(keyPath, value) {
  const cached = lru.get(keyPath);
  return cached === void 0 ? (lru.set(keyPath, Array.isArray(value) || isRecord$4(value)), isExpanded(keyPath, value)) : cached;
}
function toggleExpanded(event) {
  const {
    path
  } = event, current = lru.get(path);
  current !== void 0 && lru.set(path, !current);
}
function selectElement(element) {
  const sel = window.getSelection();
  if (sel) {
    const range = document.createRange();
    sel.removeAllRanges(), range.selectNodeContents(element), sel.addRange(range);
  }
}
function select(event) {
  selectElement(event.target);
}
function maybeSelectAll(event) {
  event.keyCode === 65 && (event.metaKey || event.ctrlKey) && (event.preventDefault(), selectElement(event.currentTarget));
}
function isDocumentLike(value) {
  return isRecord$4(value) && isString(value._id) && isString(value._type);
}
var JSONInspectorWrapper = at.div.withConfig({
  displayName: "JSONInspectorWrapper",
  componentId: "sc-1nlr6yd-0"
})(({
  theme
}) => {
  const {
    color,
    fonts,
    space
  } = theme.sanity;
  return rt`
    & .json-inspector,
    & .json-inspector .json-inspector__selection {
      font-family: ${fonts.code.family};
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
      color: var(--card-code-fg-color);
    }

    & .json-inspector .json-inspector__leaf {
      padding-left: ${rem(space[4])};
    }

    & .json-inspector .json-inspector__leaf.json-inspector__leaf_root {
      padding-top: ${rem(space[3])};
      padding-left: 0;
    }

    & .json-inspector > .json-inspector__leaf_root > .json-inspector__line > .json-inspector__key {
      display: none;
    }

    & .json-inspector .json-inspector__line {
      display: block;
      position: relative;
      cursor: default;
    }

    & .json-inspector .json-inspector__line::after {
      content: '';
      position: absolute;
      top: 0;
      left: -200px;
      right: -50px;
      bottom: 0;
      z-index: -1;
      pointer-events: none;
    }

    & .json-inspector .json-inspector__line:hover::after {
      background: var(--card-code-bg-color);
    }

    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line {
      cursor: pointer;
    }

    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line::before {
      content: ' ';
      margin-left: calc(0 - ${rem(space[4])} + 3px);
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
    }

    &
      .json-inspector
      .json-inspector__leaf_expanded.json-inspector__leaf_composite
      > .json-inspector__line::before {
      content: ' ';
      font-size: ${fonts.code.sizes[1].fontSize}px;
      line-height: ${fonts.code.sizes[1].lineHeight}px;
    }

    & .json-inspector .json-inspector__radio,
    & .json-inspector .json-inspector__flatpath {
      display: none;
    }

    & .json-inspector .json-inspector__value {
      margin-left: ${rem(space[4] / 2)};
    }

    &
      .json-inspector
      > .json-inspector__leaf_root
      > .json-inspector__line
      > .json-inspector__key
      + .json-inspector__value {
      margin: 0;
    }

    & .json-inspector .json-inspector__key {
      color: ${color.syntax.property};
    }

    & .json-inspector .json-inspector__value_helper,
    & .json-inspector .json-inspector__value_null {
      color: ${color.syntax.constant};
    }

    & .json-inspector .json-inspector__not-found {
      padding-top: ${rem(space[3])};
    }

    & .json-inspector .json-inspector__value_string {
      color: ${color.syntax.string};
    }

    & .json-inspector .json-inspector__value_boolean {
      color: ${color.syntax.boolean};
    }

    & .json-inspector .json-inspector__value_number {
      color: ${color.syntax.number};
    }

    & .json-inspector .json-inspector__show-original {
      display: inline-block;
      padding: 0 6px;
      cursor: pointer;
    }

    & .json-inspector .json-inspector__show-original:hover {
      color: inherit;
    }

    & .json-inspector .json-inspector__show-original::before {
      content: '';
    }

    & .json-inspector .json-inspector__show-original:hover::after {
      content: ' expand';
    }
  `;
});
function Search(props) {
  const $ = (0, import_compiler_runtime2.c)(8), {
    onChange,
    query
  } = props;
  let t0;
  $[0] !== onChange ? (t0 = (event) => onChange(event.target.value), $[0] = onChange, $[1] = t0) : t0 = $[1];
  const handleChange = t0, {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[2] !== t2 ? (t1 = t2("document-inspector.search.placeholder"), $[2] = t2, $[3] = t1) : t1 = $[3];
  const t22 = query || "";
  let t3;
  return $[4] !== handleChange || $[5] !== t1 || $[6] !== t22 ? (t3 = (0, import_jsx_runtime2.jsx)(TextInput, { icon: SearchIcon, onChange: handleChange, placeholder: t1, radius: 2, value: t22 }), $[4] = handleChange, $[5] = t1, $[6] = t22, $[7] = t3) : t3 = $[7], t3;
}
function InspectDialog(props) {
  const $ = (0, import_compiler_runtime2.c)(49), {
    value
  } = props, {
    onInspectClose,
    paneKey
  } = useDocumentPane(), dialogIdPrefix = `${paneKey}_inspect_`, [viewModeId, onViewModeChange] = useStructureToolSetting("inspect-view-mode", null, "parsed");
  let t0;
  $[0] !== viewModeId ? (t0 = VIEW_MODES.find((mode) => mode.id === viewModeId), $[0] = viewModeId, $[1] = t0) : t0 = $[1];
  const viewMode = t0;
  let t1;
  $[2] !== onViewModeChange ? (t1 = async () => {
    await onViewModeChange(VIEW_MODE_PARSED.id);
  }, $[2] = onViewModeChange, $[3] = t1) : t1 = $[3];
  const setParsedViewMode = t1;
  let t2;
  $[4] !== onViewModeChange ? (t2 = async () => {
    await onViewModeChange(VIEW_MODE_RAW.id);
  }, $[4] = onViewModeChange, $[5] = t2) : t2 = $[5];
  const setRawViewMode = t2, {
    t: t3
  } = useTranslation(structureLocaleNamespace), t32 = `${dialogIdPrefix}dialog`;
  let t4;
  $[6] !== t3 || $[7] !== value ? (t4 = isDocumentLike(value) ? (0, import_jsx_runtime2.jsx)(Translate, { t: t3, i18nKey: "document-inspector.dialog.title", components: {
    DocumentTitle: () => (0, import_jsx_runtime2.jsx)("em", { children: (0, import_jsx_runtime2.jsx)(DocTitle, { document: value }) })
  } }) : (0, import_jsx_runtime2.jsx)("em", { children: t3("document-inspector.dialog.title-no-value") }), $[6] = t3, $[7] = value, $[8] = t4) : t4 = $[8];
  let t5;
  $[9] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t5 = {
    position: "sticky",
    bottom: 0,
    zIndex: 3
  }, $[9] = t5) : t5 = $[9];
  const t6 = `${dialogIdPrefix}tabpanel`, t7 = `${dialogIdPrefix}tab-${VIEW_MODE_PARSED.id}`;
  let t8;
  $[10] !== t3 ? (t8 = t3(VIEW_MODE_PARSED.title), $[10] = t3, $[11] = t8) : t8 = $[11];
  const t9 = viewMode === VIEW_MODE_PARSED;
  let t10;
  $[12] !== setParsedViewMode || $[13] !== t6 || $[14] !== t7 || $[15] !== t8 || $[16] !== t9 ? (t10 = (0, import_jsx_runtime2.jsx)(Tab, { "aria-controls": t6, id: t7, label: t8, onClick: setParsedViewMode, selected: t9 }), $[12] = setParsedViewMode, $[13] = t6, $[14] = t7, $[15] = t8, $[16] = t9, $[17] = t10) : t10 = $[17];
  const t11 = `${dialogIdPrefix}tabpanel`, t12 = `${dialogIdPrefix}tab-${VIEW_MODE_RAW.id}`;
  let t13;
  $[18] !== t3 ? (t13 = t3(VIEW_MODE_RAW.title), $[18] = t3, $[19] = t13) : t13 = $[19];
  const t14 = viewMode === VIEW_MODE_RAW;
  let t15;
  $[20] !== setRawViewMode || $[21] !== t11 || $[22] !== t12 || $[23] !== t13 || $[24] !== t14 ? (t15 = (0, import_jsx_runtime2.jsx)(Tab, { "aria-controls": t11, id: t12, label: t13, onClick: setRawViewMode, selected: t14 }), $[20] = setRawViewMode, $[21] = t11, $[22] = t12, $[23] = t13, $[24] = t14, $[25] = t15) : t15 = $[25];
  let t16;
  $[26] !== t10 || $[27] !== t15 ? (t16 = (0, import_jsx_runtime2.jsx)(Card, { padding: 3, paddingTop: 0, shadow: 1, style: t5, children: (0, import_jsx_runtime2.jsxs)(TabList, { space: 1, children: [
    t10,
    t15
  ] }) }), $[26] = t10, $[27] = t15, $[28] = t16) : t16 = $[28];
  const t17 = `${dialogIdPrefix}tab-${viewModeId}`, t18 = `${dialogIdPrefix}tabpanel`;
  let t19;
  $[29] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t19 = {
    outline: "none"
  }, $[29] = t19) : t19 = $[29];
  let t20;
  $[30] !== value || $[31] !== viewMode ? (t20 = viewMode === VIEW_MODE_PARSED && (0, import_jsx_runtime2.jsx)(JSONInspectorWrapper, { children: (0, import_jsx_runtime2.jsx)(JsonInspector, { data: value, isExpanded, onClick: toggleExpanded, search: Search, filterOptions: {
    ignoreCase: true
  } }) }), $[30] = value, $[31] = viewMode, $[32] = t20) : t20 = $[32];
  let t21;
  $[33] !== value || $[34] !== viewMode ? (t21 = viewMode === VIEW_MODE_RAW && (0, import_jsx_runtime2.jsx)(Code, { language: "json", tabIndex: 0, onKeyDown: maybeSelectAll, onDoubleClick: select, size: 1, children: JSON.stringify(value, null, 2) }), $[33] = value, $[34] = viewMode, $[35] = t21) : t21 = $[35];
  let t22;
  $[36] !== t17 || $[37] !== t18 || $[38] !== t20 || $[39] !== t21 ? (t22 = (0, import_jsx_runtime2.jsxs)(TabPanel, { "aria-labelledby": t17, flex: 1, id: t18, overflow: "auto", padding: 4, style: t19, children: [
    t20,
    t21
  ] }), $[36] = t17, $[37] = t18, $[38] = t20, $[39] = t21, $[40] = t22) : t22 = $[40];
  let t23;
  $[41] !== t16 || $[42] !== t22 ? (t23 = (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", height: "fill", children: [
    t16,
    t22
  ] }), $[41] = t16, $[42] = t22, $[43] = t23) : t23 = $[43];
  let t24;
  return $[44] !== onInspectClose || $[45] !== t23 || $[46] !== t32 || $[47] !== t4 ? (t24 = (0, import_jsx_runtime2.jsx)(Dialog2, { bodyHeight: "fill", id: t32, header: t4, onClose: onInspectClose, onClickOutside: onInspectClose, padding: false, width: 2, children: t23 }), $[44] = onInspectClose, $[45] = t23, $[46] = t32, $[47] = t4, $[48] = t24) : t24 = $[48], t24;
}
function Banner(props) {
  const $ = (0, import_compiler_runtime2.c)(22);
  let Icon, action, content, rest, t0, t1;
  $[0] !== props ? ({
    action,
    content,
    icon: Icon,
    tone: t0,
    paddingY: t1,
    ...rest
  } = props, $[0] = props, $[1] = Icon, $[2] = action, $[3] = content, $[4] = rest, $[5] = t0, $[6] = t1) : (Icon = $[1], action = $[2], content = $[3], rest = $[4], t0 = $[5], t1 = $[6]);
  const tone = t0 === void 0 ? "transparent" : t0, paddingY = t1 === void 0 ? 2 : t1;
  let t2;
  $[7] !== Icon ? (t2 = Icon && (0, import_jsx_runtime2.jsx)(Text, { size: 0, children: (0, import_jsx_runtime2.jsx)(Icon, {}) }), $[7] = Icon, $[8] = t2) : t2 = $[8];
  let t3;
  $[9] !== content ? (t3 = (0, import_jsx_runtime2.jsx)(Flex, { align: "center", flex: 1, gap: 2, paddingY: 2, children: content }), $[9] = content, $[10] = t3) : t3 = $[10];
  let t4;
  $[11] !== action ? (t4 = action && (0, import_jsx_runtime2.jsx)(Button2, { ...action, mode: action.mode || "ghost", tone: action.tone || "default" }), $[11] = action, $[12] = t4) : t4 = $[12];
  let t5;
  $[13] !== t2 || $[14] !== t3 || $[15] !== t4 ? (t5 = (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 3, paddingX: 2, children: [
    t2,
    t3,
    t4
  ] }), $[13] = t2, $[14] = t3, $[15] = t4, $[16] = t5) : t5 = $[16];
  let t6;
  return $[17] !== paddingY || $[18] !== rest || $[19] !== t5 || $[20] !== tone ? (t6 = (0, import_jsx_runtime2.jsx)(Box, { padding: 1, children: (0, import_jsx_runtime2.jsx)(Card, { radius: 3, paddingX: 2, paddingY, tone, ...rest, children: t5 }) }), $[17] = paddingY, $[18] = rest, $[19] = t5, $[20] = tone, $[21] = t6) : t6 = $[21], t6;
}
function DeletedDocumentBanners() {
  const $ = (0, import_compiler_runtime2.c)(3), {
    isDeleted,
    isDeleting,
    ready
  } = useDocumentPane(), {
    selectedPerspective
  } = usePerspective();
  if (!ready)
    return null;
  if (!isPublishedPerspective(selectedPerspective) && !isDraftPerspective(selectedPerspective) && isReleaseDocument(selectedPerspective) && selectedPerspective.state === "archived") {
    let t0;
    return $[0] !== selectedPerspective ? (t0 = (0, import_jsx_runtime2.jsx)(ArchivedReleaseBanner, { release: selectedPerspective }), $[0] = selectedPerspective, $[1] = t0) : t0 = $[1], t0;
  }
  if (isDeleted && !isDeleting) {
    let t0;
    return $[2] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = (0, import_jsx_runtime2.jsx)(DeletedDocumentBanner, {}), $[2] = t0) : t0 = $[2], t0;
  }
}
function DeletedDocumentBanner() {
  const $ = (0, import_compiler_runtime2.c)(17), {
    documentId,
    documentType
  } = useDocumentPane(), {
    restore
  } = useDocumentOperation(documentId, documentType), {
    navigateIntent
  } = useRouter();
  let t0;
  $[0] !== documentId || $[1] !== documentType || $[2] !== navigateIntent || $[3] !== restore ? (t0 = () => {
    restore.execute("lastRevision"), navigateIntent("edit", {
      id: documentId,
      type: documentType
    });
  }, $[0] = documentId, $[1] = documentType, $[2] = navigateIntent, $[3] = restore, $[4] = t0) : t0 = $[4];
  const handleRestore = t0, {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[5] !== t2 ? (t1 = t2("banners.deleted-document-banner.restore-button.text"), $[5] = t2, $[6] = t1) : t1 = $[6];
  let t22;
  $[7] !== handleRestore || $[8] !== t1 ? (t22 = {
    onClick: handleRestore,
    text: t1
  }, $[7] = handleRestore, $[8] = t1, $[9] = t22) : t22 = $[9];
  let t3;
  $[10] !== t2 ? (t3 = t2("banners.deleted-document-banner.text"), $[10] = t2, $[11] = t3) : t3 = $[11];
  let t4;
  $[12] !== t3 ? (t4 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: t3 }), $[12] = t3, $[13] = t4) : t4 = $[13];
  let t5;
  return $[14] !== t22 || $[15] !== t4 ? (t5 = (0, import_jsx_runtime2.jsx)(Banner, { action: t22, content: t4, "data-testid": "deleted-document-banner", icon: ReadOnlyIcon }), $[14] = t22, $[15] = t4, $[16] = t5) : t5 = $[16], t5;
}
var ArchivedReleaseBanner = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(8), {
    release
  } = t0, {
    t: t2
  } = useTranslation();
  let t1;
  $[0] !== release.metadata?.title || $[1] !== t2 ? (t1 = release.metadata?.title || t2("release.placeholder-untitled-release"), $[0] = release.metadata?.title, $[1] = t2, $[2] = t1) : t1 = $[2];
  let t22;
  $[3] !== t1 ? (t22 = {
    title: t1
  }, $[3] = t1, $[4] = t22) : t22 = $[4];
  let t3;
  return $[5] !== t2 || $[6] !== t22 ? (t3 = (0, import_jsx_runtime2.jsx)(Banner, { tone: "caution", content: (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "banners.deleted-release-banner.text", values: t22 }) }), "data-testid": "deleted-release-banner", icon: DocumentRemoveIcon }), $[5] = t2, $[6] = t22, $[7] = t3) : t3 = $[7], t3;
};
function DeprecatedDocumentTypeBanner() {
  const $ = (0, import_compiler_runtime2.c)(5), {
    schemaType
  } = useDocumentPane(), {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  if (!isDeprecatedSchemaType(schemaType))
    return null;
  let t0;
  $[0] !== t2 ? (t0 = (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "banners.deprecated-document-type-banner.text" }), $[0] = t2, $[1] = t0) : t0 = $[1];
  let t1;
  return $[2] !== schemaType.deprecated.reason || $[3] !== t0 ? (t1 = (0, import_jsx_runtime2.jsx)(Banner, { content: (0, import_jsx_runtime2.jsxs)(Text, { size: 1, weight: "medium", children: [
    t0,
    " ",
    schemaType.deprecated.reason
  ] }), "data-testid": "deprecated-document-type-banner", icon: ErrorOutlineIcon }), $[2] = schemaType.deprecated.reason, $[3] = t0, $[4] = t1) : t1 = $[4], t1;
}
var AskToEditDialogOpened = defineEvent({
  name: "Ask To Edit Dialog Opened",
  version: 1,
  description: 'User clicked the "Ask to edit" button in the document permissions banner'
});
var AskToEditRequestSent = defineEvent({
  name: "Ask To Edit Request Sent",
  version: 1,
  description: "User sent a role change request from the dialog"
});
var MAX_NOTE_LENGTH = 150;
var DialogBody$1 = at(Box).withConfig({
  displayName: "DialogBody",
  componentId: "sc-68p9pn-0"
})`box-sizing:border-box;`;
at(Flex).attrs({
  align: "center",
  direction: "column",
  justify: "center"
}).withConfig({
  displayName: "LoadingContainer",
  componentId: "sc-68p9pn-1"
})`height:110px;`;
function RequestPermissionDialog(t0) {
  const $ = (0, import_compiler_runtime2.c)(56), {
    onClose,
    onRequestSubmitted
  } = t0, {
    t: t2
  } = useTranslation(structureLocaleNamespace), telemtry = useTelemetry(), dialogId = `request-permissions-${(0, import_react2.useId)()}`, projectId = useProjectId();
  let t1;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = {
    apiVersion: "2024-09-26"
  }, $[0] = t1) : t1 = $[0];
  const client = useClient(t1), toast = useToast(), zOffset = useZIndex(), [isSubmitting, setIsSubmitting] = (0, import_react2.useState)(false), [note, setNote] = (0, import_react2.useState)(""), [msgError, setMsgError] = (0, import_react2.useState)(), [hasTooManyRequests, setHasTooManyRequests] = (0, import_react2.useState)(false), [hasBeenDenied, setHasBeenDenied] = (0, import_react2.useState)(false);
  let t22;
  bb0: {
    const adminRole = "administrator";
    if (!projectId || !client) {
      let t33;
      $[1] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t33 = of(adminRole), $[1] = t33) : t33 = $[1], t22 = t33;
      break bb0;
    }
    let t32;
    if ($[2] !== client.observable || $[3] !== projectId) {
      let t42;
      $[5] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t42 = (roles) => roles.filter(_temp$F).find(_temp2$h) ? "editor" : adminRole, $[5] = t42) : t42 = $[5];
      let t52;
      $[6] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t52 = () => of(adminRole), $[6] = t52) : t52 = $[6], t32 = client.observable.request({
        url: `/projects/${projectId}/roles`
      }).pipe(map(t42), startWith(adminRole), catchError(t52)), $[2] = client.observable, $[3] = projectId, $[4] = t32;
    } else
      t32 = $[4];
    t22 = t32;
  }
  const requestedRole = useObservable(t22);
  let t3;
  $[7] !== client || $[8] !== note || $[9] !== onRequestSubmitted || $[10] !== projectId || $[11] !== requestedRole || $[12] !== telemtry || $[13] !== toast ? (t3 = () => {
    setIsSubmitting(true), client.request({
      url: `/access/project/${projectId}/requests`,
      method: "post",
      body: {
        note,
        requestUrl: window?.location.href,
        requestedRole,
        type: "role"
      }
    }).then((request) => {
      request && (onRequestSubmitted && onRequestSubmitted(), telemtry.log(AskToEditRequestSent), toast.push({
        title: "Edit access requested"
      }));
    }).catch((err) => {
      const statusCode = err?.response?.statusCode, errMessage = err?.response?.body?.message;
      statusCode === 429 && (setHasTooManyRequests(true), setMsgError(errMessage)), statusCode === 409 ? (setHasBeenDenied(true), setMsgError(errMessage)) : toast.push({
        title: "There was a problem submitting your request.",
        status: "error"
      });
    }).finally(() => {
      setIsSubmitting(false);
    });
  }, $[7] = client, $[8] = note, $[9] = onRequestSubmitted, $[10] = projectId, $[11] = requestedRole, $[12] = telemtry, $[13] = toast, $[14] = t3) : t3 = $[14];
  const onSubmit = t3, t4 = zOffset.fullscreen;
  let t5;
  $[15] !== t2 ? (t5 = t2("request-permission-dialog.header.text"), $[15] = t2, $[16] = t5) : t5 = $[16];
  let t6;
  $[17] !== t2 ? (t6 = t2("confirm-dialog.cancel-button.fallback-text"), $[17] = t2, $[18] = t6) : t6 = $[18];
  let t7;
  $[19] !== onClose || $[20] !== t6 ? (t7 = {
    onClick: onClose,
    text: t6
  }, $[19] = onClose, $[20] = t6, $[21] = t7) : t7 = $[21];
  const t8 = hasTooManyRequests || hasBeenDenied;
  let t9;
  $[22] !== t2 ? (t9 = t2("request-permission-dialog.confirm-button.text"), $[22] = t2, $[23] = t9) : t9 = $[23];
  let t10;
  $[24] !== isSubmitting || $[25] !== onSubmit || $[26] !== t8 || $[27] !== t9 ? (t10 = {
    onClick: onSubmit,
    loading: isSubmitting,
    disabled: t8,
    text: t9,
    tone: "primary",
    type: "submit"
  }, $[24] = isSubmitting, $[25] = onSubmit, $[26] = t8, $[27] = t9, $[28] = t10) : t10 = $[28];
  let t11;
  $[29] !== t10 || $[30] !== t7 ? (t11 = {
    cancelButton: t7,
    confirmButton: t10
  }, $[29] = t10, $[30] = t7, $[31] = t11) : t11 = $[31];
  let t12;
  $[32] !== t2 ? (t12 = t2("request-permission-dialog.description.text"), $[32] = t2, $[33] = t12) : t12 = $[33];
  let t13;
  $[34] !== t12 ? (t13 = (0, import_jsx_runtime2.jsx)(Text, { children: t12 }), $[34] = t12, $[35] = t13) : t13 = $[35];
  let t14;
  $[36] !== hasBeenDenied || $[37] !== hasTooManyRequests || $[38] !== isSubmitting || $[39] !== msgError || $[40] !== note || $[41] !== onSubmit || $[42] !== t2 ? (t14 = hasTooManyRequests || hasBeenDenied ? (0, import_jsx_runtime2.jsx)(Card, { tone: "caution", padding: 3, radius: 2, shadow: 1, children: (0, import_jsx_runtime2.jsxs)(Text, { size: 1, children: [
    hasTooManyRequests && (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: msgError ?? t2("request-permission-dialog.warning.limit-reached.text") }),
    hasBeenDenied && (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: msgError ?? t2("request-permission-dialog.warning.denied.text") })
  ] }) }) : (0, import_jsx_runtime2.jsxs)(Stack, { space: 3, paddingBottom: 0, children: [
    (0, import_jsx_runtime2.jsx)(TextInput, { placeholder: t2("request-permission-dialog.note-input.placeholder.text"), disabled: isSubmitting, onKeyDown: (e2) => {
      e2.key === "Enter" && onSubmit();
    }, maxLength: MAX_NOTE_LENGTH, value: note, onChange: (e_0) => {
      setNote(e_0.currentTarget.value);
    } }),
    (0, import_jsx_runtime2.jsx)(Text, { align: "right", muted: true, size: 1, children: `${note.length}/${MAX_NOTE_LENGTH}` })
  ] }), $[36] = hasBeenDenied, $[37] = hasTooManyRequests, $[38] = isSubmitting, $[39] = msgError, $[40] = note, $[41] = onSubmit, $[42] = t2, $[43] = t14) : t14 = $[43];
  let t15;
  $[44] !== t13 || $[45] !== t14 ? (t15 = (0, import_jsx_runtime2.jsx)(DialogBody$1, { children: (0, import_jsx_runtime2.jsxs)(Stack, { space: 4, children: [
    t13,
    t14
  ] }) }), $[44] = t13, $[45] = t14, $[46] = t15) : t15 = $[46];
  let t16;
  $[47] !== dialogId || $[48] !== onClose || $[49] !== t11 || $[50] !== t15 || $[51] !== t5 ? (t16 = (0, import_jsx_runtime2.jsx)(Dialog2, { width: 1, id: dialogId, header: t5, footer: t11, onClose, onClickOutside: onClose, children: t15 }), $[47] = dialogId, $[48] = onClose, $[49] = t11, $[50] = t15, $[51] = t5, $[52] = t16) : t16 = $[52];
  let t17;
  return $[53] !== t16 || $[54] !== zOffset.fullscreen ? (t17 = (0, import_jsx_runtime2.jsx)(DialogProvider, { position: "fixed", zOffset: t4, children: t16 }), $[53] = t16, $[54] = zOffset.fullscreen, $[55] = t17) : t17 = $[55], t17;
}
function _temp2$h(role_0) {
  return role_0.name === "editor";
}
function _temp$F(role) {
  return role?.appliesToUsers;
}
var LOADING_STATE = {
  loading: true,
  error: false,
  status: void 0
};
var EMPTY_STATE = {
  loading: false,
  error: false,
  status: "none"
};
var DECLINED_STATE = {
  loading: false,
  error: false,
  status: "declined"
};
var PENDING_STATE = {
  loading: false,
  error: false,
  status: "pending"
};
var EXPIRED_STATE = {
  loading: false,
  error: false,
  status: "expired"
};
var useRoleRequestsStatus = () => {
  const $ = (0, import_compiler_runtime2.c)(9);
  let t0;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    apiVersion: "2024-07-01"
  }, $[0] = t0) : t0 = $[0];
  const client = useClient(t0), projectId = useProjectId();
  let t1;
  bb0: {
    if (!client || !projectId) {
      let t23;
      $[1] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t23 = of(EMPTY_STATE), $[1] = t23) : t23 = $[1], t1 = t23;
      break bb0;
    }
    let t22;
    $[2] !== client || $[3] !== projectId ? (t22 = checkRoleRequests(client, projectId), $[2] = client, $[3] = projectId, $[4] = t22) : t22 = $[4], t1 = t22;
  }
  const checkRoleRequests$ = t1, {
    loading,
    error,
    status
  } = useObservable(checkRoleRequests$, LOADING_STATE);
  let t2;
  return $[5] !== error || $[6] !== loading || $[7] !== status ? (t2 = {
    data: status,
    loading,
    error
  }, $[5] = error, $[6] = loading, $[7] = status, $[8] = t2) : t2 = $[8], t2;
};
function checkRoleRequests(client, projectId) {
  return client.observable.request({
    url: "/access/requests/me",
    tag: "use-role-requests-status"
  }).pipe(
    map((requests) => {
      if (!requests || requests.length === 0)
        return EMPTY_STATE;
      const projectRequests = requests.filter((request) => request.resourceId === projectId && request.type === "role"), declinedRequest = projectRequests.find((request) => request.status === "declined");
      return declinedRequest && isAfter(addWeeks(new Date(declinedRequest.createdAt), 2), /* @__PURE__ */ new Date()) ? DECLINED_STATE : projectRequests.find((request) => request.status === "pending" && isAfter(addWeeks(new Date(request.createdAt), 2), /* @__PURE__ */ new Date())) ? PENDING_STATE : projectRequests.find((request) => request.status === "pending" && isBefore(addWeeks(new Date(request.createdAt), 2), /* @__PURE__ */ new Date())) ? EXPIRED_STATE : EMPTY_STATE;
    }),
    catchError((err) => (console.error("Failed to fetch access requests", err), of({
      loading: false,
      error: true,
      status: void 0
    }))),
    startWith(LOADING_STATE)
    // Start with loading state
  );
}
function InsufficientPermissionBanner(t0) {
  const $ = (0, import_compiler_runtime2.c)(29), {
    requiredPermission
  } = t0, currentUser = useCurrentUser(), {
    data: roleRequestStatus,
    loading: requestStatusLoading,
    error: requestStatusError
  } = useRoleRequestsStatus(), [requestSent, setRequestSent] = (0, import_react2.useState)(false), requestPending = roleRequestStatus === "pending" || roleRequestStatus === "declined" || requestSent, currentUserRoles = currentUser?.roles || [], isOnlyViewer = currentUserRoles.length === 1 && currentUserRoles[0].name === "viewer", [showRequestPermissionDialog, setShowRequestPermissionDialog] = (0, import_react2.useState)(false);
  let t1;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = {
    style: "short"
  }, $[0] = t1) : t1 = $[0];
  const listFormat = useListFormat(t1), {
    t: t2
  } = useTranslation(structureLocaleNamespace), telemetry = useTelemetry(), roleTitles = currentUserRoles.map(_temp$E), roles = listFormat.formatToParts(roleTitles).map(_temp2$g);
  let t22;
  $[1] !== roles ? (t22 = {
    Roles: () => (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: roles })
  }, $[1] = roles, $[2] = t22) : t22 = $[2];
  let t3;
  $[3] !== roleTitles || $[4] !== roles.length ? (t3 = {
    count: roles.length,
    roles: roleTitles
  }, $[3] = roleTitles, $[4] = roles.length, $[5] = t3) : t3 = $[5];
  let t4;
  $[6] !== requiredPermission || $[7] !== t2 || $[8] !== t22 || $[9] !== t3 ? (t4 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "banners.permission-check-banner.missing-permission", components: t22, values: t3, context: requiredPermission }) }), $[6] = requiredPermission, $[7] = t2, $[8] = t22, $[9] = t3, $[10] = t4) : t4 = $[10];
  let t5;
  $[11] !== isOnlyViewer || $[12] !== requestPending || $[13] !== requestStatusError || $[14] !== requestStatusLoading || $[15] !== roleRequestStatus || $[16] !== setShowRequestPermissionDialog || $[17] !== t2 || $[18] !== telemetry ? (t5 = isOnlyViewer && roleRequestStatus && !requestStatusError && !requestStatusLoading ? {
    onClick: requestPending ? void 0 : () => {
      setShowRequestPermissionDialog(true), telemetry.log(AskToEditDialogOpened);
    },
    text: t2(requestPending ? "banners.permission-check-banner.request-permission-button.sent" : "banners.permission-check-banner.request-permission-button.text"),
    tone: requestPending ? "default" : "primary",
    disabled: requestPending,
    mode: requestPending ? "bleed" : void 0
  } : void 0, $[11] = isOnlyViewer, $[12] = requestPending, $[13] = requestStatusError, $[14] = requestStatusLoading, $[15] = roleRequestStatus, $[16] = setShowRequestPermissionDialog, $[17] = t2, $[18] = telemetry, $[19] = t5) : t5 = $[19];
  let t6;
  $[20] !== t4 || $[21] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(Banner, { content: t4, action: t5, "data-testid": "permission-check-banner", icon: ReadOnlyIcon }), $[20] = t4, $[21] = t5, $[22] = t6) : t6 = $[22];
  let t7;
  $[23] !== setShowRequestPermissionDialog || $[24] !== showRequestPermissionDialog ? (t7 = showRequestPermissionDialog && (0, import_jsx_runtime2.jsx)(RequestPermissionDialog, { onClose: () => setShowRequestPermissionDialog(false), onRequestSubmitted: () => {
    setRequestSent(true), setShowRequestPermissionDialog(false);
  } }), $[23] = setShowRequestPermissionDialog, $[24] = showRequestPermissionDialog, $[25] = t7) : t7 = $[25];
  let t8;
  return $[26] !== t6 || $[27] !== t7 ? (t8 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    t6,
    t7
  ] }), $[26] = t6, $[27] = t7, $[28] = t8) : t8 = $[28], t8;
}
function _temp2$g(part) {
  return part.type === "element" ? (0, import_jsx_runtime2.jsx)("code", { children: part.value }, part.value) : part.value;
}
function _temp$E(role) {
  return role.title;
}
var ReferenceChangedBanner = (0, import_react2.memo)(() => {
  const $ = (0, import_compiler_runtime2.c)(32), documentPreviewStore = useDocumentPreviewStore(), {
    selectedPerspectiveName
  } = usePerspective(), {
    params,
    groupIndex,
    routerPanesState,
    replaceCurrent,
    BackLink: BackLink2
  } = usePaneRouter(), routerReferenceId = routerPanesState[groupIndex]?.[0].id, parentSibling = routerPanesState[groupIndex - 1]?.[0], parentId = parentSibling?.id, hasHistoryOpen = !!parentSibling?.params?.rev;
  let t0;
  $[0] !== params ? (t0 = params?.parentRefPath && fromString(params.parentRefPath) || null, $[0] = params, $[1] = t0) : t0 = $[1];
  const parentRefPath = t0, {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t1;
  bb0: {
    const parentRefPathSegment = parentRefPath?.[0];
    if (!parentId || !parentRefPathSegment || !parentRefPath) {
      let t23;
      $[2] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t23 = of({
        loading: false
      }), $[2] = t23) : t23 = $[2], t1 = t23;
      break bb0;
    }
    let t222;
    if ($[3] !== documentPreviewStore || $[4] !== parentId || $[5] !== parentRefPath || $[6] !== parentRefPathSegment || $[7] !== selectedPerspectiveName) {
      const publishedId = getPublishedId(parentId), path = fromString(parentRefPathSegment), keyedSegmentIndex = path.findIndex(_temp$D);
      let t32;
      $[9] !== selectedPerspectiveName ? (t32 = isSystemBundle(selectedPerspectiveName) ? void 0 : selectedPerspectiveName, $[9] = selectedPerspectiveName, $[10] = t32) : t32 = $[10];
      let t42;
      $[11] !== parentRefPath ? (t42 = (t52) => {
        const {
          draft,
          published,
          version
        } = t52;
        return {
          loading: false,
          result: {
            availability: {
              draft: draft.availability,
              published: published.availability,
              ...version?.availability ? {
                version: version.availability
              } : {}
            },
            refValue: get(version?.snapshot || draft.snapshot || published.snapshot, parentRefPath)?._ref
          }
        };
      }, $[11] = parentRefPath, $[12] = t42) : t42 = $[12], t222 = concat(of({
        loading: true
      }), documentPreviewStore.unstable_observePathsDocumentPair(publishedId, keyedSegmentIndex === -1 ? path : path.slice(0, keyedSegmentIndex), {
        version: t32
      }).pipe(debounceTime(750), map(t42))), $[3] = documentPreviewStore, $[4] = parentId, $[5] = parentRefPath, $[6] = parentRefPathSegment, $[7] = selectedPerspectiveName, $[8] = t222;
    } else
      t222 = $[8];
    t1 = t222;
  }
  const referenceInfoObservable = t1;
  let t22;
  $[13] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t22 = {
    loading: true
  }, $[13] = t22) : t22 = $[13];
  const referenceInfo = useObservable(referenceInfoObservable, t22);
  let t3;
  $[14] !== params || $[15] !== referenceInfo.loading || $[16] !== referenceInfo.result || $[17] !== replaceCurrent ? (t3 = () => {
    referenceInfo.loading || referenceInfo.result?.refValue && replaceCurrent({
      id: referenceInfo.result.refValue,
      params
    });
  }, $[14] = params, $[15] = referenceInfo.loading, $[16] = referenceInfo.result, $[17] = replaceCurrent, $[18] = t3) : t3 = $[18];
  const handleReloadReference = t3;
  if (!parentId || !parentRefPath || hasHistoryOpen || referenceInfo.loading || !referenceInfo.result?.availability.draft.available && !referenceInfo.result?.availability.published.available || referenceInfo.result?.refValue === routerReferenceId)
    return null;
  let t4;
  $[19] !== BackLink2 || $[20] !== handleReloadReference || $[21] !== referenceInfo.result?.refValue || $[22] !== t2 ? (t4 = referenceInfo.result?.refValue ? {
    onClick: handleReloadReference,
    icon: SyncIcon,
    text: t2("banners.reference-changed-banner.reason-changed.reload-button.text")
  } : {
    as: BackLink2,
    icon: CloseIcon,
    text: t2("banners.reference-changed-banner.reason-removed.close-button.text")
  }, $[19] = BackLink2, $[20] = handleReloadReference, $[21] = referenceInfo.result?.refValue, $[22] = t2, $[23] = t4) : t4 = $[23];
  let t5;
  $[24] !== referenceInfo.result?.refValue || $[25] !== t2 ? (t5 = referenceInfo.result?.refValue ? t2("banners.reference-changed-banner.reason-changed.text") : t2("banners.reference-changed-banner.reason-removed.text"), $[24] = referenceInfo.result?.refValue, $[25] = t2, $[26] = t5) : t5 = $[26];
  let t6;
  $[27] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: t5 }), $[27] = t5, $[28] = t6) : t6 = $[28];
  let t7;
  return $[29] !== t4 || $[30] !== t6 ? (t7 = (0, import_jsx_runtime2.jsx)(Banner, { action: t4, "data-testid": "reference-changed-banner", content: t6, icon: WarningOutlineIcon, tone: "caution" }), $[29] = t4, $[30] = t6, $[31] = t7) : t7 = $[31], t7;
});
ReferenceChangedBanner.displayName = "Memo(ReferenceChangedBanner)";
function _temp$D(p) {
  return typeof p == "object" && "_key" in p;
}
function ScheduledDraftOverrideBanner(t0) {
  const $ = (0, import_compiler_runtime2.c)(2), {
    releaseId,
    draftDocument
  } = t0, {
    t: t2
  } = useTranslation(structureLocaleNamespace), {
    firstDocument: scheduledDraftDocument
  } = useScheduledDraftDocument(releaseId), draftPublishedId = draftDocument?._id ? getPublishedId(draftDocument._id) : null, scheduledPublishedId = scheduledDraftDocument?._id ? getPublishedId(scheduledDraftDocument._id) : null, draftRev = draftDocument?._rev, scheduledBaseRev = scheduledDraftDocument?._system?.base?.rev;
  if (draftPublishedId !== scheduledPublishedId || !(!draftRev || !scheduledBaseRev || draftRev !== scheduledBaseRev))
    return null;
  let t1;
  return $[0] !== t2 ? (t1 = (0, import_jsx_runtime2.jsx)(Banner, { tone: "caution", icon: WarningOutlineIcon, content: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "banners.scheduled-draft-override-banner.text" }) }) }), $[0] = t2, $[1] = t1) : t1 = $[1], t1;
}
function usePaneRouter() {
  return (0, import_react2.useContext)(PaneRouterContext);
}
function ArchivedReleaseDocumentBanner() {
  const $ = (0, import_compiler_runtime2.c)(24), {
    t: t2
  } = useTranslation(structureLocaleNamespace), {
    t: tCore
  } = useTranslation(), {
    data: archivedReleases
  } = useArchivedReleases(), {
    params,
    setParams
  } = usePaneRouter();
  let t0;
  $[0] !== params || $[1] !== setParams ? (t0 = () => {
    setParams({
      ...params,
      rev: params?.historyEvent || void 0,
      since: void 0,
      historyVersion: void 0
    });
  }, $[0] = params, $[1] = setParams, $[2] = t0) : t0 = $[2];
  const handleGoBack = t0;
  let t1;
  if ($[3] !== archivedReleases || $[4] !== params?.historyVersion) {
    let t222;
    $[6] !== params?.historyVersion ? (t222 = (r2) => getReleaseIdFromReleaseDocumentId(r2._id) === params?.historyVersion, $[6] = params?.historyVersion, $[7] = t222) : t222 = $[7], t1 = archivedReleases.find(t222), $[3] = archivedReleases, $[4] = params?.historyVersion, $[5] = t1;
  } else
    t1 = $[5];
  const release = t1;
  let t22;
  bb0: {
    if (release?.state === "published") {
      t22 = "banners.published-release.description";
      break bb0;
    }
    if (release && isCardinalityOneRelease(release)) {
      t22 = "banners.archived-scheduled-draft.description";
      break bb0;
    }
    t22 = "banners.archived-release.description";
  }
  const description = t22, t3 = release?.metadata.title;
  let t4;
  $[8] !== tCore ? (t4 = tCore("release.placeholder-untitled-release"), $[8] = tCore, $[9] = t4) : t4 = $[9];
  let t5;
  $[10] !== description || $[11] !== release || $[12] !== t2 ? (t5 = (t62) => {
    const {
      displayTitle
    } = t62;
    return (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: description, values: {
      title: displayTitle
    }, components: {
      VersionBadge: (t72) => {
        const {
          children
        } = t72, BadgeWithTone = getVersionInlineBadge(release);
        return (0, import_jsx_runtime2.jsx)(BadgeWithTone, { children });
      }
    } });
  }, $[10] = description, $[11] = release, $[12] = t2, $[13] = t5) : t5 = $[13];
  let t6;
  $[14] !== t3 || $[15] !== t4 || $[16] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(ReleaseTitle, { title: t3, fallback: t4, children: t5 }) }), $[14] = t3, $[15] = t4, $[16] = t5, $[17] = t6) : t6 = $[17];
  let t7;
  $[18] !== handleGoBack || $[19] !== params?.archivedRelease ? (t7 = params?.archivedRelease ? void 0 : {
    text: "Go back to published version",
    onClick: handleGoBack
  }, $[18] = handleGoBack, $[19] = params?.archivedRelease, $[20] = t7) : t7 = $[20];
  let t8;
  return $[21] !== t6 || $[22] !== t7 ? (t8 = (0, import_jsx_runtime2.jsx)(Banner, { tone: "caution", content: t6, action: t7 }), $[21] = t6, $[22] = t7, $[23] = t8) : t8 = $[23], t8;
}
var Image = at.img.withConfig({
  displayName: "Image",
  componentId: "sc-9vwcvu-0"
})`object-fit:cover;width:100%;height:100%;height:180px;display:flex;`;
var CANVAS_IMAGE_URL = "https://cdn.sanity.io/images/pyrmmpch/production/b47224e2f3a7d1747e43b9da1ac31739250e628b-632x376.png";
var CANVAS_APP_NAME = "Canvas";
var CanvasPopoverContent = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(24), {
    onClose,
    isLockedByCanvas
  } = t0, {
    t: t2
  } = useTranslation(structureLocaleNamespace), ref = (0, import_react2.useRef)(null);
  let t1;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = () => [ref.current], $[0] = t1) : t1 = $[0], useClickOutsideEvent(onClose, t1);
  let t22;
  $[1] !== isLockedByCanvas || $[2] !== t2 ? (t22 = t2(isLockedByCanvas ? "canvas.banner.popover-heading" : "canvas.banner.editable.popover-heading"), $[1] = isLockedByCanvas, $[2] = t2, $[3] = t22) : t22 = $[3];
  const popoverHeading = t22;
  let t3;
  $[4] !== isLockedByCanvas || $[5] !== t2 ? (t3 = t2(isLockedByCanvas ? "canvas.banner.popover-description" : "canvas.banner.editable.popover-description"), $[4] = isLockedByCanvas, $[5] = t2, $[6] = t3) : t3 = $[6];
  const popoverDescription = t3;
  let t4;
  $[7] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t4 = (0, import_jsx_runtime2.jsx)(Image, { src: CANVAS_IMAGE_URL, alt: "Canvas" }), $[7] = t4) : t4 = $[7];
  let t5;
  $[8] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t5 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "semibold", children: CANVAS_APP_NAME }), $[8] = t5) : t5 = $[8];
  let t6;
  $[9] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t6 = (0, import_jsx_runtime2.jsxs)(Flex, { paddingY: 1, gap: 2, children: [
    t5,
    (0, import_jsx_runtime2.jsx)(Text, { size: 1, muted: true, children: (0, import_jsx_runtime2.jsx)(ComposeSparklesIcon, {}) })
  ] }), $[9] = t6) : t6 = $[9];
  let t7;
  $[10] !== popoverHeading ? (t7 = (0, import_jsx_runtime2.jsx)(Box, { paddingTop: 3, children: (0, import_jsx_runtime2.jsx)(Heading, { size: 1, children: popoverHeading }) }), $[10] = popoverHeading, $[11] = t7) : t7 = $[11];
  let t8;
  $[12] !== popoverDescription ? (t8 = (0, import_jsx_runtime2.jsx)(Box, { paddingTop: 4, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: popoverDescription }) }), $[12] = popoverDescription, $[13] = t8) : t8 = $[13];
  let t9;
  $[14] !== t7 || $[15] !== t8 ? (t9 = (0, import_jsx_runtime2.jsxs)(Flex, { paddingX: 4, paddingBottom: 4, paddingTop: 3, direction: "column", children: [
    t6,
    t7,
    t8
  ] }), $[14] = t7, $[15] = t8, $[16] = t9) : t9 = $[16];
  let t10;
  $[17] !== t2 ? (t10 = t2("canvas.banner.popover-button-text"), $[17] = t2, $[18] = t10) : t10 = $[18];
  let t11;
  $[19] !== t10 ? (t11 = (0, import_jsx_runtime2.jsx)(Flex, { width: "full", gap: 3, justify: "flex-end", paddingX: 4, paddingBottom: 4, children: (0, import_jsx_runtime2.jsx)(Button2, { mode: "bleed", text: t10, autoFocus: true, tone: "primary", href: "https://snty.link/canvas-docs", target: "_blank", rel: "noopener noreferrer", as: "a", iconRight: LaunchIcon }) }), $[19] = t10, $[20] = t11) : t11 = $[20];
  let t12;
  return $[21] !== t11 || $[22] !== t9 ? (t12 = (0, import_jsx_runtime2.jsx)(Card, { radius: 3, overflow: "hidden", width: 0, ref, children: (0, import_jsx_runtime2.jsxs)(Container, { width: 0, children: [
    t4,
    t9,
    t11
  ] }) }), $[21] = t11, $[22] = t9, $[23] = t12) : t12 = $[23], t12;
};
var CanvasLinkedBannerContent = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(21), {
    documentId
  } = t0, {
    t: t2
  } = useTranslation(structureLocaleNamespace), [open, setOpen] = (0, import_react2.useState)(false), documentVariantType = getDocumentVariantType(documentId), {
    isLockedByCanvas
  } = useCanvasCompanionDoc(documentId);
  let t1;
  bb0: {
    if (!isLockedByCanvas) {
      let t23;
      $[0] !== t2 ? (t23 = t2("canvas.banner.editable.linked-text"), $[0] = t2, $[1] = t23) : t23 = $[1], t1 = t23;
      break bb0;
    }
    if (documentVariantType === "published") {
      let t23;
      $[2] !== t2 ? (t23 = t2("canvas.banner.linked-text.published"), $[2] = t2, $[3] = t23) : t23 = $[3], t1 = t23;
      break bb0;
    }
    if (documentVariantType === "draft") {
      let t23;
      $[4] !== t2 ? (t23 = t2("canvas.banner.linked-text.draft"), $[4] = t2, $[5] = t23) : t23 = $[5], t1 = t23;
      break bb0;
    }
    let t222;
    $[6] !== t2 ? (t222 = t2("canvas.banner.linked-text.version"), $[6] = t2, $[7] = t222) : t222 = $[7], t1 = t222;
  }
  const variantText = t1;
  let t22;
  $[8] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t22 = () => setOpen(_temp$C), $[8] = t22) : t22 = $[8];
  const togglePopover = t22;
  let t3;
  $[9] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t3 = () => setOpen(false), $[9] = t3) : t3 = $[9];
  const onClose = t3;
  let t4;
  $[10] !== variantText ? (t4 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: variantText }), $[10] = variantText, $[11] = t4) : t4 = $[11];
  let t5;
  $[12] !== isLockedByCanvas ? (t5 = (0, import_jsx_runtime2.jsx)(CanvasPopoverContent, { onClose, isLockedByCanvas }), $[12] = isLockedByCanvas, $[13] = t5) : t5 = $[13];
  let t6;
  $[14] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t6 = (0, import_jsx_runtime2.jsx)(Button2, { tooltipProps: null, mode: "bleed", tone: "default", icon: InfoOutlineIcon, onClick: togglePopover }), $[14] = t6) : t6 = $[14];
  let t7;
  $[15] !== open || $[16] !== t5 ? (t7 = (0, import_jsx_runtime2.jsx)(Popover2, { open, size: 0, tone: "default", portal: true, placement: "bottom-start", content: t5, children: t6 }), $[15] = open, $[16] = t5, $[17] = t7) : t7 = $[17];
  let t8;
  return $[18] !== t4 || $[19] !== t7 ? (t8 = (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 2, children: [
    t4,
    t7
  ] }), $[18] = t4, $[19] = t7, $[20] = t8) : t8 = $[20], t8;
};
function CanvasLinkedBanner() {
  const $ = (0, import_compiler_runtime2.c)(10), {
    documentId,
    displayed
  } = useDocumentPane(), {
    t: t2
  } = useTranslation(structureLocaleNamespace), id = displayed?._id || documentId, {
    companionDoc
  } = useCanvasCompanionDoc(id), navigateToCanvas = useNavigateToCanvasDoc(companionDoc?.canvasDocumentId, "banner");
  if (!companionDoc)
    return null;
  let t0;
  $[0] !== id ? (t0 = (0, import_jsx_runtime2.jsx)(CanvasLinkedBannerContent, { documentId: id }), $[0] = id, $[1] = t0) : t0 = $[1];
  let t1;
  $[2] !== t2 ? (t1 = t2("canvas.banner.edit-in-canvas-action"), $[2] = t2, $[3] = t1) : t1 = $[3];
  let t22;
  $[4] !== navigateToCanvas || $[5] !== t1 ? (t22 = {
    mode: "ghost",
    text: t1,
    onClick: navigateToCanvas
  }, $[4] = navigateToCanvas, $[5] = t1, $[6] = t22) : t22 = $[6];
  let t3;
  return $[7] !== t0 || $[8] !== t22 ? (t3 = (0, import_jsx_runtime2.jsx)(Banner, { tone: "neutral", "data-test-id": "canvas-linked-banner", paddingY: 0, content: t0, action: t22 }), $[7] = t0, $[8] = t22, $[9] = t3) : t3 = $[9], t3;
}
function _temp$C(prev) {
  return !prev;
}
var ChooseNewDocumentDestinationBanner = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(32), {
    schemaType,
    selectedPerspective,
    reason
  } = t0, {
    t: t2
  } = useTranslation(structureLocaleNamespace), {
    t: tCore
  } = useTranslation(), {
    document: t1
  } = useWorkspace(), {
    drafts: t22
  } = t1, {
    enabled: isDraftModelEnabled
  } = t22;
  let t3;
  $[0] !== isDraftModelEnabled || $[1] !== schemaType ? (t3 = (t42) => {
    const {
      perspective
    } = t42;
    return {
      disabled: !isPerspectiveWriteable({
        selectedPerspective: perspective,
        isDraftModelEnabled,
        schemaType
      }).result
    };
  }, $[0] = isDraftModelEnabled, $[1] = schemaType, $[2] = t3) : t3 = $[2];
  const menuItemProps = t3, releaseDoc = isReleaseDocument(selectedPerspective) ? selectedPerspective : void 0;
  let t4;
  $[3] !== releaseDoc || $[4] !== tCore ? (t4 = releaseDoc ? releaseDoc.metadata.title || tCore("release.placeholder-untitled-release") : void 0, $[3] = releaseDoc, $[4] = tCore, $[5] = t4) : t4 = $[5];
  const releaseTitle = t4;
  let t5;
  $[6] !== reason || $[7] !== t2 ? (t5 = reason === "PUBLISHED_NOT_WRITEABLE" && t2("banners.choose-new-document-destination.cannot-create-published-document"), $[6] = reason, $[7] = t2, $[8] = t5) : t5 = $[8];
  let t6;
  $[9] !== reason || $[10] !== t2 ? (t6 = reason === "DRAFTS_NOT_WRITEABLE" && t2("banners.choose-new-document-destination.cannot-create-draft-document"), $[9] = reason, $[10] = t2, $[11] = t6) : t6 = $[11];
  let t7;
  $[12] !== reason || $[13] !== releaseDoc || $[14] !== releaseTitle || $[15] !== t2 || $[16] !== tCore ? (t7 = reason === "RELEASE_NOT_ACTIVE" && releaseDoc && releaseTitle && (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "banners.choose-new-document-destination.release-inactive", values: {
    title: releaseTitle
  }, components: {
    VersionBadge: (t82) => {
      const {
        children
      } = t82, BadgeWithTone = getVersionInlineBadge(releaseDoc);
      return (0, import_jsx_runtime2.jsx)(ReleaseTitle, { title: releaseDoc.metadata.title, fallback: tCore("release.placeholder-untitled-release"), children: () => (0, import_jsx_runtime2.jsx)(BadgeWithTone, { children }) });
    }
  } }), $[12] = reason, $[13] = releaseDoc, $[14] = releaseTitle, $[15] = t2, $[16] = tCore, $[17] = t7) : t7 = $[17];
  let t8;
  $[18] !== t2 ? (t8 = t2("banners.choose-new-document-destination.choose-destination"), $[18] = t2, $[19] = t8) : t8 = $[19];
  let t9;
  $[20] !== t8 ? (t9 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    " ",
    t8
  ] }), $[20] = t8, $[21] = t9) : t9 = $[21];
  let t10;
  $[22] !== t5 || $[23] !== t6 || $[24] !== t7 || $[25] !== t9 ? (t10 = (0, import_jsx_runtime2.jsxs)(Text, { size: 1, children: [
    t5,
    t6,
    t7,
    t9
  ] }), $[22] = t5, $[23] = t6, $[24] = t7, $[25] = t9, $[26] = t10) : t10 = $[26];
  let t11;
  $[27] !== menuItemProps ? (t11 = (0, import_jsx_runtime2.jsx)(ReleasesNav, { menuItemProps }), $[27] = menuItemProps, $[28] = t11) : t11 = $[28];
  let t12;
  return $[29] !== t10 || $[30] !== t11 ? (t12 = (0, import_jsx_runtime2.jsx)(Banner, { tone: "caution", icon: WarningOutlineIcon, content: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 2, children: [
    t10,
    t11
  ] }) }), $[29] = t10, $[30] = t11, $[31] = t12) : t12 = $[31], t12;
};
function CreateLinkedBanner() {
  const $ = (0, import_compiler_runtime2.c)(5), {
    value
  } = useDocumentPane(), {
    documentLinkedBannerContent: CreateLinkedBannerContent
  } = useSanityCreateConfig().components ?? {};
  let t0;
  $[0] !== value ? (t0 = getSanityCreateLinkMetadata(value), $[0] = value, $[1] = t0) : t0 = $[1];
  const createLinkMetadata = t0;
  if (!CreateLinkedBannerContent || !createLinkMetadata)
    return null;
  let t1;
  return $[2] !== CreateLinkedBannerContent || $[3] !== createLinkMetadata ? (t1 = (0, import_jsx_runtime2.jsx)(Banner, { tone: "transparent", "data-test-id": "sanity-create-read-only-banner", content: (0, import_jsx_runtime2.jsx)(CreateLinkedBannerContent, { metadata: createLinkMetadata }) }), $[2] = CreateLinkedBannerContent, $[3] = createLinkMetadata, $[4] = t1) : t1 = $[4], t1;
}
var TOAST_DELAY = 1e3;
function DocumentNotInReleaseBanner(t0) {
  const $ = (0, import_compiler_runtime2.c)(41), {
    documentId,
    currentRelease,
    isScheduledRelease
  } = t0, t1 = currentRelease ?? LATEST;
  let t2;
  $[0] !== t1 ? (t2 = getReleaseTone(t1), $[0] = t1, $[1] = t2) : t2 = $[1];
  const tone = t2, {
    t: t3
  } = useTranslation(structureLocaleNamespace), {
    t: tCore
  } = useTranslation(), {
    createVersion
  } = useVersionOperations(), isAnonymousBundle = typeof currentRelease == "string";
  let t32;
  $[2] !== currentRelease || $[3] !== isAnonymousBundle || $[4] !== tCore ? (t32 = isAnonymousBundle ? currentRelease : currentRelease?.metadata?.title || tCore("release.placeholder-untitled-release"), $[2] = currentRelease, $[3] = isAnonymousBundle, $[4] = tCore, $[5] = t32) : t32 = $[5];
  const releaseTitle = t32, [versionCreateState, setVersionCreateState] = (0, import_react2.useState)(), toast = useToast();
  let t4;
  $[6] !== createVersion || $[7] !== currentRelease || $[8] !== documentId || $[9] !== isAnonymousBundle || $[10] !== t3 || $[11] !== toast ? (t4 = async () => {
    if (isAnonymousBundle || currentRelease._id) {
      setVersionCreateState({
        status: "creating",
        lastUpdate: /* @__PURE__ */ new Date()
      });
      const bundleId = isAnonymousBundle ? currentRelease : getReleaseIdFromReleaseDocumentId(currentRelease._id);
      try {
        await createVersion(bundleId, documentId), setVersionCreateState({
          status: "created",
          lastUpdate: /* @__PURE__ */ new Date()
        });
      } catch (t52) {
        const err = t52;
        toast.push({
          status: "error",
          closable: true,
          title: t3("banners.release.error.title"),
          description: t3("banners.release.error.description", {
            message: err.message
          })
        }), setVersionCreateState(void 0);
      }
    }
  }, $[6] = createVersion, $[7] = currentRelease, $[8] = documentId, $[9] = isAnonymousBundle, $[10] = t3, $[11] = toast, $[12] = t4) : t4 = $[12];
  const handleAddToRelease = t4, now = useCurrentTime(200), t5 = versionCreateState?.status === "created" && now.getTime() - versionCreateState.lastUpdate.getTime() > TOAST_DELAY;
  let t6;
  $[13] !== t3 ? (t6 = t3("banners.release.waiting.title"), $[13] = t3, $[14] = t6) : t6 = $[14];
  let t7;
  $[15] !== t3 ? (t7 = t3("banners.release.waiting.description"), $[15] = t3, $[16] = t7) : t7 = $[16];
  let t8;
  $[17] !== t5 || $[18] !== t6 || $[19] !== t7 ? (t8 = {
    status: "info",
    id: "add-document-to-release",
    enabled: t5,
    closable: true,
    title: t6,
    description: t7
  }, $[17] = t5, $[18] = t6, $[19] = t7, $[20] = t8) : t8 = $[20], useConditionalToast(t8);
  let t9;
  $[21] !== releaseTitle ? (t9 = {
    title: releaseTitle
  }, $[21] = releaseTitle, $[22] = t9) : t9 = $[22];
  let t10;
  $[23] !== currentRelease || $[24] !== isAnonymousBundle || $[25] !== tCore ? (t10 = {
    VersionBadge: (t112) => {
      const {
        children
      } = t112, BadgeWithTone = getVersionInlineBadge(currentRelease);
      return isAnonymousBundle ? (0, import_jsx_runtime2.jsx)(BadgeWithTone, { children }) : (0, import_jsx_runtime2.jsx)(ReleaseTitle, { title: currentRelease.metadata?.title, fallback: tCore("release.placeholder-untitled-release"), children: () => (0, import_jsx_runtime2.jsx)(BadgeWithTone, { children }) });
    }
  }, $[23] = currentRelease, $[24] = isAnonymousBundle, $[25] = tCore, $[26] = t10) : t10 = $[26];
  let t11;
  $[27] !== t3 || $[28] !== t10 || $[29] !== t9 ? (t11 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(Translate, { i18nKey: "banners.release.not-in-release", t: t3, values: t9, components: t10 }) }), $[27] = t3, $[28] = t10, $[29] = t9, $[30] = t11) : t11 = $[30];
  let t12;
  $[31] !== handleAddToRelease || $[32] !== isScheduledRelease || $[33] !== t3 || $[34] !== tone || $[35] !== versionCreateState ? (t12 = isScheduledRelease ? void 0 : {
    text: t3("banners.release.action.add-to-release"),
    tone,
    disabled: !!versionCreateState,
    onClick: handleAddToRelease,
    mode: "default"
  }, $[31] = handleAddToRelease, $[32] = isScheduledRelease, $[33] = t3, $[34] = tone, $[35] = versionCreateState, $[36] = t12) : t12 = $[36];
  let t13;
  return $[37] !== t11 || $[38] !== t12 || $[39] !== tone ? (t13 = (0, import_jsx_runtime2.jsx)(Banner, { tone, content: t11, action: t12 }), $[37] = t11, $[38] = t12, $[39] = tone, $[40] = t13) : t13 = $[40], t13;
}
function useCurrentTime(updateIntervalMs) {
  const $ = (0, import_compiler_runtime2.c)(4);
  let t0;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = /* @__PURE__ */ new Date(), $[0] = t0) : t0 = $[0];
  const [currentTime, setCurrentTime] = (0, import_react2.useState)(t0);
  let t1, t2;
  return $[1] !== updateIntervalMs ? (t1 = () => {
    const intervalId = setInterval(() => {
      setCurrentTime(/* @__PURE__ */ new Date());
    }, updateIntervalMs);
    return () => clearInterval(intervalId);
  }, t2 = [updateIntervalMs], $[1] = updateIntervalMs, $[2] = t1, $[3] = t2) : (t1 = $[2], t2 = $[3]), (0, import_react2.useEffect)(t1, t2), currentTime;
}
var ResolvedLiveEdit = defineEvent({
  name: "LiveEdit Draft Resolved",
  version: 1,
  description: "User resolved a draft of a live edit document to continue editing"
});
var ObsoleteDraftBanner = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(47), {
    displayed,
    documentId,
    schemaType,
    i18nKey,
    isEditBlocking
  } = t0, {
    t: t2
  } = useTranslation(structureLocaleNamespace), [isPublishing, setPublishing] = (0, import_react2.useState)(false), [isDiscarding, setDiscarding] = (0, import_react2.useState)(false), telemetry = useTelemetry(), {
    publish,
    discardChanges
  } = useDocumentOperation(documentId, displayed?._type || "");
  let t1;
  $[0] !== publish || $[1] !== telemetry ? (t1 = () => {
    publish.execute(), setPublishing(true), telemetry.log(ResolvedLiveEdit, {
      liveEditResolveType: "publish"
    });
  }, $[0] = publish, $[1] = telemetry, $[2] = t1) : t1 = $[2];
  const handlePublish = t1;
  let t22;
  $[3] !== discardChanges || $[4] !== telemetry ? (t22 = () => {
    discardChanges.execute(), setDiscarding(true), telemetry.log(ResolvedLiveEdit, {
      liveEditResolveType: "discard"
    });
  }, $[3] = discardChanges, $[4] = telemetry, $[5] = t22) : t22 = $[5];
  const handleDiscard = t22;
  let t3;
  $[6] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t3 = () => () => {
    setPublishing(false), setDiscarding(false);
  }, $[6] = t3) : t3 = $[6], (0, import_react2.useEffect)(t3);
  const diffViewRouter = useDiffViewRouter();
  let t4;
  $[7] !== diffViewRouter || $[8] !== displayed?._id || $[9] !== schemaType.name ? (t4 = () => {
    typeof displayed?._id > "u" || diffViewRouter.navigateDiffView({
      mode: "version",
      previousDocument: {
        type: schemaType.name,
        id: getPublishedId(displayed?._id)
      },
      nextDocument: {
        type: schemaType.name,
        id: getDraftId(displayed?._id)
      }
    });
  }, $[7] = diffViewRouter, $[8] = displayed?._id, $[9] = schemaType.name, $[10] = t4) : t4 = $[10];
  const compareDraft = t4;
  let t5;
  $[11] !== schemaType.title ? (t5 = {
    schemaType: schemaType.title
  }, $[11] = schemaType.title, $[12] = t5) : t5 = $[12];
  let t6;
  $[13] !== i18nKey || $[14] !== t2 || $[15] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey, values: t5 }) }), $[13] = i18nKey, $[14] = t2, $[15] = t5, $[16] = t6) : t6 = $[16];
  let t7;
  $[17] !== t2 ? (t7 = t2("banners.obsolete-draft.actions.compare-draft.text"), $[17] = t2, $[18] = t7) : t7 = $[18];
  let t8;
  $[19] !== compareDraft || $[20] !== t7 ? (t8 = (0, import_jsx_runtime2.jsx)(Button2, { text: t7, mode: "ghost", onClick: compareDraft }), $[19] = compareDraft, $[20] = t7, $[21] = t8) : t8 = $[21];
  let t9;
  $[22] !== t2 ? (t9 = t2("banners.obsolete-draft.actions.publish-draft.text"), $[22] = t2, $[23] = t9) : t9 = $[23];
  let t10;
  $[24] !== isEditBlocking || $[25] !== t2 ? (t10 = isEditBlocking ? {
    content: t2("banners.live-edit-draft-banner.publish.tooltip")
  } : {}, $[24] = isEditBlocking, $[25] = t2, $[26] = t10) : t10 = $[26];
  let t11;
  $[27] !== handlePublish || $[28] !== isPublishing || $[29] !== t10 || $[30] !== t9 ? (t11 = (0, import_jsx_runtime2.jsx)(Button2, { onClick: handlePublish, text: t9, tooltipProps: t10, loading: isPublishing, tone: "positive" }), $[27] = handlePublish, $[28] = isPublishing, $[29] = t10, $[30] = t9, $[31] = t11) : t11 = $[31];
  let t12;
  $[32] !== t2 ? (t12 = t2("banners.obsolete-draft.actions.discard-draft.text"), $[32] = t2, $[33] = t12) : t12 = $[33];
  let t13;
  $[34] !== isEditBlocking || $[35] !== t2 ? (t13 = isEditBlocking ? {
    content: t2("banners.live-edit-draft-banner.discard.tooltip")
  } : {}, $[34] = isEditBlocking, $[35] = t2, $[36] = t13) : t13 = $[36];
  let t14;
  $[37] !== handleDiscard || $[38] !== isDiscarding || $[39] !== t12 || $[40] !== t13 ? (t14 = (0, import_jsx_runtime2.jsx)(Button2, { onClick: handleDiscard, text: t12, tooltipProps: t13, loading: isDiscarding, tone: "caution" }), $[37] = handleDiscard, $[38] = isDiscarding, $[39] = t12, $[40] = t13, $[41] = t14) : t14 = $[41];
  let t15;
  return $[42] !== t11 || $[43] !== t14 || $[44] !== t6 || $[45] !== t8 ? (t15 = (0, import_jsx_runtime2.jsx)(Banner, { content: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", justify: "space-between", gap: 2, children: [
    t6,
    t8,
    t11,
    t14
  ] }), "data-testid": "live-edit-type-banner", icon: ErrorOutlineIcon }), $[42] = t11, $[43] = t14, $[44] = t6, $[45] = t8, $[46] = t15) : t15 = $[46], t15;
};
function OpenReleaseToEditBanner(t0) {
  const $ = (0, import_compiler_runtime2.c)(4), {
    documentId,
    isPinnedDraftOrPublished
  } = t0;
  let t1;
  $[0] !== documentId ? (t1 = {
    documentId
  }, $[0] = documentId, $[1] = t1) : t1 = $[1];
  const onlyHasVersions = useOnlyHasVersions(t1);
  if (!isVersionId(documentId) || !onlyHasVersions || !isPinnedDraftOrPublished)
    return null;
  let t2;
  return $[2] !== documentId ? (t2 = (0, import_jsx_runtime2.jsx)(OpenReleaseToEditBannerInner, { documentId }), $[2] = documentId, $[3] = t2) : t2 = $[3], t2;
}
function OpenReleaseToEditBannerInner(t0) {
  const $ = (0, import_compiler_runtime2.c)(37), {
    documentId
  } = t0, {
    data: activeReleases
  } = useActiveReleases(), setPerspective = useSetPerspective();
  let t1;
  $[0] !== documentId ? (t1 = getVersionFromId(documentId) ?? "", $[0] = documentId, $[1] = t1) : t1 = $[1];
  const releaseId = t1;
  let t2;
  if ($[2] !== activeReleases || $[3] !== releaseId) {
    let t32;
    $[5] !== releaseId ? (t32 = (version) => version._id.includes(releaseId), $[5] = releaseId, $[6] = t32) : t32 = $[6], t2 = activeReleases.find(t32), $[2] = activeReleases, $[3] = releaseId, $[4] = t2;
  } else
    t2 = $[4];
  const currentVersion = t2, {
    t: tCore
  } = useTranslation();
  let t3;
  $[7] !== documentId ? (t3 = {
    documentId
  }, $[7] = documentId, $[8] = t3) : t3 = $[8];
  const {
    data: documentVersions
  } = useDocumentVersions(t3);
  let t4;
  if ($[9] !== activeReleases || $[10] !== documentVersions) {
    let t52;
    $[12] !== documentVersions ? (t52 = (version_0) => documentVersions.find((release) => {
      const r2 = getVersionFromId(release) ?? "";
      return getReleaseIdFromReleaseDocumentId(version_0._id) === r2;
    }) && !isCardinalityOneRelease(version_0), $[12] = documentVersions, $[13] = t52) : t52 = $[13], t4 = activeReleases.filter(t52), $[9] = activeReleases, $[10] = documentVersions, $[11] = t4;
  } else
    t4 = $[11];
  const documentVersionReleases = t4;
  let t5;
  $[14] !== currentVersion ? (t5 = currentVersion && getReleaseTone(currentVersion), $[14] = currentVersion, $[15] = t5) : t5 = $[15];
  const tone = t5, {
    t: t6
  } = useTranslation(structureLocaleNamespace);
  let t62;
  $[16] !== releaseId || $[17] !== setPerspective ? (t62 = async () => {
    setPerspective(releaseId);
  }, $[16] = releaseId, $[17] = setPerspective, $[18] = t62) : t62 = $[18];
  const handleGoToEdit = t62;
  if (documentVersionReleases.length === 0)
    return null;
  const firstRelease = documentVersionReleases[0];
  let t7;
  $[19] !== tCore ? (t7 = tCore("release.placeholder-untitled-release"), $[19] = tCore, $[20] = t7) : t7 = $[20];
  const fallback = t7;
  let t8;
  $[21] !== documentVersionReleases.length || $[22] !== t6 ? (t8 = (t92) => {
    const {
      displayTitle
    } = t92;
    return documentVersionReleases.length > 1 ? (0, import_jsx_runtime2.jsx)(Translate, { t: t6, i18nKey: "banners.release.navigate-to-edit-description-multiple", components: {
      VersionBadge: () => (0, import_jsx_runtime2.jsx)(VersionInlineBadge, { children: displayTitle })
    }, values: {
      count: documentVersionReleases.length - 1
    } }) : (0, import_jsx_runtime2.jsx)(Translate, { t: t6, i18nKey: "banners.release.navigate-to-edit-description-single", components: {
      VersionBadge: () => (0, import_jsx_runtime2.jsx)(VersionInlineBadge, { children: displayTitle })
    } });
  }, $[21] = documentVersionReleases.length, $[22] = t6, $[23] = t8) : t8 = $[23];
  let t9;
  $[24] !== fallback || $[25] !== firstRelease.metadata.title || $[26] !== t8 ? (t9 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(Flex, { direction: "row", gap: 1, wrap: "wrap", children: (0, import_jsx_runtime2.jsx)(ReleaseTitle, { title: firstRelease.metadata.title, fallback, children: t8 }) }) }), $[24] = fallback, $[25] = firstRelease.metadata.title, $[26] = t8, $[27] = t9) : t9 = $[27];
  let t10;
  $[28] !== documentVersionReleases.length || $[29] !== handleGoToEdit || $[30] !== t6 || $[31] !== tone ? (t10 = documentVersionReleases.length > 0 ? {
    text: t6("banners.release.action.open-to-edit"),
    tone,
    onClick: handleGoToEdit,
    mode: "default"
  } : void 0, $[28] = documentVersionReleases.length, $[29] = handleGoToEdit, $[30] = t6, $[31] = tone, $[32] = t10) : t10 = $[32];
  let t11;
  return $[33] !== t10 || $[34] !== t9 || $[35] !== tone ? (t11 = (0, import_jsx_runtime2.jsx)(Banner, { tone, "data-testid": "open-release-to-edit-banner", content: t9, action: t10 }), $[33] = t10, $[34] = t9, $[35] = tone, $[36] = t11) : t11 = $[36], t11;
}
function PausedScheduledDraftBanner() {
  const $ = (0, import_compiler_runtime2.c)(2), {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t0;
  return $[0] !== t2 ? (t0 = (0, import_jsx_runtime2.jsx)(Banner, { tone: "caution", icon: PauseIcon, content: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "banners.paused-scheduled-draft.text" }) }) }), $[0] = t2, $[1] = t0) : t0 = $[1], t0;
}
function RevisionNotFoundBanner() {
  const $ = (0, import_compiler_runtime2.c)(4), {
    revisionNotFound
  } = useDocumentPane(), {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  if (!revisionNotFound)
    return null;
  let t0;
  $[0] !== t2 ? (t0 = t2("banners.revision-not-found.description"), $[0] = t2, $[1] = t0) : t0 = $[1];
  let t1;
  return $[2] !== t0 ? (t1 = (0, import_jsx_runtime2.jsx)(Banner, { tone: "caution", "data-test-id": "revision-not-found-banner", icon: WarningOutlineIcon, content: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: t0 }) }), $[2] = t0, $[3] = t1) : t1 = $[3], t1;
}
function ScheduledReleaseBanner(t0) {
  const $ = (0, import_compiler_runtime2.c)(12), {
    currentRelease
  } = t0, t1 = currentRelease ?? LATEST;
  let t2;
  $[0] !== t1 ? (t2 = getReleaseTone(t1), $[0] = t1, $[1] = t2) : t2 = $[1];
  const tone = t2, {
    t: tCore
  } = useTranslation();
  let t3;
  $[2] !== currentRelease ? (t3 = formatRelativeLocalePublishDate(currentRelease), $[2] = currentRelease, $[3] = t3) : t3 = $[3];
  let t4;
  $[4] !== t3 ? (t4 = {
    date: t3
  }, $[4] = t3, $[5] = t4) : t4 = $[5];
  let t5;
  $[6] !== t4 || $[7] !== tCore ? (t5 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(Translate, { t: tCore, i18nKey: "release.banner.scheduled-for-publishing-on", values: t4 }) }), $[6] = t4, $[7] = tCore, $[8] = t5) : t5 = $[8];
  let t6;
  return $[9] !== t5 || $[10] !== tone ? (t6 = (0, import_jsx_runtime2.jsx)(Banner, { tone, icon: LockIcon, content: t5 }), $[9] = t5, $[10] = tone, $[11] = t6) : t6 = $[11], t6;
}
function UnpublishedDocumentBanner() {
  const $ = (0, import_compiler_runtime2.c)(17), {
    value,
    editState
  } = useDocumentPane(), {
    selectedPerspective
  } = usePerspective(), isCurrentVersionGoingToUnpublish = isGoingToUnpublish(value) || editState?.version && isGoingToUnpublish(editState?.version), {
    t: t2
  } = useTranslation(structureLocaleNamespace), {
    t: tCore
  } = useTranslation();
  if (isReleaseDocument(selectedPerspective) && isCurrentVersionGoingToUnpublish) {
    let t0;
    $[0] !== selectedPerspective.metadata?.title || $[1] !== tCore ? (t0 = selectedPerspective.metadata?.title || tCore("release.placeholder-untitled-release"), $[0] = selectedPerspective.metadata?.title, $[1] = tCore, $[2] = t0) : t0 = $[2];
    const releaseTitle = t0;
    let t1;
    $[3] !== releaseTitle ? (t1 = {
      title: releaseTitle
    }, $[3] = releaseTitle, $[4] = t1) : t1 = $[4];
    let t22;
    $[5] !== selectedPerspective || $[6] !== tCore ? (t22 = {
      VersionBadge: (t32) => {
        const {
          children
        } = t32, BadgeWithTone = getVersionInlineBadge(selectedPerspective);
        return (0, import_jsx_runtime2.jsx)(ReleaseTitle, { title: selectedPerspective.metadata?.title, fallback: tCore("release.placeholder-untitled-release"), children: () => (0, import_jsx_runtime2.jsx)(BadgeWithTone, { children }) });
      }
    }, $[5] = selectedPerspective, $[6] = tCore, $[7] = t22) : t22 = $[7];
    let t3;
    $[8] !== t2 || $[9] !== t1 || $[10] !== t22 ? (t3 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "banners.unpublished-release-banner.text", values: t1, components: t22 }) }), $[8] = t2, $[9] = t1, $[10] = t22, $[11] = t3) : t3 = $[11];
    let t4;
    $[12] !== t2 ? (t4 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "banners.unpublished-release-banner.text-with-published" }) }), $[12] = t2, $[13] = t4) : t4 = $[13];
    let t5;
    return $[14] !== t3 || $[15] !== t4 ? (t5 = (0, import_jsx_runtime2.jsx)(Banner, { tone: "critical", content: (0, import_jsx_runtime2.jsxs)(Stack, { space: 2, children: [
      t3,
      t4
    ] }), icon: UnpublishIcon }), $[14] = t3, $[15] = t4, $[16] = t5) : t5 = $[16], t5;
  }
  return null;
}
var TitleContainer = at(Stack).withConfig({
  displayName: "TitleContainer",
  componentId: "sc-e3cjxp-0"
})`${({
  theme
}) => rt`
      @supports not (container-type: inline-size) {
        display: none !important;
      }

      container-type: inline-size;

      [data-heading] {
        font-size: ${theme.sanity.fonts.heading.sizes[4].fontSize}px;
        line-height: ${theme.sanity.fonts.heading.sizes[4].lineHeight}px;
        overflow-wrap: break-word;
        text-wrap: pretty;
      }

      @container (max-width: 560px) {
        [data-heading] {
          font-size: ${theme.sanity.fonts.heading.sizes[3].fontSize}px;
          line-height: ${theme.sanity.fonts.heading.sizes[3].lineHeight}px;
        }
      }

      @container (max-width: 420px) {
        [data-heading] {
          font-size: ${theme.sanity.fonts.heading.sizes[2].fontSize}px;
          line-height: ${theme.sanity.fonts.heading.sizes[2].lineHeight}px;
        }
      }
    `}`;
var FormHeader = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(14), {
    documentId,
    schemaType,
    title
  } = t0, isSingleton = documentId === schemaType.name, description = schemaType.description, {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  if (schemaType.__experimental_formPreviewTitle === false)
    return null;
  let t1;
  $[0] !== description || $[1] !== isSingleton || $[2] !== schemaType.name || $[3] !== schemaType.title ? (t1 = !isSingleton && (0, import_jsx_runtime2.jsxs)(Inline, { space: 1, children: [
    (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: schemaType.title ?? schemaType.name }),
    description && (0, import_jsx_runtime2.jsx)(Tooltip, { content: description, placement: "right", children: (0, import_jsx_runtime2.jsx)(InfoOutlineIcon, { "data-testid": "schema-description-icon" }) })
  ] }), $[0] = description, $[1] = isSingleton, $[2] = schemaType.name, $[3] = schemaType.title, $[4] = t1) : t1 = $[4];
  const t22 = !title;
  let t3;
  $[5] !== t2 || $[6] !== title ? (t3 = title ?? t2("document-view.form-view.form-title-fallback"), $[5] = t2, $[6] = title, $[7] = t3) : t3 = $[7];
  let t4;
  $[8] !== t22 || $[9] !== t3 ? (t4 = (0, import_jsx_runtime2.jsx)(Heading, { as: "h2", "data-heading": true, muted: t22, "data-testid": "document-panel-document-title", children: t3 }), $[8] = t22, $[9] = t3, $[10] = t4) : t4 = $[10];
  let t5;
  return $[11] !== t1 || $[12] !== t4 ? (t5 = (0, import_jsx_runtime2.jsxs)(TitleContainer, { marginBottom: 6, space: 4, children: [
    t1,
    t4
  ] }), $[11] = t1, $[12] = t4, $[13] = t5) : t5 = $[13], t5;
};
var preventDefault = (ev) => ev.preventDefault();
var FormView = (0, import_react2.forwardRef)(function(props, ref) {
  const $ = (0, import_compiler_runtime2.c)(77), {
    hidden,
    margins
  } = props, {
    collapsedFieldSets,
    collapsedPaths,
    displayed: value,
    editState,
    documentId,
    documentType,
    fieldActions,
    onChange,
    validation,
    ready,
    formState,
    onFocus,
    connectionState,
    onBlur,
    onSetCollapsedPath,
    onPathOpen,
    onSetCollapsedFieldSet,
    onSetActiveFieldGroup,
    openPath,
    compareValue,
    hasUpstreamVersion
  } = useDocumentPane(), {
    selectedReleaseId,
    selectedPerspective
  } = usePerspective(), documentStore = useDocumentStore(), presence = useDocumentPresence(documentId), {
    title
  } = useDocumentTitle(), [patchChannel] = (0, import_react2.useState)(_temp$B), isLocked = editState?.transactionSyncLock?.enabled, {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t0;
  $[0] !== t2 ? (t0 = t2("document-view.form-view.sync-lock-toast.title"), $[0] = t2, $[1] = t0) : t0 = $[1];
  let t1;
  $[2] !== t2 ? (t1 = t2("document-view.form-view.sync-lock-toast.description"), $[2] = t2, $[3] = t1) : t1 = $[3];
  let t22;
  $[4] !== isLocked || $[5] !== t0 || $[6] !== t1 ? (t22 = {
    id: "sync-lock",
    status: "warning",
    enabled: isLocked,
    title: t0,
    description: t1,
    closable: true
  }, $[4] = isLocked, $[5] = t0, $[6] = t1, $[7] = t22) : t22 = $[7], useConditionalToast(t22);
  let t3;
  $[8] !== documentId || $[9] !== documentStore.pair || $[10] !== documentType || $[11] !== patchChannel || $[12] !== selectedReleaseId ? (t3 = () => {
    const sub = documentStore.pair.documentEvents(documentId, documentType, selectedReleaseId).pipe(tap((event) => {
      event.type === "mutation" && patchChannel.publish(prepareMutationEvent(event)), event.type === "rebase" && patchChannel.publish(prepareRebaseEvent(event));
    })).subscribe();
    return () => {
      sub.unsubscribe();
    };
  }, $[8] = documentId, $[9] = documentStore.pair, $[10] = documentType, $[11] = patchChannel, $[12] = selectedReleaseId, $[13] = t3) : t3 = $[13];
  let t4;
  $[14] !== documentId || $[15] !== documentStore || $[16] !== documentType || $[17] !== patchChannel || $[18] !== selectedReleaseId ? (t4 = [documentId, documentStore, documentType, patchChannel, selectedReleaseId], $[14] = documentId, $[15] = documentStore, $[16] = documentType, $[17] = patchChannel, $[18] = selectedReleaseId, $[19] = t4) : t4 = $[19], (0, import_react2.useEffect)(t3, t4);
  const hasRev = !!value?._rev;
  let t5;
  $[20] !== patchChannel || $[21] !== value ? (t5 = () => {
    patchChannel.publish({
      type: "mutation",
      patches: [],
      snapshot: value
    });
  }, $[20] = patchChannel, $[21] = value, $[22] = t5) : t5 = $[22];
  const handleInitialValue = (0, import_react2.useEffectEvent)(t5);
  let t6;
  $[23] !== handleInitialValue || $[24] !== hasRev ? (t6 = () => {
    hasRev && handleInitialValue();
  }, $[23] = handleInitialValue, $[24] = hasRev, $[25] = t6) : t6 = $[25];
  let t7;
  $[26] !== hasRev ? (t7 = [hasRev], $[26] = hasRev, $[27] = t7) : t7 = $[27], (0, import_react2.useEffect)(t6, t7);
  const [formRef, setFormRef] = (0, import_react2.useState)(null), [focusedFirstDescendant, setFocusedFirstDescendant] = (0, import_react2.useState)(false);
  let t8;
  $[28] !== focusedFirstDescendant || $[29] !== formRef || $[30] !== formState?.focusPath.length || $[31] !== ready ? (t8 = () => {
    !focusedFirstDescendant && ready && !formState?.focusPath.length && formRef && (setFocusedFirstDescendant(true), focusFirstDescendant(formRef));
  }, $[28] = focusedFirstDescendant, $[29] = formRef, $[30] = formState?.focusPath.length, $[31] = ready, $[32] = t8) : t8 = $[32];
  const t9 = formState?.focusPath.length;
  let t10;
  $[33] !== focusedFirstDescendant || $[34] !== formRef || $[35] !== ready || $[36] !== t9 ? (t10 = [focusedFirstDescendant, formRef, t9, ready], $[33] = focusedFirstDescendant, $[34] = formRef, $[35] = ready, $[36] = t9, $[37] = t10) : t10 = $[37], (0, import_react2.useEffect)(t8, t10);
  let t11;
  $[38] !== ref ? (t11 = (node) => {
    setFormRef(node), typeof ref == "function" ? ref(node) : ref && (ref.current = node);
  }, $[38] = ref, $[39] = t11) : t11 = $[39];
  const setRef = t11, isReadOnly = connectionState === "reconnecting" || formState?.readOnly || !editState?.ready, t12 = isReadOnly ? "true" : void 0;
  let t13;
  $[40] !== collapsedFieldSets || $[41] !== collapsedPaths || $[42] !== compareValue || $[43] !== connectionState || $[44] !== documentId || $[45] !== editState?.draft || $[46] !== editState?.published || $[47] !== fieldActions || $[48] !== formState || $[49] !== hasUpstreamVersion || $[50] !== hidden || $[51] !== isReadOnly || $[52] !== onBlur || $[53] !== onChange || $[54] !== onFocus || $[55] !== onPathOpen || $[56] !== onSetActiveFieldGroup || $[57] !== onSetCollapsedFieldSet || $[58] !== onSetCollapsedPath || $[59] !== openPath || $[60] !== patchChannel || $[61] !== presence || $[62] !== selectedPerspective || $[63] !== t2 || $[64] !== title || $[65] !== validation ? (t13 = connectionState === "connecting" && !editState?.draft && !editState?.published ? (0, import_jsx_runtime2.jsx)(Delay, { ms: 300, children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: [
    (0, import_jsx_runtime2.jsx)(Spinner, { muted: true }),
    (0, import_jsx_runtime2.jsx)(Box, { marginTop: 3, children: (0, import_jsx_runtime2.jsx)(Text, { align: "center", muted: true, size: 1, children: t2("document-view.form-view.loading") }) })
  ] }) }) : formState === null || hidden ? (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsx)(Text, { children: t2("document-view.form-view.form-hidden") }) }) : (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    (0, import_jsx_runtime2.jsx)(FormHeader, { documentId, schemaType: formState.schemaType, title }),
    (0, import_jsx_runtime2.jsx)(FormBuilder, { __internal_fieldActions: fieldActions, __internal_patchChannel: patchChannel, changed: formState.changed, collapsedFieldSets, collapsedPaths, compareValue: compareValue ?? void 0, focused: formState.focused, focusPath: formState.focusPath, groups: formState.groups, id: "root", members: formState.members, onChange, onFieldGroupSelect: onSetActiveFieldGroup, onPathBlur: onBlur, onPathFocus: onFocus, onPathOpen, onSetFieldSetCollapsed: onSetCollapsedFieldSet, onSetPathCollapsed: onSetCollapsedPath, openPath, perspective: selectedPerspective, hasUpstreamVersion, presence, readOnly: isReadOnly, schemaType: formState.schemaType, validation, value: formState.value })
  ] }), $[40] = collapsedFieldSets, $[41] = collapsedPaths, $[42] = compareValue, $[43] = connectionState, $[44] = documentId, $[45] = editState?.draft, $[46] = editState?.published, $[47] = fieldActions, $[48] = formState, $[49] = hasUpstreamVersion, $[50] = hidden, $[51] = isReadOnly, $[52] = onBlur, $[53] = onChange, $[54] = onFocus, $[55] = onPathOpen, $[56] = onSetActiveFieldGroup, $[57] = onSetCollapsedFieldSet, $[58] = onSetCollapsedPath, $[59] = openPath, $[60] = patchChannel, $[61] = presence, $[62] = selectedPerspective, $[63] = t2, $[64] = title, $[65] = validation, $[66] = t13) : t13 = $[66];
  let t14;
  $[67] !== setRef || $[68] !== t12 || $[69] !== t13 ? (t14 = (0, import_jsx_runtime2.jsx)(Box, { as: "form", onSubmit: preventDefault, ref: setRef, "data-testid": "form-view", "data-read-only": t12, children: t13 }), $[67] = setRef, $[68] = t12, $[69] = t13, $[70] = t14) : t14 = $[70];
  let t15;
  $[71] !== margins || $[72] !== t14 ? (t15 = (0, import_jsx_runtime2.jsx)(PresenceOverlay, { margins, children: t14 }), $[71] = margins, $[72] = t14, $[73] = t15) : t15 = $[73];
  let t16;
  return $[74] !== hidden || $[75] !== t15 ? (t16 = (0, import_jsx_runtime2.jsx)(Container, { hidden, paddingX: 4, paddingTop: 5, paddingBottom: 9, sizing: "border", width: 1, children: t15 }), $[74] = hidden, $[75] = t15, $[76] = t16) : t16 = $[76], t16;
});
function prepareMutationEvent(event) {
  const patches = event.mutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "mutation",
    snapshot: event.document,
    patches: fromMutationPatches(event.origin, patches)
  };
}
function prepareRebaseEvent(event) {
  const remotePatches = event.remoteMutations.map((mut) => mut.patch).filter(Boolean), localPatches = event.localMutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "rebase",
    snapshot: event.document,
    patches: fromMutationPatches("remote", remotePatches).concat(fromMutationPatches("local", localPatches))
  };
}
function _temp$B() {
  return createPatchChannel();
}
function DocumentHeaderTabs() {
  const $ = (0, import_compiler_runtime2.c)(11), {
    activeViewId,
    paneKey,
    views: views2
  } = useDocumentPane(), tabPanelId = `${paneKey}tabpanel`;
  let t0;
  if ($[0] !== activeViewId || $[1] !== paneKey || $[2] !== tabPanelId || $[3] !== views2) {
    let t12;
    $[5] !== activeViewId || $[6] !== paneKey || $[7] !== tabPanelId ? (t12 = (view, index) => (0, import_jsx_runtime2.jsx)(DocumentHeaderTab, { icon: view.icon, id: `${paneKey}tab-${view.id}`, isActive: activeViewId === view.id, label: view.title, tabPanelId, viewId: index === 0 ? null : view.id ?? null }, view.id), $[5] = activeViewId, $[6] = paneKey, $[7] = tabPanelId, $[8] = t12) : t12 = $[8], t0 = views2.map(t12), $[0] = activeViewId, $[1] = paneKey, $[2] = tabPanelId, $[3] = views2, $[4] = t0;
  } else
    t0 = $[4];
  let t1;
  return $[9] !== t0 ? (t1 = (0, import_jsx_runtime2.jsx)(TabList, { space: 1, children: t0 }), $[9] = t0, $[10] = t1) : t1 = $[10], t1;
}
function DocumentHeaderTab(props) {
  const $ = (0, import_compiler_runtime2.c)(20);
  let icon, id, isActive, label, rest, tabPanelId, viewId;
  $[0] !== props ? ({
    icon,
    id,
    isActive,
    label,
    tabPanelId,
    viewId,
    ...rest
  } = props, $[0] = props, $[1] = icon, $[2] = id, $[3] = isActive, $[4] = label, $[5] = rest, $[6] = tabPanelId, $[7] = viewId) : (icon = $[1], id = $[2], isActive = $[3], label = $[4], rest = $[5], tabPanelId = $[6], viewId = $[7]);
  const {
    ready,
    editState
  } = useDocumentPane(), {
    setView
  } = usePaneRouter();
  let t0;
  $[8] !== setView || $[9] !== viewId ? (t0 = () => setView(viewId), $[8] = setView, $[9] = viewId, $[10] = t0) : t0 = $[10];
  const handleClick = t0, t1 = !ready && !editState?.draft && !editState?.published;
  let t2;
  return $[11] !== handleClick || $[12] !== icon || $[13] !== id || $[14] !== isActive || $[15] !== label || $[16] !== rest || $[17] !== t1 || $[18] !== tabPanelId ? (t2 = (0, import_jsx_runtime2.jsx)(Tab, { ...rest, "aria-controls": tabPanelId, disabled: t1, icon, id, label, onClick: handleClick, selected: isActive }), $[11] = handleClick, $[12] = icon, $[13] = id, $[14] = isActive, $[15] = label, $[16] = rest, $[17] = t1, $[18] = tabPanelId, $[19] = t2) : t2 = $[19], t2;
}
var DEFAULT_VALUE = {
  paneDataItems: [],
  routerPanes: [],
  resolvedPanes: [],
  maximizedPane: null,
  setMaximizedPane: () => {
  }
};
function useResolvedPanesList() {
  return (0, import_react2.useContext)(ResolvedPanesContext) ?? DEFAULT_VALUE;
}
var _DEBUG = false;
var EMPTY_PARAMS$1 = Object.freeze({});
var LOADING_PANE = /* @__PURE__ */ Symbol("LOADING_PANE");
var DOCUMENT_PANEL_PORTAL_ELEMENT = "documentPanelPortalElement";
var FocusDocumentPaneClicked = defineEvent({
  name: "Maximized Document Pane Clicked",
  version: 1,
  description: "User pressed to maximize a document by click the focus pane button"
});
var FocusDocumentPaneCollapsed = defineEvent({
  name: "Maximized Document Pane Collapsed",
  version: 1,
  description: "User disabled the maximization on a document pane by clicking the focus pane button"
});
var FocusDocumentPaneNavigated = defineEvent({
  name: "Maximized Document Pane Navigated Via Breadcrumbs",
  version: 1,
  description: "User navigated to a different document pane via the breadcrumbs in the document header"
});
function DocumentHeaderBreadcrumbItem(t0) {
  const $ = (0, import_compiler_runtime2.c)(27), {
    paneData,
    index
  } = t0, {
    pane: pane2
  } = paneData, router2 = useRouter(), {
    t: t2
  } = useTranslation(structureLocaleNamespace), routerState = useRouterState(), telemetry = useTelemetry();
  let t1;
  $[0] !== routerState?.panes ? (t1 = routerState?.panes || [], $[0] = routerState?.panes, $[1] = t1) : t1 = $[1];
  const routerPanes = t1, {
    perspectiveStack
  } = usePerspective(), staticTitle = pane2 !== LOADING_PANE && "title" in pane2 ? pane2.title : null, documentId = pane2 !== LOADING_PANE && pane2.type === "document" ? pane2.options.id : null, documentType = pane2 !== LOADING_PANE && pane2.type === "document" ? pane2.options.type : null, t22 = documentId ?? "", t3 = documentType ?? "";
  let t4;
  $[2] !== perspectiveStack || $[3] !== t22 || $[4] !== t3 ? (t4 = {
    documentId: t22,
    documentType: t3,
    perspectiveStack
  }, $[2] = perspectiveStack, $[3] = t22, $[4] = t3, $[5] = t4) : t4 = $[5];
  const {
    value: previewValue,
    isLoading
  } = useDocumentPreviewValues(t4);
  let t5;
  bb0: {
    if (documentId && !isLoading) {
      let t62;
      $[6] !== previewValue?.title || $[7] !== t2 ? (t62 = previewValue?.title || t2("panes.document-header-title.untitled.text"), $[6] = previewValue?.title, $[7] = t2, $[8] = t62) : t62 = $[8], t5 = t62;
      break bb0;
    }
    t5 = staticTitle;
  }
  const displayTitle = t5;
  let t6;
  $[9] !== paneData.groupIndex || $[10] !== router2 || $[11] !== routerPanes || $[12] !== telemetry ? (t6 = () => {
    telemetry.log(FocusDocumentPaneNavigated), router2.navigate({
      panes: routerPanes.slice(0, paneData.groupIndex)
    });
  }, $[9] = paneData.groupIndex, $[10] = router2, $[11] = routerPanes, $[12] = telemetry, $[13] = t6) : t6 = $[13];
  const handleClick = t6;
  if (!displayTitle && !isLoading)
    return null;
  let t7;
  $[14] !== displayTitle || $[15] !== t2 ? (t7 = displayTitle || t2("panes.document-header-title.untitled.text"), $[14] = displayTitle, $[15] = t2, $[16] = t7) : t7 = $[16];
  let t8;
  $[17] !== displayTitle || $[18] !== t2 ? (t8 = displayTitle || t2("panes.document-header-title.untitled.text"), $[17] = displayTitle, $[18] = t2, $[19] = t8) : t8 = $[19];
  let t9;
  $[20] !== t8 ? (t9 = {
    content: t8
  }, $[20] = t8, $[21] = t9) : t9 = $[21];
  const t10 = index === 0 ? 0 : 1;
  let t11;
  return $[22] !== handleClick || $[23] !== t10 || $[24] !== t7 || $[25] !== t9 ? (t11 = (0, import_jsx_runtime2.jsx)(Button2, { mode: "bleed", text: t7, tooltipProps: t9, onClick: handleClick, paddingLeft: t10 }), $[22] = handleClick, $[23] = t10, $[24] = t7, $[25] = t9, $[26] = t11) : t11 = $[26], t11;
}
function DocumentHeaderBreadcrumb(t0) {
  const $ = (0, import_compiler_runtime2.c)(7), {
    paneDataItems,
    currentPaneIndex
  } = t0;
  let t1;
  if ($[0] !== currentPaneIndex || $[1] !== paneDataItems) {
    let t22;
    $[3] !== currentPaneIndex ? (t22 = (paneData, idx) => {
      if (idx > currentPaneIndex)
        return null;
      const isDocumentPane = paneData.pane !== LOADING_PANE && paneData.pane.type === "document";
      return (0, import_jsx_runtime2.jsxs)(import_react2.Fragment, { children: [
        (0, import_jsx_runtime2.jsx)(DocumentHeaderBreadcrumbItem, { paneData, index: idx }),
        idx < currentPaneIndex && (isDocumentPane ? (0, import_jsx_runtime2.jsx)(Box, { padding: 1, children: (0, import_jsx_runtime2.jsx)(ArrowRightIcon, {}) }) : (0, import_jsx_runtime2.jsx)(Text, { children: "/" }))
      ] }, `breadcrumb-item-${paneData.key}-${idx}`);
    }, $[3] = currentPaneIndex, $[4] = t22) : t22 = $[4], t1 = paneDataItems.map(t22), $[0] = currentPaneIndex, $[1] = paneDataItems, $[2] = t1;
  } else
    t1 = $[2];
  let t2;
  return $[5] !== t1 ? (t2 = (0, import_jsx_runtime2.jsx)(Flex, { direction: "row", align: "center", "data-testid": "document-header-breadcrumb", children: t1 }), $[5] = t1, $[6] = t2) : t2 = $[6], t2;
}
function DocumentHeaderTitle() {
  const $ = (0, import_compiler_runtime2.c)(23), {
    connectionState,
    schemaType,
    title,
    value: documentValue,
    index
  } = useDocumentPane(), {
    paneDataItems
  } = useResolvedPanesList(), {
    title: documentTitle,
    error
  } = useDocumentTitle(), subscribed = !!documentValue, {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t0;
  $[0] !== paneDataItems ? (t0 = paneDataItems.some(_temp$A), $[0] = paneDataItems, $[1] = t0) : t0 = $[1];
  const hasMaximizedPane = t0;
  if (connectionState === "connecting" && !subscribed) {
    let t12;
    return $[2] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t12 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {}), $[2] = t12) : t12 = $[2], t12;
  }
  if (title) {
    let t12;
    return $[3] !== title ? (t12 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: title }), $[3] = title, $[4] = t12) : t12 = $[4], t12;
  }
  if (!documentValue) {
    const t12 = schemaType?.title || schemaType?.name;
    let t222;
    $[5] !== t2 || $[6] !== t12 ? (t222 = t2("panes.document-header-title.new.text", {
      schemaType: t12
    }), $[5] = t2, $[6] = t12, $[7] = t222) : t222 = $[7];
    let t3;
    return $[8] !== t222 ? (t3 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: t222 }), $[8] = t222, $[9] = t3) : t3 = $[9], t3;
  }
  if (error) {
    let t12;
    $[10] !== error || $[11] !== t2 ? (t12 = t2("panes.document-header-title.error.text", {
      error
    }), $[10] = error, $[11] = t2, $[12] = t12) : t12 = $[12];
    let t222;
    return $[13] !== t12 ? (t222 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: t12 }), $[13] = t12, $[14] = t222) : t222 = $[14], t222;
  }
  let t1;
  $[15] !== documentTitle || $[16] !== hasMaximizedPane || $[17] !== index || $[18] !== paneDataItems || $[19] !== t2 ? (t1 = hasMaximizedPane ? (0, import_jsx_runtime2.jsx)(DocumentHeaderBreadcrumb, { paneDataItems, currentPaneIndex: index }) : documentTitle || (0, import_jsx_runtime2.jsx)("span", { style: {
    color: "var(--card-muted-fg-color)"
  }, children: t2("panes.document-header-title.untitled.text") }), $[15] = documentTitle, $[16] = hasMaximizedPane, $[17] = index, $[18] = paneDataItems, $[19] = t2, $[20] = t1) : t1 = $[20];
  let t22;
  return $[21] !== t1 ? (t22 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: t1 }), $[21] = t1, $[22] = t22) : t22 = $[22], t22;
}
function _temp$A(paneData) {
  return paneData.maximized;
}
var FavoriteToggle = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(16);
  let documentExists, props;
  $[0] !== t0 ? ({
    documentExists,
    ...props
  } = t0, $[0] = t0, $[1] = documentExists, $[2] = props) : (documentExists = $[1], props = $[2]);
  const {
    isFavorited,
    isReady,
    favorite,
    unfavorite
  } = useManageFavorite(props), {
    t: t2
  } = useTranslation(structureLocaleNamespace), t1 = isFavorited ? "document.favorites.remove-from-favorites" : "document.favorites.add-to-favorites";
  let t22;
  $[3] !== t2 || $[4] !== t1 ? (t22 = t2(t1), $[3] = t2, $[4] = t1, $[5] = t22) : t22 = $[5];
  const description = t22, t3 = isFavorited ? unfavorite : favorite, t4 = !isReady || !documentExists;
  let t5;
  $[6] !== description ? (t5 = {
    content: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: description }),
    placement: "right"
  }, $[6] = description, $[7] = t5) : t5 = $[7];
  let t6;
  $[8] !== isFavorited ? (t6 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: isFavorited ? (0, import_jsx_runtime2.jsx)(StarFilledIcon, {}) : (0, import_jsx_runtime2.jsx)(StarIcon, {}) }), $[8] = isFavorited, $[9] = t6) : t6 = $[9];
  let t7;
  return $[10] !== description || $[11] !== t3 || $[12] !== t4 || $[13] !== t5 || $[14] !== t6 ? (t7 = (0, import_jsx_runtime2.jsx)(Button2, { mode: "bleed", onClick: t3, disabled: t4, "aria-label": description, "aria-live": "assertive", tooltipProps: t5, children: t6 }), $[10] = description, $[11] = t3, $[12] = t4, $[13] = t5, $[14] = t6, $[15] = t7) : t7 = $[15], t7;
};
var DocumentPanelSubHeader = (0, import_react2.memo)(function() {
  const $ = (0, import_compiler_runtime2.c)(24), {
    editState,
    connectionState,
    views: views2,
    documentId,
    displayed
  } = useDocumentPane(), {
    features
  } = useStructureTool(), {
    index,
    BackLink: BackLink2
  } = usePaneRouter(), {
    activeWorkspace
  } = useActiveWorkspace(), showTabs = views2.length > 1, {
    collapsed,
    isLast
  } = usePane(), tabIndex = isLast && !collapsed ? -1 : 0, showBackButton = features.backButton && index > 0, {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t0;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = (0, import_jsx_runtime2.jsx)(DocumentHeaderTitle, {}), $[0] = t0) : t0 = $[0];
  const title = t0;
  let t1;
  $[1] !== showTabs ? (t1 = showTabs && (0, import_jsx_runtime2.jsx)(DocumentHeaderTabs, {}), $[1] = showTabs, $[2] = t1) : t1 = $[2];
  const tabs = t1;
  let t22;
  $[3] !== BackLink2 || $[4] !== showBackButton || $[5] !== t2 ? (t22 = showBackButton && (0, import_jsx_runtime2.jsx)(Button2, { as: BackLink2, "data-as": "a", icon: ArrowLeftIcon, mode: "bleed", tooltipProps: {
    content: t2("pane-header.back-button.text")
  } }), $[3] = BackLink2, $[4] = showBackButton, $[5] = t2, $[6] = t22) : t22 = $[6];
  const backButton = t22, t3 = displayed?._id ?? documentId, t4 = displayed?._type ?? "";
  let t5;
  $[7] !== activeWorkspace.dataset || $[8] !== activeWorkspace.projectId ? (t5 = [activeWorkspace.projectId, activeWorkspace.dataset], $[7] = activeWorkspace.dataset, $[8] = activeWorkspace.projectId, $[9] = t5) : t5 = $[9];
  const t6 = t5.join("."), t7 = (editState?.ready && (editState.version ?? editState.draft ?? editState.published) !== null) ?? false;
  let t8;
  $[10] !== activeWorkspace.dataset || $[11] !== activeWorkspace.name || $[12] !== activeWorkspace.projectId || $[13] !== t3 || $[14] !== t4 || $[15] !== t6 || $[16] !== t7 ? (t8 = (0, import_jsx_runtime2.jsx)(CapabilityGate, { capability: "comlink", condition: "available", children: (0, import_jsx_runtime2.jsx)(FavoriteToggle, { resourceType: "studio", documentId: t3, documentType: t4, resourceId: t6, schemaName: activeWorkspace.name, projectId: activeWorkspace.projectId, dataset: activeWorkspace.dataset, documentExists: t7 }) }), $[10] = activeWorkspace.dataset, $[11] = activeWorkspace.name, $[12] = activeWorkspace.projectId, $[13] = t3, $[14] = t4, $[15] = t6, $[16] = t7, $[17] = t8) : t8 = $[17];
  const favoriteToggle = t8, t9 = connectionState === "connecting" && !editState?.draft && !editState?.published;
  let t10;
  return $[18] !== backButton || $[19] !== favoriteToggle || $[20] !== t9 || $[21] !== tabIndex || $[22] !== tabs ? (t10 = (0, import_jsx_runtime2.jsx)(PaneHeader$1, { loading: t9, title, tabs, tabIndex, backButton, appendTitle: favoriteToggle }), $[18] = backButton, $[19] = favoriteToggle, $[20] = t9, $[21] = tabIndex, $[22] = tabs, $[23] = t10) : t10 = $[23], t10;
});
var DocumentBox = at(Box).withConfig({
  displayName: "DocumentBox",
  componentId: "sc-10i0hcs-0"
})({
  position: "relative"
});
var Scroller$4 = at(ScrollContainer).withConfig({
  displayName: "Scroller",
  componentId: "sc-10i0hcs-1"
})(({
  $disabled
}) => $disabled ? {
  height: "100%"
} : rt`
    height: 100%;
    overflow: auto;
    position: relative;
    scroll-behavior: smooth;
    outline: none;
  `);
var DocumentPanel = function(props) {
  const $ = (0, import_compiler_runtime2.c)(114), {
    footerHeight,
    headerHeight,
    isInspectOpen,
    rootElement,
    setDocumentPanelPortalElement,
    footer
  } = props, {
    activeViewId,
    displayed,
    documentId,
    editState,
    inspector,
    value,
    views: views2,
    ready,
    schemaType,
    permissions,
    isPermissionsLoading
  } = useDocumentPane();
  let t0;
  if ($[0] !== value) {
    const createLinkMetadata = getSanityCreateLinkMetadata(value);
    t0 = isSanityCreateLinked(createLinkMetadata), $[0] = value, $[1] = t0;
  } else
    t0 = $[1];
  const showCreateBanner = t0, {
    params
  } = usePaneRouter(), {
    collapsed: layoutCollapsed
  } = usePaneLayout(), {
    collapsed
  } = usePane(), parentPortal = usePortal(), {
    features
  } = useStructureTool(), [_portalElement, setPortalElement] = (0, import_react2.useState)(null), [documentScrollElement, setDocumentScrollElement] = (0, import_react2.useState)(null), formContainerElement = (0, import_react2.useRef)(null), workspace = useWorkspace(), requiredPermission = value._createdAt ? "update" : "create";
  let t1;
  $[2] !== activeViewId || $[3] !== views2 ? (t1 = views2.find((view) => view.id === activeViewId) || views2[0] || {
    type: "form"
  }, $[2] = activeViewId, $[3] = views2, $[4] = t1) : t1 = $[4];
  const activeView = t1, portalElement = features.splitPanes && _portalElement || parentPortal.element;
  let t2;
  bb0: {
    if (layoutCollapsed) {
      const t33 = headerHeight || 0, t42 = footerHeight ? footerHeight + 2 : 2;
      let t52;
      $[5] !== t33 || $[6] !== t42 ? (t52 = [t33, 0, t42, 0], $[5] = t33, $[6] = t42, $[7] = t52) : t52 = $[7], t2 = t52;
      break bb0;
    }
    let t32;
    $[8] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t32 = [0, 0, 2, 0], $[8] = t32) : t32 = $[8], t2 = t32;
  }
  const margins = t2, formViewHidden = activeView.type !== "form";
  let t3;
  $[9] !== activeView.component || $[10] !== activeView.options || $[11] !== activeView.type || $[12] !== displayed || $[13] !== documentId || $[14] !== editState?.draft || $[15] !== editState?.published || $[16] !== schemaType || $[17] !== value ? (t3 = () => {
    if (activeView.type === "component" && activeView.component) {
      const ActiveViewComponent = activeView.component;
      return (0, import_jsx_runtime2.jsx)(ActiveViewComponent, { document: {
        draft: editState?.draft || null,
        displayed: displayed || value,
        historical: displayed,
        published: editState?.published || null
      }, documentId, options: activeView.options, schemaType });
    }
    return false;
  }, $[9] = activeView.component, $[10] = activeView.options, $[11] = activeView.type, $[12] = displayed, $[13] = documentId, $[14] = editState?.draft, $[15] = editState?.published, $[16] = schemaType, $[17] = value, $[18] = t3) : t3 = $[18];
  let t4;
  $[19] !== t3 ? (t4 = t3(), $[19] = t3, $[20] = t4) : t4 = $[20];
  const activeViewNode = t4, prevDocumentIdRef = (0, import_react2.useRef)(void 0);
  let t5, t6;
  $[21] !== documentId || $[22] !== documentScrollElement ? (t5 = () => {
    if (documentScrollElement?.scrollTo) {
      if (prevDocumentIdRef.current === void 0) {
        prevDocumentIdRef.current = documentId;
        return;
      }
      prevDocumentIdRef.current !== documentId && (documentScrollElement.scrollTo(0, 0), prevDocumentIdRef.current = documentId);
    }
  }, t6 = [documentId, documentScrollElement], $[21] = documentId, $[22] = documentScrollElement, $[23] = t5, $[24] = t6) : (t5 = $[23], t6 = $[24]), (0, import_react2.useEffect)(t5, t6);
  let t7, t8;
  $[25] !== portalElement || $[26] !== setDocumentPanelPortalElement ? (t7 = () => {
    portalElement && setDocumentPanelPortalElement(portalElement);
  }, t8 = [portalElement, setDocumentPanelPortalElement], $[25] = portalElement, $[26] = setDocumentPanelPortalElement, $[27] = t7, $[28] = t8) : (t7 = $[27], t8 = $[28]), (0, import_react2.useEffect)(t7, t8);
  let t9;
  $[29] !== displayed || $[30] !== isInspectOpen || $[31] !== value ? (t9 = isInspectOpen ? (0, import_jsx_runtime2.jsx)(InspectDialog, { value: displayed || value }) : null, $[29] = displayed, $[30] = isInspectOpen, $[31] = value, $[32] = t9) : t9 = $[32];
  const inspectDialog = t9, showInspector = !!(!collapsed && inspector), {
    selectedPerspective,
    selectedReleaseId,
    selectedPerspectiveName
  } = usePerspective(), t10 = params?.historyVersion;
  let t11;
  $[33] !== displayed || $[34] !== documentId || $[35] !== t10 ? (t11 = {
    historyVersion: t10,
    displayed,
    documentId
  }, $[33] = displayed, $[34] = documentId, $[35] = t10, $[36] = t11) : t11 = $[36];
  const filteredReleases = useFilteredReleases(t11), {
    isPaused: isPausedDraft
  } = usePausedScheduledDraft();
  let t12;
  bb1: {
    if (params?.historyVersion) {
      let t133;
      $[37] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t133 = (0, import_jsx_runtime2.jsx)(ArchivedReleaseDocumentBanner, {}), $[37] = t133) : t133 = $[37], t12 = t133;
      break bb1;
    }
    let t132;
    $[38] !== selectedPerspective ? (t132 = isReleaseDocument(selectedPerspective) && isReleaseScheduledOrScheduling(selectedPerspective), $[38] = selectedPerspective, $[39] = t132) : t132 = $[39];
    const isScheduledRelease = t132, documentInScheduledRelease = !!(isScheduledRelease && displayed?._id && getVersionFromId(displayed?._id) === selectedReleaseId);
    let isSelectedPerspectiveWriteable, t142;
    if ($[40] !== editState || $[41] !== schemaType || $[42] !== selectedPerspective || $[43] !== workspace.document.drafts.enabled ? (isSelectedPerspectiveWriteable = isPerspectiveWriteable({
      selectedPerspective,
      isDraftModelEnabled: workspace.document.drafts.enabled,
      schemaType
    }), t142 = mustChooseNewDocumentDestination({
      isSelectedPerspectiveWriteable,
      editState
    }), $[40] = editState, $[41] = schemaType, $[42] = selectedPerspective, $[43] = workspace.document.drafts.enabled, $[44] = isSelectedPerspectiveWriteable, $[45] = t142) : (isSelectedPerspectiveWriteable = $[44], t142 = $[45]), t142) {
      let t153;
      $[46] !== isSelectedPerspectiveWriteable.reason || $[47] !== isSelectedPerspectiveWriteable.result || $[48] !== schemaType || $[49] !== selectedPerspective ? (t153 = !isSelectedPerspectiveWriteable.result && (0, import_jsx_runtime2.jsx)(ChooseNewDocumentDestinationBanner, { schemaType, selectedPerspective, reason: isSelectedPerspectiveWriteable.reason }), $[46] = isSelectedPerspectiveWriteable.reason, $[47] = isSelectedPerspectiveWriteable.result, $[48] = schemaType, $[49] = selectedPerspective, $[50] = t153) : t153 = $[50], t12 = t153;
      break bb1;
    }
    if (isPausedDraft && displayed?._id) {
      let t153;
      $[51] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t153 = (0, import_jsx_runtime2.jsx)(PausedScheduledDraftBanner, {}), $[51] = t153) : t153 = $[51], t12 = t153;
      break bb1;
    }
    if (documentInScheduledRelease) {
      const t153 = selectedPerspective;
      let t163;
      $[52] !== t153 ? (t163 = (0, import_jsx_runtime2.jsx)(ScheduledReleaseBanner, { currentRelease: t153 }), $[52] = t153, $[53] = t163) : t163 = $[53], t12 = t163;
      break bb1;
    }
    let t152;
    $[54] !== filteredReleases.currentReleases || $[55] !== filteredReleases.notCurrentReleases ? (t152 = [...filteredReleases.currentReleases, ...filteredReleases.notCurrentReleases].find(_temp$z), $[54] = filteredReleases.currentReleases, $[55] = filteredReleases.notCurrentReleases, $[56] = t152) : t152 = $[56];
    const scheduledCardinalityOneRelease = t152, displayedIsDraft = displayed?._id && isDraftId(displayed._id);
    if (selectedPerspective === "drafts" && scheduledCardinalityOneRelease && displayedIsDraft) {
      let t163;
      $[57] !== displayed || $[58] !== scheduledCardinalityOneRelease._id ? (t163 = (0, import_jsx_runtime2.jsx)(ScheduledDraftOverrideBanner, { releaseId: scheduledCardinalityOneRelease._id, draftDocument: displayed }), $[57] = displayed, $[58] = scheduledCardinalityOneRelease._id, $[59] = t163) : t163 = $[59], t12 = t163;
      break bb1;
    }
    let t162;
    $[60] !== selectedPerspective ? (t162 = isSystemBundle(selectedPerspective), $[60] = selectedPerspective, $[61] = t162) : t162 = $[61];
    const isPinnedDraftOrPublish = t162, isCurrentVersionGoingToUnpublish = editState?.version && isGoingToUnpublish(editState?.version);
    if (!isSystemBundle(selectedPerspective) && displayed?._id && getVersionFromId(displayed._id) !== selectedPerspectiveName && ready && !isPinnedDraftOrPublish && isNewDocument(editState) === false && !isCurrentVersionGoingToUnpublish) {
      let t172;
      $[62] !== isScheduledRelease || $[63] !== selectedPerspective || $[64] !== value._id ? (t172 = (0, import_jsx_runtime2.jsx)(DocumentNotInReleaseBanner, { documentId: value._id, currentRelease: selectedPerspective, isScheduledRelease }), $[62] = isScheduledRelease, $[63] = selectedPerspective, $[64] = value._id, $[65] = t172) : t172 = $[65], t12 = t172;
      break bb1;
    }
    const displayedHasObsoleteDraft = hasObsoleteDraft({
      editState,
      workspace,
      schemaType
    });
    if (activeView.type === "form" && !selectedReleaseId && displayedHasObsoleteDraft.result) {
      if (displayedHasObsoleteDraft.reason === "DRAFT_MODEL_INACTIVE") {
        let t172;
        $[66] !== displayed || $[67] !== documentId || $[68] !== schemaType ? (t172 = (0, import_jsx_runtime2.jsx)(ObsoleteDraftBanner, { displayed, documentId, schemaType, i18nKey: "banners.obsolete-draft.draft-model-inactive.text" }), $[66] = displayed, $[67] = documentId, $[68] = schemaType, $[69] = t172) : t172 = $[69], t12 = t172;
        break bb1;
      }
      if (displayedHasObsoleteDraft.reason === "LIVE_EDIT_ACTIVE") {
        let t172;
        $[70] !== displayed || $[71] !== documentId || $[72] !== schemaType ? (t172 = (0, import_jsx_runtime2.jsx)(ObsoleteDraftBanner, { displayed, documentId, schemaType, i18nKey: "banners.live-edit-draft-banner.text", isEditBlocking: true }), $[70] = displayed, $[71] = documentId, $[72] = schemaType, $[73] = t172) : t172 = $[73], t12 = t172;
        break bb1;
      }
    }
    if (activeView.type !== "form" || isPermissionsLoading) {
      t12 = null;
      break bb1;
    }
    let t17;
    $[74] !== showCreateBanner ? (t17 = showCreateBanner && (0, import_jsx_runtime2.jsx)(CreateLinkedBanner, {}), $[74] = showCreateBanner, $[75] = t17) : t17 = $[75];
    let t18;
    $[76] !== permissions?.granted || $[77] !== requiredPermission ? (t18 = !permissions?.granted && (0, import_jsx_runtime2.jsx)(InsufficientPermissionBanner, { requiredPermission }), $[76] = permissions?.granted, $[77] = requiredPermission, $[78] = t18) : t18 = $[78];
    let t19, t20, t21, t22, t23, t24;
    $[79] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t19 = (0, import_jsx_runtime2.jsx)(RevisionNotFoundBanner, {}), t20 = (0, import_jsx_runtime2.jsx)(ReferenceChangedBanner, {}), t21 = (0, import_jsx_runtime2.jsx)(DeprecatedDocumentTypeBanner, {}), t22 = (0, import_jsx_runtime2.jsx)(CanvasLinkedBanner, {}), t23 = (0, import_jsx_runtime2.jsx)(DeletedDocumentBanners, {}), t24 = (0, import_jsx_runtime2.jsx)(UnpublishedDocumentBanner, {}), $[79] = t19, $[80] = t20, $[81] = t21, $[82] = t22, $[83] = t23, $[84] = t24) : (t19 = $[79], t20 = $[80], t21 = $[81], t22 = $[82], t23 = $[83], t24 = $[84]);
    const t25 = displayed?._id ?? documentId;
    let t26;
    $[85] !== isPinnedDraftOrPublish || $[86] !== t25 ? (t26 = (0, import_jsx_runtime2.jsx)(OpenReleaseToEditBanner, { documentId: t25, isPinnedDraftOrPublished: isPinnedDraftOrPublish }), $[85] = isPinnedDraftOrPublish, $[86] = t25, $[87] = t26) : t26 = $[87];
    let t27;
    $[88] !== t17 || $[89] !== t18 || $[90] !== t26 ? (t27 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t17,
      t18,
      t19,
      t20,
      t21,
      t22,
      t23,
      t24,
      t26
    ] }), $[88] = t17, $[89] = t18, $[90] = t26, $[91] = t27) : t27 = $[91], t12 = t27;
  }
  const banners = t12;
  let t13;
  $[92] !== documentScrollElement ? (t13 = {
    documentScrollElement
  }, $[92] = documentScrollElement, $[93] = t13) : t13 = $[93];
  const portalElements = t13, showFormView = features.resizablePanes || !showInspector;
  let t14;
  $[94] !== activeViewNode || $[95] !== banners || $[96] !== documentScrollElement || $[97] !== footer || $[98] !== formViewHidden || $[99] !== inspectDialog || $[100] !== layoutCollapsed || $[101] !== margins || $[102] !== portalElement || $[103] !== portalElements || $[104] !== showFormView ? (t14 = showFormView && (0, import_jsx_runtime2.jsxs)(Flex, { height: "fill", direction: "column", width: "fill", flex: 2, children: [
    (0, import_jsx_runtime2.jsxs)(LegacyLayerProvider, { zOffset: "paneHeader", children: [
      banners,
      (0, import_jsx_runtime2.jsx)(DocumentPanelSubHeader, {})
    ] }),
    (0, import_jsx_runtime2.jsx)(DocumentBox, { flex: 2, children: (0, import_jsx_runtime2.jsx)(PortalProvider, { element: portalElement, __unstable_elements: portalElements, children: (0, import_jsx_runtime2.jsx)(BoundaryElementProvider, { element: documentScrollElement, children: (0, import_jsx_runtime2.jsxs)(VirtualizerScrollInstanceProvider, { scrollElement: documentScrollElement, containerElement: formContainerElement, children: [
      (0, import_jsx_runtime2.jsxs)(Scroller$4, { $disabled: layoutCollapsed || false, "data-testid": "document-panel-scroller", ref: setDocumentScrollElement, children: [
        (0, import_jsx_runtime2.jsx)(FormView, { hidden: formViewHidden, margins, ref: formContainerElement }),
        activeViewNode
      ] }),
      inspectDialog,
      (0, import_jsx_runtime2.jsx)("div", { "data-testid": "document-panel-portal", ref: setPortalElement })
    ] }) }) }) }),
    footer
  ] }), $[94] = activeViewNode, $[95] = banners, $[96] = documentScrollElement, $[97] = footer, $[98] = formViewHidden, $[99] = inspectDialog, $[100] = layoutCollapsed, $[101] = margins, $[102] = portalElement, $[103] = portalElements, $[104] = showFormView, $[105] = t14) : t14 = $[105];
  let t15;
  $[106] !== documentId || $[107] !== rootElement || $[108] !== schemaType || $[109] !== showInspector ? (t15 = showInspector && (0, import_jsx_runtime2.jsx)(BoundaryElementProvider, { element: rootElement, children: (0, import_jsx_runtime2.jsx)(DocumentInspectorPanel, { documentId, documentType: schemaType.name, flex: 1 }) }), $[106] = documentId, $[107] = rootElement, $[108] = schemaType, $[109] = showInspector, $[110] = t15) : t15 = $[110];
  let t16;
  return $[111] !== t14 || $[112] !== t15 ? (t16 = (0, import_jsx_runtime2.jsx)(PaneContent, { children: (0, import_jsx_runtime2.jsxs)(Flex, { height: "fill", children: [
    t14,
    t15
  ] }) }), $[111] = t14, $[112] = t15, $[113] = t16) : t16 = $[113], t16;
};
DocumentPanel.displayName = "DocumentPanel";
function _temp$z(release) {
  return isCardinalityOneRelease(release) && (isReleaseScheduledOrScheduling(release) || isPausedCardinalityOneRelease(release));
}
var useHistoryRestoreAction = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(26), {
    id,
    type,
    revision,
    release
  } = t0, {
    restore
  } = useDocumentOperation(id, type, release), {
    revisionNotFound
  } = useDocumentPane(), event = useDocumentOperationEvent(id, type), {
    navigateIntent
  } = useRouter(), prevEvent = (0, import_react2.useRef)(event), [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react2.useState)(false), {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[0] !== restore || $[1] !== revision ? (t1 = () => {
    restore.execute(revision), setConfirmDialogOpen(false);
  }, $[0] = restore, $[1] = revision, $[2] = t1) : t1 = $[2];
  const handleConfirm = t1;
  let t22;
  $[3] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t22 = () => {
    setConfirmDialogOpen(false);
  }, $[3] = t22) : t22 = $[3];
  const handleCancel = t22;
  let t3, t4;
  $[4] !== event || $[5] !== id || $[6] !== navigateIntent || $[7] !== type ? (t3 = () => {
    !event || event === prevEvent.current || (event.type === "success" && event.op === "restore" && navigateIntent("edit", {
      id,
      type
    }), prevEvent.current = event);
  }, t4 = [event, id, navigateIntent, type], $[4] = event, $[5] = id, $[6] = navigateIntent, $[7] = type, $[8] = t3, $[9] = t4) : (t3 = $[8], t4 = $[9]), (0, import_react2.useEffect)(t3, t4);
  let t5;
  $[10] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t5 = () => {
    setConfirmDialogOpen(true);
  }, $[10] = t5) : t5 = $[10];
  const handle = t5;
  let t6;
  bb0: {
    if (isConfirmDialogOpen) {
      let t72;
      $[11] !== t2 ? (t72 = t2("action.restore.confirm.message"), $[11] = t2, $[12] = t72) : t72 = $[12];
      let t8;
      $[13] !== handleConfirm || $[14] !== t72 ? (t8 = {
        type: "confirm",
        tone: "critical",
        onCancel: handleCancel,
        onConfirm: handleConfirm,
        message: t72
      }, $[13] = handleConfirm, $[14] = t72, $[15] = t8) : t8 = $[15], t6 = t8;
      break bb0;
    }
    t6 = null;
  }
  const dialog = t6, isRevisionInitial = revision === "@initial", isRevisionLatest = revision === void 0;
  let t7;
  bb1: {
    if (isRevisionLatest || revisionNotFound) {
      t7 = null;
      break bb1;
    }
    let t8;
    $[16] !== t2 ? (t8 = t2("action.restore.label"), $[16] = t2, $[17] = t8) : t8 = $[17];
    const t9 = isRevisionInitial ? "action.restore.disabled.cannot-restore-initial" : "action.restore.tooltip";
    let t10;
    $[18] !== t2 || $[19] !== t9 ? (t10 = t2(t9), $[18] = t2, $[19] = t9, $[20] = t10) : t10 = $[20];
    let t11;
    $[21] !== dialog || $[22] !== isRevisionInitial || $[23] !== t10 || $[24] !== t8 ? (t11 = {
      label: t8,
      tone: "caution",
      onHandle: handle,
      title: t10,
      icon: RevertIcon,
      dialog,
      disabled: isRevisionInitial
    }, $[21] = dialog, $[22] = isRevisionInitial, $[23] = t10, $[24] = t8, $[25] = t11) : t11 = $[25], t7 = t11;
  }
  return t7;
};
useHistoryRestoreAction.action = "restore";
useHistoryRestoreAction.displayName = "HistoryRestoreAction";
function isMenuNodeButton(node) {
  return (node.type === "item" || node.type === "group") && node.renderAsButton;
}
var isNotMenuNodeButton = negate_default(isMenuNodeButton);
function resolveMenuNodes(params) {
  const {
    fieldActions = [],
    menuItems,
    menuItemGroups
  } = params, nodes = [];
  let keyOffset = 0;
  for (let i = 0; i < fieldActions.length; i += 1) {
    const a = fieldActions[i];
    nodes.push(mapFieldActionToPaneMenuNode(a, `${i}-${a.type}`));
  }
  keyOffset += nodes.length;
  const groups = [];
  for (const itemGroup of menuItemGroups)
    groups.find((g) => g.key === itemGroup.id) || groups.push({
      type: "group",
      key: itemGroup.id,
      children: [],
      expanded: true,
      renderAsButton: false,
      title: itemGroup.title,
      i18n: itemGroup.i18n
    });
  const ungroupedItems = [];
  for (let i = 0; i < menuItems.length; i += 1) {
    const item = menuItems[i];
    let group = item.group && groups.find((g) => g.key === item.group);
    const disabled = typeof item.disabled == "string" ? {
      reason: item.disabled
    } : item.disabled;
    item.group && !group && (group = {
      type: "group",
      key: item.group,
      disabled,
      expanded: true,
      icon: item.icon,
      title: item.group,
      children: [],
      renderAsButton: false
    }, groups.push(group)), group ? group.children.push({
      type: "item",
      key: `${keyOffset + i}-item`,
      hideSelectionIndicator: item.params?.hideSelectionIndicator === true,
      hotkey: item.shortcut,
      icon: item.icon,
      intent: item.intent,
      disabled,
      onAction: () => params.actionHandler(item),
      renderAsButton: item.showAsAction ?? false,
      selected: item.selected,
      title: item.title,
      i18n: item.i18n,
      tone: item.tone
    }) : ungroupedItems.push({
      type: "item",
      key: `${keyOffset + i}-item`,
      hideSelectionIndicator: item.params?.hideSelectionIndicator === true,
      hotkey: item.shortcut,
      icon: item.icon,
      intent: item.intent,
      disabled,
      onAction: () => params.actionHandler(item),
      renderAsButton: item.showAsAction ?? false,
      selected: item.selected,
      title: item.title,
      i18n: item.i18n,
      tone: item.tone
    });
  }
  return [...ungroupedItems, ...groups, ...nodes];
}
function mapFieldActionToPaneMenuNode(a, key) {
  return a.type === "divider" ? {
    type: "divider",
    key
  } : a.type === "group" ? {
    type: "group",
    key,
    children: a.children.map((child, childIdx) => mapFieldActionToPaneMenuNode(child, `${key}-${childIdx}-${child.type}`)),
    disabled: a.disabled,
    expanded: a.expanded ?? true,
    icon: a.icon,
    title: a.title,
    i18n: a.i18n,
    renderAsButton: a.renderAsButton ?? false
  } : {
    type: "item",
    key,
    intent: a.intent,
    disabled: a.disabled,
    icon: a.icon,
    iconRight: a.iconRight,
    onAction: a.onAction,
    renderAsButton: a.renderAsButton ?? false,
    selected: a.selected,
    title: a.title,
    i18n: a.i18n,
    tone: a.tone
  };
}
var POPOVER_FALLBACK_PLACEMENTS = ["left", "bottom"];
var DIALOG_WIDTH_TO_UI_WIDTH = {
  small: 0,
  medium: 1,
  large: 2,
  full: "auto"
};
function ConfirmDialog(props) {
  const $ = (0, import_compiler_runtime2.c)(16), {
    dialog,
    referenceElement
  } = props, {
    t: t2
  } = useTranslation(structureLocaleNamespace), {
    cancelButtonIcon,
    cancelButtonText,
    confirmButtonIcon,
    confirmButtonText,
    message,
    onCancel,
    onConfirm,
    tone
  } = dialog;
  let t0;
  $[0] !== cancelButtonText || $[1] !== t2 ? (t0 = cancelButtonText || t2("confirm-dialog.cancel-button.fallback-text"), $[0] = cancelButtonText, $[1] = t2, $[2] = t0) : t0 = $[2];
  let t1;
  $[3] !== confirmButtonText || $[4] !== t2 ? (t1 = confirmButtonText || t2("confirm-dialog.confirm-button.fallback-text"), $[3] = confirmButtonText, $[4] = t2, $[5] = t1) : t1 = $[5];
  let t22;
  return $[6] !== cancelButtonIcon || $[7] !== confirmButtonIcon || $[8] !== message || $[9] !== onCancel || $[10] !== onConfirm || $[11] !== referenceElement || $[12] !== t0 || $[13] !== t1 || $[14] !== tone ? (t22 = (0, import_jsx_runtime2.jsx)(ConfirmPopover, { cancelButtonIcon, cancelButtonText: t0, confirmButtonIcon, confirmButtonText: t1, message, onCancel, onConfirm, open: true, referenceElement, tone, placement: "top", fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS }), $[6] = cancelButtonIcon, $[7] = confirmButtonIcon, $[8] = message, $[9] = onCancel, $[10] = onConfirm, $[11] = referenceElement, $[12] = t0, $[13] = t1, $[14] = tone, $[15] = t22) : t22 = $[15], t22;
}
function ModalDialog(props) {
  const $ = (0, import_compiler_runtime2.c)(12), {
    dialog
  } = props, dialogId = (0, import_react2.useId)();
  let t0;
  $[0] !== dialog.footer ? (t0 = dialog.footer && (0, import_jsx_runtime2.jsx)(Box, { paddingX: 4, paddingY: 3, children: dialog.footer }), $[0] = dialog.footer, $[1] = t0) : t0 = $[1];
  const footer = t0, t1 = dialog.showCloseButton === false, t2 = dialog.width === void 0 ? 1 : DIALOG_WIDTH_TO_UI_WIDTH[dialog.width];
  let t3;
  $[2] !== dialog.content ? (t3 = (0, import_jsx_runtime2.jsx)(Box, { padding: 4, children: dialog.content }), $[2] = dialog.content, $[3] = t3) : t3 = $[3];
  let t4;
  return $[4] !== dialog.header || $[5] !== dialog.onClose || $[6] !== dialogId || $[7] !== footer || $[8] !== t1 || $[9] !== t2 || $[10] !== t3 ? (t4 = (0, import_jsx_runtime2.jsx)(LegacyLayerProvider, { zOffset: "fullscreen", children: (0, import_jsx_runtime2.jsx)(Dialog, { animate: true, __unstable_hideCloseButton: t1, footer, header: dialog.header, id: dialogId, onClose: dialog.onClose, onClickOutside: dialog.onClose, width: t2, children: t3 }) }), $[4] = dialog.header, $[5] = dialog.onClose, $[6] = dialogId, $[7] = footer, $[8] = t1, $[9] = t2, $[10] = t3, $[11] = t4) : t4 = $[11], t4;
}
function PopoverDialog(props) {
  const $ = (0, import_compiler_runtime2.c)(5), {
    dialog,
    referenceElement
  } = props;
  let t0;
  $[0] !== dialog ? (t0 = (0, import_jsx_runtime2.jsx)(PopoverDialogContent, { dialog }), $[0] = dialog, $[1] = t0) : t0 = $[1];
  let t1;
  return $[2] !== referenceElement || $[3] !== t0 ? (t1 = (0, import_jsx_runtime2.jsx)(Popover, { content: t0, fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS, open: true, placement: "top", portal: true, preventOverflow: true, referenceElement }), $[2] = referenceElement, $[3] = t0, $[4] = t1) : t1 = $[4], t1;
}
function PopoverDialogContent(props) {
  const $ = (0, import_compiler_runtime2.c)(6), {
    dialog
  } = props, {
    content,
    onClose
  } = dialog, {
    isTopLayer
  } = useLayer(), ref = (0, import_react2.useRef)(null);
  let t0;
  $[0] !== isTopLayer || $[1] !== onClose ? (t0 = (event) => {
    event.key === "Escape" && isTopLayer && onClose();
  }, $[0] = isTopLayer, $[1] = onClose, $[2] = t0) : t0 = $[2], useGlobalKeyDown(t0);
  let t1;
  $[3] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = () => [ref.current], $[3] = t1) : t1 = $[3], useClickOutsideEvent(isTopLayer && onClose, t1);
  let t2;
  return $[4] !== content ? (t2 = (0, import_jsx_runtime2.jsx)("div", { ref, children: content }), $[4] = content, $[5] = t2) : t2 = $[5], t2;
}
function DocumentActionPortalProvider(props) {
  const $ = (0, import_compiler_runtime2.c)(3), {
    children
  } = props, {
    element,
    elements
  } = usePortal(), portalElement = elements?.[DOCUMENT_PANEL_PORTAL_ELEMENT] || element;
  let t0;
  return $[0] !== children || $[1] !== portalElement ? (t0 = (0, import_jsx_runtime2.jsx)(PortalProvider, { element: portalElement, children }), $[0] = children, $[1] = portalElement, $[2] = t0) : t0 = $[2], t0;
}
function ActionStateDialog(props) {
  const $ = (0, import_compiler_runtime2.c)(17), {
    dialog,
    referenceElement: t0
  } = props, referenceElement = t0 === void 0 ? null : t0, modalId = (0, import_react2.useId)();
  if (dialog.type === "confirm") {
    let t12;
    return $[0] !== dialog || $[1] !== referenceElement ? (t12 = (0, import_jsx_runtime2.jsx)(ConfirmDialog, { dialog, referenceElement }), $[0] = dialog, $[1] = referenceElement, $[2] = t12) : t12 = $[2], t12;
  }
  if (dialog.type === "popover") {
    let t12;
    return $[3] !== dialog || $[4] !== referenceElement ? (t12 = (0, import_jsx_runtime2.jsx)(PopoverDialog, { dialog, referenceElement }), $[3] = dialog, $[4] = referenceElement, $[5] = t12) : t12 = $[5], t12;
  }
  if (dialog.type === "dialog" || !dialog.type) {
    let t12;
    return $[6] !== dialog ? (t12 = (0, import_jsx_runtime2.jsx)(DocumentActionPortalProvider, { children: (0, import_jsx_runtime2.jsx)(ModalDialog, { dialog }) }), $[6] = dialog, $[7] = t12) : t12 = $[7], t12;
  }
  if (dialog.type === "custom") {
    const t12 = dialog?.component;
    let t22;
    return $[8] !== t12 ? (t22 = (0, import_jsx_runtime2.jsx)(DocumentActionPortalProvider, { children: t12 }), $[8] = t12, $[9] = t22) : t22 = $[9], t22;
  }
  const unknownModal = dialog;
  console.warn(`Unsupported modal type ${unknownModal.type}`);
  let t1;
  $[10] !== unknownModal.content || $[11] !== unknownModal.type ? (t1 = unknownModal.content || (0, import_jsx_runtime2.jsxs)(Text, { size: 1, children: [
    "Unexpected modal type (",
    (0, import_jsx_runtime2.jsx)("code", { children: unknownModal.type }),
    ")"
  ] }), $[10] = unknownModal.content, $[11] = unknownModal.type, $[12] = t1) : t1 = $[12];
  let t2;
  return $[13] !== modalId || $[14] !== t1 || $[15] !== unknownModal.onClose ? (t2 = (0, import_jsx_runtime2.jsx)(Dialog2, { id: modalId, onClose: unknownModal.onClose, onClickOutside: unknownModal.onClose, width: 1, children: t1 }), $[13] = modalId, $[14] = t1, $[15] = unknownModal.onClose, $[16] = t2) : t2 = $[16], t2;
}
var ActionDialogWrapper = (0, import_react2.memo)(function(t0) {
  const $ = (0, import_compiler_runtime2.c)(9), {
    actionStates,
    children,
    referenceElement
  } = t0, [actionIndex, setActionIndex] = (0, import_react2.useState)(-1), currentAction = actionStates[actionIndex];
  let t1;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = (idx) => {
    setActionIndex(idx);
  }, $[0] = t1) : t1 = $[0];
  const handleAction = t1;
  let t2;
  $[1] !== children ? (t2 = children({
    handleAction
  }), $[1] = children, $[2] = t2) : t2 = $[2];
  const result = t2;
  let t3;
  $[3] !== currentAction || $[4] !== referenceElement ? (t3 = currentAction && currentAction.dialog && (0, import_jsx_runtime2.jsx)(LegacyLayerProvider, { zOffset: "paneFooter", children: (0, import_jsx_runtime2.jsx)(ActionStateDialog, { dialog: currentAction.dialog, referenceElement }) }), $[3] = currentAction, $[4] = referenceElement, $[5] = t3) : t3 = $[5];
  let t4;
  return $[6] !== result || $[7] !== t3 ? (t4 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    t3,
    result
  ] }), $[6] = result, $[7] = t3, $[8] = t4) : t4 = $[8], t4;
});
function ActionMenuButton(props) {
  const $ = (0, import_compiler_runtime2.c)(10), {
    actionStates,
    disabled
  } = props, idPrefix = (0, import_react2.useId)(), [referenceElement, setReferenceElement] = (0, import_react2.useState)(null);
  let t0;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    placement: "top-end",
    portal: true,
    preventOverflow: true
  }, $[0] = t0) : t0 = $[0];
  const popoverProps = t0, {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[1] !== actionStates || $[2] !== disabled || $[3] !== idPrefix || $[4] !== t2 ? (t1 = (t222) => {
    const {
      handleAction
    } = t222;
    return (0, import_jsx_runtime2.jsx)(MenuButton, { id: `${idPrefix}-action-menu`, button: (0, import_jsx_runtime2.jsx)(ContextMenuButton, { "aria-label": t2("buttons.action-menu-button.aria-label"), disabled, "data-testid": "action-menu-button", tooltipProps: {
      content: t2("buttons.action-menu-button.tooltip")
    } }), menu: (0, import_jsx_runtime2.jsx)(Menu, { padding: 1, children: actionStates.map((actionState, idx) => (0, import_jsx_runtime2.jsx)(ActionMenuListItem, { actionState, disabled, index: idx, onAction: handleAction }, idx)) }), popover: popoverProps, ref: setReferenceElement });
  }, $[1] = actionStates, $[2] = disabled, $[3] = idPrefix, $[4] = t2, $[5] = t1) : t1 = $[5];
  const renderActionDialog = t1;
  let t22;
  return $[6] !== actionStates || $[7] !== referenceElement || $[8] !== renderActionDialog ? (t22 = (0, import_jsx_runtime2.jsx)(ActionDialogWrapper, { actionStates, referenceElement, children: renderActionDialog }), $[6] = actionStates, $[7] = referenceElement, $[8] = renderActionDialog, $[9] = t22) : t22 = $[9], t22;
}
function ActionMenuListItem(props) {
  const $ = (0, import_compiler_runtime2.c)(20), {
    actionState,
    disabled,
    index,
    onAction
  } = props, {
    onHandle
  } = actionState;
  let t0;
  $[0] !== index || $[1] !== onAction || $[2] !== onHandle ? (t0 = () => {
    onAction(index), onHandle && onHandle();
  }, $[0] = index, $[1] = onAction, $[2] = onHandle, $[3] = t0) : t0 = $[3];
  const handleClick = t0;
  let t1;
  $[4] !== actionState.shortcut ? (t1 = actionState.shortcut ? String(actionState.shortcut).split("+").map(_temp$y) : void 0, $[4] = actionState.shortcut, $[5] = t1) : t1 = $[5];
  const hotkeys = t1;
  let t2;
  $[6] !== actionState.label ? (t2 = actionState.label.replace(" ", ""), $[6] = actionState.label, $[7] = t2) : t2 = $[7];
  const t3 = `action-${t2}`, t4 = disabled || !!actionState.disabled;
  let t5;
  $[8] !== actionState.disabled || $[9] !== actionState.title ? (t5 = actionState.disabled && {
    tooltipProps: {
      content: actionState.title
    }
  }, $[8] = actionState.disabled, $[9] = actionState.title, $[10] = t5) : t5 = $[10];
  let t6;
  return $[11] !== actionState.icon || $[12] !== actionState.label || $[13] !== actionState.tone || $[14] !== handleClick || $[15] !== hotkeys || $[16] !== t3 || $[17] !== t4 || $[18] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(MenuItem2, { "data-testid": t3, disabled: t4, hotkeys, icon: actionState.icon, onClick: handleClick, text: actionState.label, tone: actionState.tone, ...t5 }), $[11] = actionState.icon, $[12] = actionState.label, $[13] = actionState.tone, $[14] = handleClick, $[15] = hotkeys, $[16] = t3, $[17] = t4, $[18] = t5, $[19] = t6) : t6 = $[19], t6;
}
function _temp$y(s2) {
  return s2.slice(0, 1).toUpperCase() + s2.slice(1);
}
function useChipScrollPosition(containerRef) {
  const $ = (0, import_compiler_runtime2.c)(3), [showGradient, setShowGradient] = (0, import_react2.useState)(false);
  let t0, t1;
  return $[0] !== containerRef ? (t0 = () => {
    const checkOverflow = () => {
      const container = containerRef.current;
      if (!container)
        return;
      const {
        scrollWidth,
        clientWidth
      } = container;
      if (!(scrollWidth > clientWidth)) {
        setShowGradient(false);
        return;
      }
      const {
        scrollLeft
      } = container, isAtEnd = scrollLeft + clientWidth >= scrollWidth;
      setShowGradient(!isAtEnd);
    }, setupObservers = function() {
      checkOverflow();
      const container_0 = containerRef.current;
      if (!container_0)
        return {
          intersectionObserver: null,
          mutationObserver: null
        };
      const intersectionObserver = new IntersectionObserver((entries) => {
        const entry = entries[0];
        entry && setShowGradient(!entry.isIntersecting);
      }), updateLastChipObserver = () => {
        intersectionObserver.disconnect();
        const lastChip = container_0.children[container_0.children.length - 1];
        intersectionObserver.observe(lastChip);
      };
      updateLastChipObserver();
      const mutationObserver = new MutationObserver(() => {
        updateLastChipObserver(), checkOverflow();
      });
      return mutationObserver.observe(container_0, {
        childList: true,
        subtree: false
      }), {
        intersectionObserver,
        mutationObserver
      };
    }, {
      intersectionObserver: intersectionObserver_0,
      mutationObserver: mutationObserver_0
    } = setupObservers();
    return () => {
      intersectionObserver_0?.disconnect(), mutationObserver_0?.disconnect();
    };
  }, t1 = [containerRef], $[0] = containerRef, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), (0, import_react2.useEffect)(t0, t1), showGradient;
}
function NonReleaseVersionsSelect(props) {
  const $ = (0, import_compiler_runtime2.c)(43), {
    nonReleaseVersions,
    selectedPerspective,
    onSelectBundle,
    onCopyToDraftsNavigate,
    documentType,
    releasesLoading,
    releases
  } = props, {
    t: t2
  } = useTranslation(), [nonReleaseDropdownOpen, setNonReleaseDropdownOpen] = (0, import_react2.useState)(false), [popoverReferenceElement, setPopoverReferenceElement] = (0, import_react2.useState)(null);
  let t0;
  $[0] !== selectedPerspective ? (t0 = (v) => getVersionFromId(v) === selectedPerspective, $[0] = selectedPerspective, $[1] = t0) : t0 = $[1];
  let t1;
  $[2] !== nonReleaseVersions || $[3] !== t0 ? (t1 = extract(nonReleaseVersions, t0), $[2] = nonReleaseVersions, $[3] = t0, $[4] = t1) : t1 = $[4];
  const [selectedNonReleaseVersion, otherNonReleaseVersions] = t1, popoverRef = (0, import_react2.useRef)(null);
  let t22, t3;
  if ($[5] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t22 = (event) => {
    event.target && "matches" in event.target && typeof event.target.matches == "function" && event.target.matches("[data-portal] *") || setNonReleaseDropdownOpen(false);
  }, t3 = () => [popoverRef.current], $[5] = t22, $[6] = t3) : (t22 = $[5], t3 = $[6]), useClickOutsideEvent(t22, t3), nonReleaseVersions.length === 0)
    return null;
  let t4;
  $[7] !== documentType || $[8] !== onCopyToDraftsNavigate || $[9] !== onSelectBundle || $[10] !== releases || $[11] !== releasesLoading || $[12] !== selectedNonReleaseVersion ? (t4 = selectedNonReleaseVersion && (() => {
    const bundleId = getVersionFromId(selectedNonReleaseVersion);
    return (0, import_jsx_runtime2.jsx)(VersionChip$1, { selected: true, text: bundleId, tone: "default", onClick: () => onSelectBundle(bundleId), onCopyToDraftsNavigate, contextValues: {
      documentId: getPublishedId(selectedNonReleaseVersion),
      releases,
      releasesLoading,
      documentType,
      bundleId,
      isVersion: true
    } }, selectedNonReleaseVersion);
  })(), $[7] = documentType, $[8] = onCopyToDraftsNavigate, $[9] = onSelectBundle, $[10] = releases, $[11] = releasesLoading, $[12] = selectedNonReleaseVersion, $[13] = t4) : t4 = $[13];
  let t5;
  $[14] !== nonReleaseDropdownOpen || $[15] !== otherNonReleaseVersions.length || $[16] !== t2 ? (t5 = otherNonReleaseVersions.length > 0 ? (0, import_jsx_runtime2.jsx)(Tooltip, { content: t2("release.chip.tooltip.other-versions", {
    count: otherNonReleaseVersions.length
  }), fallbackPlacements: [], portal: true, placement: nonReleaseDropdownOpen ? "top" : "bottom", children: (0, import_jsx_runtime2.jsx)(Chip, { mode: "bleed", fontSize: 1, muted: true, selected: nonReleaseDropdownOpen, iconRight: nonReleaseDropdownOpen ? ChevronUpIcon : ChevronDownIcon, ref: setPopoverReferenceElement, onClick: () => setNonReleaseDropdownOpen(_temp$x), text: t2("release.chip.button.other-versions", {
    count: otherNonReleaseVersions.length
  }) }) }) : null, $[14] = nonReleaseDropdownOpen, $[15] = otherNonReleaseVersions.length, $[16] = t2, $[17] = t5) : t5 = $[17];
  let t6;
  if ($[18] !== documentType || $[19] !== onCopyToDraftsNavigate || $[20] !== onSelectBundle || $[21] !== otherNonReleaseVersions || $[22] !== releases || $[23] !== releasesLoading || $[24] !== selectedPerspective) {
    let t72;
    $[26] !== documentType || $[27] !== onCopyToDraftsNavigate || $[28] !== onSelectBundle || $[29] !== releases || $[30] !== releasesLoading || $[31] !== selectedPerspective ? (t72 = (nonReleaseVersionId) => {
      const bundle = getVersionFromId(nonReleaseVersionId);
      return (0, import_jsx_runtime2.jsx)(VersionChip$1, { selected: selectedPerspective === bundle, text: bundle, disabled: false, contextMenuPortal: false, tone: "default", onClick: () => onSelectBundle(bundle), onCopyToDraftsNavigate, contextValues: {
        documentId: getPublishedId(nonReleaseVersionId),
        releases,
        releasesLoading,
        documentType,
        bundleId: bundle,
        isVersion: true
      } }, nonReleaseVersionId);
    }, $[26] = documentType, $[27] = onCopyToDraftsNavigate, $[28] = onSelectBundle, $[29] = releases, $[30] = releasesLoading, $[31] = selectedPerspective, $[32] = t72) : t72 = $[32], t6 = otherNonReleaseVersions.map(t72), $[18] = documentType, $[19] = onCopyToDraftsNavigate, $[20] = onSelectBundle, $[21] = otherNonReleaseVersions, $[22] = releases, $[23] = releasesLoading, $[24] = selectedPerspective, $[25] = t6;
  } else
    t6 = $[25];
  let t7;
  $[33] !== t6 ? (t7 = (0, import_jsx_runtime2.jsx)(Container, { width: 1, children: (0, import_jsx_runtime2.jsx)(Flex, { width: 1, padding: 3, gap: 2, wrap: "wrap", children: t6 }) }), $[33] = t6, $[34] = t7) : t7 = $[34];
  let t8;
  $[35] !== nonReleaseDropdownOpen || $[36] !== popoverReferenceElement || $[37] !== t7 ? (t8 = (0, import_jsx_runtime2.jsx)(Popover2, { animate: false, open: nonReleaseDropdownOpen, portal: true, arrow: true, ref: popoverRef, placement: "bottom", referenceElement: popoverReferenceElement, zOffset: 10, content: t7 }), $[35] = nonReleaseDropdownOpen, $[36] = popoverReferenceElement, $[37] = t7, $[38] = t8) : t8 = $[38];
  let t9;
  return $[39] !== t4 || $[40] !== t5 || $[41] !== t8 ? (t9 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    t4,
    t5,
    t8
  ] }), $[39] = t4, $[40] = t5, $[41] = t8, $[42] = t9) : t9 = $[42], t9;
}
function _temp$x(v_0) {
  return !v_0;
}
function extract(xs, predicate) {
  const i = xs.findIndex(predicate), match = i === -1 ? void 0 : xs[i], rest = i === -1 ? xs : xs.slice(0, i).concat(xs.slice(i + 1));
  return [match, rest];
}
var TooltipContent$1 = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(16), {
    release
  } = t0, {
    t: t2
  } = useTranslation();
  if (release.state === "archived") {
    let t1;
    $[0] !== t2 ? (t1 = t2("release.chip.tooltip.archived"), $[0] = t2, $[1] = t1) : t1 = $[1];
    let t22;
    return $[2] !== t1 ? (t22 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: t1 }), $[2] = t1, $[3] = t22) : t22 = $[3], t22;
  }
  if (release.metadata.releaseType === "asap") {
    let t1;
    $[4] !== t2 ? (t1 = t2("release.type.asap"), $[4] = t2, $[5] = t1) : t1 = $[5];
    let t22;
    return $[6] !== t1 ? (t22 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: t1 }), $[6] = t1, $[7] = t22) : t22 = $[7], t22;
  }
  if (release.metadata.releaseType === "scheduled") {
    const isActive = release.state === "active";
    let t1;
    return $[8] !== isActive || $[9] !== release || $[10] !== t2 ? (t1 = release.metadata.intendedPublishAt && (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: isActive ? (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "release.chip.tooltip.intended-for-date", values: {
      date: formatRelativeLocalePublishDate(release)
    } }) : (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "release.chip.tooltip.scheduled-for-date", values: {
      date: formatRelativeLocalePublishDate(release)
    } }) }), $[8] = isActive, $[9] = release, $[10] = t2, $[11] = t1) : t1 = $[11], t1;
  }
  if (release.metadata.releaseType === "undecided") {
    let t1;
    $[12] !== t2 ? (t1 = t2("release.type.undecided"), $[12] = t2, $[13] = t1) : t1 = $[13];
    let t22;
    return $[14] !== t1 ? (t22 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: t1 }), $[14] = t1, $[15] = t22) : t22 = $[15], t22;
  }
  return null;
};
var DATE_TIME_FORMAT = {
  dateStyle: "medium",
  timeStyle: "short"
};
var DocumentPerspectiveList = (0, import_react2.memo)(function() {
  const $ = (0, import_compiler_runtime2.c)(112), {
    selectedReleaseId,
    selectedPerspectiveName
  } = usePerspective(), {
    t: t2
  } = useTranslation(), setPerspective = useSetPerspective(), {
    params,
    setParams
  } = usePaneRouter(), dateTimeFormat = useDateTimeFormat(DATE_TIME_FORMAT), {
    loading
  } = useActiveReleases(), schema = useSchema(), {
    editState,
    displayed,
    documentType,
    documentId
  } = useDocumentPane(), isCreatingDocument = displayed && !displayed._createdAt, defaultPerspective = useGetDefaultPerspective(), t0 = params?.historyVersion;
  let t1;
  $[0] !== displayed || $[1] !== documentId || $[2] !== t0 ? (t1 = {
    historyVersion: t0,
    displayed,
    documentId
  }, $[0] = displayed, $[1] = documentId, $[2] = t0, $[3] = t1) : t1 = $[3];
  const filteredReleases = useFilteredReleases(t1);
  let t22;
  $[4] !== documentId ? (t22 = {
    documentId
  }, $[4] = documentId, $[5] = t22) : t22 = $[5];
  const {
    data: documentVersions
  } = useDocumentVersions(t22);
  let t3;
  $[6] !== documentVersions ? (t3 = documentVersions && documentVersions.length > 0 && !documentVersions.some(_temp$w), $[6] = documentVersions, $[7] = t3) : t3 = $[7];
  const onlyHasVersions = t3, workspace = useWorkspace(), {
    onSetScheduledDraftPerspective
  } = useSingleDocRelease();
  let t4;
  $[8] !== onSetScheduledDraftPerspective || $[9] !== params?.scheduledDraft || $[10] !== setPerspective ? (t4 = () => {
    params?.scheduledDraft ? onSetScheduledDraftPerspective("") : setPerspective("drafts");
  }, $[8] = onSetScheduledDraftPerspective, $[9] = params?.scheduledDraft, $[10] = setPerspective, $[11] = t4) : t4 = $[11];
  const handleCopyToDraftsNavigate = t4;
  let t5;
  $[12] !== defaultPerspective || $[13] !== onSetScheduledDraftPerspective || $[14] !== params || $[15] !== setParams || $[16] !== setPerspective ? (t5 = (perspective) => {
    if (isReleaseDocument(perspective) && isCardinalityOneRelease(perspective)) {
      onSetScheduledDraftPerspective(getReleaseIdFromReleaseDocumentId(perspective._id));
      return;
    }
    perspective === "published" && params?.historyVersion && setParams({
      ...params,
      rev: params?.historyEvent || void 0,
      since: void 0,
      historyVersion: void 0
    });
    const newPerspective = isReleaseDocument(perspective) ? getReleaseIdFromReleaseDocumentId(perspective._id) : perspective === defaultPerspective ? "" : perspective;
    params?.scheduledDraft ? setParams({
      ...params,
      scheduledDraft: void 0
    }, {
      perspective: newPerspective
    }) : setPerspective(newPerspective);
  }, $[12] = defaultPerspective, $[13] = onSetScheduledDraftPerspective, $[14] = params, $[15] = setParams, $[16] = setPerspective, $[17] = t5) : t5 = $[17];
  const handlePerspectiveChange = t5;
  let t6;
  if ($[18] !== documentType || $[19] !== schema) {
    const schemaType = schema.get(documentType);
    t6 = schemaType ? isLiveEditEnabled(schemaType) : false, $[18] = documentType, $[19] = schema, $[20] = t6;
  } else
    t6 = $[20];
  const isLiveEdit = t6;
  let t7;
  bb0: {
    if (isLiveEdit && !selectedReleaseId) {
      t7 = false;
      break bb0;
    }
    t7 = !editState?.published;
  }
  const isPublishedChipDisabled = t7;
  let t8;
  $[21] !== displayed?._id || $[22] !== editState?.version || $[23] !== params ? (t8 = (release) => {
    if (!params?.historyVersion) {
      const isCurrentVersionGoingToUnpublish = editState?.version && isGoingToUnpublish(editState?.version) && getReleaseIdFromReleaseDocumentId(release._id) === getVersionFromId(editState?.version?._id);
      return {
        selected: !!(getReleaseIdFromReleaseDocumentId(release._id) === getVersionFromId(displayed?._id || "") || isCurrentVersionGoingToUnpublish)
      };
    }
    const isReleaseHistoryMatch = getReleaseIdFromReleaseDocumentId(release._id) === params.historyVersion;
    return {
      selected: isReleaseHistoryMatch,
      disabled: isReleaseHistoryMatch
    };
  }, $[21] = displayed?._id, $[22] = editState?.version, $[23] = params, $[24] = t8) : t8 = $[24];
  const getReleaseChipState = t8;
  let t9;
  $[25] !== displayed?._id || $[26] !== editState?.draft?._id || $[27] !== isLiveEdit || $[28] !== selectedPerspectiveName || $[29] !== selectedReleaseId ? (t9 = () => !!(isLiveEdit && !editState?.draft?._id && !selectedReleaseId || isPublishedId(displayed?._id || "") && isPublishedPerspective(selectedPerspectiveName || "")), $[25] = displayed?._id, $[26] = editState?.draft?._id, $[27] = isLiveEdit, $[28] = selectedPerspectiveName, $[29] = selectedReleaseId, $[30] = t9) : t9 = $[30];
  const isPublishSelected = t9();
  let t10;
  bb1: {
    const displayedId = displayed?._id || "";
    if (isPublishSelected) {
      t10 = false;
      break bb1;
    }
    if (params?.historyVersion) {
      t10 = false;
      break bb1;
    }
    if (selectedPerspectiveName) {
      t10 = false;
      break bb1;
    }
    if (isVersionId(displayedId)) {
      t10 = false;
      break bb1;
    }
    if (isDraftId(displayedId)) {
      t10 = true;
      break bb1;
    }
    if (isPublishedId(displayedId) && editState?.published && isPublishedPerspective(selectedPerspectiveName || "")) {
      t10 = false;
      break bb1;
    }
    t10 = true;
  }
  const isDraftSelected = t10;
  let t11;
  $[31] !== editState?.draft || $[32] !== isCreatingDocument || $[33] !== isLiveEdit || $[34] !== onlyHasVersions || $[35] !== selectedReleaseId ? (t11 = () => onlyHasVersions || isCreatingDocument && selectedReleaseId ? true : !editState?.draft && !isLiveEdit ? false : !!(isCreatingDocument && selectedReleaseId || isLiveEdit), $[31] = editState?.draft, $[32] = isCreatingDocument, $[33] = isLiveEdit, $[34] = onlyHasVersions, $[35] = selectedReleaseId, $[36] = t11) : t11 = $[36];
  const isDraftDisabled = t11(), isDraftModelEnabled = workspace.document.drafts?.enabled;
  let t12;
  if ($[37] !== documentVersions || $[38] !== filteredReleases.currentReleases) {
    let t132;
    $[40] !== filteredReleases.currentReleases ? (t132 = (versionDocumentId) => isPublishedId(versionDocumentId) || isDraftId(versionDocumentId) ? false : !filteredReleases.currentReleases.some((release_0) => getReleaseIdFromReleaseDocumentId(release_0._id) === getVersionFromId(versionDocumentId)), $[40] = filteredReleases.currentReleases, $[41] = t132) : t132 = $[41], t12 = documentVersions.filter(t132), $[37] = documentVersions, $[38] = filteredReleases.currentReleases, $[39] = t12;
  } else
    t12 = $[39];
  const nonReleaseVersions = t12;
  let t13;
  $[42] !== dateTimeFormat || $[43] !== editState?.published || $[44] !== t2 ? (t13 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: editState?.published && editState?.published?._updatedAt ? (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "release.chip.tooltip.published-date", values: {
    date: dateTimeFormat.format(new Date(editState?.published._updatedAt))
  } }) : (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: t2("release.chip.tooltip.not-published") }) }), $[42] = dateTimeFormat, $[43] = editState?.published, $[44] = t2, $[45] = t13) : t13 = $[45];
  let t14;
  $[46] !== handlePerspectiveChange ? (t14 = () => handlePerspectiveChange("published"), $[46] = handlePerspectiveChange, $[47] = t14) : t14 = $[47];
  let t15;
  $[48] !== t2 ? (t15 = t2("release.chip.published"), $[48] = t2, $[49] = t15) : t15 = $[49];
  const t16 = editState?.published?._id || editState?.id || "", t17 = !editState?.published;
  let t18;
  $[50] !== documentType || $[51] !== filteredReleases.notCurrentReleases || $[52] !== loading || $[53] !== t16 || $[54] !== t17 ? (t18 = {
    documentId: t16,
    releases: filteredReleases.notCurrentReleases,
    releasesLoading: loading,
    documentType,
    bundleId: "published",
    isVersion: false,
    disabled: t17
  }, $[50] = documentType, $[51] = filteredReleases.notCurrentReleases, $[52] = loading, $[53] = t16, $[54] = t17, $[55] = t18) : t18 = $[55];
  let t19;
  $[56] !== handleCopyToDraftsNavigate || $[57] !== isPublishSelected || $[58] !== isPublishedChipDisabled || $[59] !== t13 || $[60] !== t14 || $[61] !== t15 || $[62] !== t18 ? (t19 = (0, import_jsx_runtime2.jsx)(VersionChip$1, { tooltipContent: t13, disabled: isPublishedChipDisabled, onClick: t14, selected: isPublishSelected, text: t15, tone: "positive", onCopyToDraftsNavigate: handleCopyToDraftsNavigate, contextValues: t18 }), $[56] = handleCopyToDraftsNavigate, $[57] = isPublishSelected, $[58] = isPublishedChipDisabled, $[59] = t13, $[60] = t14, $[61] = t15, $[62] = t18, $[63] = t19) : t19 = $[63];
  let t20;
  $[64] !== dateTimeFormat || $[65] !== documentType || $[66] !== editState?.draft || $[67] !== editState?.id || $[68] !== editState?.published?._id || $[69] !== filteredReleases.notCurrentReleases || $[70] !== handleCopyToDraftsNavigate || $[71] !== handlePerspectiveChange || $[72] !== isDraftDisabled || $[73] !== isDraftModelEnabled || $[74] !== isDraftSelected || $[75] !== isLiveEdit || $[76] !== loading || $[77] !== t2 ? (t20 = isDraftModelEnabled && (0, import_jsx_runtime2.jsx)(VersionChip$1, { tooltipContent: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: editState?.draft ? (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: editState?.draft._updatedAt ? (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "release.chip.tooltip.edited-date", values: {
    date: dateTimeFormat.format(new Date(editState?.draft._updatedAt))
  } }) : (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "release.chip.tooltip.created-date", values: {
    date: dateTimeFormat.format(new Date(editState?.draft._createdAt))
  } }) }) : (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: t2(isLiveEdit ? "release.chip.tooltip.draft-disabled.live-edit" : "release.chip.tooltip.no-edits") }) }), selected: isDraftSelected, disabled: isDraftDisabled, text: t2("release.chip.draft"), tone: editState?.draft ? "caution" : "neutral", onClick: () => handlePerspectiveChange("drafts"), onCopyToDraftsNavigate: handleCopyToDraftsNavigate, contextValues: {
    documentId: editState?.draft?._id || editState?.published?._id || editState?.id || "",
    documentType,
    releases: filteredReleases.notCurrentReleases,
    releasesLoading: loading,
    bundleId: "draft",
    isVersion: false
  } }), $[64] = dateTimeFormat, $[65] = documentType, $[66] = editState?.draft, $[67] = editState?.id, $[68] = editState?.published?._id, $[69] = filteredReleases.notCurrentReleases, $[70] = handleCopyToDraftsNavigate, $[71] = handlePerspectiveChange, $[72] = isDraftDisabled, $[73] = isDraftModelEnabled, $[74] = isDraftSelected, $[75] = isLiveEdit, $[76] = loading, $[77] = t2, $[78] = t20) : t20 = $[78];
  let t21;
  $[79] !== displayed?._id || $[80] !== documentType || $[81] !== filteredReleases.inCreation || $[82] !== filteredReleases.notCurrentReleases || $[83] !== handleCopyToDraftsNavigate || $[84] !== loading || $[85] !== t2 ? (t21 = filteredReleases.inCreation && (0, import_jsx_runtime2.jsx)(ReleaseTitle, { title: filteredReleases.inCreation.metadata.title, fallback: t2("release.placeholder-untitled-release"), enableTooltip: false, children: (t2222) => {
    const {
      displayTitle,
      fullTitle,
      isTruncated
    } = t2222;
    return (0, import_jsx_runtime2.jsx)(VersionChip$1, { tooltipContent: isTruncated ? (0, import_jsx_runtime2.jsxs)(Stack, { space: 2, style: {
      maxWidth: "300px"
    }, children: [
      (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: fullTitle }),
      (0, import_jsx_runtime2.jsx)(TooltipContent$1, { release: filteredReleases.inCreation })
    ] }) : (0, import_jsx_runtime2.jsx)(TooltipContent$1, { release: filteredReleases.inCreation }), selected: true, onClick: _temp2$f, locked: false, tone: getReleaseTone(filteredReleases.inCreation), text: displayTitle, onCopyToDraftsNavigate: handleCopyToDraftsNavigate, contextValues: {
      documentId: displayed?._id || "",
      documentType,
      disabled: true,
      releases: filteredReleases.notCurrentReleases,
      releasesLoading: loading,
      bundleId: getReleaseIdFromReleaseDocumentId(filteredReleases.inCreation._id),
      isVersion: true,
      release: filteredReleases.inCreation
    } });
  } }), $[79] = displayed?._id, $[80] = documentType, $[81] = filteredReleases.inCreation, $[82] = filteredReleases.notCurrentReleases, $[83] = handleCopyToDraftsNavigate, $[84] = loading, $[85] = t2, $[86] = t21) : t21 = $[86];
  let t222;
  $[87] !== displayed || $[88] !== documentType || $[89] !== editState?.version || $[90] !== filteredReleases.currentReleases || $[91] !== filteredReleases.notCurrentReleases || $[92] !== getReleaseChipState || $[93] !== handleCopyToDraftsNavigate || $[94] !== handlePerspectiveChange || $[95] !== loading || $[96] !== t2 ? (t222 = displayed && filteredReleases.currentReleases?.map((release_1) => (0, import_jsx_runtime2.jsx)(ReleaseTitle, { title: release_1.metadata.title, fallback: t2("release.placeholder-untitled-release"), enableTooltip: false, children: (t232) => {
    const {
      displayTitle: displayTitle_0,
      fullTitle: fullTitle_0,
      isTruncated: isTruncated_0
    } = t232;
    return (0, import_jsx_runtime2.jsx)(VersionChip$1, { tooltipContent: isTruncated_0 ? (0, import_jsx_runtime2.jsxs)(Stack, { space: 2, style: {
      maxWidth: "300px"
    }, children: [
      (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: fullTitle_0 }),
      (0, import_jsx_runtime2.jsx)(TooltipContent$1, { release: release_1 })
    ] }) : (0, import_jsx_runtime2.jsx)(TooltipContent$1, { release: release_1 }), ...getReleaseChipState(release_1), onClick: () => handlePerspectiveChange(release_1), text: displayTitle_0, tone: getReleaseTone(release_1), locked: isReleaseScheduledOrScheduling(release_1), onCopyToDraftsNavigate: handleCopyToDraftsNavigate, contextValues: {
      documentId: displayed?._id || "",
      documentType,
      releases: filteredReleases.notCurrentReleases,
      releasesLoading: loading,
      bundleId: getReleaseIdFromReleaseDocumentId(release_1._id),
      isVersion: true,
      release: release_1,
      isGoingToUnpublish: editState?.version ? isGoingToUnpublish(editState?.version) : false
    } });
  } }, release_1._id)), $[87] = displayed, $[88] = documentType, $[89] = editState?.version, $[90] = filteredReleases.currentReleases, $[91] = filteredReleases.notCurrentReleases, $[92] = getReleaseChipState, $[93] = handleCopyToDraftsNavigate, $[94] = handlePerspectiveChange, $[95] = loading, $[96] = t2, $[97] = t222) : t222 = $[97];
  let t23;
  $[98] !== documentType || $[99] !== filteredReleases.notCurrentReleases || $[100] !== handleCopyToDraftsNavigate || $[101] !== handlePerspectiveChange || $[102] !== loading || $[103] !== nonReleaseVersions || $[104] !== selectedPerspectiveName ? (t23 = (0, import_jsx_runtime2.jsx)(NonReleaseVersionsSelect, { nonReleaseVersions, selectedPerspective: selectedPerspectiveName, onSelectBundle: handlePerspectiveChange, onCopyToDraftsNavigate: handleCopyToDraftsNavigate, releases: filteredReleases.notCurrentReleases, releasesLoading: loading, documentType }), $[98] = documentType, $[99] = filteredReleases.notCurrentReleases, $[100] = handleCopyToDraftsNavigate, $[101] = handlePerspectiveChange, $[102] = loading, $[103] = nonReleaseVersions, $[104] = selectedPerspectiveName, $[105] = t23) : t23 = $[105];
  let t24;
  return $[106] !== t19 || $[107] !== t20 || $[108] !== t21 || $[109] !== t222 || $[110] !== t23 ? (t24 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    t19,
    t20,
    t21,
    t222,
    t23
  ] }), $[106] = t19, $[107] = t20, $[108] = t21, $[109] = t222, $[110] = t23, $[111] = t24) : t24 = $[111], t24;
});
function _temp$w(version) {
  return !isVersionId(version);
}
function _temp2$f() {
}
var HorizontalScroller = at(Card).withConfig({
  displayName: "HorizontalScroller",
  componentId: "sc-4smkq-0"
})((props) => {
  const theme = getTheme_v2(props.theme);
  return rt`
    scrollbar-width: none;
    z-index: 1;
    flex: 1;
    position: relative;
    > div {
      &::-webkit-scrollbar {
        width: 0;
        height: 0;
      }
    }

    ${props.$showGradient && rt`
      &::after {
        content: '';
        display: block;
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        width: 150px;
        background: linear-gradient(to right, ${rgba(theme.color.bg, 0)}, var(--card-bg-color));
        transition: 'opacity 300ms ease-out';
        pointer-events: none;
      }
    `}
  `;
});
var DocumentPanelHeader = (0, import_react2.memo)((0, import_react2.forwardRef)(function(_props, ref) {
  const $ = (0, import_compiler_runtime2.c)(41), {
    menuItems
  } = _props, {
    editState,
    onMenuAction,
    onPaneClose,
    onPaneSplit,
    onSetMaximizedPane,
    menuItemGroups,
    schemaType,
    connectionState,
    views: views2,
    unstable_languageFilter,
    documentId
  } = useDocumentPane(), {
    features
  } = useStructureTool(), {
    index,
    BackLink: BackLink2,
    hasGroupSiblings
  } = usePaneRouter(), {
    maximizedPane
  } = useResolvedPanesList(), {
    actions: fieldActions
  } = useFieldActions(), [referenceElement, setReferenceElement] = (0, import_react2.useState)(null), scrollContainerRef = (0, import_react2.useRef)(null), showGradient = useChipScrollPosition(scrollContainerRef), telemetry = useTelemetry();
  let t0;
  $[0] !== fieldActions || $[1] !== menuItemGroups || $[2] !== menuItems || $[3] !== onMenuAction ? (t0 = resolveMenuNodes({
    actionHandler: onMenuAction,
    fieldActions,
    menuItems,
    menuItemGroups
  }), $[0] = fieldActions, $[1] = menuItemGroups, $[2] = menuItems, $[3] = onMenuAction, $[4] = t0) : t0 = $[4];
  const menuNodes = t0;
  let t1;
  $[5] !== menuNodes ? (t1 = menuNodes.filter(isMenuNodeButton), $[5] = menuNodes, $[6] = t1) : t1 = $[6];
  const menuButtonNodes = t1;
  let t2;
  $[7] !== menuNodes ? (t2 = menuNodes.filter(isNotMenuNodeButton), $[7] = menuNodes, $[8] = t2) : t2 = $[8];
  const contextMenuNodes = t2, {
    collapsed,
    isLast
  } = usePane(), tabIndex = isLast && !collapsed ? -1 : 0, showSplitPaneButton = features.splitViews && onPaneSplit && views2.length > 1, showSplitPaneCloseButton = showSplitPaneButton && hasGroupSiblings, showBackButton = features.backButton && index > 0, showPaneGroupCloseButton = !showSplitPaneCloseButton && !showBackButton && !!BackLink2, {
    t: t3
  } = useTranslation(structureLocaleNamespace), isMaximizedPane = maximizedPane?.pane && typeof maximizedPane.pane == "object" && maximizedPane.pane.type === "document" && maximizedPane.pane.options.id === documentId;
  let t32;
  $[9] !== isMaximizedPane || $[10] !== onSetMaximizedPane || $[11] !== telemetry ? (t32 = () => {
    onSetMaximizedPane?.(), isMaximizedPane ? telemetry.log(FocusDocumentPaneCollapsed) : telemetry.log(FocusDocumentPaneClicked);
  }, $[9] = isMaximizedPane, $[10] = onSetMaximizedPane, $[11] = telemetry, $[12] = t32) : t32 = $[12];
  const handleFocusPane = t32;
  let t4;
  $[13] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t4 = (0, import_jsx_runtime2.jsx)(DocumentHeaderTitle, {}), $[13] = t4) : t4 = $[13];
  const title = t4;
  let t5;
  $[14] !== BackLink2 || $[15] !== showBackButton || $[16] !== t3 ? (t5 = showBackButton && (0, import_jsx_runtime2.jsx)(Button2, { as: BackLink2, "data-as": "a", icon: ArrowLeftIcon, mode: "bleed", tooltipProps: {
    content: t3("pane-header.back-button.text")
  } }), $[14] = BackLink2, $[15] = showBackButton, $[16] = t3, $[17] = t5) : t5 = $[17];
  const backButton = t5;
  let t6;
  return $[18] !== BackLink2 || $[19] !== backButton || $[20] !== collapsed || $[21] !== connectionState || $[22] !== contextMenuNodes || $[23] !== editState || $[24] !== handleFocusPane || $[25] !== isMaximizedPane || $[26] !== menuButtonNodes || $[27] !== onPaneClose || $[28] !== onPaneSplit || $[29] !== onSetMaximizedPane || $[30] !== ref || $[31] !== referenceElement || $[32] !== schemaType || $[33] !== showGradient || $[34] !== showPaneGroupCloseButton || $[35] !== showSplitPaneButton || $[36] !== showSplitPaneCloseButton || $[37] !== t3 || $[38] !== tabIndex || $[39] !== unstable_languageFilter ? (t6 = (0, import_jsx_runtime2.jsx)(TooltipDelayGroupProvider, { children: collapsed ? (0, import_jsx_runtime2.jsx)(PaneHeader$1, { border: true, ref, loading: connectionState === "connecting" && !editState?.draft && !editState?.published, title, tabIndex, backButton }) : (0, import_jsx_runtime2.jsx)(Card, { hidden: collapsed, style: {
    lineHeight: 0
  }, borderBottom: true, children: (0, import_jsx_runtime2.jsxs)(Flex, { gap: 3, paddingY: 3, children: [
    (0, import_jsx_runtime2.jsx)(HorizontalScroller, { $showGradient: showGradient, children: (0, import_jsx_runtime2.jsx)(Flex, { flex: 1, gap: 1, overflow: "auto", paddingX: 3, "data-testid": "document-perspective-list", ref: scrollContainerRef, children: (0, import_jsx_runtime2.jsx)(DocumentPerspectiveList, {}) }) }),
    (0, import_jsx_runtime2.jsx)(Box, { flex: "none", paddingRight: 3, children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 1, children: [
      unstable_languageFilter.length > 0 && (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: unstable_languageFilter.map((LanguageFilterComponent, idx) => (0, import_jsx_runtime2.jsx)(LanguageFilterComponent, { schemaType }, `language-filter-${idx}`)) }),
      menuButtonNodes.map(_temp$v),
      editState && (0, import_jsx_runtime2.jsx)(RenderActionCollectionState, { group: "paneActions", children: (t7) => {
        const {
          states
        } = t7;
        return (0, import_jsx_runtime2.jsx)(DocumentPanelHeaderActionDialogDeferred, { contextMenuNodes, setReferenceElement, referenceElement, states });
      } }),
      showSplitPaneButton && (0, import_jsx_runtime2.jsx)(Button2, { "aria-label": t3("buttons.split-pane-button.aria-label"), icon: SplitVerticalIcon, mode: "bleed", onClick: onPaneSplit, tooltipProps: {
        content: t3("buttons.split-pane-button.tooltip")
      } }, "split-pane-button"),
      onSetMaximizedPane && (0, import_jsx_runtime2.jsx)(Button2, { "aria-label": t3(isMaximizedPane ? "buttons.focus-pane-button.aria-label.collapse" : "buttons.focus-pane-button.aria-label.focus"), icon: isMaximizedPane ? CollapseIcon : ExpandIcon, mode: "bleed", onClick: handleFocusPane, tooltipProps: {
        content: t3(isMaximizedPane ? "buttons.focus-pane-button.tooltip.collapse" : "buttons.focus-pane-button.tooltip.focus")
      }, "data-testid": isMaximizedPane ? "focus-pane-button-collapse" : "focus-pane-button-focus" }, "focus-pane-button"),
      showSplitPaneCloseButton && (0, import_jsx_runtime2.jsx)(Button2, { icon: CloseIcon, mode: "bleed", onClick: onPaneClose, tooltipProps: {
        content: t3("buttons.split-pane-close-button.title")
      } }, "close-view-button"),
      showPaneGroupCloseButton && (0, import_jsx_runtime2.jsx)(Button2, { icon: CloseIcon, mode: "bleed", tooltipProps: {
        content: t3("buttons.split-pane-close-group-button.title")
      }, as: BackLink2 }, "close-view-button")
    ] }) })
  ] }) }) }), $[18] = BackLink2, $[19] = backButton, $[20] = collapsed, $[21] = connectionState, $[22] = contextMenuNodes, $[23] = editState, $[24] = handleFocusPane, $[25] = isMaximizedPane, $[26] = menuButtonNodes, $[27] = onPaneClose, $[28] = onPaneSplit, $[29] = onSetMaximizedPane, $[30] = ref, $[31] = referenceElement, $[32] = schemaType, $[33] = showGradient, $[34] = showPaneGroupCloseButton, $[35] = showSplitPaneButton, $[36] = showSplitPaneCloseButton, $[37] = t3, $[38] = tabIndex, $[39] = unstable_languageFilter, $[40] = t6) : t6 = $[40], t6;
}));
var DocumentPanelHeaderActionDialogDeferred = (0, import_react2.memo)(function(props) {
  const $ = (0, import_compiler_runtime2.c)(7), {
    setReferenceElement,
    referenceElement,
    contextMenuNodes
  } = props, states = (0, import_react2.useDeferredValue)(props.states);
  let t0;
  $[0] !== states ? (t0 = states.filter(_temp2$e), $[0] = states, $[1] = t0) : t0 = $[1];
  let t1;
  return $[2] !== contextMenuNodes || $[3] !== referenceElement || $[4] !== setReferenceElement || $[5] !== t0 ? (t1 = (0, import_jsx_runtime2.jsx)(DocumentPanelHeaderActionDialog, { setReferenceElement, referenceElement, contextMenuNodes, states: t0 }), $[2] = contextMenuNodes, $[3] = referenceElement, $[4] = setReferenceElement, $[5] = t0, $[6] = t1) : t1 = $[6], t1;
});
var DocumentPanelHeaderActionDialog = (0, import_react2.memo)(function(props) {
  const $ = (0, import_compiler_runtime2.c)(8), {
    states,
    setReferenceElement,
    contextMenuNodes,
    referenceElement
  } = props;
  let t0;
  $[0] !== contextMenuNodes || $[1] !== setReferenceElement || $[2] !== states ? (t0 = (t12) => {
    const {
      handleAction
    } = t12;
    return (0, import_jsx_runtime2.jsx)("div", { ref: setReferenceElement, children: (0, import_jsx_runtime2.jsx)(PaneContextMenuButton, { nodes: contextMenuNodes, actionsNodes: states.length > 0 ? states.map((actionState, actionIndex) => (0, import_jsx_runtime2.jsx)(ActionMenuListItem, { actionState, disabled: !!actionState.disabled, index: actionIndex, onAction: handleAction }, actionState.label)) : void 0 }, "context-menu") });
  }, $[0] = contextMenuNodes, $[1] = setReferenceElement, $[2] = states, $[3] = t0) : t0 = $[3];
  const renderActionDialog = t0;
  let t1;
  return $[4] !== referenceElement || $[5] !== renderActionDialog || $[6] !== states ? (t1 = (0, import_jsx_runtime2.jsx)(ActionDialogWrapper, { actionStates: states, referenceElement, children: renderActionDialog }), $[4] = referenceElement, $[5] = renderActionDialog, $[6] = states, $[7] = t1) : t1 = $[7], t1;
});
function _temp$v(item) {
  return (0, import_jsx_runtime2.jsx)(PaneHeaderActionButton, { node: item }, item.key);
}
function _temp2$e(state2) {
  return state2.action ? state2.action !== useHistoryRestoreAction.action : true;
}
function SpacerButton(t0) {
  const $ = (0, import_compiler_runtime2.c)(3), {
    size
  } = t0;
  let t1;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = {
    pointerEvents: "none",
    visibility: "hidden",
    width: 0
  }, $[0] = t1) : t1 = $[0];
  let t2;
  return $[1] !== size ? (t2 = (0, import_jsx_runtime2.jsx)(Button2, { "aria-hidden": true, disabled: true, size, style: t1, text: "-" }), $[1] = size, $[2] = t2) : t2 = $[2], t2;
}
var BADGE_TONES = {
  primary: "primary",
  success: "positive",
  warning: "caution",
  danger: "critical"
};
var DocumentBadgesInner = (0, import_react2.memo)(function(t0) {
  const $ = (0, import_compiler_runtime2.c)(4), {
    states
  } = t0;
  if (states.length === 0)
    return null;
  let t1;
  $[0] !== states ? (t1 = states.map(_temp$u), $[0] = states, $[1] = t1) : t1 = $[1];
  let t2;
  return $[2] !== t1 ? (t2 = (0, import_jsx_runtime2.jsx)(Inline, { space: 1, children: t1 }), $[2] = t1, $[3] = t2) : t2 = $[3], t2;
});
var DocumentBadgesDeferred = (0, import_react2.memo)(function(props) {
  const $ = (0, import_compiler_runtime2.c)(2), states = (0, import_react2.useDeferredValue)(props.states);
  let t0;
  return $[0] !== states ? (t0 = (0, import_jsx_runtime2.jsx)(DocumentBadgesInner, { states }), $[0] = states, $[1] = t0) : t0 = $[1], t0;
});
function DocumentBadges() {
  const $ = (0, import_compiler_runtime2.c)(3), {
    badges,
    editState
  } = useDocumentPane(), renderDocumentBadges = _temp2$d;
  if (!editState || !badges)
    return null;
  let t0;
  return $[0] !== badges || $[1] !== editState ? (t0 = (0, import_jsx_runtime2.jsx)(RenderBadgeCollectionState, { badges, badgeProps: editState, children: renderDocumentBadges }), $[0] = badges, $[1] = editState, $[2] = t0) : t0 = $[2], t0;
}
function _temp2$d(t0) {
  const {
    states
  } = t0;
  return (0, import_jsx_runtime2.jsx)(DocumentBadgesDeferred, { states });
}
function _temp$u(badge, index) {
  return (0, import_jsx_runtime2.jsx)(Tooltip, { content: badge.title, disabled: !badge.title, placement: "top", portal: true, children: (0, import_jsx_runtime2.jsx)(Badge, { fontSize: 1, mode: "outline", paddingX: 2, paddingY: 1, radius: 4, tone: badge.color ? BADGE_TONES[badge.color] : void 0, style: {
    whiteSpace: "nowrap"
  }, children: badge.label }) }, `${badge.label}-${index}`);
}
var DISABLED_REASON_TITLE_KEY$1 = {
  NOTHING_TO_DELETE: "action.delete.disabled.nothing-to-delete",
  NOT_READY: "action.delete.disabled.not-ready"
};
var useDeleteAction = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(41), {
    id,
    type,
    draft,
    version
  } = t0;
  let t1;
  $[0] !== version ? (t1 = version?._id && getVersionFromId(version._id), $[0] = version, $[1] = t1) : t1 = $[1];
  const bundleId = t1, {
    delete: deleteOp
  } = useDocumentOperation(id, type, bundleId), [isDeleting, setIsDeleting] = (0, import_react2.useState)(false), [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react2.useState)(false), {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t22;
  $[2] !== id ? (t22 = {
    documentId: id
  }, $[2] = id, $[3] = t22) : t22 = $[3];
  const {
    sortedDocumentList
  } = useDocumentVersionTypeSortedList(t22);
  let t3;
  $[4] !== sortedDocumentList ? (t3 = sortedDocumentList.some(isReleaseScheduledOrScheduling), $[4] = sortedDocumentList, $[5] = t3) : t3 = $[5];
  const hasScheduledRelease = t3;
  let t4;
  $[6] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t4 = () => {
    setConfirmDialogOpen(false);
  }, $[6] = t4) : t4 = $[6];
  const handleCancel = t4;
  let t5;
  $[7] !== deleteOp ? (t5 = (versions) => {
    setConfirmDialogOpen(false), setIsDeleting(true), deleteOp.execute(versions), setIsDeleting(false);
  }, $[7] = deleteOp, $[8] = t5) : t5 = $[8];
  const handleConfirm = t5;
  let t6;
  $[9] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t6 = () => {
    setConfirmDialogOpen(true);
  }, $[9] = t6) : t6 = $[9];
  const handle = t6;
  let t7;
  $[10] !== bundleId || $[11] !== id || $[12] !== type ? (t7 = {
    id,
    type,
    version: bundleId,
    permission: "delete"
  }, $[10] = bundleId, $[11] = id, $[12] = type, $[13] = t7) : t7 = $[13];
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions(t7), currentUser = useCurrentUser();
  let t8;
  bb0: {
    if (!isPermissionsLoading && !permissions?.granted) {
      let t92;
      $[14] !== t2 ? (t92 = t2("action.delete.label"), $[14] = t2, $[15] = t92) : t92 = $[15];
      let t102;
      $[16] !== currentUser ? (t102 = (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessage, { context: "delete-document", currentUser }), $[16] = currentUser, $[17] = t102) : t102 = $[17];
      let t112;
      $[18] !== t102 || $[19] !== t92 ? (t112 = {
        tone: "critical",
        icon: TrashIcon,
        disabled: true,
        label: t92,
        title: t102
      }, $[18] = t102, $[19] = t92, $[20] = t112) : t112 = $[20], t8 = t112;
      break bb0;
    }
    let t9;
    $[21] !== deleteOp.disabled || $[22] !== hasScheduledRelease || $[23] !== t2 ? (t9 = () => hasScheduledRelease ? t2("action.delete.disabled.scheduled-release") : deleteOp.disabled ? t2(DISABLED_REASON_TITLE_KEY$1[deleteOp.disabled]) : "", $[21] = deleteOp.disabled, $[22] = hasScheduledRelease, $[23] = t2, $[24] = t9) : t9 = $[24];
    const getTitle = t9, t10 = isDeleting || hasScheduledRelease || !!deleteOp.disabled || isPermissionsLoading;
    let t11;
    $[25] !== getTitle ? (t11 = getTitle(), $[25] = getTitle, $[26] = t11) : t11 = $[26];
    let t12;
    $[27] !== isDeleting || $[28] !== t2 ? (t12 = t2(isDeleting ? "action.delete.running.label" : "action.delete.label"), $[27] = isDeleting, $[28] = t2, $[29] = t12) : t12 = $[29];
    let t13;
    $[30] !== draft?._id || $[31] !== handleConfirm || $[32] !== id || $[33] !== isConfirmDialogOpen || $[34] !== type ? (t13 = isConfirmDialogOpen && {
      type: "custom",
      component: (0, import_jsx_runtime2.jsx)(ConfirmDeleteDialogContainer, { action: "delete", id: draft?._id || id, type, onCancel: handleCancel, onConfirm: handleConfirm })
    }, $[30] = draft?._id, $[31] = handleConfirm, $[32] = id, $[33] = isConfirmDialogOpen, $[34] = type, $[35] = t13) : t13 = $[35];
    let t14;
    $[36] !== t10 || $[37] !== t11 || $[38] !== t12 || $[39] !== t13 ? (t14 = {
      tone: "critical",
      icon: TrashIcon,
      disabled: t10,
      title: t11,
      label: t12,
      shortcut: "Ctrl+Alt+D",
      onHandle: handle,
      dialog: t13
    }, $[36] = t10, $[37] = t11, $[38] = t12, $[39] = t13, $[40] = t14) : t14 = $[40], t8 = t14;
  }
  return t8;
};
useDeleteAction.action = "delete";
useDeleteAction.displayName = "DeleteAction";
function ConfirmDiscardDialog(t0) {
  const $ = (0, import_compiler_runtime2.c)(18), {
    publishedExists,
    onCancel,
    onConfirm
  } = t0, {
    t: t2
  } = useTranslation(structureLocaleNamespace), dialogId = `deletion-confirmation-${(0, import_react2.useId)()}`;
  let t1;
  $[0] !== t2 ? (t1 = t2("action.discard-changes.confirm-dialog.header.text"), $[0] = t2, $[1] = t1) : t1 = $[1];
  let t22;
  $[2] !== t2 ? (t22 = t2("action.discard-changes.label"), $[2] = t2, $[3] = t22) : t22 = $[3];
  let t3;
  $[4] !== onConfirm || $[5] !== t22 ? (t3 = {
    confirmButton: {
      text: t22,
      onClick: onConfirm
    }
  }, $[4] = onConfirm, $[5] = t22, $[6] = t3) : t3 = $[6];
  let t4;
  $[7] !== publishedExists || $[8] !== t2 ? (t4 = t2(publishedExists ? "action.discard-changes.confirm-dialog.confirm-discard-changes" : "action.discard-changes.confirm-dialog.confirm-discard-changes-draft"), $[7] = publishedExists, $[8] = t2, $[9] = t4) : t4 = $[9];
  let t5;
  $[10] !== t4 ? (t5 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: t4 }), $[10] = t4, $[11] = t5) : t5 = $[11];
  let t6;
  return $[12] !== dialogId || $[13] !== onCancel || $[14] !== t1 || $[15] !== t3 || $[16] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(Dialog2, { width: 1, id: dialogId, header: t1, footer: t3, onClose: onCancel, onClickOutside: onCancel, children: t5 }), $[12] = dialogId, $[13] = onCancel, $[14] = t1, $[15] = t3, $[16] = t5, $[17] = t6) : t6 = $[17], t6;
}
var DISABLED_REASON_KEY$2 = {
  NO_CHANGES: "action.discard-changes.disabled.no-change",
  NOT_PUBLISHED: "action.discard-changes.disabled.not-published",
  NOT_READY: "action.discard-changes.disabled.not-ready"
};
var useDiscardChangesAction = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(31), {
    id,
    type,
    published,
    version,
    draft
  } = t0;
  let t1;
  $[0] !== version ? (t1 = version?._id && getVersionFromId(version._id), $[0] = version, $[1] = t1) : t1 = $[1];
  const bundleId = t1, {
    discardChanges
  } = useDocumentOperation(id, type, bundleId), [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react2.useState)(false);
  let t2;
  $[2] !== bundleId || $[3] !== id || $[4] !== type ? (t2 = {
    id,
    type,
    version: bundleId,
    permission: "discardDraft"
  }, $[2] = bundleId, $[3] = id, $[4] = type, $[5] = t2) : t2 = $[5];
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions(t2), currentUser = useCurrentUser(), {
    displayed
  } = useDocumentPane(), {
    t: t3
  } = useTranslation(structureLocaleNamespace), isPublished = displayed?._id && isPublishedId(displayed?._id);
  let t32;
  $[6] !== discardChanges ? (t32 = () => {
    discardChanges.execute(), setConfirmDialogOpen(false);
  }, $[6] = discardChanges, $[7] = t32) : t32 = $[7];
  const handleConfirm = t32;
  let t4;
  $[8] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t4 = () => {
    setConfirmDialogOpen(false);
  }, $[8] = t4) : t4 = $[8];
  const handleCancel = t4;
  let t5;
  $[9] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t5 = () => {
    setConfirmDialogOpen(true);
  }, $[9] = t5) : t5 = $[9];
  const handle = t5;
  let t6;
  bb0: {
    if (!version && !draft) {
      t6 = null;
      break bb0;
    }
    if (isPublished) {
      t6 = null;
      break bb0;
    }
    if (!isPermissionsLoading && !permissions?.granted) {
      let t72;
      $[10] !== t3 ? (t72 = t3("action.discard-changes.label"), $[10] = t3, $[11] = t72) : t72 = $[11];
      let t82;
      $[12] !== currentUser ? (t82 = (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessage, { context: "discard-changes", currentUser }), $[12] = currentUser, $[13] = t82) : t82 = $[13];
      let t92;
      $[14] !== t72 || $[15] !== t82 ? (t92 = {
        tone: "critical",
        icon: ResetIcon,
        disabled: true,
        label: t72,
        title: t82
      }, $[14] = t72, $[15] = t82, $[16] = t92) : t92 = $[16], t6 = t92;
      break bb0;
    }
    const t7 = !!discardChanges.disabled || isPermissionsLoading, t8 = discardChanges.disabled && DISABLED_REASON_KEY$2[discardChanges.disabled] || "";
    let t9;
    $[17] !== t3 || $[18] !== t8 ? (t9 = t3(t8), $[17] = t3, $[18] = t8, $[19] = t9) : t9 = $[19];
    let t10;
    $[20] !== t3 ? (t10 = t3("action.discard-changes.label"), $[20] = t3, $[21] = t10) : t10 = $[21];
    let t11;
    $[22] !== handleConfirm || $[23] !== isConfirmDialogOpen || $[24] !== published ? (t11 = isConfirmDialogOpen && {
      type: "custom",
      component: (0, import_jsx_runtime2.jsx)(ConfirmDiscardDialog, { onCancel: handleCancel, onConfirm: handleConfirm, publishedExists: !!published })
    }, $[22] = handleConfirm, $[23] = isConfirmDialogOpen, $[24] = published, $[25] = t11) : t11 = $[25];
    let t12;
    $[26] !== t10 || $[27] !== t11 || $[28] !== t7 || $[29] !== t9 ? (t12 = {
      tone: "critical",
      icon: ResetIcon,
      disabled: t7,
      title: t9,
      label: t10,
      onHandle: handle,
      dialog: t11
    }, $[26] = t10, $[27] = t11, $[28] = t7, $[29] = t9, $[30] = t12) : t12 = $[30], t6 = t12;
  }
  return t6;
};
useDiscardChangesAction.action = "discardChanges";
useDiscardChangesAction.displayName = "DiscardChangesAction";
var DISABLED_REASON_KEY$1 = {
  NOTHING_TO_DUPLICATE: "action.duplicate.disabled.nothing-to-duplicate",
  NOT_READY: "action.duplicate.disabled.not-ready"
};
var useDuplicateAction = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(31), {
    id,
    type,
    release,
    mapDocument,
    version
  } = t0, documentStore = useDocumentStore();
  let t1;
  $[0] !== version ? (t1 = version?._id && getVersionFromId(version._id), $[0] = version, $[1] = t1) : t1 = $[1];
  const bundleId = t1, {
    duplicate
  } = useDocumentOperation(id, type, bundleId), {
    navigateIntent
  } = useRouter(), [isDuplicating, setDuplicating] = (0, import_react2.useState)(false);
  let t2;
  $[2] !== id || $[3] !== release || $[4] !== type ? (t2 = {
    id,
    type,
    version: release,
    permission: "duplicate"
  }, $[2] = id, $[3] = release, $[4] = type, $[5] = t2) : t2 = $[5];
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions(t2), {
    t: t3
  } = useTranslation(structureLocaleNamespace), currentUser = useCurrentUser();
  let t32;
  $[6] !== documentStore.pair || $[7] !== duplicate || $[8] !== id || $[9] !== mapDocument || $[10] !== navigateIntent || $[11] !== type ? (t32 = async () => {
    const dupeId = v4_default();
    setDuplicating(true);
    const duplicateSuccess = firstValueFrom(documentStore.pair.operationEvents(id, type).pipe(filter(_temp$t)));
    duplicate.execute(dupeId, {
      mapDocument
    }), await duplicateSuccess, navigateIntent("edit", {
      id: dupeId,
      type
    }), setDuplicating(false);
  }, $[6] = documentStore.pair, $[7] = duplicate, $[8] = id, $[9] = mapDocument, $[10] = navigateIntent, $[11] = type, $[12] = t32) : t32 = $[12];
  const handle = t32;
  let t4;
  bb0: {
    if (!isPermissionsLoading && !permissions?.granted) {
      let t52;
      $[13] !== t3 ? (t52 = t3("action.duplicate.label"), $[13] = t3, $[14] = t52) : t52 = $[14];
      let t62;
      $[15] !== currentUser ? (t62 = (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessage, { context: "duplicate-document", currentUser }), $[15] = currentUser, $[16] = t62) : t62 = $[16];
      let t72;
      $[17] !== t52 || $[18] !== t62 ? (t72 = {
        icon: CopyIcon,
        disabled: true,
        label: t52,
        title: t62
      }, $[17] = t52, $[18] = t62, $[19] = t72) : t72 = $[19], t4 = t72;
      break bb0;
    }
    const t5 = isDuplicating || !!duplicate.disabled || isPermissionsLoading;
    let t6;
    $[20] !== isDuplicating || $[21] !== t3 ? (t6 = t3(isDuplicating ? "action.duplicate.running.label" : "action.duplicate.label"), $[20] = isDuplicating, $[21] = t3, $[22] = t6) : t6 = $[22];
    let t7;
    $[23] !== duplicate.disabled || $[24] !== t3 ? (t7 = duplicate.disabled ? t3(DISABLED_REASON_KEY$1[duplicate.disabled]) : "", $[23] = duplicate.disabled, $[24] = t3, $[25] = t7) : t7 = $[25];
    let t8;
    $[26] !== handle || $[27] !== t5 || $[28] !== t6 || $[29] !== t7 ? (t8 = {
      icon: CopyIcon,
      disabled: t5,
      label: t6,
      title: t7,
      onHandle: handle
    }, $[26] = handle, $[27] = t5, $[28] = t6, $[29] = t7, $[30] = t8) : t8 = $[30], t4 = t8;
  }
  return t4;
};
useDuplicateAction.action = "duplicate";
useDuplicateAction.displayName = "DuplicateAction";
function _temp$t(e2) {
  return e2.op === "duplicate" && e2.type === "success";
}
var DocumentPublished = defineEvent({
  name: "Document Published",
  version: 1,
  description: 'User clicked the "Publish" button in the document pane'
});
var DISABLED_REASON_TITLE_KEY = {
  LIVE_EDIT_ENABLED: "action.publish.live-edit.publish-disabled",
  ALREADY_PUBLISHED: "action.publish.already-published.no-time-ago.tooltip",
  NO_CHANGES: "action.publish.no-changes.tooltip",
  NOT_READY: "action.publish.disabled.not-ready"
};
var PUBLISHED_STATE = {
  status: "published"
};
function getDisabledReason(reason, publishedAt, t2) {
  return reason === "ALREADY_PUBLISHED" && publishedAt ? (0, import_jsx_runtime2.jsx)(AlreadyPublished, { publishedAt }) : t2(DISABLED_REASON_TITLE_KEY[reason]);
}
function AlreadyPublished(t0) {
  const $ = (0, import_compiler_runtime2.c)(6), {
    publishedAt
  } = t0, {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = {
    useTemporalPhrase: true
  }, $[0] = t1) : t1 = $[0];
  const timeSincePublished = useRelativeTime(publishedAt, t1);
  let t22;
  $[1] !== t2 || $[2] !== timeSincePublished ? (t22 = t2("action.publish.already-published.tooltip", {
    timeSincePublished
  }), $[1] = t2, $[2] = timeSincePublished, $[3] = t22) : t22 = $[3];
  let t3;
  return $[4] !== t22 ? (t3 = (0, import_jsx_runtime2.jsx)(Text, { children: t22 }), $[4] = t22, $[5] = t3) : t3 = $[5], t3;
}
var usePublishAction = (props) => {
  const $ = (0, import_compiler_runtime2.c)(86), {
    id,
    type,
    liveEdit,
    draft,
    published,
    release,
    version
  } = props, {
    selectedPerspective
  } = usePerspective(), [publishState, setPublishState] = (0, import_react2.useState)(null);
  let t0;
  $[0] !== version ? (t0 = version?._id && getVersionFromId(version._id), $[0] = version, $[1] = t0) : t0 = $[1];
  const bundleId = t0, {
    publish
  } = useDocumentOperation(id, type, bundleId), {
    changesOpen,
    documentId,
    documentType,
    value
  } = useDocumentPane(), validationStatus = useValidationStatus(value._id, type, !release), syncState = useSyncState(id, type), editState = useEditState(documentId, documentType, "default", bundleId), {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[2] !== editState?.draft || $[3] !== editState?.published || $[4] !== editState?.version ? (t1 = editState?.version || editState?.draft || editState?.published || {}, $[2] = editState?.draft, $[3] = editState?.published, $[4] = editState?.version, $[5] = t1) : t1 = $[5];
  const revision = t1._rev, toast = useToast();
  let t22;
  $[6] !== validationStatus.validation ? (t22 = validationStatus.validation.some(isValidationErrorMarker), $[6] = validationStatus.validation, $[7] = t22) : t22 = $[7];
  const hasValidationErrors = t22, [publishScheduled, setPublishScheduled] = (0, import_react2.useState)(false), isSyncing = syncState.isSyncing, isValidating = validationStatus.isValidating;
  let t3;
  $[8] !== id || $[9] !== type ? (t3 = {
    id,
    type,
    permission: "publish"
  }, $[8] = id, $[9] = type, $[10] = t3) : t3 = $[10];
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions(t3), currentUser = useCurrentUser();
  let t4;
  $[11] !== hasValidationErrors || $[12] !== publish.disabled || $[13] !== published || $[14] !== t2 ? (t4 = publish.disabled ? getDisabledReason(publish.disabled, (published || {})._updatedAt, t2) || "" : hasValidationErrors ? t2("action.publish.validation-issues.tooltip") : "", $[11] = hasValidationErrors, $[12] = publish.disabled, $[13] = published, $[14] = t2, $[15] = t4) : t4 = $[15];
  const title = t4, currentPublishRevision = published?._rev;
  let t5;
  $[16] !== currentPublishRevision || $[17] !== publish ? (t5 = () => {
    publish.execute(), setPublishState({
      status: "publishing",
      publishRevision: currentPublishRevision
    });
  }, $[16] = currentPublishRevision, $[17] = publish, $[18] = t5) : t5 = $[18];
  const doPublish = t5;
  let t6;
  $[19] !== doPublish || $[20] !== hasValidationErrors || $[21] !== isSyncing || $[22] !== publishScheduled || $[23] !== revision || $[24] !== t2 || $[25] !== toast || $[26] !== validationStatus.isValidating || $[27] !== validationStatus.revision ? (t6 = () => {
    const validationComplete = !validationStatus.isValidating && validationStatus.revision === revision;
    !publishScheduled || isSyncing || !validationComplete || (hasValidationErrors ? toast.push({
      title: t2("action.publish.validation-issues-toast.title"),
      description: t2("action.publish.validation-issues-toast.description"),
      status: "error"
    }) : doPublish(), setPublishScheduled(false));
  }, $[19] = doPublish, $[20] = hasValidationErrors, $[21] = isSyncing, $[22] = publishScheduled, $[23] = revision, $[24] = t2, $[25] = toast, $[26] = validationStatus.isValidating, $[27] = validationStatus.revision, $[28] = t6) : t6 = $[28];
  let t7;
  $[29] !== doPublish || $[30] !== hasValidationErrors || $[31] !== isSyncing || $[32] !== isValidating || $[33] !== publishScheduled || $[34] !== revision || $[35] !== t2 || $[36] !== toast || $[37] !== validationStatus.isValidating || $[38] !== validationStatus.revision ? (t7 = [isSyncing, doPublish, hasValidationErrors, publishScheduled, validationStatus.revision, revision, isValidating, validationStatus.isValidating, toast, t2], $[29] = doPublish, $[30] = hasValidationErrors, $[31] = isSyncing, $[32] = isValidating, $[33] = publishScheduled, $[34] = revision, $[35] = t2, $[36] = toast, $[37] = validationStatus.isValidating, $[38] = validationStatus.revision, $[39] = t7) : t7 = $[39], (0, import_react2.useEffect)(t6, t7);
  let t8;
  $[40] !== currentPublishRevision || $[41] !== publishState ? (t8 = () => {
    const didPublish = publishState?.status === "publishing" && currentPublishRevision !== publishState.publishRevision, nextState = didPublish ? PUBLISHED_STATE : null, timer2 = setTimeout(() => {
      setPublishState(nextState);
    }, didPublish ? 200 : 4e3);
    return () => clearTimeout(timer2);
  }, $[40] = currentPublishRevision, $[41] = publishState, $[42] = t8) : t8 = $[42];
  let t9;
  $[43] !== changesOpen || $[44] !== currentPublishRevision || $[45] !== publishState ? (t9 = [changesOpen, publishState, currentPublishRevision], $[43] = changesOpen, $[44] = currentPublishRevision, $[45] = publishState, $[46] = t9) : t9 = $[46], (0, import_react2.useEffect)(t8, t9);
  const telemetry = useTelemetry();
  let t10;
  $[47] !== doPublish || $[48] !== draft?._createdAt || $[49] !== published || $[50] !== revision || $[51] !== syncState.isSyncing || $[52] !== telemetry || $[53] !== validationStatus.isValidating || $[54] !== validationStatus.revision ? (t10 = () => {
    telemetry.log(DocumentPublished, {
      publishedImmediately: !draft?._createdAt,
      previouslyPublished: !!published
    }), syncState.isSyncing || validationStatus.isValidating || validationStatus.revision !== revision ? setPublishScheduled(true) : doPublish();
  }, $[47] = doPublish, $[48] = draft?._createdAt, $[49] = published, $[50] = revision, $[51] = syncState.isSyncing, $[52] = telemetry, $[53] = validationStatus.isValidating, $[54] = validationStatus.revision, $[55] = t10) : t10 = $[55];
  const handle = t10;
  let t11;
  bb0: {
    if (isPublishedPerspective(selectedPerspective)) {
      t11 = null;
      break bb0;
    }
    if (release && version) {
      t11 = null;
      break bb0;
    }
    if (liveEdit && !version) {
      t11 = null;
      break bb0;
    }
    if (published && !draft && !version) {
      let t122;
      $[56] !== t2 ? (t122 = t2("action.publish.label"), $[56] = t2, $[57] = t122) : t122 = $[57];
      const t132 = published?._updatedAt;
      let t142;
      $[58] !== t2 || $[59] !== t132 ? (t142 = getDisabledReason("ALREADY_PUBLISHED", t132, t2), $[58] = t2, $[59] = t132, $[60] = t142) : t142 = $[60];
      let t152;
      $[61] !== t122 || $[62] !== t142 ? (t152 = {
        tone: "default",
        icon: PublishIcon,
        label: t122,
        title: t142,
        disabled: true
      }, $[61] = t122, $[62] = t142, $[63] = t152) : t152 = $[63], t11 = t152;
      break bb0;
    }
    if (!isPermissionsLoading && !permissions?.granted) {
      let t122;
      $[64] !== t2 ? (t122 = t2("action.publish.label"), $[64] = t2, $[65] = t122) : t122 = $[65];
      let t132;
      $[66] !== currentUser ? (t132 = (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessage, { context: "publish-document", currentUser }), $[66] = currentUser, $[67] = t132) : t132 = $[67];
      let t142;
      $[68] !== t122 || $[69] !== t132 ? (t142 = {
        tone: "default",
        icon: PublishIcon,
        label: t122,
        title: t132,
        disabled: true
      }, $[68] = t122, $[69] = t132, $[70] = t142) : t142 = $[70], t11 = t142;
      break bb0;
    }
    const disabled = !!(publishScheduled || editState?.transactionSyncLock?.enabled || publishState?.status === "publishing" || publishState?.status === "published" || hasValidationErrors || publish.disabled), t12 = disabled || isPermissionsLoading;
    let t13;
    $[71] !== publishScheduled || $[72] !== publishState?.status || $[73] !== t2 ? (t13 = publishState?.status === "published" ? t2("action.publish.published.label") : publishScheduled ? t2("action.publish.validation-in-progress.label") : publishState?.status === "publishing" ? t2("action.publish.running.label") : t2("action.publish.draft.label"), $[71] = publishScheduled, $[72] = publishState?.status, $[73] = t2, $[74] = t13) : t13 = $[74];
    let t14;
    $[75] !== publishScheduled || $[76] !== publishState?.status || $[77] !== t2 || $[78] !== title ? (t14 = publishScheduled ? t2("action.publish.waiting") : publishState?.status === "published" || publishState?.status === "publishing" ? null : title, $[75] = publishScheduled, $[76] = publishState?.status, $[77] = t2, $[78] = title, $[79] = t14) : t14 = $[79];
    const t15 = disabled || publishScheduled ? null : "Ctrl+Alt+P";
    let t16;
    $[80] !== handle || $[81] !== t12 || $[82] !== t13 || $[83] !== t14 || $[84] !== t15 ? (t16 = {
      disabled: t12,
      tone: "default",
      label: t13,
      icon: PublishIcon,
      title: t14,
      shortcut: t15,
      onHandle: handle
    }, $[80] = handle, $[81] = t12, $[82] = t13, $[83] = t14, $[84] = t15, $[85] = t16) : t16 = $[85], t11 = t16;
  }
  return t11;
};
usePublishAction.action = "publish";
usePublishAction.displayName = "PublishAction";
var DISABLED_REASON_KEY = {
  NOT_PUBLISHED: "action.unpublish.disabled.not-published",
  NOT_READY: "action.unpublish.disabled.not-ready",
  LIVE_EDIT_ENABLED: "action.unpublish.disabled.live-edit-enabled"
};
var useUnpublishAction = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(22), {
    id,
    type,
    draft,
    liveEdit,
    release
  } = t0, {
    unpublish
  } = useDocumentOperation(id, type), [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react2.useState)(false);
  let t1;
  $[0] !== id || $[1] !== type ? (t1 = {
    id,
    type,
    permission: "unpublish"
  }, $[0] = id, $[1] = type, $[2] = t1) : t1 = $[2];
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions(t1), currentUser = useCurrentUser(), {
    t: t2
  } = useTranslation(structureLocaleNamespace), {
    selectedPerspective
  } = usePerspective(), isDraft = selectedPerspective === "drafts";
  let t22;
  $[3] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t22 = () => {
    setConfirmDialogOpen(false);
  }, $[3] = t22) : t22 = $[3];
  const handleCancel = t22;
  let t3;
  $[4] !== unpublish ? (t3 = () => {
    setConfirmDialogOpen(false), unpublish.execute();
  }, $[4] = unpublish, $[5] = t3) : t3 = $[5];
  const handleConfirm = t3;
  let t4;
  bb0: {
    if (isConfirmDialogOpen) {
      const t52 = draft?._id || id;
      let t62;
      $[6] !== handleConfirm || $[7] !== t52 || $[8] !== type ? (t62 = {
        type: "dialog",
        onClose: handleCancel,
        content: (0, import_jsx_runtime2.jsx)(ConfirmDeleteDialogContainer, { id: t52, type, action: "unpublish", onCancel: handleCancel, onConfirm: handleConfirm })
      }, $[6] = handleConfirm, $[7] = t52, $[8] = type, $[9] = t62) : t62 = $[9], t4 = t62;
      break bb0;
    }
    t4 = null;
  }
  const dialog = t4;
  let t5;
  $[10] !== currentUser || $[11] !== dialog || $[12] !== isDraft || $[13] !== isPermissionsLoading || $[14] !== liveEdit || $[15] !== permissions?.granted || $[16] !== release || $[17] !== t2 || $[18] !== unpublish.disabled ? (t5 = () => release || isDraft || liveEdit ? null : !isPermissionsLoading && !permissions?.granted ? {
    tone: "critical",
    icon: UnpublishIcon,
    label: "Unpublish",
    title: (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessage, { context: "unpublish-document", currentUser }),
    disabled: true
  } : {
    tone: "critical",
    icon: UnpublishIcon,
    disabled: !!unpublish.disabled || isPermissionsLoading,
    label: t2("action.unpublish.label"),
    title: unpublish.disabled ? t2(DISABLED_REASON_KEY[unpublish.disabled]) : "",
    onHandle: () => setConfirmDialogOpen(true),
    dialog
  }, $[10] = currentUser, $[11] = dialog, $[12] = isDraft, $[13] = isPermissionsLoading, $[14] = liveEdit, $[15] = permissions?.granted, $[16] = release, $[17] = t2, $[18] = unpublish.disabled, $[19] = t5) : t5 = $[19];
  let t6;
  return $[20] !== t5 ? (t6 = t5(), $[20] = t5, $[21] = t6) : t6 = $[21], t6;
};
useUnpublishAction.action = "unpublish";
useUnpublishAction.displayName = "UnpublishAction";
var DocumentStatusBarActionsInner = (0, import_react2.memo)(function(props) {
  const $ = (0, import_compiler_runtime2.c)(39), {
    disabled,
    states
  } = props, {
    __internal_tasks
  } = useSource(), {
    editState
  } = useDocumentPane(), {
    params
  } = usePaneRouter(), showingRevision = !!params?.rev, {
    selectedReleaseId
  } = usePerspective();
  let firstActionState, menuActionStates;
  $[0] !== states ? ([firstActionState, ...menuActionStates] = states, $[0] = states, $[1] = firstActionState, $[2] = menuActionStates) : (firstActionState = $[1], menuActionStates = $[2]);
  const [buttonElement, setButtonElement] = (0, import_react2.useState)(null), {
    isPaused
  } = usePausedScheduledDraft();
  let t0;
  bb0: {
    if (!firstActionState || !firstActionState.title && !firstActionState.shortcut) {
      t0 = null;
      break bb0;
    }
    let t12;
    $[3] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t12 = {
      maxWidth: 300
    }, $[3] = t12) : t12 = $[3];
    let t22;
    $[4] !== firstActionState.title ? (t22 = firstActionState.title && (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: firstActionState.title }), $[4] = firstActionState.title, $[5] = t22) : t22 = $[5];
    let t32;
    $[6] !== firstActionState.shortcut ? (t32 = firstActionState.shortcut && (0, import_jsx_runtime2.jsx)(Hotkeys, { "data-testid": "document-status-bar-hotkeys", fontSize: 1, style: {
      marginTop: -4,
      marginBottom: -4
    }, keys: String(firstActionState.shortcut).split("+").map(_temp$s) }), $[6] = firstActionState.shortcut, $[7] = t32) : t32 = $[7];
    let t42;
    $[8] !== t22 || $[9] !== t32 ? (t42 = (0, import_jsx_runtime2.jsxs)(Flex, { style: t12, align: "center", gap: 3, children: [
      t22,
      t32
    ] }), $[8] = t22, $[9] = t32, $[10] = t42) : t42 = $[10], t0 = t42;
  }
  const tooltipContent = t0, shouldShowScheduleAsFirstActionButton = firstActionState?.action === "schedule" && isPaused;
  let t1;
  $[11] !== editState?.liveEdit || $[12] !== editState?.version || $[13] !== firstActionState || $[14] !== selectedReleaseId || $[15] !== shouldShowScheduleAsFirstActionButton || $[16] !== showingRevision ? (t1 = showingRevision ? !!firstActionState : selectedReleaseId ? firstActionState && (shouldShowScheduleAsFirstActionButton || !isSanityDefinedAction(firstActionState)) : firstActionState && (!editState?.liveEdit || editState?.version), $[11] = editState?.liveEdit, $[12] = editState?.version, $[13] = firstActionState, $[14] = selectedReleaseId, $[15] = shouldShowScheduleAsFirstActionButton, $[16] = showingRevision, $[17] = t1) : t1 = $[17];
  const showFirstActionButton = t1;
  let t2;
  $[18] !== firstActionState || $[19] !== menuActionStates || $[20] !== showFirstActionButton ? (t2 = showFirstActionButton ? menuActionStates : [firstActionState, ...menuActionStates].filter(Boolean), $[18] = firstActionState, $[19] = menuActionStates, $[20] = showFirstActionButton, $[21] = t2) : t2 = $[21];
  const sideMenuItems = t2, t3 = __internal_tasks && __internal_tasks.footerAction;
  let t4;
  $[22] !== disabled || $[23] !== firstActionState || $[24] !== showFirstActionButton || $[25] !== tooltipContent ? (t4 = showFirstActionButton && (0, import_jsx_runtime2.jsx)(LayerProvider, { zOffset: 200, children: (0, import_jsx_runtime2.jsx)(Tooltip, { disabled: !tooltipContent, content: tooltipContent, placement: "top", children: (0, import_jsx_runtime2.jsx)(Stack, { children: (0, import_jsx_runtime2.jsx)(Button2, { "data-testid": `action-${toLowerCaseNoSpaces(firstActionState.label)}`, disabled: disabled || !!firstActionState.disabled, icon: firstActionState.icon, onClick: firstActionState.onHandle, ref: setButtonElement, text: firstActionState.label, tone: firstActionState.tone || "primary" }) }) }) }), $[22] = disabled, $[23] = firstActionState, $[24] = showFirstActionButton, $[25] = tooltipContent, $[26] = t4) : t4 = $[26];
  let t5;
  $[27] !== disabled || $[28] !== sideMenuItems ? (t5 = sideMenuItems.length > 0 && (0, import_jsx_runtime2.jsx)(ActionMenuButton, { actionStates: sideMenuItems, disabled }), $[27] = disabled, $[28] = sideMenuItems, $[29] = t5) : t5 = $[29];
  let t6;
  $[30] !== buttonElement || $[31] !== firstActionState || $[32] !== showFirstActionButton ? (t6 = showFirstActionButton && firstActionState && firstActionState.dialog && (0, import_jsx_runtime2.jsx)(ActionStateDialog, { dialog: firstActionState.dialog, referenceElement: buttonElement }), $[30] = buttonElement, $[31] = firstActionState, $[32] = showFirstActionButton, $[33] = t6) : t6 = $[33];
  let t7;
  return $[34] !== t3 || $[35] !== t4 || $[36] !== t5 || $[37] !== t6 ? (t7 = (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 1, children: [
    t3,
    t4,
    t5,
    t6
  ] }), $[34] = t3, $[35] = t4, $[36] = t5, $[37] = t6, $[38] = t7) : t7 = $[38], t7;
});
var DocumentStatusBarActions = (0, import_react2.memo)(function() {
  const $ = (0, import_compiler_runtime2.c)(1);
  let t0;
  return $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = (0, import_jsx_runtime2.jsx)(RenderActionCollectionState, { group: "default", children: _temp2$c }), $[0] = t0) : t0 = $[0], t0;
});
function RenderDocumentStatusBarActions(props) {
  const $ = (0, import_compiler_runtime2.c)(6), {
    connectionState,
    documentId
  } = useDocumentPane();
  let t0;
  $[0] !== props.states ? (t0 = props.states.filter(_temp3$8), $[0] = props.states, $[1] = t0) : t0 = $[1];
  const states = t0;
  if (states.length === 0)
    return null;
  const t1 = connectionState !== "connected";
  let t2;
  return $[2] !== documentId || $[3] !== states || $[4] !== t1 ? (t2 = (0, import_jsx_runtime2.jsx)(DocumentStatusBarActionsInner, { disabled: t1, states }, documentId), $[2] = documentId, $[3] = states, $[4] = t1, $[5] = t2) : t2 = $[5], t2;
}
function _temp3$8(state2) {
  return state2.action ? state2.action !== useHistoryRestoreAction.action : true;
}
var HistoryStatusBarActions = (0, import_react2.memo)(function() {
  const $ = (0, import_compiler_runtime2.c)(1);
  let t0;
  return $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = (0, import_jsx_runtime2.jsx)(RenderActionCollectionState, { group: "default", children: _temp4$8 }), $[0] = t0) : t0 = $[0], t0;
});
function RenderHistoryStatusBarActions(t0) {
  const $ = (0, import_compiler_runtime2.c)(8), {
    states
  } = t0, {
    connectionState,
    editState,
    revisionId: revision
  } = useDocumentPane();
  let t1;
  $[0] !== editState?.draft || $[1] !== editState?.published ? (t1 = editState?.draft || editState?.published || {}, $[0] = editState?.draft, $[1] = editState?.published, $[2] = t1) : t1 = $[2];
  const disabled = t1._rev === revision, t2 = connectionState !== "connected" || !!disabled;
  let t3;
  $[3] !== states ? (t3 = states.filter(_temp5$5).slice(-1), $[3] = states, $[4] = t3) : t3 = $[4];
  let t4;
  return $[5] !== t2 || $[6] !== t3 ? (t4 = (0, import_jsx_runtime2.jsx)(DocumentStatusBarActionsInner, { disabled: t2, states: t3 }), $[5] = t2, $[6] = t3, $[7] = t4) : t4 = $[7], t4;
}
function _temp5$5(state2) {
  return state2.action ? state2.action === useHistoryRestoreAction.action : false;
}
function _temp$s(s2) {
  return s2.slice(0, 1).toUpperCase() + s2.slice(1).toLowerCase();
}
function _temp2$c(t0) {
  const {
    states
  } = t0;
  return (0, import_jsx_runtime2.jsx)(RenderDocumentStatusBarActions, { states });
}
function _temp4$8(t0) {
  const {
    states
  } = t0;
  return (0, import_jsx_runtime2.jsx)(RenderHistoryStatusBarActions, { states });
}
var TIMELINE_ICON_COMPONENTS = {
  create: AddIcon,
  delete: TrashIcon,
  discardDraft: CloseIcon,
  initial: AddIcon,
  editDraft: EditIcon,
  editLive: EditIcon,
  publish: PublishIcon,
  unpublish: UnpublishIcon
};
function getTimelineEventIconComponent(type) {
  return TIMELINE_ICON_COMPONENTS[type];
}
function hideScrollbarOnExpand(isExpanded2) {
  if (isExpanded2) return;
  const listWrapper = document.getElementById(TIMELINE_LIST_WRAPPER_ID$1);
  if (listWrapper) {
    const firstChildren = listWrapper.children[0];
    if (!(firstChildren.scrollHeight > firstChildren.clientHeight)) {
      const currentStyle = getComputedStyle(firstChildren).overflowY;
      firstChildren.style.overflowY = "hidden", setTimeout(() => {
        firstChildren.style.overflowY = currentStyle;
      }, 0);
    }
  }
}
var FlipIcon = at(ChevronLeftIcon).withConfig({
  displayName: "FlipIcon",
  componentId: "sc-13ovfi5-0"
})`transition:transform 200ms;&[data-expanded='true']{transform:rotate(-90deg);}`;
function ExpandableTimelineItemButton(t0) {
  const $ = (0, import_compiler_runtime2.c)(14), {
    isExpanded: isExpanded2,
    onExpand
  } = t0, {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[0] !== isExpanded2 || $[1] !== onExpand ? (t1 = (e2) => {
    e2.stopPropagation(), hideScrollbarOnExpand(isExpanded2), onExpand();
  }, $[0] = isExpanded2, $[1] = onExpand, $[2] = t1) : t1 = $[2];
  const handleExpandClick = t1;
  let t22;
  $[3] !== isExpanded2 ? (t22 = (0, import_jsx_runtime2.jsx)(FlipIcon, { "data-expanded": isExpanded2 }), $[3] = isExpanded2, $[4] = t22) : t22 = $[4];
  let t3;
  $[5] !== isExpanded2 || $[6] !== t2 ? (t3 = t2(isExpanded2 ? "timeline-item.menu.action-collapse" : "timeline-item.menu.action-expand"), $[5] = isExpanded2, $[6] = t2, $[7] = t3) : t3 = $[7];
  let t4;
  $[8] !== t3 ? (t4 = {
    content: t3
  }, $[8] = t3, $[9] = t4) : t4 = $[9];
  let t5;
  return $[10] !== handleExpandClick || $[11] !== t22 || $[12] !== t4 ? (t5 = (0, import_jsx_runtime2.jsx)(Button2, { mode: "bleed", icon: t22, tooltipProps: t4, onClick: handleExpandClick }), $[10] = handleExpandClick, $[11] = t22, $[12] = t4, $[13] = t5) : t5 = $[13], t5;
}
var StackWrapper = at(Stack).withConfig({
  displayName: "StackWrapper",
  componentId: "sc-1ai615s-0"
})`max-width:200px;`;
var ListWrapper = at(Flex).withConfig({
  displayName: "ListWrapper",
  componentId: "sc-1ai615s-1"
})`max-height:${(props) => props.$maxHeight};min-width:244px;`;
var Root$3 = at(Box).withConfig({
  displayName: "Root",
  componentId: "sc-1ai615s-2"
})(({
  $visible
}) => rt`
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s;

    ${$visible && rt`
        opacity: 1;
        pointer-events: auto;
      `}
  `);
var TIMELINE_ITEM_I18N_KEY_MAPPING2 = {
  initial: "timeline.operation.created-initial",
  create: "timeline.operation.created",
  publish: "timeline.operation.published",
  editLive: "timeline.operation.edited-live",
  editDraft: "timeline.operation.edited-draft",
  unpublish: "timeline.operation.unpublished",
  discardDraft: "timeline.operation.draft-discarded",
  delete: "timeline.operation.deleted"
};
function UserAvatarStack(t0) {
  const $ = (0, import_compiler_runtime2.c)(9), {
    maxLength,
    userIds,
    size,
    withTooltip: t1
  } = t0, withTooltip = t1 === void 0 ? true : t1;
  let t2;
  if ($[0] !== userIds || $[1] !== withTooltip) {
    let t32;
    $[3] !== withTooltip ? (t32 = (userId) => (0, import_jsx_runtime2.jsx)(UserAvatar, { user: userId, withTooltip }, userId), $[3] = withTooltip, $[4] = t32) : t32 = $[4], t2 = userIds.map(t32), $[0] = userIds, $[1] = withTooltip, $[2] = t2;
  } else
    t2 = $[2];
  let t3;
  return $[5] !== maxLength || $[6] !== size || $[7] !== t2 ? (t3 = (0, import_jsx_runtime2.jsx)(AvatarStack, { maxLength, size, children: t2 }), $[5] = maxLength, $[6] = size, $[7] = t2, $[8] = t3) : t3 = $[8], t3;
}
var IconBox = at(Flex).withConfig({
  displayName: "IconBox",
  componentId: "sc-19iwr6i-0"
})((props) => {
  const theme = getTheme_v2(props.theme), color = props.$color;
  return rt`
    --card-icon-color: ${theme.color.avatar[color].fg};
    background-color: ${theme.color.avatar[color].bg};
    box-shadow: 0 0 0 1px var(--card-bg-color);

    position: absolute;
    width: ${theme.avatar.sizes[0].size}px;
    height: ${theme.avatar.sizes[0].size}px;
    right: -3px;
    bottom: -3px;
    border-radius: 50%;
  `;
});
var TIMELINE_ITEM_EVENT_TONE = {
  initial: "blue",
  create: "blue",
  publish: "green",
  editLive: "green",
  editDraft: "yellow",
  unpublish: "orange",
  discardDraft: "orange",
  delete: "red",
  withinSelection: "magenta"
};
var RELATIVE_TIME_OPTIONS$1 = {
  minimal: true,
  useTemporalPhrase: true
};
var NameSkeleton = at(Skeleton).withConfig({
  displayName: "NameSkeleton",
  componentId: "sc-19iwr6i-1"
})((props) => {
  const theme = getTheme_v2(props.theme);
  return rt`
    width: 6ch;
    height: ${theme.font.text.sizes[0].lineHeight}px;
  `;
});
var UserLine = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(10), {
    userId
  } = t0, [user, loading] = useUser(userId);
  let t1;
  $[0] !== loading || $[1] !== user ? (t1 = (0, import_jsx_runtime2.jsx)(Box, { children: loading || !user ? (0, import_jsx_runtime2.jsx)(AvatarSkeleton$1, { animated: true }) : (0, import_jsx_runtime2.jsx)(UserAvatar, { user }) }), $[0] = loading, $[1] = user, $[2] = t1) : t1 = $[2];
  let t2;
  $[3] !== loading || $[4] !== user ? (t2 = (0, import_jsx_runtime2.jsx)(Box, { children: loading || !user?.displayName ? (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(NameSkeleton, { animated: true }) }) : (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: user.displayName }) }), $[3] = loading, $[4] = user, $[5] = t2) : t2 = $[5];
  let t3;
  return $[6] !== t1 || $[7] !== t2 || $[8] !== userId ? (t3 = (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 2, padding: 1, children: [
    t1,
    t2
  ] }, userId), $[6] = t1, $[7] = t2, $[8] = userId, $[9] = t3) : t3 = $[9], t3;
};
var TooltipContent = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(9), {
    collaborators
  } = t0, {
    t: t2
  } = useTranslation("studio");
  let t1;
  $[0] !== t2 ? (t1 = t2("timeline.changes.title"), $[0] = t2, $[1] = t1) : t1 = $[1];
  let t22;
  $[2] !== t1 ? (t22 = (0, import_jsx_runtime2.jsx)(Box, { padding: 1, paddingBottom: 2, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: t1 }) }), $[2] = t1, $[3] = t22) : t22 = $[3];
  let t3;
  $[4] !== collaborators ? (t3 = collaborators.map(_temp$r), $[4] = collaborators, $[5] = t3) : t3 = $[5];
  let t4;
  return $[6] !== t22 || $[7] !== t3 ? (t4 = (0, import_jsx_runtime2.jsxs)(Stack, { paddingBottom: 1, children: [
    t22,
    t3
  ] }), $[6] = t22, $[7] = t3, $[8] = t4) : t4 = $[8], t4;
};
function TimelineItem(t0) {
  const $ = (0, import_compiler_runtime2.c)(55), {
    chunk,
    isSelected,
    onSelect,
    collaborators,
    optionsMenu
  } = t0, {
    t: t2
  } = useTranslation("studio"), {
    type,
    endTimestamp: timestamp
  } = chunk;
  let t1;
  $[0] !== type ? (t1 = getTimelineEventIconComponent(type), $[0] = type, $[1] = t1) : t1 = $[1];
  const IconComponent = t1;
  let t22;
  $[2] !== chunk.authors ? (t22 = Array.from(chunk.authors), $[2] = chunk.authors, $[3] = t22) : t22 = $[3];
  const authorUserIds = t22;
  let t3;
  $[4] !== collaborators ? (t3 = collaborators ? Array.from(collaborators) : [], $[4] = collaborators, $[5] = t3) : t3 = $[5];
  const collaboratorsUsersIds = t3, isSelectable = type !== "delete";
  let t4;
  $[6] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t4 = {
    dateStyle: "medium",
    timeStyle: "short"
  }, $[6] = t4) : t4 = $[6];
  const dateFormat = useDateTimeFormat(t4);
  let t5;
  $[7] !== timestamp ? (t5 = new Date(timestamp), $[7] = timestamp, $[8] = t5) : t5 = $[8];
  const updatedTimeAgo = useRelativeTime(t5 || "", RELATIVE_TIME_OPTIONS$1);
  let t6;
  if ($[9] !== dateFormat || $[10] !== timestamp) {
    const parsedDate = new Date(timestamp);
    t6 = dateFormat.format(parsedDate), $[9] = dateFormat, $[10] = timestamp, $[11] = t6;
  } else
    t6 = $[11];
  const formattedTimestamp = t6;
  let t7;
  $[12] !== chunk || $[13] !== isSelectable || $[14] !== onSelect ? (t7 = (evt) => {
    evt.preventDefault(), evt.stopPropagation(), isSelectable && onSelect(chunk);
  }, $[12] = chunk, $[13] = isSelectable, $[14] = onSelect, $[15] = t7) : t7 = $[15];
  const handleClick = t7;
  let t8;
  $[16] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t8 = {
    position: "relative"
  }, $[16] = t8) : t8 = $[16];
  let t9;
  $[17] !== authorUserIds ? (t9 = (0, import_jsx_runtime2.jsx)(UserAvatarStack, { maxLength: 3, userIds: authorUserIds, size: 2 }), $[17] = authorUserIds, $[18] = t9) : t9 = $[18];
  const t10 = TIMELINE_ITEM_EVENT_TONE[type];
  let t11;
  $[19] !== IconComponent ? (t11 = IconComponent && (0, import_jsx_runtime2.jsx)(IconComponent, {}), $[19] = IconComponent, $[20] = t11) : t11 = $[20];
  let t12;
  $[21] !== t11 ? (t12 = (0, import_jsx_runtime2.jsx)(Text, { size: 0, children: t11 }), $[21] = t11, $[22] = t12) : t12 = $[22];
  let t13;
  $[23] !== t10 || $[24] !== t12 ? (t13 = (0, import_jsx_runtime2.jsx)(IconBox, { align: "center", justify: "center", $color: t10, children: t12 }), $[23] = t10, $[24] = t12, $[25] = t13) : t13 = $[25];
  let t14;
  $[26] !== t13 || $[27] !== t9 ? (t14 = (0, import_jsx_runtime2.jsxs)("div", { style: t8, children: [
    t9,
    t13
  ] }), $[26] = t13, $[27] = t9, $[28] = t14) : t14 = $[28];
  let t15;
  $[29] !== t2 || $[30] !== type ? (t15 = t2(TIMELINE_ITEM_I18N_KEY_MAPPING2[type]) || (0, import_jsx_runtime2.jsx)("code", { children: type }), $[29] = t2, $[30] = type, $[31] = t15) : t15 = $[31];
  let t16;
  $[32] !== t15 ? (t16 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: t15 }), $[32] = t15, $[33] = t16) : t16 = $[33];
  let t17;
  $[34] !== formattedTimestamp || $[35] !== timestamp || $[36] !== updatedTimeAgo ? (t17 = (0, import_jsx_runtime2.jsx)(Text, { as: "time", size: 1, muted: true, dateTime: timestamp, title: formattedTimestamp, children: updatedTimeAgo }), $[34] = formattedTimestamp, $[35] = timestamp, $[36] = updatedTimeAgo, $[37] = t17) : t17 = $[37];
  let t18;
  $[38] !== t16 || $[39] !== t17 ? (t18 = (0, import_jsx_runtime2.jsxs)(Stack, { space: 2, children: [
    t16,
    t17
  ] }), $[38] = t16, $[39] = t17, $[40] = t18) : t18 = $[40];
  let t19;
  $[41] !== collaboratorsUsersIds ? (t19 = collaboratorsUsersIds.length > 0 && (0, import_jsx_runtime2.jsx)(Flex, { flex: 1, justify: "flex-end", align: "center", children: (0, import_jsx_runtime2.jsx)(Tooltip, { placement: "top", content: (0, import_jsx_runtime2.jsx)(TooltipContent, { collaborators: collaboratorsUsersIds }), portal: true, children: (0, import_jsx_runtime2.jsx)(Box, { paddingLeft: 2, paddingY: 2, children: (0, import_jsx_runtime2.jsx)(UserAvatarStack, { maxLength: 3, userIds: collaboratorsUsersIds, size: 0, withTooltip: false }) }) }) }), $[41] = collaboratorsUsersIds, $[42] = t19) : t19 = $[42];
  let t20;
  $[43] !== t14 || $[44] !== t18 || $[45] !== t19 ? (t20 = (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 3, children: [
    t14,
    t18,
    t19
  ] }), $[43] = t14, $[44] = t18, $[45] = t19, $[46] = t20) : t20 = $[46];
  let t21;
  $[47] !== chunk.id || $[48] !== handleClick || $[49] !== isSelected || $[50] !== t20 ? (t21 = (0, import_jsx_runtime2.jsx)(Card, { as: "button", onClick: handleClick, padding: 2, pressed: isSelected, radius: 2, "data-ui": "timelineItem", "data-testid": "timeline-item-button", "data-chunk-id": chunk.id, children: t20 }), $[47] = chunk.id, $[48] = handleClick, $[49] = isSelected, $[50] = t20, $[51] = t21) : t21 = $[51];
  let t222;
  return $[52] !== optionsMenu || $[53] !== t21 ? (t222 = (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 1, children: [
    t21,
    optionsMenu
  ] }), $[52] = optionsMenu, $[53] = t21, $[54] = t222) : t222 = $[54], t222;
}
function _temp$r(userId) {
  return (0, import_jsx_runtime2.jsx)(UserLine, { userId }, userId);
}
var isNonPublishChunk = (chunk) => chunk.type !== "publish";
var isPublishChunk = (chunk) => chunk.type === "publish";
function getPreviousPublishAction(chunks) {
  let previousPublish = null;
  for (let index = chunks.length - 1; index >= 0; index--) {
    const chunk = chunks[index];
    if (isPublishChunk(chunk)) {
      previousPublish = chunk;
      break;
    }
    if (chunk.type !== "editDraft")
      break;
  }
  return previousPublish;
}
function addChunksMetadata(chunks) {
  const result = [];
  for (const chunk of chunks) {
    if (isPublishChunk(chunk)) {
      result.push({
        ...chunk,
        type: "publish",
        children: [],
        collaborators: /* @__PURE__ */ new Set()
        // Initialize the collaborators array
      });
      continue;
    }
    if (isNonPublishChunk(chunk)) {
      const previousPublish = getPreviousPublishAction(result);
      if (chunk.type === "editDraft" && previousPublish?.type === "publish") {
        Array.from(chunk.authors).forEach((id) => {
          previousPublish.collaborators.add(id);
        }), previousPublish.children.push(chunk.id), result.push({
          ...chunk,
          parentId: previousPublish.id
        });
        continue;
      }
    }
    isNonPublishChunk(chunk) && result.push(chunk);
  }
  return result;
}
var TIMELINE_LIST_WRAPPER_ID$1 = "timeline-list-wrapper";
var Timeline = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(51), {
    chunks,
    hasMoreChunks,
    lastChunk: selectedChunk,
    onLoadMore,
    onSelect,
    listMaxHeight: t1
  } = t0, listMaxHeight = t1 === void 0 ? "calc(100vh - 280px)" : t1, [mounted, setMounted] = (0, import_react2.useState)(false), {
    t: t2
  } = useTranslation("studio"), selectedChunkId = selectedChunk?.id;
  let t22;
  $[0] !== chunks ? (t22 = addChunksMetadata(chunks), $[0] = chunks, $[1] = t22) : t22 = $[1];
  const chunksWithMetadata = t22;
  let t3;
  $[2] !== chunksWithMetadata || $[3] !== selectedChunkId ? (t3 = () => {
    if (selectedChunkId) {
      const selected = chunksWithMetadata.find((chunk) => chunk.id === selectedChunkId);
      if (selected && isNonPublishChunk(selected) && selected.parentId)
        return /* @__PURE__ */ new Set([selected.parentId]);
    }
    return /* @__PURE__ */ new Set();
  }, $[2] = chunksWithMetadata, $[3] = selectedChunkId, $[4] = t3) : t3 = $[4];
  const [expandedParents, setExpandedParents] = (0, import_react2.useState)(t3);
  let t4, t5;
  $[5] !== chunksWithMetadata || $[6] !== selectedChunkId ? (t4 = () => {
    if (selectedChunkId) {
      const selected_0 = chunksWithMetadata.find((chunk_0) => chunk_0.id === selectedChunkId);
      if (selected_0 && isNonPublishChunk(selected_0) && selected_0.parentId) {
        const parentId = selected_0.parentId;
        setExpandedParents((prev) => {
          if (prev.has(parentId))
            return prev;
          const next = new Set(prev);
          return next.add(parentId), next;
        });
      }
    }
  }, t5 = [chunksWithMetadata, selectedChunkId], $[5] = chunksWithMetadata, $[6] = selectedChunkId, $[7] = t4, $[8] = t5) : (t4 = $[7], t5 = $[8]), (0, import_react2.useEffect)(t4, t5);
  let t6;
  if ($[9] !== chunksWithMetadata || $[10] !== expandedParents) {
    let t72;
    $[12] !== expandedParents ? (t72 = (chunk_1) => isPublishChunk(chunk_1) || !chunk_1.parentId ? true : expandedParents.has(chunk_1.parentId), $[12] = expandedParents, $[13] = t72) : t72 = $[13], t6 = chunksWithMetadata.filter(t72), $[9] = chunksWithMetadata, $[10] = expandedParents, $[11] = t6;
  } else
    t6 = $[11];
  const filteredChunks = t6;
  let t7;
  $[14] !== filteredChunks.length || $[15] !== hasMoreChunks || $[16] !== onLoadMore ? (t7 = () => {
    filteredChunks.length < 16 && hasMoreChunks && onLoadMore();
  }, $[14] = filteredChunks.length, $[15] = hasMoreChunks, $[16] = onLoadMore, $[17] = t7) : t7 = $[17];
  let t8;
  $[18] !== filteredChunks || $[19] !== hasMoreChunks || $[20] !== onLoadMore ? (t8 = [filteredChunks, hasMoreChunks, onLoadMore], $[18] = filteredChunks, $[19] = hasMoreChunks, $[20] = onLoadMore, $[21] = t8) : t8 = $[21], (0, import_react2.useEffect)(t7, t8);
  let t9;
  $[22] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t9 = (parentId_0) => () => setExpandedParents((prev_0) => {
    const next_0 = new Set(prev_0);
    return prev_0.has(parentId_0) ? next_0.delete(parentId_0) : next_0.add(parentId_0), next_0;
  }), $[22] = t9) : t9 = $[22];
  const handleExpandParent = t9;
  let t10;
  $[23] !== filteredChunks || $[24] !== selectedChunkId ? (t10 = selectedChunkId ? filteredChunks.findIndex((chunk_2) => chunk_2.id === selectedChunkId) : -1, $[23] = filteredChunks, $[24] = selectedChunkId, $[25] = t10) : t10 = $[25];
  const selectedIndex = t10;
  let t11;
  $[26] !== chunks || $[27] !== onSelect ? (t11 = (chunk_3) => {
    const timelineChunk = chunks.find((c22) => c22.id === chunk_3.id);
    timelineChunk ? onSelect(timelineChunk) : (console.error("TimelineItem: chunk not found"), onSelect(chunk_3));
  }, $[26] = chunks, $[27] = onSelect, $[28] = t11) : t11 = $[28];
  const handleSelectChunk = t11;
  let t12;
  $[29] !== expandedParents || $[30] !== filteredChunks.length || $[31] !== handleSelectChunk || $[32] !== hasMoreChunks || $[33] !== selectedChunkId ? (t12 = (chunk_4, t132) => {
    const {
      activeIndex
    } = t132;
    return (0, import_jsx_runtime2.jsxs)(Box, { paddingBottom: 1, paddingTop: activeIndex === 0 ? 1 : 0, paddingRight: 1, paddingLeft: isNonPublishChunk(chunk_4) && chunk_4.parentId ? 4 : 1, children: [
      (0, import_jsx_runtime2.jsx)(TimelineItem, { chunk: chunk_4, isSelected: selectedChunkId === chunk_4.id, onSelect: handleSelectChunk, collaborators: isPublishChunk(chunk_4) ? chunk_4.collaborators : void 0, optionsMenu: isPublishChunk(chunk_4) && chunk_4.children.length > 0 ? (0, import_jsx_runtime2.jsx)(ExpandableTimelineItemButton, { isExpanded: expandedParents.has(chunk_4.id), onExpand: handleExpandParent(chunk_4.id) }) : null }),
      activeIndex === filteredChunks.length - 1 && hasMoreChunks && (0, import_jsx_runtime2.jsx)(LoadingBlock, {})
    ] });
  }, $[29] = expandedParents, $[30] = filteredChunks.length, $[31] = handleSelectChunk, $[32] = hasMoreChunks, $[33] = selectedChunkId, $[34] = t12) : t12 = $[34];
  const renderItem = t12;
  let t13, t14;
  $[35] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t13 = () => setMounted(true), t14 = [], $[35] = t13, $[36] = t14) : (t13 = $[35], t14 = $[36]), (0, import_react2.useEffect)(t13, t14);
  const t15 = !selectedIndex || mounted;
  let t16;
  $[37] !== filteredChunks.length || $[38] !== t2 ? (t16 = filteredChunks.length === 0 && (0, import_jsx_runtime2.jsxs)(StackWrapper, { padding: 3, space: 3, children: [
    (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: t2("timeline.error.no-document-history-title") }),
    (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: t2("timeline.error.no-document-history-description") })
  ] }), $[37] = filteredChunks.length, $[38] = t2, $[39] = t16) : t16 = $[39];
  let t17;
  $[40] !== filteredChunks || $[41] !== listMaxHeight || $[42] !== onLoadMore || $[43] !== renderItem || $[44] !== selectedIndex || $[45] !== t2 ? (t17 = filteredChunks.length > 0 && (0, import_jsx_runtime2.jsx)(ListWrapper, { direction: "column", $maxHeight: listMaxHeight, id: TIMELINE_LIST_WRAPPER_ID$1, children: (0, import_jsx_runtime2.jsx)(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: t2("timeline.list.aria-label"), autoFocus: "list", initialIndex: selectedIndex, initialScrollAlign: "center", itemHeight: 57, items: filteredChunks, onEndReached: onLoadMore, onEndReachedIndexOffset: 20, overscan: 5, renderItem, wrapAround: false }) }), $[40] = filteredChunks, $[41] = listMaxHeight, $[42] = onLoadMore, $[43] = renderItem, $[44] = selectedIndex, $[45] = t2, $[46] = t17) : t17 = $[46];
  let t18;
  return $[47] !== t15 || $[48] !== t16 || $[49] !== t17 ? (t18 = (0, import_jsx_runtime2.jsxs)(Root$3, { $visible: t15, "data-ui": "timeline", children: [
    t16,
    t17
  ] }), $[47] = t15, $[48] = t16, $[49] = t17, $[50] = t18) : t18 = $[50], t18;
};
function TimelineError(t0) {
  const $ = (0, import_compiler_runtime2.c)(14), {
    versionError
  } = t0, {
    t: t2
  } = useTranslation("studio");
  let t1;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = (0, import_jsx_runtime2.jsx)(TextWithTone, { tone: "critical", children: (0, import_jsx_runtime2.jsx)(ErrorOutlineIcon, {}) }), $[0] = t1) : t1 = $[0];
  let t22;
  $[1] !== t2 || $[2] !== versionError ? (t22 = t2(versionError ? "timeline.error.load-document-changes-version-title" : "timeline.error.load-document-changes-title"), $[1] = t2, $[2] = versionError, $[3] = t22) : t22 = $[3];
  let t3;
  $[4] !== t22 ? (t3 = (0, import_jsx_runtime2.jsx)(TextWithTone, { size: 1, tone: "critical", weight: "medium", children: t22 }), $[4] = t22, $[5] = t3) : t3 = $[5];
  let t4;
  $[6] !== t2 || $[7] !== versionError ? (t4 = t2(versionError ? "timeline.error.load-document-changes-version-description" : "timeline.error.load-document-changes-description"), $[6] = t2, $[7] = versionError, $[8] = t4) : t4 = $[8];
  let t5;
  $[9] !== t4 ? (t5 = (0, import_jsx_runtime2.jsx)(TextWithTone, { size: 1, tone: "critical", children: t4 }), $[9] = t4, $[10] = t5) : t5 = $[10];
  let t6;
  return $[11] !== t3 || $[12] !== t5 ? (t6 = (0, import_jsx_runtime2.jsxs)(Flex, { align: "flex-start", gap: 3, padding: 4, children: [
    t1,
    (0, import_jsx_runtime2.jsxs)(Stack, { space: 4, children: [
      t3,
      t5
    ] })
  ] }), $[11] = t3, $[12] = t5, $[13] = t6) : t6 = $[13], t6;
}
var Root$2 = at(Popover2).withConfig({
  displayName: "Root",
  componentId: "sc-5dzvio-0"
})`overflow:hidden;overflow:clip;`;
var TIMELINE_MENU_PORTAL$1 = "timeline-menu";
function TimelineMenu(t0) {
  const $ = (0, import_compiler_runtime2.c)(62), {
    chunk,
    mode,
    placement
  } = t0, {
    setTimelineRange,
    timelineError,
    ready,
    timelineStore
  } = useDocumentPane(), [open, setOpen] = (0, import_react2.useState)(false), [button, setButton] = (0, import_react2.useState)(null), [popoverRef, setPopoverRef] = (0, import_react2.useState)(null), toast = useToast(), chunks = useTimelineSelector(timelineStore, _temp$q), loading = useTimelineSelector(timelineStore, _temp2$b), hasMoreChunks = useTimelineSelector(timelineStore, _temp3$7), realRevChunk = useTimelineSelector(timelineStore, _temp4$7), sinceTime = useTimelineSelector(timelineStore, _temp5$4), {
    t: t2
  } = useTranslation("studio");
  let t1;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = () => {
    setOpen(true);
  }, $[0] = t1) : t1 = $[0];
  const handleOpen = t1;
  let t22;
  $[1] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t22 = () => {
    setOpen(false);
  }, $[1] = t22) : t22 = $[1];
  const handleClose = t22;
  let t3;
  $[2] !== button || $[3] !== open ? (t3 = (event) => {
    open && (event.key === "Escape" || event.key === "Tab") && (handleClose(), button?.focus());
  }, $[2] = button, $[3] = open, $[4] = t3) : t3 = $[4], useGlobalKeyDown(t3);
  let t4;
  $[5] !== button || $[6] !== popoverRef ? (t4 = () => [button, popoverRef], $[5] = button, $[6] = popoverRef, $[7] = t4) : t4 = $[7], useClickOutsideEvent(open && handleClose, t4);
  let t5;
  $[8] !== setTimelineRange || $[9] !== t2 || $[10] !== timelineStore || $[11] !== toast ? (t5 = (revChunk) => {
    const run = () => {
      const [sinceId, revId] = timelineStore?.findRangeForRev(revChunk) || [null, null];
      setTimelineRange(sinceId, revId);
    };
    try {
      run();
    } catch (t62) {
      const err = t62;
      toast.push({
        closable: true,
        description: err.message,
        status: "error",
        title: t2("timeline.error.unable-to-load-revision")
      });
    }
  }, $[8] = setTimelineRange, $[9] = t2, $[10] = timelineStore, $[11] = toast, $[12] = t5) : t5 = $[12];
  const selectRev = t5;
  let t6;
  $[13] !== setTimelineRange || $[14] !== t2 || $[15] !== timelineStore || $[16] !== toast ? (t6 = (sinceChunk) => {
    const run_0 = () => {
      const [sinceId_0, revId_0] = timelineStore?.findRangeForSince(sinceChunk) || [null, null];
      setTimelineRange(sinceId_0, revId_0);
    };
    try {
      run_0();
    } catch (t72) {
      const err_0 = t72;
      toast.push({
        closable: true,
        description: err_0.message,
        status: "error",
        title: t2("timeline.error.unable-to-load-revision")
      });
    }
  }, $[13] = setTimelineRange, $[14] = t2, $[15] = timelineStore, $[16] = toast, $[17] = t6) : t6 = $[17];
  const selectSince = t6;
  let t7;
  $[18] !== loading || $[19] !== timelineStore ? (t7 = () => {
    loading || timelineStore?.loadMore();
  }, $[18] = loading, $[19] = timelineStore, $[20] = t7) : t7 = $[20];
  const handleLoadMore = t7;
  let t8;
  bb0: {
    if (timelineError) {
      let t93;
      $[21] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t93 = (0, import_jsx_runtime2.jsx)(TimelineError, {}), $[21] = t93) : t93 = $[21], t8 = t93;
      break bb0;
    }
    if (mode === "rev") {
      let t93;
      $[22] !== chunks || $[23] !== handleLoadMore || $[24] !== hasMoreChunks || $[25] !== realRevChunk || $[26] !== selectRev ? (t93 = (0, import_jsx_runtime2.jsx)(Timeline, { chunks, hasMoreChunks, lastChunk: realRevChunk, onLoadMore: handleLoadMore, onSelect: selectRev }), $[22] = chunks, $[23] = handleLoadMore, $[24] = hasMoreChunks, $[25] = realRevChunk, $[26] = selectRev, $[27] = t93) : t93 = $[27], t8 = t93;
      break bb0;
    }
    let t92;
    $[28] !== chunks || $[29] !== realRevChunk ? (t92 = realRevChunk ? chunks.filter((c22) => c22.index < realRevChunk.index) : chunks, $[28] = chunks, $[29] = realRevChunk, $[30] = t92) : t92 = $[30];
    const filteredChunks = t92;
    let t102;
    $[31] !== filteredChunks || $[32] !== handleLoadMore || $[33] !== hasMoreChunks || $[34] !== selectSince || $[35] !== sinceTime ? (t102 = (0, import_jsx_runtime2.jsx)(Timeline, { chunks: filteredChunks, hasMoreChunks, lastChunk: sinceTime, onLoadMore: handleLoadMore, onSelect: selectSince }), $[31] = filteredChunks, $[32] = handleLoadMore, $[33] = hasMoreChunks, $[34] = selectSince, $[35] = sinceTime, $[36] = t102) : t102 = $[36], t8 = t102;
  }
  const content = t8;
  let revLabel, t9;
  if ($[37] !== chunk || $[38] !== t2) {
    const formatParams2 = {
      timestamp: {
        dateStyle: "medium",
        timeStyle: "short"
      }
    };
    revLabel = chunk ? t2(TIMELINE_ITEM_I18N_KEY_MAPPING2[chunk.type], {
      context: "timestamp",
      timestamp: new Date(chunk?.endTimestamp),
      formatParams: formatParams2
    }) : t2("timeline.latest-revision"), t9 = chunk ? t2("timeline.since", {
      timestamp: new Date(chunk?.endTimestamp),
      formatParams: formatParams2
    }) : t2("timeline.since-version-missing"), $[37] = chunk, $[38] = t2, $[39] = revLabel, $[40] = t9;
  } else
    revLabel = $[39], t9 = $[40];
  const buttonLabel = mode === "rev" ? revLabel : t9;
  let t10;
  $[41] !== popoverRef ? (t10 = {
    [TIMELINE_MENU_PORTAL$1]: popoverRef
  }, $[41] = popoverRef, $[42] = t10) : t10 = $[42];
  const portalElements = t10, t11 = open && content, t12 = open ? "timeline-menu-close-button" : "timeline-menu-open-button", t13 = !ready, t14 = open ? handleClose : handleOpen;
  let t15;
  $[43] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t15 = {
    maxWidth: "100%"
  }, $[43] = t15) : t15 = $[43];
  let t16;
  $[44] !== buttonLabel || $[45] !== ready || $[46] !== t2 ? (t16 = ready ? buttonLabel : t2("timeline.loading-history"), $[44] = buttonLabel, $[45] = ready, $[46] = t2, $[47] = t16) : t16 = $[47];
  let t17;
  $[48] !== open || $[49] !== t12 || $[50] !== t13 || $[51] !== t14 || $[52] !== t16 ? (t17 = (0, import_jsx_runtime2.jsx)(Flex, { width: "fill", children: (0, import_jsx_runtime2.jsx)(Button2, { "data-testid": t12, disabled: t13, mode: "ghost", onClick: t14, ref: setButton, selected: open, width: "fill", tooltipProps: null, justify: "space-between", style: t15, iconRight: ChevronDownIcon, text: t16 }) }), $[48] = open, $[49] = t12, $[50] = t13, $[51] = t14, $[52] = t16, $[53] = t17) : t17 = $[53];
  let t18;
  $[54] !== open || $[55] !== placement || $[56] !== t11 || $[57] !== t17 ? (t18 = (0, import_jsx_runtime2.jsx)(Root$2, { "data-testid": "timeline-menu", constrainSize: true, content: t11, "data-ui": "versionMenu", open, placement, matchReferenceWidth: true, portal: true, ref: setPopoverRef, children: t17 }), $[54] = open, $[55] = placement, $[56] = t11, $[57] = t17, $[58] = t18) : t18 = $[58];
  let t19;
  return $[59] !== portalElements || $[60] !== t18 ? (t19 = (0, import_jsx_runtime2.jsx)(PortalProvider, { __unstable_elements: portalElements, children: t18 }), $[59] = portalElements, $[60] = t18, $[61] = t19) : t19 = $[61], t19;
}
function _temp5$4(state_3) {
  return state_3.sinceTime;
}
function _temp4$7(state_2) {
  return state_2.realRevChunk;
}
function _temp3$7(state_1) {
  return state_1.hasMoreChunks;
}
function _temp2$b(state_0) {
  return state_0.isLoading;
}
function _temp$q(state2) {
  return state2.chunks;
}
var StyledMotionPath = at(motion.path).withConfig({
  displayName: "StyledMotionPath",
  componentId: "sc-1l2ln4p-0"
})`transform-origin:center;`;
var Circle = (props) => {
  const $ = (0, import_compiler_runtime2.c)(2);
  let t0;
  return $[0] !== props ? (t0 = (0, import_jsx_runtime2.jsx)(motion.circle, { fill: "none", r: "8", cx: "12.5", cy: "12.5", strokeWidth: "1.2", ...props }), $[0] = props, $[1] = t0) : t0 = $[1], t0;
};
var Arrows = (props) => {
  const $ = (0, import_compiler_runtime2.c)(2);
  let t0;
  return $[0] !== props ? (t0 = (0, import_jsx_runtime2.jsx)(StyledMotionPath, { fill: "none", d: "M14 17.5619L11.5 20.5L14.5 23.0619M11 7.43811L13.5 4.50001L10.5 1.93811", ...props }), $[0] = props, $[1] = t0) : t0 = $[1], t0;
};
var Checkmark = (props) => {
  const $ = (0, import_compiler_runtime2.c)(2);
  let t0;
  return $[0] !== props ? (t0 = (0, import_jsx_runtime2.jsx)(motion.path, { d: "M9.5 12.1316L11.7414 14.5L16 10", ...props }), $[0] = props, $[1] = t0) : t0 = $[1], t0;
};
var rotateAnimation = lt`
  0% {
    transform: rotate(0);
  }
  100% {
    transform: rotate(360deg);
  }
`;
var RotateGroup = at.g.withConfig({
  displayName: "RotateGroup",
  componentId: "sc-1l2ln4p-1"
})`transform-origin:center;&[data-rotate]{animation:${rotateAnimation} 1s ease-in-out infinite;}`;
var root = {
  syncing: {
    scale: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    scale: [1, 0.8, 1.2, 0.9, 1.1, 0.95, 1.05, 0.99, 1],
    transition: {
      duration: 0.5,
      delay: 0.2
    }
  },
  changes: {
    transition: {
      duration: 0
    }
  }
};
var circle = {
  syncing: {
    strokeDasharray: "0, 0, 23, 3, 23, 3",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    strokeDasharray: "0, 0, 23, 0, 23, 0",
    strokeDashoffset: 10,
    opacity: 1,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    strokeDasharray: "0, 60, 23, 0, 23, 0",
    strokeDashoffset: 0,
    opacity: 0,
    transition: {
      duration: 0.5
    }
  }
};
var arrows = {
  syncing: {
    opacity: 1,
    transition: {
      duration: 0
    }
  },
  saved: {
    opacity: 0,
    transition: {
      duration: 0.2
    }
  },
  changes: {
    opacity: 0
  }
};
var checkmark = {
  syncing: {
    pathLength: 0,
    transition: {
      duration: 0
    }
  },
  saved: {
    pathLength: 1,
    transition: {
      delay: 0.4,
      duration: 0.3
    }
  },
  changes: {
    pathLength: 0,
    transition: {
      duration: 0.2
    }
  }
};
function AnimatedStatusIcon(props) {
  const $ = (0, import_compiler_runtime2.c)(13), {
    status
  } = props;
  if (!status)
    return null;
  const t0 = status === "changes" ? void 0 : "";
  let t1, t2;
  $[0] !== status ? (t1 = (0, import_jsx_runtime2.jsx)(Arrows, { variants: arrows, initial: status, animate: status }), t2 = (0, import_jsx_runtime2.jsx)(Circle, { variants: circle, initial: status, animate: status }), $[0] = status, $[1] = t1, $[2] = t2) : (t1 = $[1], t2 = $[2]);
  let t3;
  $[3] !== t0 || $[4] !== t1 || $[5] !== t2 ? (t3 = (0, import_jsx_runtime2.jsxs)(RotateGroup, { "data-rotate": t0, children: [
    t1,
    t2
  ] }), $[3] = t0, $[4] = t1, $[5] = t2, $[6] = t3) : t3 = $[6];
  let t4;
  $[7] !== status ? (t4 = (0, import_jsx_runtime2.jsx)(Checkmark, { variants: checkmark, initial: status, animate: status }), $[7] = status, $[8] = t4) : t4 = $[8];
  let t5;
  return $[9] !== status || $[10] !== t3 || $[11] !== t4 ? (t5 = (0, import_jsx_runtime2.jsx)("svg", { width: "1em", height: "1em", viewBox: "0 0 25 25", fill: "none", stroke: "currentColor", strokeWidth: "1.2", "data-sanity-icon": "animated-status-icon", children: (0, import_jsx_runtime2.jsxs)(motion.g, { variants: root, initial: status, animate: status, children: [
    t3,
    t4
  ] }) }), $[9] = status, $[10] = t3, $[11] = t4, $[12] = t5) : t5 = $[12], t5;
}
var STATUS_DICTIONARY = {
  saved: {
    i18nKey: "status-bar.document-status-pulse.status.saved.text",
    tone: "positive"
  },
  syncing: {
    i18nKey: "status-bar.document-status-pulse.status.syncing.text",
    tone: "default"
  }
};
var DocumentStatusPulse = (props) => {
  const $ = (0, import_compiler_runtime2.c)(13), {
    status
  } = props, {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  if (status !== "saved" && status !== "syncing")
    return null;
  const currentStatus = STATUS_DICTIONARY[status];
  let t0;
  $[0] !== status ? (t0 = (0, import_jsx_runtime2.jsx)(AnimatedStatusIcon, { status }), $[0] = status, $[1] = t0) : t0 = $[1];
  let t1;
  $[2] !== currentStatus.tone || $[3] !== t0 ? (t1 = (0, import_jsx_runtime2.jsx)(TextWithTone, { size: 1, tone: currentStatus.tone, children: t0 }), $[2] = currentStatus.tone, $[3] = t0, $[4] = t1) : t1 = $[4];
  let t22;
  $[5] !== currentStatus.i18nKey || $[6] !== t2 ? (t22 = t2(currentStatus.i18nKey), $[5] = currentStatus.i18nKey, $[6] = t2, $[7] = t22) : t22 = $[7];
  let t3;
  $[8] !== t22 ? (t3 = (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: t22 }), $[8] = t22, $[9] = t3) : t3 = $[9];
  let t4;
  return $[10] !== t1 || $[11] !== t3 ? (t4 = (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 2, "data-testid": "pane-footer-document-status-pulse", children: [
    t1,
    t3
  ] }), $[10] = t1, $[11] = t3, $[12] = t4) : t4 = $[12], t4;
};
var RELATIVE_TIME_OPTIONS = {
  minimal: true,
  useTemporalPhrase: true
};
var MotionButton = motion.create(Button);
var MotionBox = motion.create(Box);
function getDocumentStatusKey(timelineKey) {
  return timelineKey === "timeline.operation.published" ? "document-status.last-published" : timelineKey;
}
var ButtonSkeleton = () => {
  const $ = (0, import_compiler_runtime2.c)(2);
  let t0;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = (0, import_jsx_runtime2.jsx)("div", { style: {
    margin: -5
  }, children: (0, import_jsx_runtime2.jsx)(AvatarSkeleton$1, { $size: 0, animated: true }) }), $[0] = t0) : t0 = $[0];
  let t1;
  return $[1] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 3, paddingLeft: 1, paddingRight: 2, paddingY: 2, children: [
    t0,
    (0, import_jsx_runtime2.jsx)(Skeleton, { animated: true, style: {
      width: "80px",
      height: "15px"
    }, radius: 2 })
  ] }), $[1] = t1) : t1 = $[1], t1;
};
var DocumentStatusButton = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(17), {
    author,
    translationKey,
    timestamp: t1
  } = t0, timestamp = t1 === void 0 ? "" : t1, {
    onHistoryOpen,
    inspector,
    onHistoryClose
  } = useDocumentPane(), {
    t: t2
  } = useTranslation(), relativeTime = useRelativeTime(timestamp, RELATIVE_TIME_OPTIONS);
  let t22, t3, t4;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t22 = {
    opacity: 1
  }, t3 = {
    opacity: 0
  }, t4 = {
    opacity: 0
  }, $[0] = t22, $[1] = t3, $[2] = t4) : (t22 = $[0], t3 = $[1], t4 = $[2]);
  const t5 = inspector?.name === HISTORY_INSPECTOR_NAME ? onHistoryClose : onHistoryOpen;
  let t6;
  $[3] !== author ? (t6 = author && (0, import_jsx_runtime2.jsx)("div", { style: {
    margin: -5
  }, children: (0, import_jsx_runtime2.jsx)(UserAvatar, { user: author, size: 0 }) }), $[3] = author, $[4] = t6) : t6 = $[4];
  let t7;
  $[5] !== t2 || $[6] !== translationKey ? (t7 = t2(translationKey), $[5] = t2, $[6] = translationKey, $[7] = t7) : t7 = $[7];
  let t8;
  $[8] !== relativeTime || $[9] !== t7 ? (t8 = (0, import_jsx_runtime2.jsxs)(Text, { muted: true, size: 1, children: [
    t7,
    " ",
    relativeTime
  ] }), $[8] = relativeTime, $[9] = t7, $[10] = t8) : t8 = $[10];
  let t9;
  $[11] !== t6 || $[12] !== t8 ? (t9 = (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", flex: "none", gap: 3, children: [
    t6,
    t8
  ] }), $[11] = t6, $[12] = t8, $[13] = t9) : t9 = $[13];
  let t10;
  return $[14] !== t5 || $[15] !== t9 ? (t10 = (0, import_jsx_runtime2.jsx)(MotionButton, { "data-testid": "pane-footer-document-status", animate: t22, initial: t3, exit: t4, mode: "bleed", onClick: t5, padding: 2, muted: true, children: t9 }), $[14] = t5, $[15] = t9, $[16] = t10) : t10 = $[16], t10;
};
var FallbackStatus = () => {
  const $ = (0, import_compiler_runtime2.c)(6), {
    editState
  } = useDocumentPane(), {
    selectedPerspective
  } = usePerspective();
  let t0;
  $[0] !== editState || $[1] !== selectedPerspective ? (t0 = (function() {
    return isPublishedPerspective(selectedPerspective) && editState?.published?._updatedAt ? {
      translationKey: TIMELINE_ITEM_I18N_KEY_MAPPING.published.createDocumentVersion,
      timestamp: editState.published._updatedAt
    } : editState?.version?._updatedAt ? {
      translationKey: editState.version._updatedAt === editState.version._createdAt ? TIMELINE_ITEM_I18N_KEY_MAPPING.version.createDocumentVersion : TIMELINE_ITEM_I18N_KEY_MAPPING.version.editDocumentVersion,
      timestamp: editState.version._updatedAt
    } : editState?.draft?._updatedAt ? {
      translationKey: editState.draft._updatedAt === editState.draft._createdAt ? TIMELINE_ITEM_I18N_KEY_MAPPING.draft.createDocumentVersion : TIMELINE_ITEM_I18N_KEY_MAPPING.draft.editDocumentVersion,
      timestamp: editState.draft._updatedAt
    } : null;
  })(), $[0] = editState, $[1] = selectedPerspective, $[2] = t0) : t0 = $[2];
  const status = t0;
  if (!status)
    return null;
  let t1;
  return $[3] !== status.timestamp || $[4] !== status.translationKey ? (t1 = (0, import_jsx_runtime2.jsx)(DocumentStatusButton, { author: "", translationKey: status.translationKey, timestamp: status.timestamp }), $[3] = status.timestamp, $[4] = status.translationKey, $[5] = t1) : t1 = $[5], t1;
};
var EventsStatus = () => {
  const $ = (0, import_compiler_runtime2.c)(8), {
    events,
    loading
  } = useEvents(), event = events?.[0];
  if (!event && loading) {
    let t02;
    return $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t02 = (0, import_jsx_runtime2.jsx)(ButtonSkeleton, {}), $[0] = t02) : t02 = $[0], t02;
  }
  if (!event) {
    let t02;
    return $[1] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t02 = (0, import_jsx_runtime2.jsx)(FallbackStatus, {}), $[1] = t02) : t02 = $[1], t02;
  }
  const t0 = event.author, t1 = TIMELINE_ITEM_I18N_KEY_MAPPING[event.documentVariantType][event.type];
  let t2;
  $[2] !== t1 ? (t2 = getDocumentStatusKey(t1), $[2] = t1, $[3] = t2) : t2 = $[3];
  let t3;
  return $[4] !== event.author || $[5] !== event.timestamp || $[6] !== t2 ? (t3 = (0, import_jsx_runtime2.jsx)(DocumentStatusButton, { author: t0, translationKey: t2, timestamp: event.timestamp }), $[4] = event.author, $[5] = event.timestamp, $[6] = t2, $[7] = t3) : t3 = $[7], t3;
};
var TimelineStatus = () => {
  const $ = (0, import_compiler_runtime2.c)(10), {
    timelineStore
  } = useDocumentPane(), chunks = useTimelineSelector(timelineStore, _temp$p), loading = useTimelineSelector(timelineStore, _temp2$a), event = chunks?.[0];
  if (!event && loading) {
    let t02;
    return $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t02 = (0, import_jsx_runtime2.jsx)(ButtonSkeleton, {}), $[0] = t02) : t02 = $[0], t02;
  }
  if (!event) {
    let t02;
    return $[1] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t02 = (0, import_jsx_runtime2.jsx)(FallbackStatus, {}), $[1] = t02) : t02 = $[1], t02;
  }
  let t0;
  $[2] !== event.authors ? (t0 = Array.from(event.authors), $[2] = event.authors, $[3] = t0) : t0 = $[3];
  const author = t0[0], t1 = TIMELINE_ITEM_I18N_KEY_MAPPING2[event.type];
  let t2;
  $[4] !== t1 ? (t2 = getDocumentStatusKey(t1), $[4] = t1, $[5] = t2) : t2 = $[5];
  let t3;
  return $[6] !== author || $[7] !== event.endTimestamp || $[8] !== t2 ? (t3 = (0, import_jsx_runtime2.jsx)(DocumentStatusButton, { author, translationKey: t2, timestamp: event.endTimestamp }), $[6] = author, $[7] = event.endTimestamp, $[8] = t2, $[9] = t3) : t3 = $[9], t3;
};
var SYNCING_TIMEOUT = 1e3;
var SAVED_TIMEOUT = 3e3;
function DocumentStatusLine() {
  const $ = (0, import_compiler_runtime2.c)(18), {
    documentId,
    documentType,
    editState,
    value
  } = useDocumentPane(), [status, setStatus] = (0, import_react2.useState)(null), eventsEnabled = useSource().beta?.eventsAPI?.documents, syncState = useSyncState(documentId, documentType, editState?.release), lastUpdated = value?._updatedAt;
  let t0;
  $[0] !== status || $[1] !== syncState.isSyncing ? (t0 = () => {
    if (status === "syncing" && !syncState.isSyncing) {
      const timerId = setTimeout(() => setStatus("saved"), SYNCING_TIMEOUT);
      return () => clearTimeout(timerId);
    }
    if (status === "saved") {
      const timerId_0 = setTimeout(() => setStatus(null), SAVED_TIMEOUT);
      return () => clearTimeout(timerId_0);
    }
  }, $[0] = status, $[1] = syncState.isSyncing, $[2] = t0) : t0 = $[2];
  let t1;
  $[3] !== lastUpdated || $[4] !== status || $[5] !== syncState.isSyncing ? (t1 = [status, lastUpdated, syncState.isSyncing], $[3] = lastUpdated, $[4] = status, $[5] = syncState.isSyncing, $[6] = t1) : t1 = $[6], (0, import_react2.useEffect)(t0, t1);
  let t2;
  $[7] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t2 = () => {
    setStatus(null);
  }, $[7] = t2) : t2 = $[7];
  let t3;
  $[8] !== documentId ? (t3 = [documentId], $[8] = documentId, $[9] = t3) : t3 = $[9], (0, import_react2.useLayoutEffect)(t2, t3);
  let t4;
  $[10] !== syncState.isSyncing ? (t4 = () => {
    syncState.isSyncing && setStatus("syncing");
  }, $[10] = syncState.isSyncing, $[11] = t4) : t4 = $[11];
  let t5;
  $[12] !== lastUpdated || $[13] !== syncState.isSyncing ? (t5 = [syncState.isSyncing, lastUpdated], $[12] = lastUpdated, $[13] = syncState.isSyncing, $[14] = t5) : t5 = $[14], (0, import_react2.useLayoutEffect)(t4, t5);
  let t6;
  return $[15] !== eventsEnabled || $[16] !== status ? (t6 = (0, import_jsx_runtime2.jsx)(AnimatePresence, { children: status ? (0, import_jsx_runtime2.jsx)(MotionBox, { paddingLeft: 2, animate: {
    opacity: 1
  }, initial: {
    opacity: 0
  }, exit: {
    opacity: 0
  }, children: (0, import_jsx_runtime2.jsx)(DocumentStatusPulse, { status: status || void 0 }) }) : (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: eventsEnabled ? (0, import_jsx_runtime2.jsx)(EventsStatus, {}) : (0, import_jsx_runtime2.jsx)(TimelineStatus, {}) }) }), $[15] = eventsEnabled, $[16] = status, $[17] = t6) : t6 = $[17], t6;
}
function _temp$p(state2) {
  return state2.chunks;
}
function _temp2$a(state_0) {
  return state_0.isLoading;
}
var StatusText = at(Text).withConfig({
  displayName: "StatusText",
  componentId: "sc-15z6xze-0"
})`color:var(--card-muted-fg-color);em{color:var(--card-fg-color);font-weight:500;font-style:normal;}`;
function RevisionStatusLine() {
  const $ = (0, import_compiler_runtime2.c)(9), {
    displayed,
    revisionNotFound
  } = useDocumentPane(), events = (0, import_react2.useContext)(EventsContext), revision = events?.revision, revisionEvent = events?.events.find((ev) => ev.id === revision?.revisionId), {
    t: t2
  } = useTranslation(), date = revisionEvent?.timestamp || displayed?._updatedAt || displayed?._createdAt, t0 = "revision", t1 = date ? (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "document-status.revision-from", values: {
    date: format(new Date(date), "MMM d, yyyy '@' pp")
  } }) : null;
  let t22;
  $[0] !== t1 ? (t22 = {
    name: t0,
    text: t1,
    tone: "caution"
  }, $[0] = t1, $[1] = t22) : t22 = $[1];
  const message = t22;
  let t3;
  $[2] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t3 = (0, import_jsx_runtime2.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(RestoreIcon, {}) }) }), $[2] = t3) : t3 = $[2];
  let t4;
  $[3] !== message || $[4] !== revisionNotFound || $[5] !== t2 ? (t4 = revisionNotFound ? (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "document-status.revision-not-found" }) : message.text, $[3] = message, $[4] = revisionNotFound, $[5] = t2, $[6] = t4) : t4 = $[6];
  let t5;
  return $[7] !== t4 ? (t5 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: (0, import_jsx_runtime2.jsxs)(Flex, { flex: 1, gap: 3, padding: 2, children: [
    t3,
    (0, import_jsx_runtime2.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime2.jsx)(StatusText, { size: 1, textOverflow: "ellipsis", children: t4 }) })
  ] }) }), $[7] = t4, $[8] = t5) : t5 = $[8], t5;
}
function useResizeObserver(t0) {
  const $ = (0, import_compiler_runtime2.c)(4), {
    element,
    onResize
  } = t0;
  let t1, t2;
  $[0] !== element || $[1] !== onResize ? (t1 = () => (element && resizeObserver.observe(element, onResize), () => {
    element && resizeObserver.unobserve(element);
  }), t2 = [element, onResize], $[0] = element, $[1] = onResize, $[2] = t1, $[3] = t2) : (t1 = $[2], t2 = $[3]), (0, import_react2.useLayoutEffect)(t1, t2);
}
var CONTAINER_BREAKPOINT = 480;
var AnimatedCard = motion.create(Card);
function DocumentStatusBar(props) {
  const $ = (0, import_compiler_runtime2.c)(22), {
    actionsBoxRef,
    createLinkMetadata
  } = props, {
    editState,
    onChange: onDocumentChange,
    revisionNotFound
  } = useDocumentPane(), {
    params: t0
  } = usePaneRouter(), params = t0 === void 0 ? EMPTY_PARAMS$2 : t0, {
    selectedPerspective
  } = usePerspective(), {
    title
  } = useDocumentTitle(), CreateLinkedActions = useSanityCreateConfig().components?.documentLinkedActions, showingRevision = !!params.rev, [collapsed, setCollapsed] = (0, import_react2.useState)(null), [rootElement, setRootElement] = (0, import_react2.useState)(null);
  let t1;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = (event) => {
    setCollapsed(event.contentRect.width < CONTAINER_BREAKPOINT);
  }, $[0] = t1) : t1 = $[0];
  const handleResize = t1;
  let t2;
  $[1] !== rootElement ? (t2 = {
    element: rootElement,
    onResize: handleResize
  }, $[1] = rootElement, $[2] = t2) : t2 = $[2], useResizeObserver(t2);
  let t3;
  bb0: {
    const isReady = !!(editState?.ready && typeof collapsed == "boolean");
    if (selectedPerspective) {
      if (isPublishedPerspective(selectedPerspective)) {
        t3 = isReady && !!editState?.published;
        break bb0;
      }
      if (isReleaseDocument(selectedPerspective)) {
        t3 = isReady && !!editState?.version;
        break bb0;
      }
    }
    t3 = isReady;
  }
  const shouldRender = t3;
  let actions;
  if (createLinkMetadata && isSanityCreateLinked(createLinkMetadata) && CreateLinkedActions) {
    let t42;
    $[3] !== CreateLinkedActions || $[4] !== createLinkMetadata || $[5] !== onDocumentChange || $[6] !== title ? (t42 = (0, import_jsx_runtime2.jsx)(CreateLinkedActions, { metadata: createLinkMetadata, panelPortalElementId: DOCUMENT_PANEL_PORTAL_ELEMENT, onDocumentChange, documentTitle: title }), $[3] = CreateLinkedActions, $[4] = createLinkMetadata, $[5] = onDocumentChange, $[6] = title, $[7] = t42) : t42 = $[7], actions = t42;
  } else if (showingRevision) {
    let t42;
    $[8] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t42 = (0, import_jsx_runtime2.jsx)(HistoryStatusBarActions, {}), $[8] = t42) : t42 = $[8], actions = t42;
  } else {
    let t42;
    $[9] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t42 = (0, import_jsx_runtime2.jsx)(DocumentStatusBarActions, {}), $[9] = t42) : t42 = $[9], actions = t42;
  }
  if (showingRevision && revisionNotFound)
    return null;
  const t4 = showingRevision ? "revision" : "published";
  let t5;
  $[10] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t5 = {
    opacity: 0.2
  }, $[10] = t5) : t5 = $[10];
  let t6;
  $[11] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t6 = {
    opacity: 1,
    transition: {
      duration: 0.3
    }
  }, $[11] = t6) : t6 = $[11];
  const t7 = showingRevision ? "caution" : void 0;
  let t8;
  $[12] !== actions || $[13] !== actionsBoxRef || $[14] !== collapsed || $[15] !== shouldRender || $[16] !== showingRevision ? (t8 = shouldRender && (0, import_jsx_runtime2.jsxs)(Flex, { align: "stretch", gap: 1, justify: "space-between", paddingLeft: showingRevision ? 0 : 1, paddingRight: showingRevision ? 0 : 1, children: [
    (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", flex: 1, gap: collapsed ? 2 : 3, wrap: "wrap", paddingRight: 3, children: [
      (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", children: [
        showingRevision ? (0, import_jsx_runtime2.jsx)(RevisionStatusLine, {}) : (0, import_jsx_runtime2.jsx)(DocumentStatusLine, {}),
        (0, import_jsx_runtime2.jsx)(SpacerButton, {})
      ] }),
      (0, import_jsx_runtime2.jsx)(DocumentBadges, {})
    ] }),
    (0, import_jsx_runtime2.jsxs)(Flex, { align: "flex-start", justify: "flex-end", ref: actionsBoxRef, style: {
      flexShrink: 0,
      marginLeft: "auto"
    }, children: [
      (0, import_jsx_runtime2.jsx)(SpacerButton, {}),
      actions
    ] })
  ] }), $[12] = actions, $[13] = actionsBoxRef, $[14] = collapsed, $[15] = shouldRender, $[16] = showingRevision, $[17] = t8) : t8 = $[17];
  let t9;
  return $[18] !== t4 || $[19] !== t7 || $[20] !== t8 ? (t9 = (0, import_jsx_runtime2.jsx)(AnimatedCard, { initial: t5, animate: t6, tone: t7, radius: 3, ref: setRootElement, sizing: "border", padding: 2, children: t8 }, t4), $[18] = t4, $[19] = t7, $[20] = t8, $[21] = t9) : t9 = $[21], t9;
}
var KeyboardShortcutResponder = (0, import_react2.memo)(function(props) {
  const $ = (0, import_compiler_runtime2.c)(26);
  let actionsBoxElement, activeIndex, children, id, onActionStart, onKeyDown, rest, rootRef, states, t0;
  $[0] !== props ? ({
    actionsBoxElement,
    activeIndex,
    as: t0,
    children,
    id,
    onActionStart,
    onKeyDown,
    rootRef,
    states,
    ...rest
  } = props, $[0] = props, $[1] = actionsBoxElement, $[2] = activeIndex, $[3] = children, $[4] = id, $[5] = onActionStart, $[6] = onKeyDown, $[7] = rest, $[8] = rootRef, $[9] = states, $[10] = t0) : (actionsBoxElement = $[1], activeIndex = $[2], children = $[3], id = $[4], onActionStart = $[5], onKeyDown = $[6], rest = $[7], rootRef = $[8], states = $[9], t0 = $[10]);
  const As = t0 === void 0 ? "div" : t0, activeAction = states[activeIndex];
  let t1;
  $[11] !== onActionStart || $[12] !== onKeyDown || $[13] !== states ? (t1 = (event) => {
    const matchingStates = states.filter((state2) => state2.shortcut && isHotkey(state2.shortcut, event)), matchingState = matchingStates[0];
    if (matchingStates.length > 1 && console.warn(`Keyboard shortcut conflict: More than one document action matches the shortcut "${matchingState.shortcut}"`), matchingState && !matchingState.disabled && matchingState.onHandle) {
      event.preventDefault(), matchingState.onHandle(), onActionStart(states.indexOf(matchingState));
      return;
    }
    onKeyDown && onKeyDown(event);
  }, $[11] = onActionStart, $[12] = onKeyDown, $[13] = states, $[14] = t1) : t1 = $[14];
  const handleKeyDown = t1;
  let t2;
  $[15] !== actionsBoxElement || $[16] !== activeAction ? (t2 = activeAction && activeAction.dialog && (0, import_jsx_runtime2.jsx)(LegacyLayerProvider, { zOffset: "paneFooter", children: (0, import_jsx_runtime2.jsx)(ActionStateDialog, { dialog: activeAction.dialog, referenceElement: actionsBoxElement }) }), $[15] = actionsBoxElement, $[16] = activeAction, $[17] = t2) : t2 = $[17];
  let t3;
  return $[18] !== As || $[19] !== children || $[20] !== handleKeyDown || $[21] !== id || $[22] !== rest || $[23] !== rootRef || $[24] !== t2 ? (t3 = (0, import_jsx_runtime2.jsxs)(As, { id, onKeyDown: handleKeyDown, tabIndex: -1, ...rest, ref: rootRef, children: [
    children,
    t2
  ] }), $[18] = As, $[19] = children, $[20] = handleKeyDown, $[21] = id, $[22] = rest, $[23] = rootRef, $[24] = t2, $[25] = t3) : t3 = $[25], t3;
});
var DocumentActionShortcuts = (0, import_react2.memo)((props) => {
  const $ = (0, import_compiler_runtime2.c)(12);
  let actionsBoxElement, children, rest, t0;
  $[0] !== props ? ({
    actionsBoxElement,
    as: t0,
    children,
    ...rest
  } = props, $[0] = props, $[1] = actionsBoxElement, $[2] = children, $[3] = rest, $[4] = t0) : (actionsBoxElement = $[1], children = $[2], rest = $[3], t0 = $[4]);
  const as = t0 === void 0 ? "div" : t0, [activeIndex, setActiveIndex] = (0, import_react2.useState)(-1);
  let t1;
  $[5] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = (idx) => {
    setActiveIndex(idx);
  }, $[5] = t1) : t1 = $[5];
  const onActionStart = t1;
  let t2;
  return $[6] !== actionsBoxElement || $[7] !== activeIndex || $[8] !== as || $[9] !== children || $[10] !== rest ? (t2 = (0, import_jsx_runtime2.jsx)(RenderActionCollectionState, { children: (t3) => {
    const {
      states
    } = t3;
    return (0, import_jsx_runtime2.jsx)(KeyboardShortcutResponder, { ...rest, activeIndex, actionsBoxElement, as, onActionStart, states, children });
  } }), $[6] = actionsBoxElement, $[7] = activeIndex, $[8] = as, $[9] = children, $[10] = rest, $[11] = t2) : t2 = $[11], t2;
});
DocumentActionShortcuts.displayName = "Memo(DocumentActionShortcuts)";
var HiddenCheckmarkIcon = () => {
  const $ = (0, import_compiler_runtime2.c)(1);
  let t0;
  return $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = (0, import_jsx_runtime2.jsx)(CheckmarkIcon, { style: {
    visibility: "hidden"
  } }), $[0] = t0) : t0 = $[0], t0;
};
function getInspectorItems({
  currentInspector,
  hasValue,
  inspectors: inspectors2,
  inspectorMenuItems
}) {
  return inspectors2.map((inspector, index) => {
    const menuItem = inspectorMenuItems[index];
    return !menuItem || menuItem.hidden ? null : {
      action: `${INSPECT_ACTION_PREFIX}${inspector.name}`,
      group: menuItem.showAsAction ? void 0 : "inspectors",
      icon: menuItem.icon,
      disabled: !hasValue,
      selected: currentInspector?.name === inspector.name,
      shortcut: menuItem.hotkeys?.join("+"),
      showAsAction: menuItem.showAsAction,
      title: menuItem.title,
      tone: menuItem.tone
    };
  }).filter(Boolean);
}
function getInspectItem({
  hasValue,
  t: t2
}) {
  return {
    action: "inspect",
    group: "inspectors",
    title: t2("document-inspector.menu-item.title"),
    icon: JsonIcon,
    disabled: !hasValue,
    shortcut: "Ctrl+Alt+I"
  };
}
function getCompareVersionsItem({
  documentIdStack,
  t: t2
}) {
  const disabled = typeof documentIdStack?.previousId > "u" && {
    reason: t2("compare-versions.menu-item.disabled-reason")
  };
  return {
    action: "compareVersions",
    group: "inspectors",
    title: t2("compare-versions.menu-item.title"),
    icon: TransferIcon,
    disabled
  };
}
function getInlineChangesItem({
  displayInlineChanges,
  t: t2
}) {
  return {
    action: "toggleInlineChanges",
    group: "inspectors",
    title: t2("toggle-inline-changes.menu-item.title"),
    // The simplest way to render no icon, while preserving an icon-sized space, is to render a
    // hidden icon.
    icon: displayInlineChanges ? CheckmarkIcon : HiddenCheckmarkIcon
  };
}
function getProductionPreviewItem({
  previewUrl,
  t: t2
}) {
  return previewUrl ? {
    action: "production-preview",
    group: "links",
    title: t2("production-preview.menu-item.title"),
    icon: EarthAmericasIcon,
    shortcut: "Ctrl+Alt+O"
  } : null;
}
function getMenuItems(params) {
  const inspectorItems = getInspectorItems(params), items = [
    // Get production preview item
    getProductionPreviewItem(params),
    getCompareVersionsItem(params),
    getInlineChangesItem(params)
  ].filter(Boolean);
  return [
    // Always present document menu item to copy current url to clipboard
    {
      action: "copy-document-url",
      showAsAction: true,
      title: params.t("action.copy-document-url.label"),
      icon: LinkIcon
    },
    ...inspectorItems,
    // TODO: convert to inspector or document view?
    getInspectItem(params),
    ...items
  ];
}
function DocumentLayoutError(props) {
  const $ = (0, import_compiler_runtime2.c)(23), {
    documentType,
    value,
    currentMinWidth,
    paneKey,
    minWidth
  } = props, {
    t: t2
  } = useTranslation();
  let t0;
  $[0] !== documentType ? (t0 = {
    documentType
  }, $[0] = documentType, $[1] = t0) : t0 = $[1];
  let t1;
  $[2] !== t2 || $[3] !== t0 ? (t1 = (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "panes.document-pane.document-unknown-type.title", values: t0 }), $[2] = t2, $[3] = t0, $[4] = t1) : t1 = $[4];
  let t22;
  $[5] !== documentType || $[6] !== t2 ? (t22 = documentType && (0, import_jsx_runtime2.jsx)(Text, { as: "p", children: (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "panes.document-pane.document-unknown-type.text", values: {
    documentType
  } }) }), $[5] = documentType, $[6] = t2, $[7] = t22) : t22 = $[7];
  let t3;
  $[8] !== documentType || $[9] !== t2 ? (t3 = !documentType && (0, import_jsx_runtime2.jsx)(Text, { as: "p", children: t2("panes.document-pane.document-unknown-type.without-schema.text") }), $[8] = documentType, $[9] = t2, $[10] = t3) : t3 = $[10];
  let t4;
  $[11] !== value ? (t4 = isDev && value && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    (0, import_jsx_runtime2.jsx)(Text, { as: "p", children: "Here is the JSON representation of the document:" }),
    (0, import_jsx_runtime2.jsx)(Card, { padding: 3, overflow: "auto", radius: 2, shadow: 1, tone: "inherit", children: (0, import_jsx_runtime2.jsx)(Code, { language: "json", size: [1, 1, 2], children: JSON.stringify(value, null, 2) }) })
  ] }), $[11] = value, $[12] = t4) : t4 = $[12];
  let t5;
  $[13] !== t22 || $[14] !== t3 || $[15] !== t4 ? (t5 = (0, import_jsx_runtime2.jsxs)(Stack, { space: 4, children: [
    t22,
    t3,
    t4
  ] }), $[13] = t22, $[14] = t3, $[15] = t4, $[16] = t5) : t5 = $[16];
  let t6;
  return $[17] !== currentMinWidth || $[18] !== minWidth || $[19] !== paneKey || $[20] !== t1 || $[21] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(ErrorPane, { currentMinWidth, flex: 2.5, minWidth, paneKey, title: t1, tone: "caution", children: t5 }), $[17] = currentMinWidth, $[18] = minWidth, $[19] = paneKey, $[20] = t1, $[21] = t5, $[22] = t6) : t6 = $[22], t6;
}
var DIALOG_PROVIDER_POSITION$1 = [
  // We use the `position: fixed` for dialogs on narrower screens (first two media breakpoints).
  "fixed",
  "fixed",
  // And we use the `position: absolute` strategy (within panes) on wide screens.
  "absolute"
];
function DocumentLayoutFooter(t0) {
  const $ = (0, import_compiler_runtime2.c)(16), {
    documentPanelPortalElement,
    setFooterElement,
    setActionsBoxElement
  } = t0, zOffsets = useZIndex(), {
    value
  } = useDocumentPane();
  let t1;
  $[0] !== documentPanelPortalElement ? (t1 = {
    [DOCUMENT_PANEL_PORTAL_ELEMENT]: documentPanelPortalElement
  }, $[0] = documentPanelPortalElement, $[1] = t1) : t1 = $[1];
  const portalElements = t1;
  let t2;
  $[2] !== value ? (t2 = getSanityCreateLinkMetadata(value), $[2] = value, $[3] = t2) : t2 = $[3];
  const createLinkMetadata = t2;
  let t3;
  $[4] !== createLinkMetadata || $[5] !== setActionsBoxElement ? (t3 = (0, import_jsx_runtime2.jsx)(TooltipDelayGroupProvider, { children: (0, import_jsx_runtime2.jsx)(DocumentStatusBar, { actionsBoxRef: setActionsBoxElement, createLinkMetadata }) }), $[4] = createLinkMetadata, $[5] = setActionsBoxElement, $[6] = t3) : t3 = $[6];
  let t4;
  $[7] !== setFooterElement || $[8] !== t3 ? (t4 = (0, import_jsx_runtime2.jsx)(PaneFooter, { ref: setFooterElement, padding: 1, children: t3 }), $[7] = setFooterElement, $[8] = t3, $[9] = t4) : t4 = $[9];
  let t5;
  $[10] !== t4 || $[11] !== zOffsets.portal ? (t5 = (0, import_jsx_runtime2.jsx)(DialogProvider, { position: DIALOG_PROVIDER_POSITION$1, zOffset: zOffsets.portal, children: t4 }), $[10] = t4, $[11] = zOffsets.portal, $[12] = t5) : t5 = $[12];
  let t6;
  return $[13] !== portalElements || $[14] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(PortalProvider, { __unstable_elements: portalElements, children: t5 }), $[13] = portalElements, $[14] = t5, $[15] = t6) : t6 = $[15], t6;
}
var EMPTY_ARRAY$1 = [];
var DIALOG_PROVIDER_POSITION = [
  // We use the `position: fixed` for dialogs on narrower screens (first two media breakpoints).
  "fixed",
  "fixed",
  // And we use the `position: absolute` strategy (within panes) on wide screens.
  "absolute"
];
var StyledChangeConnectorRoot = at(ChangeConnectorRoot).withConfig({
  displayName: "StyledChangeConnectorRoot",
  componentId: "sc-tn8aer-0"
})`flex:1;display:flex;flex-direction:column;min-height:0;min-width:0;`;
function DocumentLayout() {
  const $ = (0, import_compiler_runtime2.c)(82), {
    changesOpen,
    displayed,
    documentId,
    documentType,
    editState,
    fieldActions,
    focusPath,
    inspectOpen,
    inspector,
    inspectors: inspectors2,
    onFocus,
    onHistoryOpen,
    onMenuAction,
    onPathOpen,
    paneKey,
    schemaType,
    value,
    previewUrl
  } = useDocumentPane(), {
    stickyParams
  } = useRouter(), {
    params: paneParams
  } = usePaneRouter(), {
    features
  } = useStructureTool(), {
    t: t2
  } = useTranslation(structureLocaleNamespace), {
    collapsed: layoutCollapsed
  } = usePaneLayout(), zOffsets = useZIndex(), [rootElement, setRootElement] = (0, import_react2.useState)(null), [footerElement, setFooterElement] = (0, import_react2.useState)(null), [headerElement, setHeaderElement] = (0, import_react2.useState)(null), [actionsBoxElement, setActionsBoxElement] = (0, import_react2.useState)(null), [documentPanelPortalElement, setDocumentPanelPortalElement] = (0, import_react2.useState)(null);
  let t0;
  $[0] !== focusPath || $[1] !== rootElement || $[2] !== value ? (t0 = {
    element: rootElement,
    focusPath,
    value
  }, $[0] = focusPath, $[1] = rootElement, $[2] = value, $[3] = t0) : t0 = $[3], useGlobalCopyPasteElementHandler(t0);
  let t1;
  $[4] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = [], $[4] = t1) : t1 = $[4];
  const [inspectorMenuItems, setInspectorMenuItems] = (0, import_react2.useState)(t1);
  let t22;
  $[5] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t22 = [], $[5] = t22) : t22 = $[5];
  const [rootFieldActionNodes, setRootFieldActionNodes] = (0, import_react2.useState)(t22), footerRect = useElementRect(footerElement), headerRect = useElementRect(headerElement), footerHeight = footerRect?.height, headerHeight = headerRect?.height, currentMinWidth = DOCUMENT_PANEL_INITIAL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0), minWidth = DOCUMENT_PANEL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0);
  let t3;
  $[6] !== inspector?.name || $[7] !== inspectors2 ? (t3 = inspectors2?.find((i) => i.name === inspector?.name), $[6] = inspector?.name, $[7] = inspectors2, $[8] = t3) : t3 = $[8];
  const currentInspector = t3;
  let t4;
  $[9] !== displayed || $[10] !== documentId || $[11] !== editState ? (t4 = {
    displayed,
    documentId,
    editState
  }, $[9] = displayed, $[10] = documentId, $[11] = editState, $[12] = t4) : t4 = $[12];
  const documentIdStack = useDocumentIdStack(t4), hasValue = !!value, t5 = stickyParams.displayInlineChanges === "true";
  let t6;
  $[13] !== currentInspector || $[14] !== documentIdStack || $[15] !== features || $[16] !== hasValue || $[17] !== inspectorMenuItems || $[18] !== inspectors2 || $[19] !== previewUrl || $[20] !== t2 || $[21] !== t5 ? (t6 = getMenuItems({
    currentInspector,
    features,
    hasValue,
    inspectorMenuItems,
    inspectors: inspectors2,
    previewUrl,
    documentIdStack,
    t: t2,
    displayInlineChanges: t5
  }), $[13] = currentInspector, $[14] = documentIdStack, $[15] = features, $[16] = hasValue, $[17] = inspectorMenuItems, $[18] = inspectors2, $[19] = previewUrl, $[20] = t2, $[21] = t5, $[22] = t6) : t6 = $[22];
  const menuItems = t6;
  let t7;
  $[23] !== menuItems || $[24] !== onMenuAction ? (t7 = (event) => {
    for (const item of menuItems)
      if (item.shortcut && isHotkey(item.shortcut, event)) {
        event.preventDefault(), event.stopPropagation(), onMenuAction(item);
        return;
      }
  }, $[23] = menuItems, $[24] = onMenuAction, $[25] = t7) : t7 = $[25];
  const handleKeyUp = t7;
  let t8;
  $[26] !== onFocus || $[27] !== onPathOpen ? (t8 = (path) => {
    onPathOpen(path), onFocus(path);
  }, $[26] = onFocus, $[27] = onPathOpen, $[28] = t8) : t8 = $[28];
  const onConnectorSetFocus = t8;
  if (!schemaType) {
    let t92;
    return $[29] !== currentMinWidth || $[30] !== documentType || $[31] !== minWidth || $[32] !== paneKey || $[33] !== value ? (t92 = (0, import_jsx_runtime2.jsx)(DocumentLayoutError, { currentMinWidth, documentType, minWidth, paneKey, value }), $[29] = currentMinWidth, $[30] = documentType, $[31] = minWidth, $[32] = paneKey, $[33] = value, $[34] = t92) : t92 = $[34], t92;
  }
  let t9;
  $[35] !== documentId || $[36] !== documentType || $[37] !== inspectors2 ? (t9 = inspectors2.length > 0 && (0, import_jsx_runtime2.jsx)(DocumentInspectorMenuItemsResolver, { documentId, documentType, inspectors: inspectors2, onMenuItems: setInspectorMenuItems }), $[35] = documentId, $[36] = documentType, $[37] = inspectors2, $[38] = t9) : t9 = $[38];
  let t10;
  $[39] !== documentId || $[40] !== documentType || $[41] !== fieldActions || $[42] !== schemaType ? (t10 = fieldActions.length > 0 && schemaType && (0, import_jsx_runtime2.jsx)(FieldActionsResolver, { actions: fieldActions, documentId, documentType, onActions: setRootFieldActionNodes, path: EMPTY_ARRAY$1, schemaType }), $[39] = documentId, $[40] = documentType, $[41] = fieldActions, $[42] = schemaType, $[43] = t10) : t10 = $[43];
  let t11;
  $[44] !== menuItems ? (t11 = (0, import_jsx_runtime2.jsx)(DocumentPanelHeader, { ref: setHeaderElement, menuItems }), $[44] = menuItems, $[45] = t11) : t11 = $[45];
  const t12 = layoutCollapsed ? void 0 : "fill", t13 = changesOpen && paneParams?.changesInspectorTab === "review", t14 = footerHeight || null, t15 = headerHeight || null;
  let t16;
  $[46] !== documentPanelPortalElement ? (t16 = (0, import_jsx_runtime2.jsx)(DocumentLayoutFooter, { documentPanelPortalElement, setFooterElement, setActionsBoxElement }), $[46] = documentPanelPortalElement, $[47] = t16) : t16 = $[47];
  let t17;
  $[48] !== inspectOpen || $[49] !== rootElement || $[50] !== t14 || $[51] !== t15 || $[52] !== t16 ? (t17 = (0, import_jsx_runtime2.jsx)(DocumentPanel, { footerHeight: t14, headerHeight: t15, isInspectOpen: inspectOpen, rootElement, setDocumentPanelPortalElement, footer: t16 }), $[48] = inspectOpen, $[49] = rootElement, $[50] = t14, $[51] = t15, $[52] = t16, $[53] = t17) : t17 = $[53];
  let t18;
  $[54] !== onConnectorSetFocus || $[55] !== onHistoryOpen || $[56] !== t13 || $[57] !== t17 ? (t18 = (0, import_jsx_runtime2.jsx)(StyledChangeConnectorRoot, { "data-testid": "change-connector-root", isReviewChangesOpen: t13, onOpenReviewChanges: onHistoryOpen, onSetFocus: onConnectorSetFocus, children: t17 }), $[54] = onConnectorSetFocus, $[55] = onHistoryOpen, $[56] = t13, $[57] = t17, $[58] = t18) : t18 = $[58];
  let t19;
  $[59] !== t12 || $[60] !== t18 ? (t19 = (0, import_jsx_runtime2.jsx)(Flex, { direction: "column", flex: 1, height: t12, children: t18 }), $[59] = t12, $[60] = t18, $[61] = t19) : t19 = $[61];
  let t20;
  $[62] !== t19 || $[63] !== zOffsets.paneDialog ? (t20 = (0, import_jsx_runtime2.jsx)(DialogProvider, { position: DIALOG_PROVIDER_POSITION, zOffset: zOffsets.paneDialog, children: t19 }), $[62] = t19, $[63] = zOffsets.paneDialog, $[64] = t20) : t20 = $[64];
  let t21;
  $[65] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t21 = (0, import_jsx_runtime2.jsx)(DocumentOperationResults, {}), $[65] = t21) : t21 = $[65];
  let t222;
  $[66] !== actionsBoxElement || $[67] !== currentMinWidth || $[68] !== handleKeyUp || $[69] !== minWidth || $[70] !== paneKey || $[71] !== t11 || $[72] !== t20 ? (t222 = (0, import_jsx_runtime2.jsxs)(DocumentActionShortcuts, { actionsBoxElement, as: Pane, currentMinWidth, "data-testid": "document-pane", flex: 2.5, id: paneKey, minWidth, onKeyUp: handleKeyUp, rootRef: setRootElement, children: [
    t11,
    t20,
    t21
  ] }), $[66] = actionsBoxElement, $[67] = currentMinWidth, $[68] = handleKeyUp, $[69] = minWidth, $[70] = paneKey, $[71] = t11, $[72] = t20, $[73] = t222) : t222 = $[73];
  let t23;
  $[74] !== rootFieldActionNodes || $[75] !== t222 ? (t23 = (0, import_jsx_runtime2.jsx)(DocumentActionsProvider, { children: (0, import_jsx_runtime2.jsx)(FieldActionsProvider, { actions: rootFieldActionNodes, path: EMPTY_ARRAY$1, children: t222 }) }), $[74] = rootFieldActionNodes, $[75] = t222, $[76] = t23) : t23 = $[76];
  let t24;
  return $[77] !== t10 || $[78] !== t23 || $[79] !== t9 || $[80] !== value ? (t24 = (0, import_jsx_runtime2.jsxs)(GetFormValueProvider, { value, children: [
    t9,
    t10,
    t23
  ] }), $[77] = t10, $[78] = t23, $[79] = t9, $[80] = value, $[81] = t24) : t24 = $[81], t24;
}
function useDocumentLayoutComponent() {
  const $ = (0, import_compiler_runtime2.c)(1);
  let t0;
  return $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    pick: pickDocumentLayoutComponent,
    defaultComponent: DocumentLayout
  }, $[0] = t0) : t0 = $[0], useMiddlewareComponents(t0);
}
var useDocumentLastRev = (documentId, documentType) => {
  const $ = (0, import_compiler_runtime2.c)(11), historyStore = useHistoryStore(), [lastRevisionDocument, setLastRevisionDocument] = (0, import_react2.useState)(null), [loading, setLoading] = (0, import_react2.useState)(false);
  let t0;
  $[0] !== documentId || $[1] !== documentType ? (t0 = {
    documentId,
    documentType
  }, $[0] = documentId, $[1] = documentType, $[2] = t0) : t0 = $[2];
  const timelineStore = useTimelineStore(t0), lastNonDeletedRevId = useTimelineSelector(timelineStore, _temp$o);
  let t1, t2;
  $[3] !== documentId || $[4] !== historyStore || $[5] !== lastNonDeletedRevId ? (t1 = () => {
    lastNonDeletedRevId && documentId ? (setLoading(true), historyStore.getDocumentAtRevision(documentId, lastNonDeletedRevId).then((document2) => {
      setLastRevisionDocument(document2 || null), setLoading(false);
    }).catch(() => {
      setLastRevisionDocument(null), setLoading(false);
    })) : (setLastRevisionDocument(null), setLoading(false));
  }, t2 = [documentId, lastNonDeletedRevId, historyStore], $[3] = documentId, $[4] = historyStore, $[5] = lastNonDeletedRevId, $[6] = t1, $[7] = t2) : (t1 = $[6], t2 = $[7]), (0, import_react2.useEffect)(t1, t2);
  let t3;
  return $[8] !== lastRevisionDocument || $[9] !== loading ? (t3 = {
    lastRevisionDocument,
    loading
  }, $[8] = lastRevisionDocument, $[9] = loading, $[10] = t3) : t3 = $[10], t3;
};
function _temp$o(state2) {
  return state2.lastNonDeletedRevId;
}
var DocumentURLCopied = defineEvent({
  name: "DocumentURLCopied",
  version: 1,
  description: "User copied document URL to clipboard"
});
var InlineChangesSwitchedOn = defineEvent({
  name: "InlineChangesSwitchedOn",
  version: 1,
  description: "User switched on display of inline changes"
});
var InlineChangesSwitchedOff = defineEvent({
  name: "InlineChangesSwitchedOff",
  version: 1,
  description: "User switched off display of inline changes"
});
function getInitialValueTemplateOpts(templates, opts) {
  const payload = opts.panePayload || {}, structureNodeTemplate = opts.templateName;
  opts.urlTemplate && structureNodeTemplate && structureNodeTemplate !== opts.urlTemplate && console.warn(`Conflicting templates: URL says "${opts.urlTemplate}", structure node says "${structureNodeTemplate}". Using "${structureNodeTemplate}".`);
  const template = structureNodeTemplate || opts.urlTemplate, typeTemplates = templates.filter((t2) => t2.schemaType === opts.documentType), templateParams = {
    ...opts.templateParams,
    ...typeof payload == "object" ? payload || {} : {}
  };
  let templateName = template;
  return !template && typeTemplates.length === 1 && (templateName = typeTemplates[0].id), {
    templateName,
    templateParams
  };
}
var useDocumentPaneInitialValue = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(13), {
    paneOptions,
    documentType,
    documentId,
    params
  } = t0, templates = useTemplates(), paneRouter = usePaneRouter(), panePayload = useUnique(paneRouter.payload);
  let t1;
  $[0] !== documentType || $[1] !== paneOptions.template || $[2] !== paneOptions.templateParameters || $[3] !== panePayload || $[4] !== params.template || $[5] !== templates ? (t1 = getInitialValueTemplateOpts(templates, {
    documentType,
    templateName: paneOptions.template,
    templateParams: paneOptions.templateParameters,
    panePayload,
    urlTemplate: params.template
  }), $[0] = documentType, $[1] = paneOptions.template, $[2] = paneOptions.templateParameters, $[3] = panePayload, $[4] = params.template, $[5] = templates, $[6] = t1) : t1 = $[6];
  const {
    templateName,
    templateParams
  } = t1;
  let t2;
  $[7] !== documentId || $[8] !== documentType || $[9] !== params.version || $[10] !== templateName || $[11] !== templateParams ? (t2 = {
    documentId,
    documentType,
    templateName,
    templateParams,
    version: params.version
  }, $[7] = documentId, $[8] = documentType, $[9] = params.version, $[10] = templateName, $[11] = templateParams, $[12] = t2) : t2 = $[12];
  const initialValueRaw = useInitialValue(t2);
  return useUnique(initialValueRaw);
};
function useDocumentPaneInspector(t0) {
  const $ = (0, import_compiler_runtime2.c)(54), {
    documentId,
    documentType,
    params,
    setParams
  } = t0, {
    features
  } = useStructureTool(), inspectorsResolver = useSource().document.inspectors;
  let t1;
  $[0] !== documentId || $[1] !== documentType || $[2] !== inspectorsResolver ? (t1 = inspectorsResolver({
    documentId,
    documentType
  }), $[0] = documentId, $[1] = documentType, $[2] = inspectorsResolver, $[3] = t1) : t1 = $[3];
  const inspectors2 = t1;
  let t2;
  $[4] !== params.inspect ? (t2 = () => params.inspect || null, $[4] = params.inspect, $[5] = t2) : t2 = $[5];
  const [inspectorName, setInspectorName] = (0, import_react2.useState)(t2), inspectParamRef = (0, import_react2.useRef)(params.inspect);
  let t3, t4;
  $[6] !== params.inspect ? (t3 = () => {
    inspectParamRef.current !== params.inspect && (inspectParamRef.current = params.inspect, setInspectorName(params.inspect || null));
  }, t4 = [params.inspect], $[6] = params.inspect, $[7] = t3, $[8] = t4) : (t3 = $[7], t4 = $[8]), (0, import_react2.useEffect)(t3, t4);
  let t5;
  $[9] !== inspectorName || $[10] !== inspectors2 ? (t5 = inspectors2?.find((i) => i.name === inspectorName), $[9] = inspectorName, $[10] = inspectors2, $[11] = t5) : t5 = $[11];
  const currentInspector = t5;
  let t6;
  $[12] !== inspectors2 ? (t6 = inspectors2.find(_temp$n), $[12] = inspectors2, $[13] = t6) : t6 = $[13];
  const historyInspector = t6, changesOpen = currentInspector?.name === HISTORY_INSPECTOR_NAME;
  let t7;
  $[14] !== currentInspector || $[15] !== inspectors2 || $[16] !== params || $[17] !== setParams ? (t7 = (closeInspectorName) => {
    const inspector = closeInspectorName && inspectors2.find((i_1) => i_1.name === closeInspectorName);
    if (closeInspectorName && !inspector) {
      console.warn(`No inspector named "${closeInspectorName}"`);
      return;
    }
    if (currentInspector) {
      if (inspector) {
        const result = inspector.onClose?.({
          params
        }) ?? {
          params
        };
        setInspectorName(null), inspectParamRef.current = void 0, setParams({
          ...result.params,
          inspect: void 0
        });
        return;
      }
      if (currentInspector) {
        const result_0 = currentInspector.onClose?.({
          params
        }) ?? {
          params
        };
        setInspectorName(null), inspectParamRef.current = void 0, setParams({
          ...result_0.params,
          inspect: void 0
        });
      }
    }
  }, $[14] = currentInspector, $[15] = inspectors2, $[16] = params, $[17] = setParams, $[18] = t7) : t7 = $[18];
  const closeInspector = t7;
  let t8;
  $[19] !== currentInspector || $[20] !== inspectors2 || $[21] !== params || $[22] !== setParams ? (t8 = (nextInspectorName, paneParams) => {
    const nextInspector = inspectors2.find((i_2) => i_2.name === nextInspectorName);
    if (!nextInspector) {
      console.warn(`No inspector named "${nextInspectorName}"`);
      return;
    }
    if (currentInspector?.name === nextInspector.name) {
      setParams({
        ...params,
        ...paneParams,
        inspect: nextInspector.name
      });
      return;
    }
    let currentParams = params;
    currentInspector && (currentParams = (nextInspector.onClose?.({
      params: currentParams
    }) ?? {
      params: currentParams
    }).params);
    const result_1 = nextInspector.onOpen?.({
      params: currentParams
    }) ?? {
      params: currentParams
    };
    setInspectorName(nextInspector.name), inspectParamRef.current = nextInspector.name, setParams({
      ...result_1.params,
      ...paneParams,
      inspect: nextInspector.name
    });
  }, $[19] = currentInspector, $[20] = inspectors2, $[21] = params, $[22] = setParams, $[23] = t8) : t8 = $[23];
  const openInspector = t8;
  let t9;
  $[24] !== closeInspector || $[25] !== historyInspector ? (t9 = () => {
    historyInspector && closeInspector(historyInspector.name);
  }, $[24] = closeInspector, $[25] = historyInspector, $[26] = t9) : t9 = $[26];
  const handleHistoryClose = t9;
  let t10;
  $[27] !== features.reviewChanges || $[28] !== historyInspector || $[29] !== openInspector ? (t10 = () => {
    features.reviewChanges && historyInspector && openInspector(historyInspector.name, {
      changesInspectorTab: "review"
    });
  }, $[27] = features.reviewChanges, $[28] = historyInspector, $[29] = openInspector, $[30] = t10) : t10 = $[30];
  const handleHistoryOpen = t10, inspectOpen = params.inspect === "on";
  let t11;
  $[31] !== inspectOpen || $[32] !== params || $[33] !== setParams ? (t11 = (t122) => {
    setParams((t122 === void 0 ? !inspectOpen : t122) ? {
      ...params,
      inspect: "on"
    } : {
      ...params,
      inspect: void 0
    });
  }, $[31] = inspectOpen, $[32] = params, $[33] = setParams, $[34] = t11) : t11 = $[34];
  const toggleLegacyInspect = t11;
  let t12;
  $[35] !== toggleLegacyInspect ? (t12 = () => toggleLegacyInspect(false), $[35] = toggleLegacyInspect, $[36] = t12) : t12 = $[36];
  const handleLegacyInspectClose = t12;
  let t13;
  $[37] !== closeInspector || $[38] !== inspectorName || $[39] !== inspectors2 || $[40] !== openInspector || $[41] !== toggleLegacyInspect ? (t13 = (item) => {
    if (item.action === "inspect")
      return toggleLegacyInspect(true), true;
    if (typeof item.action != "string")
      return false;
    const nextInspectorName_0 = item.action.slice(INSPECT_ACTION_PREFIX.length), nextInspector_0 = inspectors2.find((i_3) => i_3.name === nextInspectorName_0);
    return nextInspector_0 ? (nextInspector_0.name === inspectorName ? closeInspector(nextInspector_0.name) : openInspector(nextInspector_0.name), true) : false;
  }, $[37] = closeInspector, $[38] = inspectorName, $[39] = inspectors2, $[40] = openInspector, $[41] = toggleLegacyInspect, $[42] = t13) : t13 = $[42];
  const handleInspectorAction = t13;
  let t14;
  return $[43] !== changesOpen || $[44] !== closeInspector || $[45] !== currentInspector || $[46] !== handleHistoryClose || $[47] !== handleHistoryOpen || $[48] !== handleInspectorAction || $[49] !== handleLegacyInspectClose || $[50] !== inspectOpen || $[51] !== inspectors2 || $[52] !== openInspector ? (t14 = {
    changesOpen,
    currentInspector,
    inspectors: inspectors2,
    closeInspector,
    openInspector,
    handleHistoryClose,
    handleHistoryOpen,
    handleInspectorAction,
    handleLegacyInspectClose,
    inspectOpen
  }, $[43] = changesOpen, $[44] = closeInspector, $[45] = currentInspector, $[46] = handleHistoryClose, $[47] = handleHistoryOpen, $[48] = handleInspectorAction, $[49] = handleLegacyInspectClose, $[50] = inspectOpen, $[51] = inspectors2, $[52] = openInspector, $[53] = t14) : t14 = $[53], t14;
}
function _temp$n(i_0) {
  return i_0.name === HISTORY_INSPECTOR_NAME;
}
var isSanityDocument2 = (value) => isRecord$4(value) && typeof value._id == "string" && typeof value._type == "string";
function usePreviewUrl(value) {
  const $ = (0, import_compiler_runtime2.c)(6), {
    resolveProductionUrl
  } = useSource().document;
  let t0;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = new BehaviorSubject(void 0), $[0] = t0) : t0 = $[0];
  const subject = t0;
  let t1, t2;
  $[1] !== value ? (t1 = () => {
    subject.next(value);
  }, t2 = [subject, value], $[1] = value, $[2] = t1, $[3] = t2) : (t1 = $[2], t2 = $[3]), (0, import_react2.useEffect)(t1, t2);
  let t3;
  return $[4] !== resolveProductionUrl ? (t3 = subject.asObservable().pipe(distinctUntilChanged(), debounceTime(500), switchMap((document2) => isSanityDocument2(document2) ? from(resolveProductionUrl({
    document: document2
  })) : of(void 0)), distinctUntilChanged(), catchError(_temp$m)), $[4] = resolveProductionUrl, $[5] = t3) : t3 = $[5], useObservable(t3);
}
function _temp$m(err) {
  const message = isRecord$4(err) && typeof err.message == "string" ? err.message : "Unknown error";
  throw new Error(`An error was thrown while trying to get your preview url: ${message}`);
}
function DocumentPaneProvider(props) {
  const $ = (0, import_compiler_runtime2.c)(204), {
    children,
    index,
    pane: pane2,
    paneKey,
    onFocusPath,
    onSetMaximizedPane,
    maximized: t0,
    forcedVersion,
    historyStore
  } = props, maximized = t0 === void 0 ? false : t0, {
    store: timelineStore,
    error: timelineError,
    ready: timelineReady,
    revisionDocument,
    onOlderRevision,
    sinceDocument,
    isPristine,
    revisionId,
    lastNonDeletedRevId
  } = historyStore, schema = useSchema(), {
    setDocumentMeta
  } = useCopyPaste(), {
    document: t1
  } = useSource(), {
    actions: documentActions2,
    badges: documentBadges2,
    unstable_fieldActions: fieldActionsResolver,
    unstable_languageFilter: languageFilterResolver,
    drafts: t2
  } = t1, {
    enabled: draftsEnabled
  } = t2, telemetry = useTelemetry(), router2 = useRouter(), paneRouter = usePaneRouter(), setPaneParams = paneRouter.setParams, {
    push: pushToast
  } = useToast(), {
    options,
    menuItemGroups: t3,
    title: t4,
    views: t5
  } = pane2, menuItemGroups = t3 === void 0 ? DEFAULT_MENU_ITEM_GROUPS : t3, title = t4 === void 0 ? null : t4;
  let t6;
  $[0] !== t5 ? (t6 = t5 === void 0 ? [] : t5, $[0] = t5, $[1] = t6) : t6 = $[1];
  const viewsProp = t6, paneOptions = useUnique(options), documentIdRaw = paneOptions.id;
  let t7;
  $[2] !== documentIdRaw ? (t7 = getPublishedId(documentIdRaw), $[2] = documentIdRaw, $[3] = t7) : t7 = $[3];
  const documentId = t7, documentType = options.type, params = useUnique(paneRouter.params) || EMPTY_PARAMS$2, {
    buildStudioUrl
  } = useStudioUrl(), perspective = usePerspective(), {
    document: t8,
    beta
  } = useWorkspace(), {
    drafts: t9
  } = t8, {
    enabled: isDraftModelEnabled
  } = t9, enhancedObjectDialogEnabled = beta?.form?.enhancedObjectDialog?.enabled;
  let t10;
  bb0: {
    if (forcedVersion) {
      t10 = forcedVersion;
      break bb0;
    }
    let t112;
    $[4] !== perspective.selectedPerspectiveName || $[5] !== perspective.selectedReleaseId ? (t112 = {
      selectedPerspectiveName: perspective.selectedPerspectiveName,
      selectedReleaseId: perspective.selectedReleaseId
    }, $[4] = perspective.selectedPerspectiveName, $[5] = perspective.selectedReleaseId, $[6] = t112) : t112 = $[6], t10 = t112;
  }
  const {
    selectedReleaseId,
    selectedPerspectiveName
  } = t10, {
    data: t11
  } = useActiveReleases(), releases = t11 === void 0 ? EMPTY_ARRAY$z : t11, diffViewRouter = useDiffViewRouter();
  let t12;
  $[7] !== documentId || $[8] !== documentType || $[9] !== paneOptions || $[10] !== params ? (t12 = {
    paneOptions,
    documentId,
    documentType,
    params
  }, $[7] = documentId, $[8] = documentType, $[9] = paneOptions, $[10] = params, $[11] = t12) : t12 = $[11];
  const initialValue = useDocumentPaneInitialValue(t12), isInitialValueLoading = initialValue.loading;
  let t13;
  $[12] !== documentId || $[13] !== documentType || $[14] !== params || $[15] !== setPaneParams ? (t13 = {
    documentId,
    documentType,
    params,
    setParams: setPaneParams
  }, $[12] = documentId, $[13] = documentType, $[14] = params, $[15] = setPaneParams, $[16] = t13) : t13 = $[16];
  const {
    changesOpen,
    currentInspector,
    inspectors: inspectors2,
    closeInspector,
    openInspector,
    handleHistoryClose,
    handleHistoryOpen,
    handleInspectorAction,
    inspectOpen,
    handleLegacyInspectClose
  } = useDocumentPaneInspector(t13), [isDeleting, setIsDeleting] = (0, import_react2.useState)(false), {
    lastRevisionDocument
  } = useDocumentLastRev(documentId, documentType);
  let t14;
  $[17] !== isPristine || $[18] !== timelineReady ? (t14 = (editState) => timelineReady ? !editState?.draft && !editState?.published && !editState?.version && !isPristine : false, $[17] = isPristine, $[18] = timelineReady, $[19] = t14) : t14 = $[19];
  const getIsDeleted = t14;
  let t15;
  $[20] !== changesOpen || $[21] !== sinceDocument ? (t15 = (upstreamEditState) => {
    const upstream = selectUpstreamVersion(upstreamEditState);
    return changesOpen ? sinceDocument || upstream : upstream || null;
  }, $[20] = changesOpen, $[21] = sinceDocument, $[22] = t15) : t15 = $[22];
  const getComparisonValue = t15;
  let t16;
  $[23] !== documentType || $[24] !== schema ? (t16 = schema.get(documentType), $[23] = documentType, $[24] = schema, $[25] = t16) : t16 = $[25];
  const schemaType = t16;
  let t17;
  $[26] !== getIsDeleted || $[27] !== isDeleting || $[28] !== isDraftModelEnabled || $[29] !== params.rev || $[30] !== perspective.selectedPerspective || $[31] !== releases || $[32] !== schemaType || $[33] !== selectedReleaseId ? (t17 = (editState_0) => {
    const isDeleted = getIsDeleted(editState_0), seeingHistoryDocument = !!params.rev, currentRelease = releases.find((r2) => getReleaseIdFromReleaseDocumentId(r2._id) === selectedReleaseId), isPaused = isPausedCardinalityOneRelease(currentRelease);
    return seeingHistoryDocument || isDeleting || isDeleted || !isPaused && !isPerspectiveWriteable({
      selectedPerspective: perspective.selectedPerspective,
      isDraftModelEnabled,
      schemaType
    }).result;
  }, $[26] = getIsDeleted, $[27] = isDeleting, $[28] = isDraftModelEnabled, $[29] = params.rev, $[30] = perspective.selectedPerspective, $[31] = releases, $[32] = schemaType, $[33] = selectedReleaseId, $[34] = t17) : t17 = $[34];
  const getIsReadOnly = t17;
  let t18;
  $[35] !== lastNonDeletedRevId || $[36] !== lastRevisionDocument || $[37] !== onOlderRevision || $[38] !== revisionDocument ? (t18 = (value) => onOlderRevision ? revisionDocument || {
    _id: value._id,
    _type: value._type
  } : !value._createdAt && !value._updatedAt && lastNonDeletedRevId && lastRevisionDocument ? lastRevisionDocument : value, $[35] = lastNonDeletedRevId, $[36] = lastRevisionDocument, $[37] = onOlderRevision, $[38] = revisionDocument, $[39] = t18) : t18 = $[39];
  const getDisplayed = t18;
  let t19;
  $[40] !== params.path ? (t19 = params.path ? fromString(params.path) : EMPTY_ARRAY$z, $[40] = params.path, $[41] = t19) : t19 = $[41];
  const t20 = router2.stickyParams.displayInlineChanges === "true";
  let t21;
  $[42] !== changesOpen || $[43] !== documentId || $[44] !== documentType || $[45] !== getComparisonValue || $[46] !== getDisplayed || $[47] !== getIsReadOnly || $[48] !== initialValue || $[49] !== onFocusPath || $[50] !== selectedPerspectiveName || $[51] !== t19 || $[52] !== t20 ? (t21 = {
    changesOpen,
    documentType,
    documentId,
    initialValue,
    comparisonValue: getComparisonValue,
    releaseId: selectedPerspectiveName,
    selectedPerspectiveName,
    initialFocusPath: t19,
    readOnly: getIsReadOnly,
    onFocusPath,
    getFormDocumentValue: getDisplayed,
    displayInlineChanges: t20
  }, $[42] = changesOpen, $[43] = documentId, $[44] = documentType, $[45] = getComparisonValue, $[46] = getDisplayed, $[47] = getIsReadOnly, $[48] = initialValue, $[49] = onFocusPath, $[50] = selectedPerspectiveName, $[51] = t19, $[52] = t20, $[53] = t21) : t21 = $[53];
  const {
    editState: editState_1,
    upstreamEditState: upstreamEditState_0,
    hasUpstreamVersion,
    connectionState,
    focusPath,
    onChange,
    validation,
    ready: formReady,
    value: value_0,
    formState,
    permissions,
    onPathOpen,
    isPermissionsLoading,
    formStateRef,
    onProgrammaticFocus,
    collapsedFieldSets,
    collapsedPaths,
    onBlur,
    onFocus,
    onSetActiveFieldGroup,
    onSetCollapsedPath,
    onSetCollapsedFieldSet,
    openPath
  } = useDocumentForm(t21);
  let t22;
  $[54] !== draftsEnabled || $[55] !== params || $[56] !== releases || $[57] !== selectedPerspectiveName || $[58] !== selectedReleaseId || $[59] !== value_0 ? (t22 = getDocumentVersionType(params, selectedReleaseId, value_0, selectedPerspectiveName, draftsEnabled, releases), $[54] = draftsEnabled, $[55] = params, $[56] = releases, $[57] = selectedPerspectiveName, $[58] = selectedReleaseId, $[59] = value_0, $[60] = t22) : t22 = $[60];
  const actionsVersionType = t22;
  let t23;
  $[61] !== actionsVersionType || $[62] !== documentId || $[63] !== documentType || $[64] !== selectedReleaseId ? (t23 = {
    schemaType: documentType,
    documentId,
    versionType: actionsVersionType,
    releaseId: selectedReleaseId
  }, $[61] = actionsVersionType, $[62] = documentId, $[63] = documentType, $[64] = selectedReleaseId, $[65] = t23) : t23 = $[65];
  const documentActionsContext = t23;
  let t24;
  $[66] !== documentActions2 || $[67] !== documentActionsContext ? (t24 = documentActions2(documentActionsContext), $[66] = documentActions2, $[67] = documentActionsContext, $[68] = t24) : t24 = $[68];
  const actions = t24;
  let t25;
  $[69] !== enhancedObjectDialogEnabled || $[70] !== onPathOpen || $[71] !== params || $[72] !== setPaneParams ? (t25 = (path) => {
    if (onPathOpen(path), enhancedObjectDialogEnabled) {
      const nextPath = pathToString$1(path);
      params.path !== nextPath && setPaneParams({
        ...params,
        path: nextPath
      });
    }
  }, $[69] = enhancedObjectDialogEnabled, $[70] = onPathOpen, $[71] = params, $[72] = setPaneParams, $[73] = t25) : t25 = $[73];
  const handlePathOpen = t25;
  let t26;
  $[74] !== documentBadges2 || $[75] !== documentId || $[76] !== documentType ? (t26 = documentBadges2({
    schemaType: documentType,
    documentId
  }), $[74] = documentBadges2, $[75] = documentId, $[76] = documentType, $[77] = t26) : t26 = $[77];
  const badges = t26;
  let t27;
  $[78] !== documentId || $[79] !== documentType || $[80] !== languageFilterResolver ? (t27 = languageFilterResolver({
    schemaType: documentType,
    documentId
  }), $[78] = documentId, $[79] = documentType, $[80] = languageFilterResolver, $[81] = t27) : t27 = $[81];
  const languageFilter = t27, views2 = useUnique(viewsProp), activeViewId = params.view || views2[0] && views2[0].id || null, previewUrl = usePreviewUrl(value_0), {
    t: t28
  } = useTranslation(structureLocaleNamespace);
  let t282;
  $[82] !== documentId || $[83] !== documentType || $[84] !== fieldActionsResolver || $[85] !== schemaType ? (t282 = schemaType ? fieldActionsResolver({
    documentId,
    documentType,
    schemaType
  }) : [], $[82] = documentId, $[83] = documentType, $[84] = fieldActionsResolver, $[85] = schemaType, $[86] = t282) : t282 = $[86];
  const fieldActions = t282, ready = formReady && (!params.rev || timelineReady || !!timelineError);
  let t29;
  $[87] !== getDisplayed || $[88] !== value_0 ? (t29 = getDisplayed(value_0), $[87] = getDisplayed, $[88] = value_0, $[89] = t29) : t29 = $[89];
  const displayed = t29;
  let t30;
  $[90] !== displayed || $[91] !== documentId || $[92] !== editState_1 ? (t30 = {
    strict: true,
    displayed,
    documentId,
    editState: editState_1
  }, $[90] = displayed, $[91] = documentId, $[92] = editState_1, $[93] = t30) : t30 = $[93];
  const {
    previousId
  } = useDocumentIdStack(t30);
  let t31;
  $[94] !== params || $[95] !== setPaneParams ? (t31 = (newSince, newRev) => {
    setPaneParams({
      ...params,
      since: newSince,
      rev: newRev || void 0
    });
  }, $[94] = params, $[95] = setPaneParams, $[96] = t31) : t31 = $[96];
  const setTimelineRange = t31;
  let t32;
  $[97] !== paneRouter ? (t32 = () => paneRouter.closeCurrent(), $[97] = paneRouter, $[98] = t32) : t32 = $[98];
  const handlePaneClose = t32;
  let t33;
  $[99] !== paneRouter ? (t33 = () => paneRouter.duplicateCurrent(), $[99] = paneRouter, $[100] = t33) : t33 = $[100];
  const handlePaneSplit = t33;
  let t34;
  $[101] !== router2 || $[102] !== telemetry ? (t34 = () => {
    const nextState = router2.stickyParams.displayInlineChanges !== "true";
    telemetry.log(nextState ? InlineChangesSwitchedOn : InlineChangesSwitchedOff), router2.navigate({
      stickyParams: {
        displayInlineChanges: String(nextState)
      }
    });
  }, $[101] = router2, $[102] = telemetry, $[103] = t34) : t34 = $[103];
  const toggleInlineChanges = t34;
  let t35;
  $[104] !== buildStudioUrl || $[105] !== diffViewRouter || $[106] !== documentId || $[107] !== documentType || $[108] !== handleHistoryOpen || $[109] !== handleInspectorAction || $[110] !== previewUrl || $[111] !== previousId || $[112] !== pushToast || $[113] !== t28 || $[114] !== telemetry || $[115] !== toggleInlineChanges || $[116] !== value_0._id ? (t35 = async (item) => {
    if (item.action === "production-preview" && previewUrl)
      return window.open(previewUrl), true;
    if (item.action === "copy-document-url" && navigator) {
      telemetry.log(DocumentURLCopied);
      const copyUrl = buildStudioUrl({
        coreUi: (url) => `${url}/intent/edit/id=${documentId};type=${documentType}`
      });
      return await navigator.clipboard.writeText(copyUrl), pushToast({
        id: "copy-document-url",
        status: "info",
        title: t28("panes.document-operation-results.operation-success_copy-url")
      }), true;
    }
    return item.action === "reviewChanges" ? (handleHistoryOpen(), true) : ((item.action === "inspect" || typeof item.action == "string" && item.action.startsWith(INSPECT_ACTION_PREFIX)) && handleInspectorAction(item), item.action === "compareVersions" && typeof previousId < "u" ? (diffViewRouter.navigateDiffView({
      mode: "version",
      previousDocument: {
        type: documentType,
        id: previousId
      },
      nextDocument: {
        type: documentType,
        id: value_0._id
      }
    }), true) : item.action === "toggleInlineChanges" ? (toggleInlineChanges(), true) : false);
  }, $[104] = buildStudioUrl, $[105] = diffViewRouter, $[106] = documentId, $[107] = documentType, $[108] = handleHistoryOpen, $[109] = handleInspectorAction, $[110] = previewUrl, $[111] = previousId, $[112] = pushToast, $[113] = t28, $[114] = telemetry, $[115] = toggleInlineChanges, $[116] = value_0._id, $[117] = t35) : t35 = $[117];
  const handleMenuAction = t35;
  let t36, t37;
  $[118] !== documentId || $[119] !== documentType || $[120] !== onChange || $[121] !== schemaType || $[122] !== setDocumentMeta ? (t36 = () => {
    setDocumentMeta({
      documentId,
      documentType,
      schemaType,
      onChange
    });
  }, t37 = [documentId, documentType, schemaType, onChange, setDocumentMeta], $[118] = documentId, $[119] = documentType, $[120] = onChange, $[121] = schemaType, $[122] = setDocumentMeta, $[123] = t36, $[124] = t37) : (t36 = $[123], t37 = $[124]), (0, import_react2.useEffect)(t36, t37);
  let t38;
  $[125] !== getComparisonValue || $[126] !== upstreamEditState_0 ? (t38 = getComparisonValue(upstreamEditState_0), $[125] = getComparisonValue, $[126] = upstreamEditState_0, $[127] = t38) : t38 = $[127];
  const compareValue = t38, isDeleted_1 = getIsDeleted(editState_1), revisionNotFound = onOlderRevision && !revisionDocument && ready;
  let t39;
  bb1: {
    if (editState_1.version && isGoingToUnpublish(editState_1.version)) {
      t39 = editState_1.published;
      break bb1;
    }
    t39 = displayed;
  }
  const currentDisplayed = t39, t40 = currentInspector || null;
  let t41;
  $[128] !== menuItemGroups ? (t41 = menuItemGroups || [], $[128] = menuItemGroups, $[129] = t41) : t41 = $[129];
  let t42;
  $[130] !== actions || $[131] !== activeViewId || $[132] !== badges || $[133] !== changesOpen || $[134] !== closeInspector || $[135] !== collapsedFieldSets || $[136] !== collapsedPaths || $[137] !== compareValue || $[138] !== connectionState || $[139] !== currentDisplayed || $[140] !== documentId || $[141] !== documentIdRaw || $[142] !== documentType || $[143] !== editState_1 || $[144] !== fieldActions || $[145] !== focusPath || $[146] !== formState || $[147] !== handleHistoryClose || $[148] !== handleHistoryOpen || $[149] !== handleLegacyInspectClose || $[150] !== handleMenuAction || $[151] !== handlePaneClose || $[152] !== handlePaneSplit || $[153] !== handlePathOpen || $[154] !== hasUpstreamVersion || $[155] !== index || $[156] !== inspectOpen || $[157] !== inspectors2 || $[158] !== isDeleted_1 || $[159] !== isDeleting || $[160] !== isInitialValueLoading || $[161] !== isPermissionsLoading || $[162] !== languageFilter || $[163] !== lastNonDeletedRevId || $[164] !== lastRevisionDocument || $[165] !== maximized || $[166] !== onBlur || $[167] !== onChange || $[168] !== onFocus || $[169] !== onSetActiveFieldGroup || $[170] !== onSetCollapsedFieldSet || $[171] !== onSetCollapsedPath || $[172] !== onSetMaximizedPane || $[173] !== openInspector || $[174] !== openPath || $[175] !== paneKey || $[176] !== permissions || $[177] !== previewUrl || $[178] !== ready || $[179] !== revisionId || $[180] !== revisionNotFound || $[181] !== schemaType || $[182] !== selectedReleaseId || $[183] !== setTimelineRange || $[184] !== t40 || $[185] !== t41 || $[186] !== timelineError || $[187] !== timelineStore || $[188] !== title || $[189] !== validation || $[190] !== value_0 || $[191] !== views2 ? (t42 = {
    actions,
    activeViewId,
    badges,
    changesOpen,
    closeInspector,
    collapsedFieldSets,
    collapsedPaths,
    compareValue,
    connectionState,
    displayed: currentDisplayed,
    documentId,
    documentIdRaw,
    documentType,
    editState: editState_1,
    fieldActions,
    focusPath,
    inspector: t40,
    inspectors: inspectors2,
    onBlur,
    onChange,
    onFocus,
    onPathOpen: handlePathOpen,
    onHistoryClose: handleHistoryClose,
    onHistoryOpen: handleHistoryOpen,
    onInspectClose: handleLegacyInspectClose,
    onMenuAction: handleMenuAction,
    onPaneClose: handlePaneClose,
    onPaneSplit: handlePaneSplit,
    onSetActiveFieldGroup,
    onSetCollapsedPath,
    onSetCollapsedFieldSet,
    onSetMaximizedPane,
    maximized,
    openInspector,
    openPath,
    index,
    inspectOpen,
    validation,
    menuItemGroups: t41,
    paneKey,
    previewUrl,
    ready,
    schemaType,
    hasUpstreamVersion,
    isPermissionsLoading,
    isInitialValueLoading,
    permissions,
    setTimelineRange,
    setIsDeleting,
    isDeleting,
    isDeleted: isDeleted_1,
    timelineError,
    timelineStore,
    title,
    value: value_0,
    selectedReleaseId,
    views: views2,
    formState,
    unstable_languageFilter: languageFilter,
    revisionId,
    revisionNotFound,
    lastNonDeletedRevId,
    lastRevisionDocument
  }, $[130] = actions, $[131] = activeViewId, $[132] = badges, $[133] = changesOpen, $[134] = closeInspector, $[135] = collapsedFieldSets, $[136] = collapsedPaths, $[137] = compareValue, $[138] = connectionState, $[139] = currentDisplayed, $[140] = documentId, $[141] = documentIdRaw, $[142] = documentType, $[143] = editState_1, $[144] = fieldActions, $[145] = focusPath, $[146] = formState, $[147] = handleHistoryClose, $[148] = handleHistoryOpen, $[149] = handleLegacyInspectClose, $[150] = handleMenuAction, $[151] = handlePaneClose, $[152] = handlePaneSplit, $[153] = handlePathOpen, $[154] = hasUpstreamVersion, $[155] = index, $[156] = inspectOpen, $[157] = inspectors2, $[158] = isDeleted_1, $[159] = isDeleting, $[160] = isInitialValueLoading, $[161] = isPermissionsLoading, $[162] = languageFilter, $[163] = lastNonDeletedRevId, $[164] = lastRevisionDocument, $[165] = maximized, $[166] = onBlur, $[167] = onChange, $[168] = onFocus, $[169] = onSetActiveFieldGroup, $[170] = onSetCollapsedFieldSet, $[171] = onSetCollapsedPath, $[172] = onSetMaximizedPane, $[173] = openInspector, $[174] = openPath, $[175] = paneKey, $[176] = permissions, $[177] = previewUrl, $[178] = ready, $[179] = revisionId, $[180] = revisionNotFound, $[181] = schemaType, $[182] = selectedReleaseId, $[183] = setTimelineRange, $[184] = t40, $[185] = t41, $[186] = timelineError, $[187] = timelineStore, $[188] = title, $[189] = validation, $[190] = value_0, $[191] = views2, $[192] = t42) : t42 = $[192];
  const documentPane = t42, pathRef = (0, import_react2.useRef)(void 0);
  let t43, t44;
  $[193] !== enhancedObjectDialogEnabled || $[194] !== formStateRef || $[195] !== onProgrammaticFocus || $[196] !== paneRouter || $[197] !== params || $[198] !== ready ? (t43 = () => {
    if (ready && params.path) {
      const {
        path: path_0,
        ...restParams
      } = params;
      if (path_0 !== pathRef.current) {
        const pathFromUrl = resolveKeyedPath(formStateRef.current?.value, fromString(path_0));
        onProgrammaticFocus(pathFromUrl);
      }
      enhancedObjectDialogEnabled || paneRouter.setParams(restParams);
    }
    pathRef.current = params.path;
  }, t44 = [formStateRef, onProgrammaticFocus, paneRouter, params, ready, enhancedObjectDialogEnabled], $[193] = enhancedObjectDialogEnabled, $[194] = formStateRef, $[195] = onProgrammaticFocus, $[196] = paneRouter, $[197] = params, $[198] = ready, $[199] = t43, $[200] = t44) : (t43 = $[199], t44 = $[200]), (0, import_react2.useEffect)(t43, t44);
  let t45;
  return $[201] !== children || $[202] !== documentPane ? (t45 = (0, import_jsx_runtime2.jsx)(DocumentPaneContext.Provider, { value: documentPane, children }), $[201] = children, $[202] = documentPane, $[203] = t45) : t45 = $[203], t45;
}
function getDocumentVersionType(params, selectedReleaseId, value, selectedPerspectiveName, draftsEnabled, releases) {
  let version;
  switch (true) {
    case !!params?.rev:
      version = "revision";
      break;
    case (selectedReleaseId && isVersionId(value._id)): {
      const releaseDocument = releases.find((r2) => getReleaseIdFromReleaseDocumentId(r2._id) === selectedReleaseId);
      releaseDocument && isCardinalityOneRelease(releaseDocument) ? version = "scheduled-draft" : version = "version";
      break;
    }
    case selectedPerspectiveName === "published":
      version = "published";
      break;
    case draftsEnabled:
      version = "draft";
      break;
    default:
      version = "published";
  }
  return version;
}
var DocumentEventsPane = (props) => {
  const $ = (0, import_compiler_runtime2.c)(37), {
    params: t0
  } = usePaneRouter(), params = t0 === void 0 ? EMPTY_PARAMS$2 : t0, options = usePaneOptions(props.pane.options, params), schema = useSchema(), documentType = options.type, liveEdit = !!schema.get(options.type)?.liveEdit, {
    selectedPerspectiveName,
    selectedReleaseId,
    selectedPerspective
  } = usePerspective(), {
    data: archivedReleases
  } = useArchivedReleases();
  let t1;
  $[0] !== options.id ? (t1 = getPublishedId(options.id), $[0] = options.id, $[1] = t1) : t1 = $[1];
  const editState = useEditState(t1, documentType, "default", selectedReleaseId), showingPublishedOnDraft = liveEdit && selectedPerspective === "drafts" && !editState?.draft, {
    rev,
    since
  } = params, historyVersion = params.historyVersion;
  let t2;
  bb0: {
    if (showingPublishedOnDraft) {
      let t32;
      $[2] !== options.id ? (t32 = getPublishedId(options.id), $[2] = options.id, $[3] = t32) : t32 = $[3], t2 = t32;
      break bb0;
    }
    if (historyVersion && archivedReleases.some((release) => getReleaseIdFromReleaseDocumentId(release._id) === historyVersion)) {
      let t32;
      $[4] !== historyVersion || $[5] !== options.id ? (t32 = getVersionId(options.id, historyVersion), $[4] = historyVersion, $[5] = options.id, $[6] = t32) : t32 = $[6], t2 = t32;
      break bb0;
    }
    if (typeof selectedPerspectiveName > "u") {
      let t32;
      $[7] !== options.id ? (t32 = getDraftId(options.id), $[7] = options.id, $[8] = t32) : t32 = $[8], t2 = t32;
      break bb0;
    }
    if (selectedPerspectiveName === "published") {
      let t32;
      $[9] !== options.id ? (t32 = getPublishedId(options.id), $[9] = options.id, $[10] = t32) : t32 = $[10], t2 = t32;
      break bb0;
    }
    if (selectedPerspectiveName.length !== 0) {
      let t32;
      $[11] !== options.id || $[12] !== selectedPerspectiveName ? (t32 = getVersionId(options.id, selectedPerspectiveName), $[11] = options.id, $[12] = selectedPerspectiveName, $[13] = t32) : t32 = $[13], t2 = t32;
      break bb0;
    }
    t2 = options.id;
  }
  const documentId = t2;
  let t3;
  $[14] !== documentId || $[15] !== options.type || $[16] !== rev || $[17] !== since ? (t3 = {
    documentId,
    documentType: options.type,
    rev,
    since
  }, $[14] = documentId, $[15] = options.type, $[16] = rev, $[17] = since, $[18] = t3) : t3 = $[18];
  const eventsStore = useEventsStore(t3), t4 = eventsStore.error, t5 = eventsStore.revision?.revisionId || null, t6 = !!(rev && !eventsStore.revision?.loading), t7 = eventsStore.revision?.document || null, t8 = eventsStore.sinceRevision?.document || null, t9 = !eventsStore.loading, t10 = eventsStore.events.length === 0;
  let t11;
  $[19] !== eventsStore.events ? (t11 = eventsStore.events.find(_temp$l)?.id || null, $[19] = eventsStore.events, $[20] = t11) : t11 = $[20];
  let t12;
  $[21] !== eventsStore.error || $[22] !== t10 || $[23] !== t11 || $[24] !== t5 || $[25] !== t6 || $[26] !== t7 || $[27] !== t8 || $[28] !== t9 ? (t12 = {
    error: t4,
    revisionId: t5,
    onOlderRevision: t6,
    revisionDocument: t7,
    sinceDocument: t8,
    ready: t9,
    isPristine: t10,
    lastNonDeletedRevId: t11
  }, $[21] = eventsStore.error, $[22] = t10, $[23] = t11, $[24] = t5, $[25] = t6, $[26] = t7, $[27] = t8, $[28] = t9, $[29] = t12) : t12 = $[29];
  const historyStoreProps = t12, value = eventsStore;
  let t13;
  $[30] !== historyStoreProps || $[31] !== historyVersion || $[32] !== props ? (t13 = historyVersion ? (0, import_jsx_runtime2.jsx)(PerspectiveProvider, { selectedPerspectiveName: historyVersion, excludedPerspectives: EMPTY_ARRAY$z, children: (0, import_jsx_runtime2.jsx)(DocumentPaneProvider, { ...props, historyStore: historyStoreProps }) }) : (0, import_jsx_runtime2.jsx)(DocumentPaneProvider, { ...props, historyStore: historyStoreProps }), $[30] = historyStoreProps, $[31] = historyVersion, $[32] = props, $[33] = t13) : t13 = $[33];
  let t14;
  return $[34] !== t13 || $[35] !== value ? (t14 = (0, import_jsx_runtime2.jsx)(EventsProvider, { value, children: t13 }), $[34] = t13, $[35] = value, $[36] = t14) : t14 = $[36], t14;
};
function _temp$l(e2) {
  return !isDeleteDocumentGroupEvent(e2) && !isDeleteDocumentVersionEvent(e2);
}
var DocumentPaneWithLegacyTimelineStore = (props) => {
  const $ = (0, import_compiler_runtime2.c)(20), {
    pane: pane2
  } = props, paneRouter = usePaneRouter(), options = usePaneOptions(pane2.options, paneRouter.params), params = paneRouter.params || EMPTY_PARAMS$2, [timelineError, setTimelineError] = (0, import_react2.useState)(null);
  let t0;
  $[0] !== options.id ? (t0 = getPublishedId(options.id), $[0] = options.id, $[1] = t0) : t0 = $[1];
  let t1;
  $[2] !== options.type || $[3] !== params.rev || $[4] !== params.since || $[5] !== t0 ? (t1 = {
    documentId: t0,
    documentType: options.type,
    onError: setTimelineError,
    rev: params.rev,
    since: params.since
  }, $[2] = options.type, $[3] = params.rev, $[4] = params.since, $[5] = t0, $[6] = t1) : t1 = $[6];
  const store = useTimelineStore(t1), onOlderRevision = useTimelineSelector(store, _temp$k), revTime = useTimelineSelector(store, _temp2$9), sinceAttributes = useTimelineSelector(store, _temp3$6), timelineDisplayed = useTimelineSelector(store, _temp4$6), timelineReady = useTimelineSelector(store, _temp5$3), isPristine = useTimelineSelector(store, _temp6$3), lastNonDeletedRevId = useTimelineSelector(store, _temp7$1), t2 = revTime?.id || null, t3 = timelineDisplayed, t4 = sinceAttributes, t5 = !!isPristine;
  let t6;
  $[7] !== lastNonDeletedRevId || $[8] !== onOlderRevision || $[9] !== store || $[10] !== t2 || $[11] !== t3 || $[12] !== t4 || $[13] !== t5 || $[14] !== timelineError || $[15] !== timelineReady ? (t6 = {
    store,
    error: timelineError,
    revisionId: t2,
    onOlderRevision,
    revisionDocument: t3,
    sinceDocument: t4,
    ready: timelineReady,
    isPristine: t5,
    lastNonDeletedRevId
  }, $[7] = lastNonDeletedRevId, $[8] = onOlderRevision, $[9] = store, $[10] = t2, $[11] = t3, $[12] = t4, $[13] = t5, $[14] = timelineError, $[15] = timelineReady, $[16] = t6) : t6 = $[16];
  const historyStoreProps = t6;
  let t7;
  return $[17] !== historyStoreProps || $[18] !== props ? (t7 = (0, import_jsx_runtime2.jsx)(DocumentPaneProvider, { ...props, historyStore: historyStoreProps }), $[17] = historyStoreProps, $[18] = props, $[19] = t7) : t7 = $[19], t7;
};
function _temp$k(state2) {
  return state2.onOlderRevision;
}
function _temp2$9(state_0) {
  return state_0.revTime;
}
function _temp3$6(state_1) {
  return state_1.sinceAttributes;
}
function _temp4$6(state_2) {
  return state_2.timelineDisplayed;
}
function _temp5$3(state_3) {
  return state_3.timelineReady;
}
function _temp6$3(state_4) {
  return state_4.isPristine;
}
function _temp7$1(state_5) {
  return state_5.lastNonDeletedRevId;
}
function DocumentPerspectiveProvider(t0) {
  const $ = (0, import_compiler_runtime2.c)(4), {
    children
  } = t0, paneRouter = usePaneRouter(), {
    excludedPerspectives
  } = usePerspective(), {
    scheduledDraft
  } = paneRouter.params;
  if (scheduledDraft) {
    let t1;
    return $[0] !== children || $[1] !== excludedPerspectives || $[2] !== scheduledDraft ? (t1 = (0, import_jsx_runtime2.jsx)(PerspectiveProvider, { selectedPerspectiveName: scheduledDraft, excludedPerspectives, children }), $[0] = children, $[1] = excludedPerspectives, $[2] = scheduledDraft, $[3] = t1) : t1 = $[3], t1;
  }
  return children;
}
var DocumentPaneProviderWrapper = (0, import_react2.memo)((props) => {
  const $ = (0, import_compiler_runtime2.c)(9), source = useSource(), {
    setParams,
    params
  } = usePaneRouter();
  let t0;
  $[0] !== params || $[1] !== setParams ? (t0 = (releaseId) => {
    setParams({
      ...params,
      scheduledDraft: releaseId
    }, {
      perspective: ""
    });
  }, $[0] = params, $[1] = setParams, $[2] = t0) : t0 = $[2];
  const handleSetScheduledDraftPerspective = t0;
  let t1;
  $[3] !== props || $[4] !== source.beta?.eventsAPI?.documents ? (t1 = source.beta?.eventsAPI?.documents ? (0, import_jsx_runtime2.jsx)(DocumentEventsPane, { ...props }) : (0, import_jsx_runtime2.jsx)(DocumentPaneWithLegacyTimelineStore, { ...props }), $[3] = props, $[4] = source.beta?.eventsAPI?.documents, $[5] = t1) : t1 = $[5];
  let t2;
  return $[6] !== handleSetScheduledDraftPerspective || $[7] !== t1 ? (t2 = (0, import_jsx_runtime2.jsx)(DocumentPerspectiveProvider, { children: (0, import_jsx_runtime2.jsx)(SingleDocReleaseProvider, { onSetScheduledDraftPerspective: handleSetScheduledDraftPerspective, children: t1 }) }), $[6] = handleSetScheduledDraftPerspective, $[7] = t1, $[8] = t2) : t2 = $[8], t2;
});
DocumentPaneProviderWrapper.displayName = "Memo(DocumentPaneProviderWrapper)";
function useResetHistoryParams() {
  const $ = (0, import_compiler_runtime2.c)(10), {
    params: t0,
    setParams
  } = usePaneRouter(), params = t0 === void 0 ? EMPTY_PARAMS$2 : t0, {
    selectedPerspectiveName
  } = usePerspective(), isMounted = (0, import_react2.useRef)(false);
  let t1;
  $[0] !== params || $[1] !== setParams ? (t1 = (_perspective) => {
    ["since", "historyVersion", "rev", "preserveRev"].some((param) => params[param]) && setParams({
      ...params,
      rev: params.preserveRev === "true" ? params.rev : void 0,
      preserveRev: void 0,
      since: void 0,
      historyVersion: void 0
    });
  }, $[0] = params, $[1] = setParams, $[2] = t1) : t1 = $[2];
  const updateHistoryParams = (0, import_react2.useEffectEvent)(t1);
  let t2;
  $[3] !== selectedPerspectiveName || $[4] !== updateHistoryParams ? (t2 = () => {
    isMounted.current && updateHistoryParams(selectedPerspectiveName);
  }, $[3] = selectedPerspectiveName, $[4] = updateHistoryParams, $[5] = t2) : t2 = $[5];
  let t3;
  $[6] !== selectedPerspectiveName ? (t3 = [selectedPerspectiveName], $[6] = selectedPerspectiveName, $[7] = t3) : t3 = $[7], (0, import_react2.useEffect)(t2, t3);
  let t4, t5;
  $[8] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t4 = () => (isMounted.current = true, () => {
    isMounted.current = false;
  }), t5 = [], $[8] = t4, $[9] = t5) : (t4 = $[8], t5 = $[9]), (0, import_react2.useEffect)(t4, t5);
}
var DocumentPane = (0, import_react2.memo)(function(props) {
  const $ = (0, import_compiler_runtime2.c)(5), {
    name: parentSourceName
  } = useSource(), t0 = props.pane.source || parentSourceName;
  let t1;
  $[0] !== props ? (t1 = (0, import_jsx_runtime2.jsx)(CopyPasteProvider, { children: (0, import_jsx_runtime2.jsx)(DocumentPaneInner, { ...props }) }), $[0] = props, $[1] = t1) : t1 = $[1];
  let t2;
  return $[2] !== t0 || $[3] !== t1 ? (t2 = (0, import_jsx_runtime2.jsx)(SourceProvider, { name: t0, children: t1 }), $[2] = t0, $[3] = t1, $[4] = t2) : t2 = $[4], t2;
});
function DocumentPaneInner(props) {
  const $ = (0, import_compiler_runtime2.c)(57), {
    pane: pane2,
    paneKey
  } = props, {
    resolveNewDocumentOptions
  } = useSource().document, {
    selectedPerspectiveName
  } = usePerspective(), paneRouter = usePaneRouter(), options = usePaneOptions(pane2.options, paneRouter.params), {
    documentType,
    isLoaded: isDocumentLoaded
  } = useDocumentType(options.id, options.type);
  useResetHistoryParams();
  const DocumentLayout2 = useDocumentLayoutComponent();
  let t0;
  $[0] !== options.id || $[1] !== options.type || $[2] !== resolveNewDocumentOptions ? (t0 = resolveNewDocumentOptions({
    type: "document",
    documentId: options.id,
    schemaType: options.type
  }), $[0] = options.id, $[1] = options.type, $[2] = resolveNewDocumentOptions, $[3] = t0) : t0 = $[3];
  const templateItems = t0;
  let t1;
  $[4] !== templateItems ? (t1 = {
    templateItems
  }, $[4] = templateItems, $[5] = t1) : t1 = $[5];
  const [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions(t1), isLoaded = isDocumentLoaded && !isTemplatePermissionsLoading;
  let t2;
  $[6] !== documentType || $[7] !== isLoaded || $[8] !== options || $[9] !== props ? (t2 = isLoaded && documentType && options.type !== documentType ? mergeDocumentType(props, options, documentType) : props, $[6] = documentType, $[7] = isLoaded, $[8] = options, $[9] = props, $[10] = t2) : t2 = $[10];
  const providerProps = t2, {
    ReferenceChildLink: ReferenceChildLink2,
    handleEditReference,
    groupIndex,
    routerPanesState
  } = paneRouter;
  let t3;
  $[11] !== groupIndex || $[12] !== routerPanesState ? (t3 = routerPanesState[groupIndex + 1]?.[0].params || {}, $[11] = groupIndex, $[12] = routerPanesState, $[13] = t3) : t3 = $[13];
  const childParams = t3, routerPanesStateLength = routerPanesState.length, {
    parentRefPath
  } = childParams;
  let t4;
  $[14] !== groupIndex || $[15] !== parentRefPath || $[16] !== routerPanesStateLength ? (t4 = parentRefPath ? {
    path: fromString(parentRefPath),
    state: groupIndex >= routerPanesStateLength - 1 ? "none" : groupIndex >= routerPanesStateLength - 2 ? "selected" : "pressed"
  } : {
    path: [],
    state: "none"
  }, $[14] = groupIndex, $[15] = parentRefPath, $[16] = routerPanesStateLength, $[17] = t4) : t4 = $[17];
  const activePath = t4, {
    t: t5
  } = useTranslation(structureLocaleNamespace);
  if (options.type === "*" && !isLoaded) {
    let t522;
    $[18] !== t5 ? (t522 = t5("panes.document-pane.document-not-found.loading"), $[18] = t5, $[19] = t522) : t522 = $[19];
    let t62;
    return $[20] !== paneKey || $[21] !== t522 ? (t62 = (0, import_jsx_runtime2.jsx)(LoadingPane, { flex: 2.5, minWidth: 320, paneKey, title: t522 }), $[20] = paneKey, $[21] = t522, $[22] = t62) : t62 = $[22], t62;
  }
  if (!documentType) {
    let t522;
    $[23] !== t5 ? (t522 = t5("panes.document-pane.document-not-found.title"), $[23] = t5, $[24] = t522) : t522 = $[24];
    let t62;
    $[25] !== options.id ? (t62 = {
      id: options.id
    }, $[25] = options.id, $[26] = t62) : t62 = $[26];
    let t72;
    $[27] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t72 = {
      Code: _temp$j
    }, $[27] = t72) : t72 = $[27];
    let t82;
    $[28] !== t5 || $[29] !== t62 ? (t82 = (0, import_jsx_runtime2.jsx)(Stack, { space: 4, children: (0, import_jsx_runtime2.jsx)(Text, { as: "p", children: (0, import_jsx_runtime2.jsx)(Translate, { t: t5, i18nKey: "panes.document-pane.document-not-found.text", values: t62, components: t72 }) }) }), $[28] = t5, $[29] = t62, $[30] = t82) : t82 = $[30];
    let t92;
    return $[31] !== paneKey || $[32] !== t522 || $[33] !== t82 ? (t92 = (0, import_jsx_runtime2.jsx)(ErrorPane, { flex: 2.5, minWidth: 320, paneKey, title: t522, children: t82 }), $[31] = paneKey, $[32] = t522, $[33] = t82, $[34] = t92) : t92 = $[34], t92;
  }
  const t52 = `${documentType}-${options.id}-${selectedPerspectiveName || ""}`;
  let t6;
  $[35] !== DocumentLayout2 || $[36] !== options.id || $[37] !== options.type ? (t6 = (0, import_jsx_runtime2.jsx)(DocumentLayout2, { documentId: options.id, documentType: options.type }), $[35] = DocumentLayout2, $[36] = options.id, $[37] = options.type, $[38] = t6) : t6 = $[38];
  let t7;
  $[39] !== options.id || $[40] !== options.type || $[41] !== t6 ? (t7 = (0, import_jsx_runtime2.jsx)(CommentsWrapper, { documentId: options.id, documentType: options.type, children: t6 }), $[39] = options.id, $[40] = options.type, $[41] = t6, $[42] = t7) : t7 = $[42];
  let t8;
  $[43] !== options.id || $[44] !== options.type || $[45] !== t7 ? (t8 = (0, import_jsx_runtime2.jsx)(DiffViewDocumentLayout, { documentId: options.id, documentType: options.type, children: t7 }), $[43] = options.id, $[44] = options.type, $[45] = t7, $[46] = t8) : t8 = $[46];
  let t9;
  $[47] !== ReferenceChildLink2 || $[48] !== activePath || $[49] !== handleEditReference || $[50] !== t8 || $[51] !== templatePermissions ? (t9 = (0, import_jsx_runtime2.jsx)(ReferenceInputOptionsProvider, { EditReferenceLinkComponent: ReferenceChildLink2, onEditReference: handleEditReference, initialValueTemplateItems: templatePermissions, activePath, children: t8 }), $[47] = ReferenceChildLink2, $[48] = activePath, $[49] = handleEditReference, $[50] = t8, $[51] = templatePermissions, $[52] = t9) : t9 = $[52];
  let t10;
  return $[53] !== providerProps || $[54] !== t52 || $[55] !== t9 ? (t10 = (0, import_jsx_runtime2.jsx)(DocumentPaneProviderWrapper, { ...providerProps, children: t9 }, t52), $[53] = providerProps, $[54] = t52, $[55] = t9, $[56] = t10) : t10 = $[56], t10;
}
function _temp$j(t0) {
  const {
    children
  } = t0;
  return (0, import_jsx_runtime2.jsx)("code", { children });
}
function usePaneOptions(options, t0) {
  const $ = (0, import_compiler_runtime2.c)(8);
  let t1;
  $[0] !== t0 ? (t1 = t0 === void 0 ? {} : t0, $[0] = t0, $[1] = t1) : t1 = $[1];
  const params = t1, templates = useTemplates();
  let t2;
  bb0: {
    if (options.type && options.type !== "*") {
      t2 = options;
      break bb0;
    }
    const templateName = options.template || params.template;
    let t3;
    $[2] !== templateName || $[3] !== templates ? (t3 = templateName ? templates.find((t5) => t5.id === templateName) : void 0, $[2] = templateName, $[3] = templates, $[4] = t3) : t3 = $[4];
    const documentType = t3?.schemaType;
    if (!documentType) {
      t2 = options;
      break bb0;
    }
    let t4;
    $[5] !== documentType || $[6] !== options ? (t4 = {
      ...options,
      type: documentType
    }, $[5] = documentType, $[6] = options, $[7] = t4) : t4 = $[7], t2 = t4;
  }
  return t2;
}
function mergeDocumentType(props, options, documentType) {
  return {
    ...props,
    pane: {
      ...props.pane,
      options: {
        ...options,
        type: documentType
      }
    }
  };
}
var BackLink = (0, import_react2.forwardRef)(function(props, ref) {
  const $ = (0, import_compiler_runtime2.c)(9), {
    routerPanesState,
    groupIndex
  } = (0, import_react2.useContext)(PaneRouterContext);
  let t0;
  $[0] !== groupIndex || $[1] !== routerPanesState ? (t0 = routerPanesState.slice(0, groupIndex), $[0] = groupIndex, $[1] = routerPanesState, $[2] = t0) : t0 = $[2];
  const panes = t0;
  let t1;
  $[3] !== panes ? (t1 = {
    panes
  }, $[3] = panes, $[4] = t1) : t1 = $[4];
  const state2 = t1;
  let t2;
  return $[5] !== props || $[6] !== ref || $[7] !== state2 ? (t2 = (0, import_jsx_runtime2.jsx)(StateLink, { ...props, ref, state: state2 }), $[5] = props, $[6] = ref, $[7] = state2, $[8] = t2) : t2 = $[8], t2;
});
var ChildLink = (0, import_react2.forwardRef)(function(props, ref) {
  const $ = (0, import_compiler_runtime2.c)(19);
  let childId, childParameters, childPayload, rest;
  $[0] !== props ? ({
    childId,
    childPayload,
    childParameters,
    ...rest
  } = props, $[0] = props, $[1] = childId, $[2] = childParameters, $[3] = childPayload, $[4] = rest) : (childId = $[1], childParameters = $[2], childPayload = $[3], rest = $[4]);
  const {
    routerPanesState,
    groupIndex
  } = (0, import_react2.useContext)(PaneRouterContext);
  let t0;
  if ($[5] !== childId || $[6] !== childParameters || $[7] !== childPayload || $[8] !== groupIndex || $[9] !== routerPanesState) {
    let t12;
    $[11] !== childId || $[12] !== childParameters || $[13] !== childPayload ? (t12 = [{
      id: childId,
      params: childParameters,
      payload: childPayload
    }], $[11] = childId, $[12] = childParameters, $[13] = childPayload, $[14] = t12) : t12 = $[14], t0 = {
      panes: [...routerPanesState.slice(0, groupIndex + 1), t12]
    }, $[5] = childId, $[6] = childParameters, $[7] = childPayload, $[8] = groupIndex, $[9] = routerPanesState, $[10] = t0;
  } else
    t0 = $[10];
  let t1;
  return $[15] !== ref || $[16] !== rest || $[17] !== t0 ? (t1 = (0, import_jsx_runtime2.jsx)(StateLink, { ...rest, ref, state: t0 }), $[15] = ref, $[16] = rest, $[17] = t0, $[18] = t1) : t1 = $[18], t1;
});
var ParameterizedLink = (0, import_react2.forwardRef)(function(props, ref) {
  const $ = (0, import_compiler_runtime2.c)(20), {
    routerPanesState: currentPanes,
    groupIndex,
    siblingIndex
  } = (0, import_react2.useContext)(PaneRouterContext);
  let params, payload, rest;
  $[0] !== props ? ({
    params,
    payload,
    ...rest
  } = props, $[0] = props, $[1] = params, $[2] = payload, $[3] = rest) : (params = $[1], payload = $[2], rest = $[3]);
  const nextParams = useUnique(params), nextPayload = useUnique(payload), currentGroup = currentPanes[groupIndex], currentSibling = currentGroup[siblingIndex], t0 = nextParams ?? currentSibling.params, t1 = nextPayload ?? currentSibling.payload;
  let t2;
  $[4] !== currentSibling || $[5] !== t0 || $[6] !== t1 ? (t2 = {
    ...currentSibling,
    params: t0,
    payload: t1
  }, $[4] = currentSibling, $[5] = t0, $[6] = t1, $[7] = t2) : t2 = $[7];
  const nextSibling = t2;
  let t3;
  $[8] !== currentGroup || $[9] !== nextSibling || $[10] !== siblingIndex ? (t3 = [...currentGroup.slice(0, siblingIndex), nextSibling, ...currentGroup.slice(siblingIndex + 1)], $[8] = currentGroup, $[9] = nextSibling, $[10] = siblingIndex, $[11] = t3) : t3 = $[11];
  const nextGroup = t3;
  let t4;
  $[12] !== currentPanes || $[13] !== groupIndex || $[14] !== nextGroup ? (t4 = {
    panes: [...currentPanes.slice(0, groupIndex), nextGroup, ...currentPanes.slice(groupIndex + 1)]
  }, $[12] = currentPanes, $[13] = groupIndex, $[14] = nextGroup, $[15] = t4) : t4 = $[15];
  const nextState = t4;
  let t5;
  return $[16] !== nextState || $[17] !== ref || $[18] !== rest ? (t5 = (0, import_jsx_runtime2.jsx)(StateLink, { ref, ...rest, state: nextState }), $[16] = nextState, $[17] = ref, $[18] = rest, $[19] = t5) : t5 = $[19], t5;
});
var ReferenceChildLink = (0, import_react2.forwardRef)(function(t0, ref) {
  const $ = (0, import_compiler_runtime2.c)(24);
  let children, documentId, documentType, parentRefPath, rest, template;
  $[0] !== t0 ? ({
    documentId,
    documentType,
    parentRefPath,
    children,
    template,
    ...rest
  } = t0, $[0] = t0, $[1] = children, $[2] = documentId, $[3] = documentType, $[4] = parentRefPath, $[5] = rest, $[6] = template) : (children = $[1], documentId = $[2], documentType = $[3], parentRefPath = $[4], rest = $[5], template = $[6]);
  let t1;
  $[7] !== documentId ? (t1 = getPublishedId(documentId), $[7] = documentId, $[8] = t1) : t1 = $[8];
  const t2 = template?.params;
  let t3;
  $[9] !== parentRefPath ? (t3 = toString(parentRefPath), $[9] = parentRefPath, $[10] = t3) : t3 = $[10];
  let t4;
  $[11] !== template ? (t4 = template && {
    template: template?.id
  }, $[11] = template, $[12] = t4) : t4 = $[12];
  let t5;
  $[13] !== documentType || $[14] !== t3 || $[15] !== t4 ? (t5 = {
    type: documentType,
    parentRefPath: t3,
    ...t4
  }, $[13] = documentType, $[14] = t3, $[15] = t4, $[16] = t5) : t5 = $[16];
  let t6;
  return $[17] !== children || $[18] !== ref || $[19] !== rest || $[20] !== t1 || $[21] !== t2 || $[22] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(ChildLink, { ...rest, ref, childId: t1, childPayload: t2, childParameters: t5, children }), $[17] = children, $[18] = ref, $[19] = rest, $[20] = t1, $[21] = t2, $[22] = t5, $[23] = t6) : t6 = $[23], t6;
});
var emptyArray = [];
function PaneRouterProvider(props) {
  const $ = (0, import_compiler_runtime2.c)(60), {
    children,
    flatIndex,
    index,
    params,
    payload,
    siblingIndex
  } = props, {
    navigate,
    navigateIntent,
    resolvePathFromState
  } = useRouter(), routerState = useRouterState(), {
    panes,
    expand
  } = usePaneLayout(), routerPaneGroups = routerState?.panes || emptyArray, lastPane = panes?.[panes.length - 2], groupIndex = index - 1;
  let t0;
  $[0] !== groupIndex || $[1] !== routerPaneGroups || $[2] !== routerState || $[3] !== siblingIndex ? (t0 = (modifier) => {
    const currentGroup = routerPaneGroups[groupIndex] || [], currentItem = currentGroup[siblingIndex], nextGroup = modifier(currentGroup, currentItem), nextPanes = [...routerPaneGroups.slice(0, groupIndex), nextGroup, ...routerPaneGroups.slice(groupIndex + 1)];
    return {
      ...routerState,
      panes: nextPanes
    };
  }, $[0] = groupIndex, $[1] = routerPaneGroups, $[2] = routerState, $[3] = siblingIndex, $[4] = t0) : t0 = $[4];
  const createNextRouterState = t0;
  let t1;
  $[5] !== createNextRouterState || $[6] !== navigate ? (t1 = (modifier_0, stickyParams) => {
    const nextRouterState_0 = createNextRouterState(modifier_0);
    return setTimeout(() => navigate(nextRouterState_0, stickyParams ? {
      stickyParams
    } : void 0), 0), nextRouterState_0;
  }, $[5] = createNextRouterState, $[6] = navigate, $[7] = t1) : t1 = $[7];
  const modifyCurrentGroup = t1;
  let t2;
  $[8] !== createNextRouterState || $[9] !== resolvePathFromState || $[10] !== siblingIndex ? (t2 = (nextParams) => {
    const nextRouterState_1 = createNextRouterState((siblings, item) => [...siblings.slice(0, siblingIndex), {
      ...item,
      params: nextParams
    }, ...siblings.slice(siblingIndex + 1)]);
    return resolvePathFromState(nextRouterState_1);
  }, $[8] = createNextRouterState, $[9] = resolvePathFromState, $[10] = siblingIndex, $[11] = t2) : t2 = $[11];
  const createPathWithParams = t2;
  let t3;
  $[12] !== modifyCurrentGroup || $[13] !== siblingIndex ? (t3 = (nextPayload) => {
    modifyCurrentGroup((siblings_0, item_0) => [...siblings_0.slice(0, siblingIndex), {
      ...item_0,
      payload: nextPayload
    }, ...siblings_0.slice(siblingIndex + 1)]);
  }, $[12] = modifyCurrentGroup, $[13] = siblingIndex, $[14] = t3) : t3 = $[14];
  const setPayload = t3;
  let t4;
  $[15] !== modifyCurrentGroup || $[16] !== siblingIndex ? (t4 = (nextParams_0, stickyParams_0) => {
    modifyCurrentGroup((siblings_1, item_1) => [...siblings_1.slice(0, siblingIndex), {
      ...item_1,
      params: nextParams_0
    }, ...siblings_1.slice(siblingIndex + 1)], stickyParams_0);
  }, $[15] = modifyCurrentGroup, $[16] = siblingIndex, $[17] = t4) : t4 = $[17];
  const setParams = t4;
  let t5;
  $[18] !== groupIndex || $[19] !== navigate || $[20] !== routerPaneGroups ? (t5 = (t62) => {
    const {
      id,
      parentRefPath,
      type,
      template,
      version
    } = t62;
    navigate({
      panes: [...routerPaneGroups.slice(0, groupIndex + 1), [{
        id,
        params: {
          template: template.id,
          parentRefPath: toString(parentRefPath),
          type,
          version
        },
        payload: template.params
      }]]
    });
  }, $[18] = groupIndex, $[19] = navigate, $[20] = routerPaneGroups, $[21] = t5) : t5 = $[21];
  const handleEditReference = t5, t6 = routerPaneGroups[groupIndex] ? routerPaneGroups[groupIndex].length > 1 : false, t7 = routerPaneGroups[groupIndex] ? routerPaneGroups[groupIndex].length : 0, t8 = flatIndex ? BackLink : void 0;
  let t10, t9;
  $[22] !== modifyCurrentGroup ? (t9 = (t112) => {
    const opts = t112 === void 0 ? {} : t112;
    modifyCurrentGroup(() => [{
      id: opts.id || "",
      payload: opts.payload,
      params: opts.params || {}
    }]);
  }, t10 = () => {
    modifyCurrentGroup(_temp$i);
  }, $[22] = modifyCurrentGroup, $[23] = t10, $[24] = t9) : (t10 = $[23], t9 = $[24]);
  let t11;
  $[25] !== expand || $[26] !== groupIndex || $[27] !== lastPane || $[28] !== navigate || $[29] !== routerPaneGroups ? (t11 = (t122) => {
    (t122 === void 0 || t122) && lastPane && expand(lastPane.element), navigate({
      panes: routerPaneGroups.slice(0, groupIndex)
    });
  }, $[25] = expand, $[26] = groupIndex, $[27] = lastPane, $[28] = navigate, $[29] = routerPaneGroups, $[30] = t11) : t11 = $[30];
  let t12;
  $[31] !== modifyCurrentGroup || $[32] !== siblingIndex ? (t12 = (options) => {
    modifyCurrentGroup((siblings_3, item_3) => {
      const duplicatedItem = {
        ...item_3,
        payload: options?.payload || item_3.payload,
        params: options?.params || item_3.params
      };
      return [...siblings_3.slice(0, siblingIndex), duplicatedItem, ...siblings_3.slice(siblingIndex)];
    });
  }, $[31] = modifyCurrentGroup, $[32] = siblingIndex, $[33] = t12) : t12 = $[33];
  let t13;
  $[34] !== params || $[35] !== setParams ? (t13 = (viewId) => {
    const restParams = omit_default(params, "view");
    return setParams(viewId ? {
      ...restParams,
      view: viewId
    } : restParams);
  }, $[34] = params, $[35] = setParams, $[36] = t13) : t13 = $[36];
  let t14;
  $[37] !== createPathWithParams || $[38] !== flatIndex || $[39] !== groupIndex || $[40] !== handleEditReference || $[41] !== navigateIntent || $[42] !== params || $[43] !== payload || $[44] !== routerPaneGroups || $[45] !== setParams || $[46] !== setPayload || $[47] !== siblingIndex || $[48] !== t10 || $[49] !== t11 || $[50] !== t12 || $[51] !== t13 || $[52] !== t6 || $[53] !== t7 || $[54] !== t8 || $[55] !== t9 ? (t14 = {
    index: flatIndex,
    groupIndex,
    siblingIndex,
    payload,
    params,
    hasGroupSiblings: t6,
    groupLength: t7,
    routerPanesState: routerPaneGroups,
    ChildLink,
    BackLink: t8,
    ReferenceChildLink,
    handleEditReference,
    ParameterizedLink,
    replaceCurrent: t9,
    closeCurrent: t10,
    closeCurrentAndAfter: t11,
    duplicateCurrent: t12,
    setView: t13,
    setParams,
    setPayload,
    createPathWithParams,
    navigateIntent
  }, $[37] = createPathWithParams, $[38] = flatIndex, $[39] = groupIndex, $[40] = handleEditReference, $[41] = navigateIntent, $[42] = params, $[43] = payload, $[44] = routerPaneGroups, $[45] = setParams, $[46] = setPayload, $[47] = siblingIndex, $[48] = t10, $[49] = t11, $[50] = t12, $[51] = t13, $[52] = t6, $[53] = t7, $[54] = t8, $[55] = t9, $[56] = t14) : t14 = $[56];
  const ctx = t14;
  let t15;
  return $[57] !== children || $[58] !== ctx ? (t15 = (0, import_jsx_runtime2.jsx)(PaneRouterContext.Provider, { value: ctx, children }), $[57] = children, $[58] = ctx, $[59] = t15) : t15 = $[59], t15;
}
function _temp$i(siblings_2, item_2) {
  return siblings_2.length > 1 ? siblings_2.filter((sibling) => sibling !== item_2) : siblings_2;
}
function UnknownPane(props) {
  const $ = (0, import_compiler_runtime2.c)(14), {
    isSelected,
    pane: pane2,
    paneKey
  } = props;
  let t0;
  $[0] !== pane2 ? (t0 = isRecord$4(pane2) && pane2.type || null, $[0] = pane2, $[1] = t0) : t0 = $[1];
  const type = t0, {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[2] !== t2 ? (t1 = t2("panes.unknown-pane-type.title"), $[2] = t2, $[3] = t1) : t1 = $[3];
  let t22;
  $[4] !== t1 ? (t22 = (0, import_jsx_runtime2.jsx)(PaneHeader$1, { title: t1 }), $[4] = t1, $[5] = t22) : t22 = $[5];
  let t3;
  $[6] !== t2 || $[7] !== type ? (t3 = (0, import_jsx_runtime2.jsx)(PaneContent, { children: (0, import_jsx_runtime2.jsx)(Box, { padding: 4, children: typeof type == "string" ? (0, import_jsx_runtime2.jsx)(Text, { as: "p", muted: true, children: (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "panes.unknown-pane-type.unknown-type.text", values: {
    type
  } }) }) : (0, import_jsx_runtime2.jsx)(Text, { as: "p", muted: true, children: (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "panes.unknown-pane-type.missing-type.text" }) }) }) }), $[6] = t2, $[7] = type, $[8] = t3) : t3 = $[8];
  let t4;
  return $[9] !== isSelected || $[10] !== paneKey || $[11] !== t22 || $[12] !== t3 ? (t4 = (0, import_jsx_runtime2.jsxs)(Pane, { id: paneKey, selected: isSelected, children: [
    t22,
    t3
  ] }), $[9] = isSelected, $[10] = paneKey, $[11] = t22, $[12] = t3, $[13] = t4) : t4 = $[13], t4;
}
var paneMap = {
  component: (0, import_react2.lazy)(() => import("./index2-HII2S7IV.js")),
  document: (0, import_react2.lazy)(() => Promise.resolve().then(function() {
    return pane$1;
  })),
  documentList: (0, import_react2.lazy)(() => Promise.resolve().then(function() {
    return pane;
  })),
  list: (0, import_react2.lazy)(() => import("./index3-XTVP3LPH.js"))
};
var StructureToolPane = (0, import_react2.memo)(function(props) {
  const $ = (0, import_compiler_runtime2.c)(25), {
    active,
    childItemId,
    groupIndex,
    index,
    itemId,
    pane: pane2,
    paneKey,
    params,
    payload,
    path,
    selected,
    siblingIndex,
    maximized,
    onSetMaximizedPane
  } = props, PaneComponent = paneMap[pane2.type] || UnknownPane;
  let t0;
  $[0] !== paneKey || $[1] !== path || $[2] !== selected ? (t0 = (0, import_jsx_runtime2.jsx)(LoadingPane, { paneKey, path, selected }), $[0] = paneKey, $[1] = path, $[2] = selected, $[3] = t0) : t0 = $[3];
  const t1 = childItemId || "";
  let t2;
  $[4] !== PaneComponent || $[5] !== active || $[6] !== index || $[7] !== itemId || $[8] !== maximized || $[9] !== onSetMaximizedPane || $[10] !== pane2 || $[11] !== paneKey || $[12] !== selected || $[13] !== t1 ? (t2 = (0, import_jsx_runtime2.jsx)(PaneComponent, { childItemId: t1, index, itemId, isActive: active, isSelected: selected, paneKey, pane: pane2, maximized, onSetMaximizedPane }), $[4] = PaneComponent, $[5] = active, $[6] = index, $[7] = itemId, $[8] = maximized, $[9] = onSetMaximizedPane, $[10] = pane2, $[11] = paneKey, $[12] = selected, $[13] = t1, $[14] = t2) : t2 = $[14];
  let t3;
  $[15] !== t0 || $[16] !== t2 ? (t3 = (0, import_jsx_runtime2.jsx)(import_react2.Suspense, { fallback: t0, children: t2 }), $[15] = t0, $[16] = t2, $[17] = t3) : t3 = $[17];
  let t4;
  return $[18] !== groupIndex || $[19] !== index || $[20] !== params || $[21] !== payload || $[22] !== siblingIndex || $[23] !== t3 ? (t4 = (0, import_jsx_runtime2.jsx)(PaneRouterProvider, { flatIndex: index, index: groupIndex, params, payload, siblingIndex, children: t3 }), $[18] = groupIndex, $[19] = index, $[20] = params, $[21] = payload, $[22] = siblingIndex, $[23] = t3, $[24] = t4) : t4 = $[24], t4;
}, ({
  params: prevParams = {},
  payload: prevPayload = null,
  ...prev
}, {
  params: nextParams = {},
  payload: nextPayload = null,
  ...next
}) => {
  if (!isEqual_default(prevParams, nextParams) || !isEqual_default(prevPayload, nextPayload)) return false;
  const keys = /* @__PURE__ */ new Set([...Object.keys(prev), ...Object.keys(next)]);
  for (const key of keys)
    if (prev[key] !== next[key]) return false;
  return true;
});
function DocTitle(props) {
  const $ = (0, import_compiler_runtime2.c)(10), {
    document: documentValue
  } = props, schemaType = useSchema().get(documentValue._type), {
    t: t2
  } = useTranslation(structureLocaleNamespace), {
    title
  } = useDocumentTitle();
  if (!schemaType) {
    let t02;
    $[0] !== documentValue._type || $[1] !== t2 ? (t02 = t2("doc-title.unknown-schema-type.text", {
      schemaType: documentValue._type
    }), $[0] = documentValue._type, $[1] = t2, $[2] = t02) : t02 = $[2];
    let t12;
    return $[3] !== t02 ? (t12 = (0, import_jsx_runtime2.jsx)("code", { children: t02 }), $[3] = t02, $[4] = t12) : t12 = $[4], t12;
  }
  let t0;
  $[5] !== t2 || $[6] !== title ? (t0 = title || (0, import_jsx_runtime2.jsx)("span", { style: {
    color: "var(--card-muted-fg-color)"
  }, children: t2("doc-title.fallback.text") }), $[5] = t2, $[6] = title, $[7] = t0) : t0 = $[7];
  let t1;
  return $[8] !== t0 ? (t1 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: t0 }), $[8] = t0, $[9] = t1) : t1 = $[9], t1;
}
var ChevronWrapper = at(Box).withConfig({
  displayName: "ChevronWrapper",
  componentId: "sc-1ldyu0k-0"
})`margin-left:auto;`;
var CrossDatasetReferencesDetails = at.details.withConfig({
  displayName: "CrossDatasetReferencesDetails",
  componentId: "sc-1ldyu0k-1"
})`flex:none;&[open] ${ChevronWrapper}{transform:rotate(180deg);}`;
var CrossDatasetReferencesSummary = at.summary.withConfig({
  displayName: "CrossDatasetReferencesSummary",
  componentId: "sc-1ldyu0k-2"
})`list-style:none;&::-webkit-details-marker{display:none;}`;
var Table$1 = at.table.withConfig({
  displayName: "Table",
  componentId: "sc-1ldyu0k-3"
})`width:100%;text-align:left;padding:0 ${({
  theme
}) => rem(theme.sanity.space[2])};border-collapse:collapse;th{padding:${({
  theme
}) => rem(theme.sanity.space[1])};}td{padding:0 ${({
  theme
}) => rem(theme.sanity.space[1])};}tr > *:last-child{text-align:right;}`;
var DocumentIdFlex = at(Flex).withConfig({
  displayName: "DocumentIdFlex",
  componentId: "sc-1ldyu0k-4"
})`min-height:33px;`;
var OtherReferenceCount = (props) => {
  const $ = (0, import_compiler_runtime2.c)(13), {
    t: t2
  } = useTranslation(structureLocaleNamespace), difference = props.totalCount - props.references.length;
  if (!difference)
    return null;
  let t0;
  $[0] !== difference || $[1] !== t2 ? (t0 = t2("confirm-delete-dialog.other-reference-count.title", {
    count: difference
  }), $[0] = difference, $[1] = t2, $[2] = t0) : t0 = $[2];
  let t1;
  $[3] !== t0 ? (t1 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, muted: true, children: t0 }), $[3] = t0, $[4] = t1) : t1 = $[4];
  let t22;
  $[5] !== t2 ? (t22 = t2("confirm-delete-dialog.other-reference-count.tooltip"), $[5] = t2, $[6] = t22) : t22 = $[6];
  let t3;
  $[7] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t3 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, muted: true, children: (0, import_jsx_runtime2.jsx)(InfoOutlineIcon, {}) }), $[7] = t3) : t3 = $[7];
  let t4;
  $[8] !== t22 ? (t4 = (0, import_jsx_runtime2.jsx)(Tooltip, { portal: true, placement: "top", content: t22, children: t3 }), $[8] = t22, $[9] = t4) : t4 = $[9];
  let t5;
  return $[10] !== t1 || $[11] !== t4 ? (t5 = (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsxs)(Inline, { space: 2, children: [
    t1,
    t4
  ] }) }), $[10] = t1, $[11] = t4, $[12] = t5) : t5 = $[12], t5;
};
function PaneItemPreview(props) {
  const $ = (0, import_compiler_runtime2.c)(30), {
    icon,
    layout,
    presence,
    schemaType,
    sortOrder,
    value
  } = props, versionsInfo = useDocumentVersionInfo(value._id), {
    perspectiveStack
  } = usePerspective();
  let t0;
  bb0: {
    if (!sortOrder) {
      t0 = void 0;
      break bb0;
    }
    let t12;
    $[0] !== sortOrder.by ? (t12 = {
      ordering: {
        title: "",
        name: "",
        by: sortOrder.by
      }
    }, $[0] = sortOrder.by, $[1] = t12) : t12 = $[1], t0 = t12;
  }
  const viewOptions = t0;
  let t1;
  $[2] !== perspectiveStack || $[3] !== props.documentPreviewStore || $[4] !== schemaType || $[5] !== value._id || $[6] !== viewOptions ? (t1 = getPreviewStateObservable$1(props.documentPreviewStore, schemaType, value._id, perspectiveStack, viewOptions), $[2] = perspectiveStack, $[3] = props.documentPreviewStore, $[4] = schemaType, $[5] = value._id, $[6] = viewOptions, $[7] = t1) : t1 = $[7];
  const previewStateObservable = t1;
  let t2;
  $[8] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t2 = {
    snapshot: null,
    isLoading: true,
    original: null
  }, $[8] = t2) : t2 = $[8];
  const {
    snapshot,
    original,
    isLoading: previewIsLoading
  } = useObservable(previewStateObservable, t2), isLoading = previewIsLoading;
  let t3;
  $[9] !== isLoading || $[10] !== presence || $[11] !== versionsInfo.draft || $[12] !== versionsInfo.published || $[13] !== versionsInfo.versions ? (t3 = isLoading ? null : (0, import_jsx_runtime2.jsx)(TooltipDelayGroupProvider, { children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 3, children: [
    presence && presence.length > 0 && (0, import_jsx_runtime2.jsx)(DocumentPreviewPresence, { presence }),
    (0, import_jsx_runtime2.jsx)(DocumentStatusIndicator, { draft: versionsInfo.draft, published: versionsInfo.published, versions: versionsInfo.versions })
  ] }) }), $[9] = isLoading, $[10] = presence, $[11] = versionsInfo.draft, $[12] = versionsInfo.published, $[13] = versionsInfo.versions, $[14] = t3) : t3 = $[14];
  const status = t3;
  let t4;
  $[15] !== versionsInfo.draft || $[16] !== versionsInfo.published || $[17] !== versionsInfo.versions ? (t4 = (0, import_jsx_runtime2.jsx)(DocumentStatus, { draft: versionsInfo.draft, published: versionsInfo.published, versions: versionsInfo.versions }), $[15] = versionsInfo.draft, $[16] = versionsInfo.published, $[17] = versionsInfo.versions, $[18] = t4) : t4 = $[18];
  const tooltip = t4;
  let t5;
  $[19] !== original || $[20] !== snapshot || $[21] !== value ? (t5 = getPreviewValueWithFallback({
    snapshot,
    original,
    fallback: value
  }), $[19] = original, $[20] = snapshot, $[21] = value, $[22] = t5) : t5 = $[22];
  let t6;
  return $[23] !== icon || $[24] !== isLoading || $[25] !== layout || $[26] !== status || $[27] !== t5 || $[28] !== tooltip ? (t6 = (0, import_jsx_runtime2.jsx)(SanityDefaultPreview, { ...t5, isPlaceholder: isLoading, icon, layout, status, tooltip }), $[23] = icon, $[24] = isLoading, $[25] = layout, $[26] = status, $[27] = t5, $[28] = tooltip, $[29] = t6) : t6 = $[29], t6;
}
var EMPTY_ARRAY = [];
function ReferencePreviewLink(props) {
  const $ = (0, import_compiler_runtime2.c)(16), {
    onClick,
    type,
    value
  } = props, t0 = value?._id;
  let t1;
  $[0] !== t0 ? (t1 = getPublishedId(t0), $[0] = t0, $[1] = t1) : t1 = $[1];
  const documentPresence = useDocumentPresence(t1), documentPreviewStore = useDocumentPreviewStore(), {
    ReferenceChildLink: ReferenceChildLink2
  } = usePaneRouter();
  let t2;
  $[2] !== ReferenceChildLink2 || $[3] !== type?.name || $[4] !== value?._id ? (t2 = function(linkProps) {
    return (0, import_jsx_runtime2.jsx)(ReferenceChildLink2, { documentId: value?._id, documentType: type?.name, parentRefPath: EMPTY_ARRAY, ...linkProps });
  }, $[2] = ReferenceChildLink2, $[3] = type?.name, $[4] = value?._id, $[5] = t2) : t2 = $[5];
  const t3 = t2, t4 = type?.icon, t5 = documentPresence?.length > 0 ? documentPresence : EMPTY_ARRAY;
  let t6;
  $[6] !== documentPreviewStore || $[7] !== t4 || $[8] !== t5 || $[9] !== type || $[10] !== value ? (t6 = (0, import_jsx_runtime2.jsx)(PaneItemPreview, { documentPreviewStore, icon: t4, layout: "compact", presence: t5, schemaType: type, value }), $[6] = documentPreviewStore, $[7] = t4, $[8] = t5, $[9] = type, $[10] = value, $[11] = t6) : t6 = $[11];
  let t7;
  return $[12] !== onClick || $[13] !== t3 || $[14] !== t6 ? (t7 = (0, import_jsx_runtime2.jsx)(PreviewCard, { __unstable_focusRing: true, as: t3, "data-as": "a", onClick, radius: 2, children: t6 }), $[12] = onClick, $[13] = t3, $[14] = t6, $[15] = t7) : t7 = $[15], t7;
}
var EllipsisText = at(Text).withConfig({
  displayName: "EllipsisText",
  componentId: "sc-1meclkc-0"
})`max-width:120px;`;
var VersionItemPreview = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(43), {
    versionId,
    schemaType
  } = t0, {
    t: t2
  } = useTranslation(), documentPreviewStore = useDocumentPreviewStore();
  let t1;
  $[0] !== versionId ? (t1 = getDocumentVariantType(versionId), $[0] = versionId, $[1] = t1) : t1 = $[1];
  const documentVariant = t1, {
    data: releases
  } = useActiveReleases();
  let t22;
  if ($[2] !== documentPreviewStore || $[3] !== documentVariant || $[4] !== schemaType || $[5] !== versionId) {
    const perspectiveStack = [documentVariant === "version" ? getVersionFromId(versionId) : documentVariant === "published" ? "published" : "drafts"];
    t22 = getPreviewStateObservable$1(documentPreviewStore, schemaType, getPublishedId(versionId), perspectiveStack), $[2] = documentPreviewStore, $[3] = documentVariant, $[4] = schemaType, $[5] = versionId, $[6] = t22;
  } else
    t22 = $[6];
  const previewStateObservable = t22;
  let t3;
  $[7] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t3 = {
    snapshot: null,
    isLoading: true,
    original: null
  }, $[7] = t3) : t3 = $[7];
  const {
    snapshot,
    original,
    isLoading: previewIsLoading
  } = useObservable(previewStateObservable, t3);
  let t4;
  bb0: {
    if (documentVariant !== "version") {
      t4 = void 0;
      break bb0;
    }
    let t52;
    if ($[8] !== releases || $[9] !== versionId) {
      let t62;
      $[11] !== versionId ? (t62 = (r2) => getReleaseIdFromReleaseDocumentId(r2._id) === getVersionFromId(versionId), $[11] = versionId, $[12] = t62) : t62 = $[12], t52 = releases.find(t62), $[8] = releases, $[9] = versionId, $[10] = t52;
    } else
      t52 = $[10];
    t4 = t52;
  }
  const release = t4;
  let t5;
  bb1: {
    if (documentVariant === "version") {
      t5 = void 0;
      break bb1;
    }
    let t62;
    $[13] !== documentVariant || $[14] !== t2 ? (t62 = t2(documentVariant === "published" ? "release.chip.published" : "release.chip.draft"), $[13] = documentVariant, $[14] = t2, $[15] = t62) : t62 = $[15], t5 = t62;
  }
  const systemTitle = t5;
  let t6;
  $[16] !== documentVariant || $[17] !== release ? (t6 = release ? getReleaseTone(release) : documentVariant === "published" ? "positive" : "caution", $[16] = documentVariant, $[17] = release, $[18] = t6) : t6 = $[18];
  const tone = t6;
  let t7;
  $[19] !== original || $[20] !== schemaType.name || $[21] !== snapshot || $[22] !== versionId ? (t7 = getPreviewValueWithFallback({
    snapshot,
    original,
    fallback: {
      _id: versionId,
      _type: schemaType.name
    }
  }), $[19] = original, $[20] = schemaType.name, $[21] = snapshot, $[22] = versionId, $[23] = t7) : t7 = $[23];
  let t8;
  $[24] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t8 = {
    backgroundColor: "transparent"
  }, $[24] = t8) : t8 = $[24];
  let t9;
  $[25] !== tone ? (t9 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(ReleaseAvatarIcon, { tone }) }), $[25] = tone, $[26] = t9) : t9 = $[26];
  let t10;
  $[27] !== documentVariant || $[28] !== release?.metadata?.title || $[29] !== systemTitle || $[30] !== versionId ? (t10 = documentVariant === "version" ? (0, import_jsx_runtime2.jsx)(ReleaseTitle, { title: release?.metadata?.title, fallback: getVersionFromId(versionId), children: _temp$h }) : (0, import_jsx_runtime2.jsx)(EllipsisText, { size: 1, weight: "medium", textOverflow: "ellipsis", children: systemTitle }), $[27] = documentVariant, $[28] = release?.metadata?.title, $[29] = systemTitle, $[30] = versionId, $[31] = t10) : t10 = $[31];
  let t11;
  $[32] !== t10 || $[33] !== t9 ? (t11 = (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 2, paddingY: 2, paddingRight: 3, paddingLeft: 2, children: [
    t9,
    t10
  ] }), $[32] = t10, $[33] = t9, $[34] = t11) : t11 = $[34];
  let t12;
  $[35] !== t11 || $[36] !== tone ? (t12 = (0, import_jsx_runtime2.jsx)(Card, { border: true, radius: "full", children: (0, import_jsx_runtime2.jsx)(Card, { radius: "full", tone, style: t8, children: t11 }) }), $[35] = t11, $[36] = tone, $[37] = t12) : t12 = $[37];
  let t13;
  return $[38] !== previewIsLoading || $[39] !== schemaType.icon || $[40] !== t12 || $[41] !== t7 ? (t13 = (0, import_jsx_runtime2.jsx)(SanityDefaultPreview, { ...t7, isPlaceholder: previewIsLoading, icon: schemaType.icon, layout: "default", status: t12 }), $[38] = previewIsLoading, $[39] = schemaType.icon, $[40] = t12, $[41] = t7, $[42] = t13) : t13 = $[42], t13;
};
var VersionsPreviewList = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(8), {
    documentType,
    documentVersions
  } = t0, schema = useSchema();
  let t1;
  $[0] !== documentType || $[1] !== schema ? (t1 = schema.get(documentType), $[0] = documentType, $[1] = schema, $[2] = t1) : t1 = $[2];
  const schemaType = t1;
  if (!schemaType)
    throw new Error(`Schema type ${documentType} not found`);
  let t2;
  $[3] !== documentVersions || $[4] !== schemaType ? (t2 = documentVersions?.map((version) => (0, import_jsx_runtime2.jsx)(VersionItemPreview, { versionId: version, schemaType }, version)), $[3] = documentVersions, $[4] = schemaType, $[5] = t2) : t2 = $[5];
  let t3;
  return $[6] !== t2 ? (t3 = (0, import_jsx_runtime2.jsx)(Card, { border: true, padding: 1, radius: 2, children: (0, import_jsx_runtime2.jsx)(Stack, { children: t2 }) }), $[6] = t2, $[7] = t3) : t3 = $[7], t3;
};
function _temp$h(t0) {
  const {
    displayTitle
  } = t0;
  return (0, import_jsx_runtime2.jsx)(EllipsisText, { size: 1, weight: "medium", textOverflow: "ellipsis", children: displayTitle });
}
function ConfirmDeleteDialogBody(t0) {
  const $ = (0, import_compiler_runtime2.c)(66), {
    crossDatasetReferences,
    internalReferences,
    documentTitle,
    totalCount,
    action,
    datasetNames,
    hasUnknownDatasetNames,
    documentId,
    documentType,
    onReferenceLinkClick,
    documentVersions
  } = t0, schema = useSchema(), toast = useToast(), {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[0] !== onReferenceLinkClick || $[1] !== schema || $[2] !== t2 ? (t1 = (item) => {
    const type = schema.get(item._type);
    return type ? (0, import_jsx_runtime2.jsx)(ReferencePreviewLink, { type, value: item, onClick: onReferenceLinkClick }) : (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsx)(SanityDefaultPreview, { icon: UnknownIcon, title: t2("confirm-delete-dialog.preview-item.preview-unavailable.title"), subtitle: t2("confirm-delete-dialog.preview-item.preview-unavailable.subtitle", {
      documentId: item._id
    }), layout: "default" }) });
  }, $[0] = onReferenceLinkClick, $[1] = schema, $[2] = t2, $[3] = t1) : t1 = $[3];
  const renderPreviewItem = t1;
  let t22;
  $[4] !== action || $[5] !== documentTitle || $[6] !== documentType || $[7] !== documentVersions || $[8] !== t2 ? (t22 = () => (0, import_jsx_runtime2.jsxs)(Stack, { space: 4, children: [
    (0, import_jsx_runtime2.jsx)(Text, { as: "p", size: 1, children: (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "confirm-delete-dialog.confirmation.text", context: action, components: {
      DocumentTitle: () => (0, import_jsx_runtime2.jsx)("strong", { children: documentTitle })
    } }) }),
    action === "delete" && (0, import_jsx_runtime2.jsx)(VersionsPreviewList, { documentType, documentVersions })
  ] }), $[4] = action, $[5] = documentTitle, $[6] = documentType, $[7] = documentVersions, $[8] = t2, $[9] = t22) : t22 = $[9];
  const confirmationMessage = t22;
  if (internalReferences?.totalCount === 0 && crossDatasetReferences?.totalCount === 0) {
    let t32;
    return $[10] !== confirmationMessage ? (t32 = confirmationMessage(), $[10] = confirmationMessage, $[11] = t32) : t32 = $[11], t32;
  }
  let t3;
  $[12] !== hasUnknownDatasetNames ? (t3 = hasUnknownDatasetNames ? ["unavailable"] : [], $[12] = hasUnknownDatasetNames, $[13] = t3) : t3 = $[13];
  let t4;
  $[14] !== datasetNames || $[15] !== t3 ? (t4 = [...datasetNames, ...t3], $[14] = datasetNames, $[15] = t3, $[16] = t4) : t4 = $[16];
  const normalizedDatasetNames = t4, t5 = normalizedDatasetNames.length, t6 = normalizedDatasetNames.join(", "), t7 = hasUnknownDatasetNames && normalizedDatasetNames.length ? "unavailable" : "";
  let t8;
  $[17] !== normalizedDatasetNames.length || $[18] !== t2 || $[19] !== t6 || $[20] !== t7 ? (t8 = t2("confirm-delete-dialog.cdr-summary.subtitle", {
    count: t5,
    datasets: t6,
    context: t7
  }), $[17] = normalizedDatasetNames.length, $[18] = t2, $[19] = t6, $[20] = t7, $[21] = t8) : t8 = $[21];
  const datasetSubtitle = t8;
  let t9;
  $[22] !== confirmationMessage ? (t9 = confirmationMessage(), $[22] = confirmationMessage, $[23] = t9) : t9 = $[23];
  let t10;
  $[24] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t10 = (0, import_jsx_runtime2.jsx)(Card, { borderTop: true, padding: 1 }), $[24] = t10) : t10 = $[24];
  let t11;
  $[25] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t11 = (0, import_jsx_runtime2.jsx)(Text, { "aria-hidden": "true", size: 1, children: (0, import_jsx_runtime2.jsx)(WarningOutlineIcon, {}) }), $[25] = t11) : t11 = $[25];
  let t12;
  $[26] !== documentTitle ? (t12 = {
    DocumentTitle: () => documentTitle
  }, $[26] = documentTitle, $[27] = t12) : t12 = $[27];
  let t13;
  $[28] !== totalCount ? (t13 = {
    count: totalCount
  }, $[28] = totalCount, $[29] = t13) : t13 = $[29];
  let t14;
  $[30] !== t2 || $[31] !== t12 || $[32] !== t13 ? (t14 = (0, import_jsx_runtime2.jsxs)("div", { children: [
    t10,
    (0, import_jsx_runtime2.jsx)(Card, { padding: 3, radius: 2, tone: "caution", flex: "none", children: (0, import_jsx_runtime2.jsxs)(Flex, { children: [
      t11,
      (0, import_jsx_runtime2.jsx)(Box, { flex: 1, marginLeft: 3, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(Translate, { i18nKey: "confirm-delete-dialog.referring-document-count.text", components: t12, t: t2, values: t13 }) }) })
    ] }) })
  ] }), $[30] = t2, $[31] = t12, $[32] = t13, $[33] = t14) : t14 = $[33];
  let t15;
  $[34] !== documentTitle ? (t15 = {
    DocumentTitle: () => documentTitle
  }, $[34] = documentTitle, $[35] = t15) : t15 = $[35];
  let t16;
  $[36] !== action || $[37] !== t2 || $[38] !== t15 ? (t16 = (0, import_jsx_runtime2.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(Translate, { i18nKey: "confirm-delete-dialog.referring-documents-descriptor.text", t: t2, context: action, components: t15 }) }) }), $[36] = action, $[37] = t2, $[38] = t15, $[39] = t16) : t16 = $[39];
  let t17;
  $[40] !== internalReferences || $[41] !== renderPreviewItem ? (t17 = internalReferences.totalCount > 0 && (0, import_jsx_runtime2.jsxs)(Stack, { as: "ul", space: 2, "data-testid": "internal-references", children: [
    internalReferences?.references.map((item_0) => (0, import_jsx_runtime2.jsx)(Box, { as: "li", children: renderPreviewItem(item_0) }, item_0._id)),
    internalReferences.totalCount > internalReferences.references.length && (0, import_jsx_runtime2.jsx)(Box, { as: "li", padding: 3, children: (0, import_jsx_runtime2.jsx)(OtherReferenceCount, { ...internalReferences }) })
  ] }), $[40] = internalReferences, $[41] = renderPreviewItem, $[42] = t17) : t17 = $[42];
  let t18;
  $[43] !== crossDatasetReferences || $[44] !== datasetSubtitle || $[45] !== documentId || $[46] !== internalReferences.totalCount || $[47] !== normalizedDatasetNames.length || $[48] !== t2 || $[49] !== toast ? (t18 = crossDatasetReferences.totalCount > 0 && (0, import_jsx_runtime2.jsxs)(CrossDatasetReferencesDetails, { "data-testid": "cross-dataset-references", style: {
    borderTop: internalReferences.totalCount > 0 ? "1px solid var(--card-shadow-outline-color)" : void 0
  }, children: [
    (0, import_jsx_runtime2.jsx)(CrossDatasetReferencesSummary, { children: (0, import_jsx_runtime2.jsx)(Card, { as: "a", marginTop: internalReferences.totalCount > 0 ? 2 : 0, radius: 2, shadow: 1, paddingY: 1, children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 3, paddingX: 3, paddingY: 1, children: [
      (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(DocumentsIcon, {}) }),
      (0, import_jsx_runtime2.jsxs)(Stack, { space: 2, children: [
        (0, import_jsx_runtime2.jsx)(Text, { textOverflow: "ellipsis", size: 1, children: t2("confirm-delete-dialog.cdr-summary.title", {
          count: normalizedDatasetNames.length,
          documentCount: t2("confirm-delete-dialog.cdr-summary.document-count", {
            count: crossDatasetReferences.totalCount
          })
        }) }),
        (0, import_jsx_runtime2.jsx)(Text, { title: datasetSubtitle, textOverflow: "ellipsis", size: 1, muted: true, children: datasetSubtitle })
      ] }),
      (0, import_jsx_runtime2.jsx)(ChevronWrapper, { children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: (0, import_jsx_runtime2.jsx)(ChevronDownIcon, {}) }) })
    ] }) }) }),
    (0, import_jsx_runtime2.jsxs)(Box, { overflow: "auto", paddingTop: 2, children: [
      (0, import_jsx_runtime2.jsxs)(Table$1, { children: [
        (0, import_jsx_runtime2.jsx)("thead", { children: (0, import_jsx_runtime2.jsxs)("tr", { children: [
          (0, import_jsx_runtime2.jsx)("th", { children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, style: {
            minWidth: "5rem"
          }, weight: "medium", children: t2("confirm-delete-dialog.cdr-table.project-id.label") }) }),
          (0, import_jsx_runtime2.jsx)("th", { children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, weight: "medium", children: t2("confirm-delete-dialog.cdr-table.dataset.label") }) }),
          (0, import_jsx_runtime2.jsx)("th", { children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, weight: "medium", children: t2("confirm-delete-dialog.cdr-table.document-id.label") }) })
        ] }) }),
        (0, import_jsx_runtime2.jsx)("tbody", { children: crossDatasetReferences.references.filter(_temp$g).map((t192, index) => {
          const {
            projectId,
            datasetName,
            documentId: referenceId
          } = t192;
          return (0, import_jsx_runtime2.jsxs)("tr", { children: [
            (0, import_jsx_runtime2.jsx)("td", { children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: projectId }) }),
            (0, import_jsx_runtime2.jsx)("td", { children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: datasetName || "unavailable" }) }),
            (0, import_jsx_runtime2.jsx)("td", { children: (0, import_jsx_runtime2.jsxs)(DocumentIdFlex, { align: "center", gap: 2, justify: "flex-end", children: [
              (0, import_jsx_runtime2.jsx)(Text, { textOverflow: "ellipsis", size: 1, children: referenceId || "unavailable" }),
              referenceId && (0, import_jsx_runtime2.jsx)(Button2, { mode: "bleed", icon: CopyIcon, tooltipProps: {
                content: t2("confirm-delete-dialog.cdr-table.copy-id-button.tooltip")
              }, onClick: () => {
                navigator.clipboard.writeText(referenceId).catch(() => {
                  toast.push({
                    status: "error",
                    title: t2("confirm-delete-dialog.cdr-table.id-copied-toast.title-failed")
                  });
                });
              } })
            ] }) })
          ] }, `${documentId}-${index}`);
        }) })
      ] }),
      (0, import_jsx_runtime2.jsx)(OtherReferenceCount, { ...crossDatasetReferences })
    ] })
  ] }), $[43] = crossDatasetReferences, $[44] = datasetSubtitle, $[45] = documentId, $[46] = internalReferences.totalCount, $[47] = normalizedDatasetNames.length, $[48] = t2, $[49] = toast, $[50] = t18) : t18 = $[50];
  let t19;
  $[51] !== t17 || $[52] !== t18 ? (t19 = (0, import_jsx_runtime2.jsx)(Card, { radius: 2, shadow: 1, flex: "auto", padding: 1, children: (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", children: [
    t17,
    t18
  ] }) }), $[51] = t17, $[52] = t18, $[53] = t19) : t19 = $[53];
  let t20;
  $[54] !== documentTitle ? (t20 = {
    DocumentTitle: () => documentTitle
  }, $[54] = documentTitle, $[55] = t20) : t20 = $[55];
  let t21;
  $[56] !== action || $[57] !== t2 || $[58] !== t20 ? (t21 = (0, import_jsx_runtime2.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(Translate, { i18nKey: "confirm-delete-dialog.referential-integrity-disclaimer.text", t: t2, context: action, components: t20 }) }) }), $[56] = action, $[57] = t2, $[58] = t20, $[59] = t21) : t21 = $[59];
  let t222;
  return $[60] !== t14 || $[61] !== t16 || $[62] !== t19 || $[63] !== t21 || $[64] !== t9 ? (t222 = (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", gap: 4, children: [
    t9,
    t14,
    t16,
    t19,
    t21
  ] }), $[60] = t14, $[61] = t16, $[62] = t19, $[63] = t21, $[64] = t9, $[65] = t222) : t222 = $[65], t222;
}
function _temp$g(reference) {
  return "projectId" in reference;
}
function isClientError(e2) {
  return typeof e2 != "object" || !e2 ? false : "statusCode" in e2 && "response" in e2;
}
var POLL_INTERVAL = 5e3;
var visiblePoll$;
var getVisiblePoll$ = () => (visiblePoll$ || (visiblePoll$ = fromEvent(document, "visibilitychange").pipe(
  // add empty emission to have this fire on creation
  startWith(null),
  map(() => document.visibilityState === "visible"),
  distinctUntilChanged(),
  switchMap((visible) => visible ? (
    // using timer instead of interval since timer will emit on creation
    timer(0, POLL_INTERVAL)
  ) : EMPTY),
  shareReplay({
    refCount: true,
    bufferSize: 1
  })
)), visiblePoll$);
function getDocumentExistence(documentId, {
  versionedClient
}) {
  const draftId = getDraftId(documentId), publishedId = getPublishedId(documentId), requestOptions = {
    uri: versionedClient.getDataUrl("doc", `${draftId},${publishedId}`),
    json: true,
    query: {
      excludeContent: "true"
    },
    tag: "use-referring-documents.document-existence"
  };
  return versionedClient.observable.request(requestOptions).pipe(map(({
    omitted
  }) => {
    const nonExistant = omitted.filter((doc) => doc.reason === "existence");
    if (nonExistant.length !== 2)
      return nonExistant.length === 0 || nonExistant.some((doc) => doc.id === draftId) ? publishedId : draftId;
  }));
}
function fetchCrossDatasetReferences(documentId, context) {
  const {
    versionedClient
  } = context;
  return getVisiblePoll$().pipe(switchMap(() => getDocumentExistence(documentId, context)), switchMap((checkDocumentId) => {
    if (!checkDocumentId)
      return of({
        totalCount: 0,
        references: []
      });
    const currentDataset = versionedClient.config().dataset;
    return versionedClient.observable.request({
      url: `/data/references/${currentDataset}/documents/${checkDocumentId}/to?excludeInternalReferences=true&excludePaths=true`,
      tag: "use-referring-documents.external"
    }).pipe(catchError((e2) => {
      if (isClientError(e2) && e2.statusCode === 404)
        return of({
          totalCount: 0,
          references: []
        });
      throw e2;
    }));
  }));
}
var useInternalReferences = createHookFromObservableFactory(([documentId, documentStore]) => documentStore.listenQuery({
  fetch: '{"references":*[references($documentId)][0...100]{_id,_type},"totalCount":count(*[references($documentId)])}',
  listen: "*[references($documentId)]"
}, {
  documentId
}, {
  tag: "use-referring-documents",
  transitions: ["appear", "disappear"],
  throttleTime: 5e3
}));
var useCrossDatasetReferences = createHookFromObservableFactory(([documentId, versionedClient]) => getVisiblePoll$().pipe(switchMap(() => fetchCrossDatasetReferences(documentId, {
  versionedClient
}))));
function useReferringDocuments(documentId) {
  const $ = (0, import_compiler_runtime2.c)(24), versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS), documentStore = useDocumentStore();
  let t0;
  $[0] !== documentId ? (t0 = getPublishedId(documentId), $[0] = documentId, $[1] = t0) : t0 = $[1];
  const publishedId = t0;
  let t1;
  $[2] !== documentStore || $[3] !== publishedId ? (t1 = [publishedId, documentStore], $[2] = documentStore, $[3] = publishedId, $[4] = t1) : t1 = $[4];
  const [internalReferences, isInternalReferencesLoading] = useInternalReferences(t1);
  let t2;
  $[5] !== publishedId || $[6] !== versionedClient ? (t2 = [publishedId, versionedClient], $[5] = publishedId, $[6] = versionedClient, $[7] = t2) : t2 = $[7];
  const [crossDatasetReferences, isCrossDatasetReferencesLoading] = useCrossDatasetReferences(t2);
  let t3;
  $[8] !== crossDatasetReferences?.references ? (t3 = () => Array.from(new Set(crossDatasetReferences?.references.map(_temp$f).filter(Boolean))).sort(), $[8] = crossDatasetReferences?.references, $[9] = t3) : t3 = $[9];
  let t4;
  $[10] !== t3 ? (t4 = t3(), $[10] = t3, $[11] = t4) : t4 = $[11];
  const projectIds = t4;
  let t5;
  $[12] !== crossDatasetReferences?.references ? (t5 = Array.from(new Set(crossDatasetReferences?.references.map(_temp2$8).filter(_temp3$5))).sort(), $[12] = crossDatasetReferences?.references, $[13] = t5) : t5 = $[13];
  const datasetNames = t5;
  let t6;
  $[14] !== crossDatasetReferences?.references ? (t6 = () => !!crossDatasetReferences?.references.some(_temp4$5), $[14] = crossDatasetReferences?.references, $[15] = t6) : t6 = $[15];
  const hasUnknownDatasetNames = t6(), t7 = (internalReferences?.totalCount || 0) + (crossDatasetReferences?.totalCount || 0), t8 = isInternalReferencesLoading || isCrossDatasetReferencesLoading;
  let t9;
  return $[16] !== crossDatasetReferences || $[17] !== datasetNames || $[18] !== hasUnknownDatasetNames || $[19] !== internalReferences || $[20] !== projectIds || $[21] !== t7 || $[22] !== t8 ? (t9 = {
    totalCount: t7,
    projectIds,
    datasetNames,
    hasUnknownDatasetNames,
    internalReferences,
    crossDatasetReferences,
    isLoading: t8
  }, $[16] = crossDatasetReferences, $[17] = datasetNames, $[18] = hasUnknownDatasetNames, $[19] = internalReferences, $[20] = projectIds, $[21] = t7, $[22] = t8, $[23] = t9) : t9 = $[23], t9;
}
function _temp4$5(crossDatasetReference_1) {
  return typeof crossDatasetReference_1.datasetName != "string";
}
function _temp3$5(datasetName) {
  return !!datasetName && datasetName !== "";
}
function _temp2$8(crossDatasetReference_0) {
  return crossDatasetReference_0?.datasetName || "";
}
function _temp$f(crossDatasetReference) {
  return crossDatasetReference.projectId;
}
var DialogBody = at(Box).withConfig({
  displayName: "DialogBody",
  componentId: "sc-jawiy-0"
})`box-sizing:border-box;`;
var LoadingContainer = at(Flex).attrs({
  align: "center",
  direction: "column",
  justify: "center"
}).withConfig({
  displayName: "LoadingContainer",
  componentId: "sc-jawiy-1"
})`height:110px;`;
function ConfirmDeleteDialog(t0) {
  const $ = (0, import_compiler_runtime2.c)(51), {
    id,
    type,
    action: t1,
    onCancel,
    onConfirm
  } = t0, action = t1 === void 0 ? "delete" : t1, {
    t: t2
  } = useTranslation(structureLocaleNamespace), dialogId = `deletion-confirmation-${(0, import_react2.useId)()}`, {
    internalReferences,
    crossDatasetReferences,
    isLoading,
    totalCount,
    projectIds,
    datasetNames,
    hasUnknownDatasetNames
  } = useReferringDocuments(id);
  let t22;
  $[0] !== id || $[1] !== type ? (t22 = {
    _id: id,
    _type: type
  }, $[0] = id, $[1] = type, $[2] = t22) : t22 = $[2];
  const t3 = t22;
  let t4;
  $[3] !== t3 ? (t4 = (0, import_jsx_runtime2.jsx)(DocTitle, { document: t3 }), $[3] = t3, $[4] = t4) : t4 = $[4];
  const documentTitle = t4, showConfirmButton = !isLoading;
  let t5;
  $[5] !== id ? (t5 = getPublishedId(id), $[5] = id, $[6] = t5) : t5 = $[6];
  let t6;
  $[7] !== t5 ? (t6 = {
    documentId: t5
  }, $[7] = t5, $[8] = t6) : t6 = $[8];
  const {
    data: documentVersions,
    loading: versionsLoading
  } = useDocumentVersions(t6);
  let t7;
  $[9] !== documentVersions || $[10] !== onConfirm ? (t7 = () => {
    onConfirm(documentVersions);
  }, $[9] = documentVersions, $[10] = onConfirm, $[11] = t7) : t7 = $[11];
  const handleConfirm = t7;
  let t8;
  $[12] !== action || $[13] !== t2 ? (t8 = t2("confirm-delete-dialog.header.text", {
    context: action
  }), $[12] = action, $[13] = t2, $[14] = t8) : t8 = $[14];
  let t9;
  $[15] !== t2 ? (t9 = t2("confirm-delete-dialog.cancel-button.text"), $[15] = t2, $[16] = t9) : t9 = $[16];
  let t10;
  $[17] !== onCancel || $[18] !== t9 ? (t10 = {
    onClick: onCancel,
    text: t9
  }, $[17] = onCancel, $[18] = t9, $[19] = t10) : t10 = $[19];
  let t11;
  $[20] !== action || $[21] !== handleConfirm || $[22] !== showConfirmButton || $[23] !== t2 || $[24] !== totalCount ? (t11 = showConfirmButton ? {
    text: totalCount > 0 ? t2("confirm-delete-dialog.confirm-anyway-button.text", {
      context: action
    }) : t2("confirm-delete-dialog.confirm-button.text", {
      context: action
    }),
    onClick: handleConfirm
  } : void 0, $[20] = action, $[21] = handleConfirm, $[22] = showConfirmButton, $[23] = t2, $[24] = totalCount, $[25] = t11) : t11 = $[25];
  let t12;
  $[26] !== t10 || $[27] !== t11 ? (t12 = {
    cancelButton: t10,
    confirmButton: t11
  }, $[26] = t10, $[27] = t11, $[28] = t12) : t12 = $[28];
  let t13;
  $[29] !== action || $[30] !== crossDatasetReferences || $[31] !== datasetNames || $[32] !== documentTitle || $[33] !== documentVersions || $[34] !== hasUnknownDatasetNames || $[35] !== id || $[36] !== internalReferences || $[37] !== isLoading || $[38] !== onCancel || $[39] !== projectIds || $[40] !== t2 || $[41] !== totalCount || $[42] !== type || $[43] !== versionsLoading ? (t13 = (0, import_jsx_runtime2.jsx)(DialogBody, { children: crossDatasetReferences && internalReferences && !isLoading && !versionsLoading ? (0, import_jsx_runtime2.jsx)(ConfirmDeleteDialogBody, { crossDatasetReferences, internalReferences, documentTitle, isLoading, totalCount, action, projectIds, datasetNames, hasUnknownDatasetNames, onReferenceLinkClick: onCancel, documentId: id, documentType: type, documentVersions }) : (0, import_jsx_runtime2.jsx)(LoadingContainer, { "data-testid": "loading-container", children: (0, import_jsx_runtime2.jsx)(LoadingBlock, { showText: true, title: t2("confirm-delete-dialog.loading.text") }) }) }), $[29] = action, $[30] = crossDatasetReferences, $[31] = datasetNames, $[32] = documentTitle, $[33] = documentVersions, $[34] = hasUnknownDatasetNames, $[35] = id, $[36] = internalReferences, $[37] = isLoading, $[38] = onCancel, $[39] = projectIds, $[40] = t2, $[41] = totalCount, $[42] = type, $[43] = versionsLoading, $[44] = t13) : t13 = $[44];
  let t14;
  return $[45] !== dialogId || $[46] !== onCancel || $[47] !== t12 || $[48] !== t13 || $[49] !== t8 ? (t14 = (0, import_jsx_runtime2.jsx)(Dialog2, { width: 1, id: dialogId, header: t8, footer: t12, onClose: onCancel, onClickOutside: onCancel, children: t13 }), $[45] = dialogId, $[46] = onCancel, $[47] = t12, $[48] = t13, $[49] = t8, $[50] = t14) : t14 = $[50], t14;
}
function ConfirmDeleteDialogContainer(props) {
  const $ = (0, import_compiler_runtime2.c)(6), {
    t: t2
  } = useTranslation(structureLocaleNamespace), id = (0, import_react2.useId)(), [error, setError] = (0, import_react2.useState)(null);
  let t0;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = () => setError(null), $[0] = t0) : t0 = $[0];
  const handleRetry = t0;
  let t1;
  return $[1] !== error || $[2] !== id || $[3] !== props || $[4] !== t2 ? (t1 = error ? (0, import_jsx_runtime2.jsx)(Dialog2, { id: `dialog-error-${id}`, "data-testid": "confirm-delete-error-dialog", header: t2("confirm-delete-dialog.error.title.text"), footer: {
    confirmButton: {
      text: t2("confirm-delete-dialog.error.retry-button.text"),
      onClick: handleRetry,
      tone: "default"
    }
  }, onClose: props.onCancel, children: (0, import_jsx_runtime2.jsx)(Box, { padding: 4, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: t2("confirm-delete-dialog.error.message.text") }) }) }) : (0, import_jsx_runtime2.jsx)(ErrorBoundary, { onCatch: setError, children: (0, import_jsx_runtime2.jsx)(ConfirmDeleteDialog, { ...props }) }), $[1] = error, $[2] = id, $[3] = props, $[4] = t2, $[5] = t1) : t1 = $[5], t1;
}
var IntentButton = (0, import_react2.forwardRef)(function(props, ref) {
  const $ = (0, import_compiler_runtime2.c)(10);
  let intent, restProps;
  $[0] !== props ? ({
    intent,
    ...restProps
  } = props, $[0] = props, $[1] = intent, $[2] = restProps) : (intent = $[1], restProps = $[2]);
  let t0;
  $[3] !== intent ? (t0 = (0, import_react2.forwardRef)(function(linkProps, linkRef) {
    return (0, import_jsx_runtime2.jsx)(IntentLink, { ...linkProps, intent: intent.type, params: intent.params, ref: linkRef, searchParams: intent.searchParams });
  }), $[3] = intent, $[4] = t0) : t0 = $[4];
  const Link2 = t0;
  let t1;
  return $[5] !== Link2 || $[6] !== props.disabled || $[7] !== ref || $[8] !== restProps ? (t1 = props.disabled ? (0, import_jsx_runtime2.jsx)(Button2, { ...restProps, as: "a", role: "link", "aria-disabled": "true" }) : (0, import_jsx_runtime2.jsx)(Button2, { ...restProps, as: Link2, "data-as": "a", ref }), $[5] = Link2, $[6] = props.disabled, $[7] = ref, $[8] = restProps, $[9] = t1) : t1 = $[9], t1;
});
function InsufficientPermissionsMessageTooltip(t0) {
  const $ = (0, import_compiler_runtime2.c)(12), {
    reveal,
    context,
    loading,
    children
  } = t0, currentUser = useCurrentUser(), {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  if (!reveal) {
    let t12;
    return $[0] !== children ? (t12 = (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children }), $[0] = children, $[1] = t12) : t12 = $[1], t12;
  }
  let t1;
  $[2] !== context || $[3] !== currentUser || $[4] !== loading || $[5] !== t2 ? (t1 = loading ? t2("insufficient-permissions-message-tooltip.loading-text") : (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessage, { context, currentUser }), $[2] = context, $[3] = currentUser, $[4] = loading, $[5] = t2, $[6] = t1) : t1 = $[6];
  let t22;
  $[7] !== children ? (t22 = (0, import_jsx_runtime2.jsx)("div", { children }), $[7] = children, $[8] = t22) : t22 = $[8];
  let t3;
  return $[9] !== t1 || $[10] !== t22 ? (t3 = (0, import_jsx_runtime2.jsx)(Tooltip, { content: t1, portal: true, children: t22 }), $[9] = t1, $[10] = t22, $[11] = t3) : t3 = $[11], t3;
}
var POPOVER_PROPS = {
  constrainSize: true,
  placement: "bottom",
  portal: true
};
var getIntent = (templates, item, version) => {
  const typeName = templates.find((t2) => t2.id === item.templateId)?.schemaType;
  if (!typeName) return null;
  const baseParams = {
    template: item.templateId,
    type: typeName,
    version,
    id: item.initialDocumentId
  };
  return {
    type: "create",
    params: item.parameters ? [baseParams, item.parameters] : baseParams,
    searchParams: version ? [["perspective", version]] : void 0
  };
};
function PaneHeaderCreateButton(t0) {
  const $ = (0, import_compiler_runtime2.c)(60), {
    templateItems
  } = t0, templates = useTemplates(), {
    selectedReleaseId
  } = usePerspective(), {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[0] !== templateItems || $[1] !== templates ? (t1 = [...templateItems, ...templates], $[0] = templateItems, $[1] = templates, $[2] = t1) : t1 = $[2];
  const getI18nText = useGetI18nText(t1);
  let t22;
  $[3] !== templateItems ? (t22 = {
    templateItems
  }, $[3] = templateItems, $[4] = t22) : t22 = $[4];
  const [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions(t22), nothingGranted = !isTemplatePermissionsLoading && templatePermissions?.length !== 0 && templatePermissions?.every(_temp$e);
  let t3;
  bb0: {
    if (!templatePermissions) {
      let t43;
      $[5] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t43 = {}, $[5] = t43) : t43 = $[5], t3 = t43;
      break bb0;
    }
    let t42;
    $[6] !== templatePermissions ? (t42 = templatePermissions.reduce(_temp2$7, {}), $[6] = templatePermissions, $[7] = t42) : t42 = $[7], t3 = t42;
  }
  const permissionsById = t3;
  if (templateItems.length === 0)
    return null;
  if (nothingGranted) {
    let t42;
    $[8] !== t2 ? (t42 = t2("pane-header.disabled-created-button.aria-label"), $[8] = t2, $[9] = t42) : t42 = $[9];
    let t52;
    $[10] !== t42 ? (t52 = (0, import_jsx_runtime2.jsx)(Button2, { "aria-label": t42, icon: AddIcon, "data-testid": "action-intent-button", disabled: true, mode: "bleed", tooltipProps: null }), $[10] = t42, $[11] = t52) : t52 = $[11];
    let t62;
    return $[12] !== isTemplatePermissionsLoading || $[13] !== t52 ? (t62 = (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessageTooltip, { context: "create-document-type", reveal: true, loading: isTemplatePermissionsLoading, children: t52 }), $[12] = isTemplatePermissionsLoading, $[13] = t52, $[14] = t62) : t62 = $[14], t62;
  }
  if (templateItems.length === 1) {
    const firstItem = templateItems[0], disabled = !permissionsById[firstItem.id]?.granted;
    let t42;
    $[15] !== firstItem || $[16] !== selectedReleaseId || $[17] !== templates ? (t42 = getIntent(templates, firstItem, selectedReleaseId), $[15] = firstItem, $[16] = selectedReleaseId, $[17] = templates, $[18] = t42) : t42 = $[18];
    const intent = t42;
    if (!intent)
      return null;
    let t52;
    $[19] !== firstItem || $[20] !== getI18nText ? (t52 = getI18nText(firstItem), $[19] = firstItem, $[20] = getI18nText, $[21] = t52) : t52 = $[21];
    const t62 = t52.title, t72 = firstItem.icon || AddIcon;
    let t82;
    $[22] !== t2 ? (t82 = t2("pane-header.create-new-button.tooltip"), $[22] = t2, $[23] = t82) : t82 = $[23];
    let t9;
    $[24] !== t82 ? (t9 = {
      content: t82
    }, $[24] = t82, $[25] = t9) : t9 = $[25];
    let t10;
    $[26] !== disabled || $[27] !== intent || $[28] !== t52.title || $[29] !== t72 || $[30] !== t9 ? (t10 = (0, import_jsx_runtime2.jsx)(IntentButton, { "aria-label": t62, icon: t72, intent, mode: "bleed", disabled, "data-testid": "action-intent-button", tooltipProps: t9 }), $[26] = disabled, $[27] = intent, $[28] = t52.title, $[29] = t72, $[30] = t9, $[31] = t10) : t10 = $[31];
    let t11;
    return $[32] !== disabled || $[33] !== isTemplatePermissionsLoading || $[34] !== t10 ? (t11 = (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessageTooltip, { reveal: disabled, loading: isTemplatePermissionsLoading, context: "create-document-type", children: t10 }), $[32] = disabled, $[33] = isTemplatePermissionsLoading, $[34] = t10, $[35] = t11) : t11 = $[35], t11;
  }
  let t4;
  $[36] !== t2 ? (t4 = t2("pane-header.create-new-button.tooltip"), $[36] = t2, $[37] = t4) : t4 = $[37];
  let t5;
  $[38] !== t4 ? (t5 = (0, import_jsx_runtime2.jsx)(Button2, { icon: AddIcon, mode: "bleed", "data-testid": "multi-action-intent-button", tooltipProps: {
    content: t4
  } }), $[38] = t4, $[39] = t5) : t5 = $[39];
  let t6;
  if ($[40] !== getI18nText || $[41] !== isTemplatePermissionsLoading || $[42] !== permissionsById || $[43] !== selectedReleaseId || $[44] !== t2 || $[45] !== templateItems || $[46] !== templates) {
    let t72;
    $[48] !== getI18nText || $[49] !== isTemplatePermissionsLoading || $[50] !== permissionsById || $[51] !== selectedReleaseId || $[52] !== t2 || $[53] !== templates ? (t72 = (item, itemIndex) => {
      const disabled_0 = !permissionsById[item.id]?.granted, intent_0 = getIntent(templates, item, selectedReleaseId), template = templates.find((i) => i.id === item.templateId);
      if (!template || !intent_0)
        return null;
      const Link2 = (0, import_react2.forwardRef)((linkProps, linkRef) => disabled_0 ? (0, import_jsx_runtime2.jsx)("button", { type: "button", disabled: true, ...linkProps, ref: linkRef }) : (0, import_jsx_runtime2.jsx)(IntentLink, { ...linkProps, intent: intent_0.type, params: intent_0.params, searchParams: intent_0.searchParams, ref: linkRef }));
      Link2.displayName = "Link";
      const {
        title
      } = getI18nText({
        ...item,
        title: item.title || getI18nText(template).title
      });
      return (0, import_jsx_runtime2.jsx)(InsufficientPermissionsMessageTooltip, { context: "create-document-type", reveal: disabled_0, loading: isTemplatePermissionsLoading, children: (0, import_jsx_runtime2.jsx)(MenuItem2, { as: Link2, "data-as": disabled_0 ? "button" : "a", text: title, "aria-label": disabled_0 ? t2("pane-header.disabled-created-button.aria-label") : title, disabled: disabled_0, "data-testid": `action-intent-button-${itemIndex}` }) }, item.id);
    }, $[48] = getI18nText, $[49] = isTemplatePermissionsLoading, $[50] = permissionsById, $[51] = selectedReleaseId, $[52] = t2, $[53] = templates, $[54] = t72) : t72 = $[54], t6 = templateItems.map(t72), $[40] = getI18nText, $[41] = isTemplatePermissionsLoading, $[42] = permissionsById, $[43] = selectedReleaseId, $[44] = t2, $[45] = templateItems, $[46] = templates, $[47] = t6;
  } else
    t6 = $[47];
  let t7;
  $[55] !== t6 ? (t7 = (0, import_jsx_runtime2.jsx)(Menu, { children: t6 }), $[55] = t6, $[56] = t7) : t7 = $[56];
  let t8;
  return $[57] !== t5 || $[58] !== t7 ? (t8 = (0, import_jsx_runtime2.jsx)(MenuButton, { button: t5, id: "create-menu", menu: t7, popover: POPOVER_PROPS }), $[57] = t5, $[58] = t7, $[59] = t8) : t8 = $[59], t8;
}
function _temp2$7(acc, permission_0) {
  return acc[permission_0.id] = permission_0, acc;
}
function _temp$e(permission) {
  return !permission.granted;
}
function isNonNullable(value) {
  return value != null;
}
var hashObject = (value) => {
  const sortObject = (v) => typeof v != "object" || !v ? v : Array.isArray(v) ? v.map(sortObject) : Object.entries(v).sort(([keyA], [keyB]) => keyA.localeCompare(keyB, "en"));
  return JSON.stringify(sortObject(((v) => JSON.parse(JSON.stringify(v)))(value)));
};
var PaneHeaderActions = (0, import_react2.memo)(function(props) {
  const $ = (0, import_compiler_runtime2.c)(28), {
    initialValueTemplateItems: t0,
    menuItems: t1,
    menuItemGroups: t2,
    actionHandlers: t3
  } = props, initialValueTemplateItemsFromStructure = t0 === void 0 ? EMPTY_ARRAY$z : t0, menuItems = t1 === void 0 ? EMPTY_ARRAY$z : t1, menuItemGroups = t2 === void 0 ? EMPTY_ARRAY$z : t2, actionHandlers = t3 === void 0 ? EMPTY_OBJECT : t3, templates = useTemplates();
  let t4;
  $[0] !== actionHandlers ? (t4 = (item) => {
    if (item.id) {
      const toggleHandler = actionHandlers.setMenuItemState;
      if (toggleHandler && toggleHandler({
        _menuItemId: item.id,
        ...item.params
      }), !item.action || item.action === "setMenuItemState")
        return !!toggleHandler;
    }
    if (typeof item.action == "string" && !(item.action in actionHandlers))
      return console.warn("No handler for action:", item.action), false;
    const handler = typeof item.action == "function" ? item.action : typeof item.action == "string" ? actionHandlers[item.action] : null;
    if (handler) {
      const paramsWithId = item.id ? {
        ...item.params,
        _menuItemId: item.id,
        isSelected: !item.selected
      } : {
        ...item.params,
        isSelected: !item.selected
      };
      return handler(paramsWithId), true;
    }
    return false;
  }, $[0] = actionHandlers, $[1] = t4) : t4 = $[1];
  const handleAction = t4;
  let t5;
  $[2] !== handleAction || $[3] !== menuItemGroups || $[4] !== menuItems ? (t5 = resolveMenuNodes({
    actionHandler: handleAction,
    menuItemGroups,
    menuItems: menuItems.filter(_temp$d)
  }), $[2] = handleAction, $[3] = menuItemGroups, $[4] = menuItems, $[5] = t5) : t5 = $[5];
  const menuNodes = t5;
  let t6;
  $[6] !== menuNodes ? (t6 = menuNodes.filter(isMenuNodeButton), $[6] = menuNodes, $[7] = t6) : t6 = $[7];
  const actionNodes = t6;
  let t7;
  $[8] !== menuNodes ? (t7 = menuNodes.filter(isNotMenuNodeButton), $[8] = menuNodes, $[9] = t7) : t7 = $[9];
  const contextMenuNodes = t7;
  let t8;
  if ($[10] !== menuItems || $[11] !== templates) {
    let t92;
    $[13] !== templates ? (t92 = (item_1, menuItemIndex) => {
      if (item_1.intent?.type !== "create")
        return null;
      const {
        params
      } = item_1.intent;
      if (!params)
        return null;
      const intentParams = Array.isArray(params) ? params[0] : params, templateParams = Array.isArray(params) ? params[1] : void 0, templateId = intentParams.template || intentParams.type;
      if (!templateId)
        return null;
      const template = templates.find((t14) => t14.id === templateId);
      if (!template)
        return null;
      const initialDocumentId = intentParams.id;
      return {
        item: item_1,
        template,
        templateParams,
        menuItemIndex,
        initialDocumentId
      };
    }, $[13] = templates, $[14] = t92) : t92 = $[14], t8 = menuItems.map(t92).filter(isNonNullable).map(_temp2$6), $[10] = menuItems, $[11] = templates, $[12] = t8;
  } else
    t8 = $[12];
  const initialValueTemplateItemFromMenuItems = t8;
  let t9;
  $[15] !== initialValueTemplateItemFromMenuItems || $[16] !== initialValueTemplateItemsFromStructure ? (t9 = uniqBy_default([...initialValueTemplateItemFromMenuItems, ...initialValueTemplateItemsFromStructure], _temp3$4), $[15] = initialValueTemplateItemFromMenuItems, $[16] = initialValueTemplateItemsFromStructure, $[17] = t9) : t9 = $[17];
  const combinedInitialValueTemplates = t9;
  let t10;
  $[18] !== combinedInitialValueTemplates ? (t10 = (0, import_jsx_runtime2.jsx)(PaneHeaderCreateButton, { templateItems: combinedInitialValueTemplates }), $[18] = combinedInitialValueTemplates, $[19] = t10) : t10 = $[19];
  let t11;
  $[20] !== actionNodes ? (t11 = actionNodes.map(_temp4$4), $[20] = actionNodes, $[21] = t11) : t11 = $[21];
  let t12;
  $[22] !== contextMenuNodes ? (t12 = contextMenuNodes.length > 0 && (0, import_jsx_runtime2.jsx)(PaneContextMenuButton, { nodes: contextMenuNodes }), $[22] = contextMenuNodes, $[23] = t12) : t12 = $[23];
  let t13;
  return $[24] !== t10 || $[25] !== t11 || $[26] !== t12 ? (t13 = (0, import_jsx_runtime2.jsxs)(Flex, { gap: 1, children: [
    t10,
    t11,
    t12
  ] }), $[24] = t10, $[25] = t11, $[26] = t12, $[27] = t13) : t13 = $[27], t13;
});
function _temp$d(item_0) {
  return item_0.intent?.type !== "create";
}
function _temp2$6(t0) {
  const {
    initialDocumentId: initialDocumentId_0,
    item: item_2,
    template: template_0,
    menuItemIndex: menuItemIndex_0,
    templateParams: templateParams_0
  } = t0;
  return {
    id: `menuItem${menuItemIndex_0}`,
    initialDocumentId: initialDocumentId_0,
    templateId: template_0.id,
    type: "initialValueTemplateItem",
    title: item_2.title || template_0.title,
    i18n: item_2.i18n || template_0.i18n,
    icon: item_2.icon,
    description: template_0.description,
    parameters: templateParams_0,
    schemaType: template_0.schemaType
  };
}
function _temp3$4(item_3) {
  return hashObject([item_3.initialDocumentId, item_3.templateId, item_3.parameters]);
}
function _temp4$4(node) {
  return (0, import_jsx_runtime2.jsx)(PaneHeaderActionButton, { node }, node.key);
}
function MissingSchemaType(props) {
  const $ = (0, import_compiler_runtime2.c)(16), {
    t: t2
  } = useTranslation(structureLocaleNamespace), {
    layout,
    value
  } = props;
  let t0;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    Code: "code"
  }, $[0] = t0) : t0 = $[0];
  let t1;
  $[1] !== value._type ? (t1 = {
    documentType: value._type
  }, $[1] = value._type, $[2] = t1) : t1 = $[2];
  let t22;
  $[3] !== t2 || $[4] !== t1 ? (t22 = (0, import_jsx_runtime2.jsx)("em", { children: (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "pane-item.missing-schema-type.title", components: t0, values: t1 }) }), $[3] = t2, $[4] = t1, $[5] = t22) : t22 = $[5];
  let t3;
  $[6] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t3 = {
    Code: "code"
  }, $[6] = t3) : t3 = $[6];
  let t4;
  $[7] !== value._id ? (t4 = {
    documentId: value._id
  }, $[7] = value._id, $[8] = t4) : t4 = $[8];
  let t5;
  $[9] !== t2 || $[10] !== t4 ? (t5 = (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "pane-item.missing-schema-type.subtitle", components: t3, values: t4 }), $[9] = t2, $[10] = t4, $[11] = t5) : t5 = $[11];
  let t6;
  return $[12] !== layout || $[13] !== t22 || $[14] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(SanityDefaultPreview, { title: t22, subtitle: t5, media: _temp$c, layout }), $[12] = layout, $[13] = t22, $[14] = t5, $[15] = t6) : t6 = $[15], t6;
}
function _temp$c() {
  return (0, import_jsx_runtime2.jsx)(WarningOutlineIcon, {});
}
function getIconWithFallback(icon, schemaType, defaultIcon) {
  return icon === false ? false : icon || schemaType && schemaType.icon || defaultIcon || false;
}
function PaneItem(props) {
  const $ = (0, import_compiler_runtime2.c)(43), {
    icon,
    id,
    layout: t0,
    pressed,
    schemaType,
    selected,
    sortOrder,
    title,
    value,
    margin,
    marginBottom,
    marginTop
  } = props, layout = t0 === void 0 ? "default" : t0, schema = useSchema(), documentPreviewStore = useDocumentPreviewStore(), {
    ChildLink: ChildLink2
  } = usePaneRouter(), documentPresence = useDocumentPresence(id), hasSchemaType = !!(schemaType && schemaType.name && schema.get(schemaType.name)), [clicked, setClicked] = (0, import_react2.useState)(false);
  let t1;
  bb0: {
    if (value && isSanityDocument(value)) {
      if (!schemaType || !hasSchemaType) {
        let t24;
        $[0] !== value ? (t24 = (0, import_jsx_runtime2.jsx)(MissingSchemaType, { value }), $[0] = value, $[1] = t24) : t24 = $[1], t1 = t24;
        break bb0;
      }
      let t23;
      $[2] !== icon || $[3] !== schemaType ? (t23 = getIconWithFallback(icon, schemaType, DocumentIcon), $[2] = icon, $[3] = schemaType, $[4] = t23) : t23 = $[4];
      let t33;
      $[5] !== documentPresence || $[6] !== documentPreviewStore || $[7] !== layout || $[8] !== schemaType || $[9] !== sortOrder || $[10] !== t23 || $[11] !== value ? (t33 = (0, import_jsx_runtime2.jsx)(PaneItemPreview, { documentPreviewStore, icon: t23, layout, schemaType, sortOrder, value, presence: documentPresence }), $[5] = documentPresence, $[6] = documentPreviewStore, $[7] = layout, $[8] = schemaType, $[9] = sortOrder, $[10] = t23, $[11] = value, $[12] = t33) : t33 = $[12], t1 = t33;
      break bb0;
    }
    let t22;
    $[13] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t22 = {
      opacity: 0.5
    }, $[13] = t22) : t22 = $[13];
    let t32;
    $[14] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t32 = (0, import_jsx_runtime2.jsx)(Box, { style: t22, children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: (0, import_jsx_runtime2.jsx)(ChevronRightIcon, {}) }) }), $[14] = t32) : t32 = $[14];
    let t42;
    $[15] !== icon || $[16] !== schemaType ? (t42 = getIconWithFallback(icon, schemaType, FolderIcon), $[15] = icon, $[16] = schemaType, $[17] = t42) : t42 = $[17];
    let t52;
    $[18] !== t42 || $[19] !== title ? (t52 = (0, import_jsx_runtime2.jsx)(SanityDefaultPreview, { status: t32, icon: t42, layout: "compact", title }), $[18] = t42, $[19] = title, $[20] = t52) : t52 = $[20], t1 = t52;
  }
  const preview = t1;
  let t2;
  $[21] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t2 = (e2) => {
    if (e2.metaKey) {
      setClicked(false);
      return;
    }
    setClicked(true);
  }, $[21] = t2) : t2 = $[21];
  const handleClick = t2;
  let t3;
  $[22] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t3 = () => setClicked(false), $[22] = t3) : t3 = $[22];
  let t4;
  $[23] !== selected ? (t4 = [selected], $[23] = selected, $[24] = t4) : t4 = $[24], (0, import_react2.useEffect)(t3, t4);
  const [preloading, setPreload] = (0, import_react2.useState)(false), timeoutRef = (0, import_react2.useRef)(null);
  let t5;
  $[25] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t5 = () => {
    timeoutRef.current = setTimeout(() => (0, import_react2.startTransition)(() => setPreload(true)), 400);
  }, $[25] = t5) : t5 = $[25];
  const handleMouseEnter = t5;
  let t6;
  $[26] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t6 = () => {
    timeoutRef.current && clearTimeout(timeoutRef.current), (0, import_react2.startTransition)(() => setPreload(false));
  }, $[26] = t6) : t6 = $[26];
  const handleMouseLeave = t6, t7 = `pane-item-${title}`, t8 = ChildLink2, t9 = selected || clicked;
  let t10;
  $[27] !== id || $[28] !== preloading || $[29] !== schemaType || $[30] !== value ? (t10 = preloading && schemaType?.name && value && isSanityDocument(value) && (0, import_jsx_runtime2.jsx)(PreloadDocumentPane, { documentId: id, documentType: schemaType.name }), $[27] = id, $[28] = preloading, $[29] = schemaType, $[30] = value, $[31] = t10) : t10 = $[31];
  let t11;
  return $[32] !== id || $[33] !== margin || $[34] !== marginBottom || $[35] !== marginTop || $[36] !== pressed || $[37] !== preview || $[38] !== t10 || $[39] !== t7 || $[40] !== t8 || $[41] !== t9 ? (t11 = (0, import_jsx_runtime2.jsxs)(PreviewCard, { "data-testid": t7, __unstable_focusRing: true, as: t8, childId: id, "data-as": "a", margin, marginBottom, marginTop, onClick: handleClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, pressed, radius: 2, selected: t9, sizing: "border", tabIndex: -1, tone: "inherit", children: [
    preview,
    t10
  ] }), $[32] = id, $[33] = margin, $[34] = marginBottom, $[35] = marginTop, $[36] = pressed, $[37] = preview, $[38] = t10, $[39] = t7, $[40] = t8, $[41] = t9, $[42] = t11) : t11 = $[42], t11;
}
function PreloadDocumentPane(props) {
  const $ = (0, import_compiler_runtime2.c)(2), {
    documentId,
    documentType
  } = props;
  let t0;
  return $[0] !== documentId ? (t0 = getPublishedId(documentId), $[0] = documentId, $[1] = t0) : t0 = $[1], useEditState(t0, documentType), null;
}
PreloadDocumentPane.displayName = "PreloadDocumentPane";
var RenderActionCollectionState = (0, import_react2.memo)((props) => {
  const $ = (0, import_compiler_runtime2.c)(4), {
    children,
    group
  } = props, states = (0, import_react2.useContext)(DocumentActionsStateContext);
  if (states === null)
    throw new Error("DocumentActionsStateContext is not set. This should not happen.");
  let t0;
  if ($[0] !== children || $[1] !== group || $[2] !== states) {
    const filteredStates = group ? states.filter((state2) => (state2.group || ["default"]).includes(group)) : states;
    t0 = children({
      states: filteredStates
    }), $[0] = children, $[1] = group, $[2] = states, $[3] = t0;
  } else
    t0 = $[3];
  return t0;
});
RenderActionCollectionState.displayName = "Memo(RenderActionCollectionState)";
var RenderBadgeCollectionState = (0, import_react2.memo)((props) => {
  const $ = (0, import_compiler_runtime2.c)(4), {
    badges,
    children,
    badgeProps
  } = props;
  let t0;
  return $[0] !== badgeProps || $[1] !== badges || $[2] !== children ? (t0 = (0, import_jsx_runtime2.jsx)(GetHookCollectionState, { hooks: badges, args: badgeProps, children }), $[0] = badgeProps, $[1] = badges, $[2] = children, $[3] = t0) : t0 = $[3], t0;
});
RenderBadgeCollectionState.displayName = "Memo(RenderBadgeCollectionState)";
var INITIAL_STATE$1 = {
  documents: [],
  loading: true
};
async function resolveRawFilterCallback(filterResolver, {
  document: document2,
  getClient
}) {
  const resolvedFilter = await filterResolver({
    document: document2,
    getClient
  });
  return typeof resolvedFilter == "string" ? {
    filter: resolvedFilter,
    filterParams: void 0
  } : resolvedFilter;
}
function getIncomingReferences({
  documentId,
  documentPreviewStore,
  type,
  filter: filterQueryRaw,
  filterParams: filterParamsRaw,
  getClient
}) {
  const publishedId = getPublishedId(documentId);
  return (typeof filterQueryRaw == "function" ? documentPreviewStore.unstable_observeDocument(documentId).pipe(distinctUntilChanged((a, b) => a?._rev === b?._rev), switchMap((document2) => resolveRawFilterCallback(filterQueryRaw, {
    document: document2,
    getClient
  })), map((resolvedFilter) => ({
    filter: resolvedFilter.filter,
    filterParams: resolvedFilter.filterParams || filterParamsRaw
  }))) : of({
    filter: filterQueryRaw,
    filterParams: filterParamsRaw
  })).pipe(distinctUntilChanged((a, b) => a.filter === b.filter && JSON.stringify(a.filterParams) === JSON.stringify(b.filterParams)), switchMap(({
    filter: filterQuery,
    filterParams
  }) => documentPreviewStore.unstable_observeDocumentIdSet(`references("${publishedId}") ${type ? `&& _type == "${type}"` : ""} ${filterQuery ? `&& ${filterQuery}` : ""}`, filterParams, {
    insert: "append"
  }).pipe(
    map((state2) => state2.documentIds),
    mergeMapArray((id) => documentPreviewStore.unstable_observeDocument(id).pipe(filter(Boolean), map((doc) => doc))),
    // Remove duplicates due to different versions of the same document.
    map((documents) => {
      const seenPublishedId = [];
      return documents.filter((doc) => {
        const pId = getPublishedId(doc._id);
        return seenPublishedId.includes(pId) ? false : (seenPublishedId.push(pId), true);
      });
    }),
    map((documents) => ({
      documents,
      loading: false
    })),
    startWith(INITIAL_STATE$1)
  )));
}
var INCOMING_REFERENCES_ITEM_HEIGHT = 51;
var INCOMING_REFERENCES_MAX_VISIBLE_ITEMS = 10;
var IncomingReferencesListContainer = at(Box).withConfig({
  displayName: "IncomingReferencesListContainer",
  componentId: "sc-17ysjqh-0"
})`height:${({
  $itemCount
}) => Math.min($itemCount, INCOMING_REFERENCES_MAX_VISIBLE_ITEMS) * INCOMING_REFERENCES_ITEM_HEIGHT}px;`;
function CrossDatasetIncomingReferenceDocumentPreview(t0) {
  const $ = (0, import_compiler_runtime2.c)(26), {
    type,
    document: document2
  } = t0;
  let t1;
  $[0] !== document2.id || $[1] !== document2.type || $[2] !== type ? (t1 = type?.studioUrl?.({
    id: document2.id,
    type: document2.type
  }), $[0] = document2.id, $[1] = document2.type, $[2] = type, $[3] = t1) : t1 = $[3];
  const studioUrl = t1, t2 = document2.id, t3 = studioUrl ? "a" : "div", t4 = studioUrl ? 3 : 0;
  let t5;
  $[4] !== studioUrl ? (t5 = studioUrl ? {
    href: studioUrl,
    target: "_blank",
    rel: "noopener noreferrer",
    as: "a"
  } : {}, $[4] = studioUrl, $[5] = t5) : t5 = $[5];
  const t6 = document2.availability, t7 = !!studioUrl, t8 = !!studioUrl;
  let t9;
  $[6] !== document2.preview || $[7] !== type ? (t9 = type ? {
    type: type.type,
    title: document2.preview.published?.title,
    icon: _temp$b,
    preview: type.preview
  } : void 0, $[6] = document2.preview, $[7] = type, $[8] = t9) : t9 = $[8];
  let t10;
  $[9] !== document2.availability || $[10] !== document2.dataset || $[11] !== document2.id || $[12] !== document2.preview || $[13] !== document2.projectId || $[14] !== t7 || $[15] !== t8 || $[16] !== t9 ? (t10 = (0, import_jsx_runtime2.jsx)(CrossDatasetReferencePreview, { availability: t6, hasStudioUrl: t7, showStudioUrlIcon: t8, preview: document2.preview, refType: t9, projectId: document2.projectId, dataset: document2.dataset, id: document2.id, showTypeLabel: false }), $[9] = document2.availability, $[10] = document2.dataset, $[11] = document2.id, $[12] = document2.preview, $[13] = document2.projectId, $[14] = t7, $[15] = t8, $[16] = t9, $[17] = t10) : t10 = $[17];
  let t11;
  $[18] !== t10 || $[19] !== t3 || $[20] !== t4 || $[21] !== t5 ? (t11 = (0, import_jsx_runtime2.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime2.jsx)(PreviewCard, { "data-as": t3, flex: 1, radius: 2, paddingRight: t4, tone: "inherit", __unstable_focusRing: true, tabIndex: 0, ...t5, children: t10 }) }), $[18] = t10, $[19] = t3, $[20] = t4, $[21] = t5, $[22] = t11) : t11 = $[22];
  let t12;
  return $[23] !== document2.id || $[24] !== t11 ? (t12 = (0, import_jsx_runtime2.jsx)(Flex, { gap: 1, align: "center", children: t11 }, t2), $[23] = document2.id, $[24] = t11, $[25] = t12) : t12 = $[25], t12;
}
function _temp$b() {
  return null;
}
var INITIAL_STATE = {
  documents: [],
  loading: true
};
function getCrossDatasetIncomingReferences({
  documentId,
  type,
  client,
  documentPreviewStore
}) {
  return fetchCrossDatasetReferences(documentId, {
    versionedClient: client
  }).pipe(
    map((result) => result ? type?.dataset ? result.references.filter((ref) => ref.datasetName === type.dataset && ref.documentId) : result.references.filter((ref) => ref.documentId && ref.datasetName) : []),
    // Now that we have all the references from the dataset the user defined, we need to get the document type from the documentId
    mergeMapArray((document2) => documentPreviewStore.observeDocumentTypeFromId(getPublishedId(document2.documentId), {
      dataset: document2.datasetName,
      projectId: document2.projectId
    }).pipe(map((documentType) => ({
      ...document2,
      documentType
    })))),
    mergeMapArray((document2) => {
      if (!document2.documentType) return of(null);
      if (!type)
        return of({
          type: document2.documentType,
          id: document2.documentId,
          preview: {
            published: {
              _id: document2.documentId,
              title: `Document Id: ${document2.documentId}`,
              subtitle: `Dataset: ${document2.datasetName} - Project Id: ${document2.projectId}`,
              media: (0, import_jsx_runtime2.jsx)(DocumentIcon, {})
            }
          },
          availability: {
            available: true,
            reason: "READABLE"
          },
          projectId: document2.projectId,
          dataset: document2.datasetName
        });
      if (document2.documentType !== type.type) return of(null);
      const previewPaths = getPreviewPaths(type.preview) || [];
      return documentPreviewStore.observePaths({
        _id: getPublishedId(document2.documentId)
      }, previewPaths, {
        dataset: document2.datasetName,
        projectId: document2.projectId
      }).pipe(map((result) => {
        const previewValue = prepareForPreview(result, {
          type: type.type,
          title: type.title || "",
          icon: () => (0, import_jsx_runtime2.jsx)(DocumentIcon, {}),
          preview: type.preview
        });
        return {
          type: document2.documentType,
          id: document2.documentId,
          preview: {
            published: {
              ...previewValue,
              media: previewValue.media ?? (0, import_jsx_runtime2.jsx)(DocumentIcon, {})
            }
          },
          availability: {
            available: true,
            reason: "READABLE"
          },
          projectId: document2.projectId,
          dataset: document2.datasetName
        };
      }));
    }),
    map((documents) => ({
      documents: documents.filter(isNonNullable$2),
      loading: false
    })),
    startWith(INITIAL_STATE)
  );
}
var IncomingReferenceDocumentActionsInner = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(20), {
    states,
    document: document2,
    setIsExecutingAction,
    isExecutingAction
  } = t0, [actionIndex, setActionIndex] = (0, import_react2.useState)(-1), [referenceElement, setReferenceElement] = (0, import_react2.useState)(null), currentAction = states[actionIndex];
  if (!states.length)
    return null;
  let t1;
  $[0] !== isExecutingAction ? (t1 = (0, import_jsx_runtime2.jsx)(ContextMenuButton, { loading: isExecutingAction }), $[0] = isExecutingAction, $[1] = t1) : t1 = $[1];
  const t2 = `${document2._id}-menuButton`;
  let t3;
  if ($[2] !== setIsExecutingAction || $[3] !== states) {
    let t42;
    $[5] !== setIsExecutingAction ? (t42 = (action, index) => (0, import_jsx_runtime2.jsx)(MenuItem2, { text: action.label, icon: action.icon, tone: action.tone, disabled: !!action.disabled, onClick: async () => {
      setActionIndex(index), setIsExecutingAction(true), await action.onHandle?.(), setIsExecutingAction(false);
    } }, action.label), $[5] = setIsExecutingAction, $[6] = t42) : t42 = $[6], t3 = states.map(t42), $[2] = setIsExecutingAction, $[3] = states, $[4] = t3;
  } else
    t3 = $[4];
  let t4;
  $[7] !== t3 ? (t4 = (0, import_jsx_runtime2.jsx)(Menu, { children: t3 }), $[7] = t3, $[8] = t4) : t4 = $[8];
  let t5;
  $[9] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t5 = {
    portal: true,
    tone: "default"
  }, $[9] = t5) : t5 = $[9];
  let t6;
  $[10] !== t1 || $[11] !== t2 || $[12] !== t4 ? (t6 = (0, import_jsx_runtime2.jsx)(Box, { ref: setReferenceElement, children: (0, import_jsx_runtime2.jsx)(MenuButton, { button: t1, id: t2, menu: t4, popover: t5 }) }), $[10] = t1, $[11] = t2, $[12] = t4, $[13] = t6) : t6 = $[13];
  let t7;
  $[14] !== currentAction || $[15] !== referenceElement ? (t7 = currentAction && currentAction.dialog && (0, import_jsx_runtime2.jsx)(LegacyLayerProvider, { zOffset: "pane", children: (0, import_jsx_runtime2.jsx)(ActionStateDialog, { dialog: currentAction.dialog, referenceElement }) }), $[14] = currentAction, $[15] = referenceElement, $[16] = t7) : t7 = $[16];
  let t8;
  return $[17] !== t6 || $[18] !== t7 ? (t8 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    t6,
    t7
  ] }), $[17] = t6, $[18] = t7, $[19] = t8) : t8 = $[19], t8;
};
var IncomingReferenceDocumentActions = (props) => {
  const $ = (0, import_compiler_runtime2.c)(11), {
    document: document2,
    actions,
    setIsExecutingAction,
    isExecutingAction
  } = props, {
    getClient
  } = useSource();
  let t0;
  $[0] !== document2 || $[1] !== isExecutingAction || $[2] !== setIsExecutingAction ? (t0 = (t12) => {
    const {
      states
    } = t12;
    return (0, import_jsx_runtime2.jsx)(IncomingReferenceDocumentActionsInner, { states, document: document2, setIsExecutingAction, isExecutingAction }, document2._id);
  }, $[0] = document2, $[1] = isExecutingAction, $[2] = setIsExecutingAction, $[3] = t0) : t0 = $[3];
  const renderActions = t0;
  let t1;
  $[4] !== document2 || $[5] !== getClient ? (t1 = {
    document: document2,
    getClient
  }, $[4] = document2, $[5] = getClient, $[6] = t1) : t1 = $[6];
  let t2;
  return $[7] !== actions || $[8] !== renderActions || $[9] !== t1 ? (t2 = (0, import_jsx_runtime2.jsx)(GetHookCollectionState, { hooks: actions, args: t1, children: renderActions }), $[7] = actions, $[8] = renderActions, $[9] = t1, $[10] = t2) : t2 = $[10], t2;
};
function IncomingReferencePreview(props) {
  const $ = (0, import_compiler_runtime2.c)(17), {
    onClick,
    type,
    value,
    path
  } = props, t0 = value?._id;
  let t1;
  $[0] !== t0 ? (t1 = getPublishedId(t0), $[0] = t0, $[1] = t1) : t1 = $[1];
  const documentPresence = useDocumentPresence(t1), documentPreviewStore = useDocumentPreviewStore(), {
    ChildLink: ChildLink2
  } = usePaneRouter();
  let t2;
  $[2] !== ChildLink2 || $[3] !== path || $[4] !== type.name || $[5] !== value?._id ? (t2 = function(linkProps) {
    return (0, import_jsx_runtime2.jsx)(ChildLink2, { childId: getPublishedId(value?._id), childParameters: {
      type: type.name,
      path: pathToString$1(path)
    }, ...linkProps });
  }, $[2] = ChildLink2, $[3] = path, $[4] = type.name, $[5] = value?._id, $[6] = t2) : t2 = $[6];
  const t3 = t2, t4 = type.icon || false;
  let t5;
  $[7] !== documentPresence || $[8] !== documentPreviewStore || $[9] !== t4 || $[10] !== type || $[11] !== value ? (t5 = (0, import_jsx_runtime2.jsx)(PaneItemPreview, { documentPreviewStore, icon: t4, layout: "default", presence: documentPresence, schemaType: type, value }), $[7] = documentPresence, $[8] = documentPreviewStore, $[9] = t4, $[10] = type, $[11] = value, $[12] = t5) : t5 = $[12];
  let t6;
  return $[13] !== onClick || $[14] !== t3 || $[15] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(PreviewCard, { __unstable_focusRing: true, as: t3, "data-as": "a", onClick, radius: 2, children: t5 }), $[13] = onClick, $[14] = t3, $[15] = t5, $[16] = t6) : t6 = $[16], t6;
}
var Root$1 = motion.create(Flex);
var variants = {
  initial: {
    opacity: 0
  },
  animate: {
    opacity: 1
  },
  actionInProgress: {
    opacity: [0.5, 1, 0.5],
    transition: {
      duration: 1.8,
      repeat: 1 / 0,
      ease: "easeInOut"
    }
  }
};
var ErrorCard = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(2), {
    message
  } = t0;
  let t1;
  return $[0] !== message ? (t1 = (0, import_jsx_runtime2.jsx)(Card, { border: true, radius: 2, padding: 1, tone: "critical", children: (0, import_jsx_runtime2.jsx)(Box, { paddingY: 4, paddingX: 3, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: message }) }) }), $[0] = message, $[1] = t1) : t1 = $[1], t1;
};
var IncomingReferenceDocument$1 = (props) => {
  const $ = (0, import_compiler_runtime2.c)(33), {
    document: document2,
    referenceToId,
    actions
  } = props;
  let t0;
  $[0] !== document2 || $[1] !== referenceToId ? (t0 = getReferencePaths(document2, referenceToId), $[0] = document2, $[1] = referenceToId, $[2] = t0) : t0 = $[2];
  const referencePaths = t0, [isExecutingAction, setIsExecutingAction] = (0, import_react2.useState)(false), id = document2._id, schema = useSchema(), {
    navigate
  } = useRouter(), {
    routerPanesState,
    groupIndex
  } = usePaneRouter(), type = document2?._type, {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[3] !== groupIndex || $[4] !== id || $[5] !== navigate || $[6] !== referencePaths[0] || $[7] !== referencePaths.length || $[8] !== routerPanesState || $[9] !== type ? (t1 = () => {
    if (!referencePaths.length)
      throw new Error("No reference paths found");
    navigate({
      panes: [...routerPanesState.slice(0, groupIndex + 1), [{
        id: getPublishedId(id),
        params: {
          type,
          path: pathToString$1(referencePaths[0])
        }
      }]]
    });
  }, $[3] = groupIndex, $[4] = id, $[5] = navigate, $[6] = referencePaths[0], $[7] = referencePaths.length, $[8] = routerPanesState, $[9] = type, $[10] = t1) : t1 = $[10];
  const handleClick = t1;
  let t22;
  $[11] !== schema || $[12] !== type ? (t22 = schema.get(type), $[11] = schema, $[12] = type, $[13] = t22) : t22 = $[13];
  const schemaType = t22;
  if (!schemaType) {
    let t32;
    $[14] !== t2 || $[15] !== type ? (t32 = t2("incoming-references-input.schema-type-not-found", {
      type
    }), $[14] = t2, $[15] = type, $[16] = t32) : t32 = $[16];
    let t42;
    return $[17] !== t32 ? (t42 = (0, import_jsx_runtime2.jsx)(ErrorCard, { message: t32 }), $[17] = t32, $[18] = t42) : t42 = $[18], t42;
  }
  const t3 = isExecutingAction ? "actionInProgress" : "animate";
  let t4;
  $[19] !== document2 || $[20] !== handleClick || $[21] !== referencePaths[0] || $[22] !== referencePaths.length || $[23] !== schemaType ? (t4 = (0, import_jsx_runtime2.jsx)(Box, { flex: 1, children: referencePaths.length > 0 ? (0, import_jsx_runtime2.jsx)(IncomingReferencePreview, { type: schemaType, value: document2, onClick: handleClick, path: referencePaths[0] }) : (0, import_jsx_runtime2.jsx)(SanityDefaultPreview, { icon: schemaType.icon, layout: "default", isPlaceholder: true }) }), $[19] = document2, $[20] = handleClick, $[21] = referencePaths[0], $[22] = referencePaths.length, $[23] = schemaType, $[24] = t4) : t4 = $[24];
  let t5;
  $[25] !== actions || $[26] !== document2 || $[27] !== isExecutingAction ? (t5 = actions && actions?.length > 0 && (0, import_jsx_runtime2.jsx)(IncomingReferenceDocumentActions, { document: document2, actions, isExecutingAction, setIsExecutingAction }), $[25] = actions, $[26] = document2, $[27] = isExecutingAction, $[28] = t5) : t5 = $[28];
  let t6;
  return $[29] !== t3 || $[30] !== t4 || $[31] !== t5 ? (t6 = (0, import_jsx_runtime2.jsxs)(Root$1, { initial: "initial", animate: t3, gap: 1, align: "center", variants, children: [
    t4,
    t5
  ] }), $[29] = t3, $[30] = t4, $[31] = t5, $[32] = t6) : t6 = $[32], t6;
};
var randomIdCache = /* @__PURE__ */ new WeakMap();
function assignId(obj) {
  const cachedValue = randomIdCache.get(obj);
  if (cachedValue) return cachedValue;
  const id = nanoid();
  return randomIdCache.set(obj, id), id;
}
var PARTIAL_PAGE_LIMIT = 100;
var FULL_LIST_LIMIT = 2e3;
var DEFAULT_ORDERING = {
  by: [{
    field: "_updatedAt",
    direction: "desc"
  }]
};
var EMPTY_RECORD = {};
var RootBox = at(Box).withConfig({
  displayName: "RootBox",
  componentId: "sc-1xocekz-0"
})`position:relative;opacity:${(props) => props.$opacity || 1};transition:opacity 0.4s;`;
var CommandListBox = at(Box).withConfig({
  displayName: "CommandListBox",
  componentId: "sc-1xocekz-1"
})`position:absolute;left:0;right:0;top:0;bottom:0;`;
var SKELETON_ITEMS = [...Array(30).keys()];
function LoadingView(props) {
  const $ = (0, import_compiler_runtime2.c)(4), {
    layout
  } = props;
  let t0;
  $[0] !== layout ? (t0 = SKELETON_ITEMS.map((num) => (0, import_jsx_runtime2.jsx)(SanityDefaultPreview, { isPlaceholder: true, layout }, num)), $[0] = layout, $[1] = t0) : t0 = $[1];
  let t1;
  return $[2] !== t0 ? (t1 = (0, import_jsx_runtime2.jsx)(Stack, { paddingX: 3, paddingY: 2, paddingTop: 0, space: 1, children: t0 }), $[2] = t0, $[3] = t1) : t1 = $[3], t1;
}
function DocumentListPaneContent(props) {
  const $ = (0, import_compiler_runtime2.c)(67), {
    childItemId,
    error,
    isRetrying,
    autoRetry,
    filterIsSimpleTypeConstraint,
    hasMaxItems,
    hasSearchQuery,
    isActive,
    isLazyLoading,
    muted,
    isLoading,
    isConnected,
    retryCount,
    canRetry,
    items,
    layout,
    loadingVariant,
    onEndReached,
    onRetry,
    paneTitle,
    searchInputElement,
    showIcons,
    sortOrder
  } = props, schema = useSchema(), {
    collapsed: layoutCollapsed
  } = usePaneLayout(), {
    collapsed,
    index
  } = usePane(), [shouldRender, setShouldRender] = (0, import_react2.useState)(!collapsed), {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t0;
  $[0] !== onEndReached || $[1] !== shouldRender ? (t0 = () => {
    shouldRender && onEndReached();
  }, $[0] = onEndReached, $[1] = shouldRender, $[2] = t0) : t0 = $[2];
  const handleEndReached = t0;
  let t1;
  $[3] !== collapsed ? (t1 = () => {
    if (collapsed)
      return;
    const timer2 = setTimeout(() => {
      setShouldRender(true);
    }, 0);
    return () => {
      clearTimeout(timer2);
    };
  }, $[3] = collapsed, $[4] = t1) : t1 = $[4];
  let t22;
  $[5] !== collapsed || $[6] !== items ? (t22 = [collapsed, items], $[5] = collapsed, $[6] = items, $[7] = t22) : t22 = $[7], (0, import_react2.useEffect)(t1, t22);
  let t3;
  $[8] !== childItemId || $[9] !== hasMaxItems || $[10] !== isActive || $[11] !== isLazyLoading || $[12] !== items.length || $[13] !== layout || $[14] !== schema || $[15] !== showIcons || $[16] !== sortOrder || $[17] !== t2 ? (t3 = (item, t42) => {
    const {
      activeIndex
    } = t42, publishedId = getPublishedId(item._id), isSelected = childItemId === publishedId, pressed = !isActive && isSelected, selected = isActive && isSelected, isLastItem = activeIndex === items.length - 1, showSpinner = isLastItem && isLazyLoading, showMaxItemsMessage = isLastItem && hasMaxItems;
    return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      (0, import_jsx_runtime2.jsx)(PaneItem, { icon: showIcons ? void 0 : false, id: publishedId, layout, marginBottom: 1, pressed, schemaType: schema.get(item._type), selected, sortOrder, value: item }),
      showSpinner && (0, import_jsx_runtime2.jsx)(LoadingBlock, {}),
      showMaxItemsMessage && (0, import_jsx_runtime2.jsx)(Box, { marginY: 1, paddingX: 3, paddingY: 4, children: (0, import_jsx_runtime2.jsx)(Text, { align: "center", muted: true, size: 1, children: t2("panes.document-list-pane.max-items.text", {
        limit: FULL_LIST_LIMIT
      }) }) })
    ] });
  }, $[8] = childItemId, $[9] = hasMaxItems, $[10] = isActive, $[11] = isLazyLoading, $[12] = items.length, $[13] = layout, $[14] = schema, $[15] = showIcons, $[16] = sortOrder, $[17] = t2, $[18] = t3) : t3 = $[18];
  const renderItem = t3;
  let t4;
  bb0: {
    if (hasSearchQuery) {
      let t53;
      $[19] !== t2 ? (t53 = t2("panes.document-list-pane.no-documents.text"), $[19] = t2, $[20] = t53) : t53 = $[20];
      let t63;
      $[21] !== t53 ? (t63 = (0, import_jsx_runtime2.jsx)(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: (0, import_jsx_runtime2.jsx)(Container, { width: 1, children: (0, import_jsx_runtime2.jsx)(Box, { paddingX: 4, paddingY: 5, children: (0, import_jsx_runtime2.jsx)(Text, { align: "center", muted: true, children: t53 }) }) }) }), $[21] = t53, $[22] = t63) : t63 = $[22], t4 = t63;
      break bb0;
    }
    let t52;
    $[23] !== filterIsSimpleTypeConstraint || $[24] !== t2 ? (t52 = t2(filterIsSimpleTypeConstraint ? "panes.document-list-pane.no-documents-of-type.text" : "panes.document-list-pane.no-matching-documents.text"), $[23] = filterIsSimpleTypeConstraint, $[24] = t2, $[25] = t52) : t52 = $[25];
    let t62;
    $[26] !== t52 ? (t62 = (0, import_jsx_runtime2.jsx)(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: (0, import_jsx_runtime2.jsx)(Container, { width: 1, children: (0, import_jsx_runtime2.jsx)(Box, { paddingX: 4, paddingY: 5, children: (0, import_jsx_runtime2.jsx)(Text, { align: "center", muted: true, children: t52 }) }) }) }), $[26] = t52, $[27] = t62) : t62 = $[27], t4 = t62;
  }
  const noDocumentsContent = t4;
  let t5;
  bb1: {
    if (!shouldRender) {
      t5 = null;
      break bb1;
    }
    const isOnline = window.navigator.onLine;
    if (error) {
      let t63;
      $[28] !== t2 ? (t63 = t2("panes.document-list-pane.error.title"), $[28] = t2, $[29] = t63) : t63 = $[29];
      let t73;
      $[30] !== t63 ? (t73 = (0, import_jsx_runtime2.jsx)(Heading, { as: "h3", children: t63 }), $[30] = t63, $[31] = t73) : t73 = $[31];
      let t82;
      $[32] !== error || $[33] !== t2 ? (t82 = isDev ? (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "panes.document-list-pane.error.text.dev", values: {
        error: error.message
      }, components: {
        Code: _temp$a
      } }) : t2(isOnline ? "panes.document-list-pane.error.text" : "panes.document-list-pane.error.text.offline"), $[32] = error, $[33] = t2, $[34] = t82) : t82 = $[34];
      let t9;
      $[35] !== t82 ? (t9 = (0, import_jsx_runtime2.jsx)(Text, { as: "p", children: t82 }), $[35] = t82, $[36] = t9) : t9 = $[36];
      const t10 = isOnline && canRetry ? onRetry : void 0;
      let t11;
      $[37] !== error || $[38] !== isRetrying || $[39] !== t10 ? (t11 = (0, import_jsx_runtime2.jsx)(ErrorActions, { error, eventId: null, onRetry: t10, isRetrying }), $[37] = error, $[38] = isRetrying, $[39] = t10, $[40] = t11) : t11 = $[40];
      let t12;
      $[41] !== autoRetry || $[42] !== canRetry || $[43] !== isRetrying || $[44] !== retryCount || $[45] !== t2 ? (t12 = canRetry ? (0, import_jsx_runtime2.jsx)(Text, { as: "p", muted: true, size: 1, children: isRetrying ? t2("panes.document-list-pane.error.retrying", {
        count: retryCount
      }) : autoRetry ? t2("panes.document-list-pane.error.will-retry-automatically", {
        count: retryCount
      }) : t2("panes.document-list-pane.error.max-retries-attempted", {
        count: retryCount
      }) }) : null, $[41] = autoRetry, $[42] = canRetry, $[43] = isRetrying, $[44] = retryCount, $[45] = t2, $[46] = t12) : t12 = $[46];
      let t13;
      $[47] !== t11 || $[48] !== t12 || $[49] !== t73 || $[50] !== t9 ? (t13 = (0, import_jsx_runtime2.jsx)(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: (0, import_jsx_runtime2.jsx)(Container, { width: 1, children: (0, import_jsx_runtime2.jsxs)(Stack, { paddingX: 4, paddingY: 5, space: 4, children: [
        t73,
        t9,
        t11,
        t12
      ] }) }) }), $[47] = t11, $[48] = t12, $[49] = t73, $[50] = t9, $[51] = t13) : t13 = $[51], t5 = t13;
      break bb1;
    }
    if (isConnected && !isLoading && items.length === 0) {
      t5 = noDocumentsContent;
      break bb1;
    }
    if (loadingVariant === "initial" && isLoading) {
      let t63;
      $[52] !== layout ? (t63 = (0, import_jsx_runtime2.jsx)(Delay, { ms: 300, children: (0, import_jsx_runtime2.jsx)(LoadingView, { layout }) }), $[52] = layout, $[53] = t63) : t63 = $[53], t5 = t63;
      break bb1;
    }
    if (loadingVariant === "spinner" && isLoading) {
      t5 = null;
      break bb1;
    }
    const key = `${index}-${collapsed}`, t62 = muted ? 0.8 : 1;
    let t72;
    $[54] !== handleEndReached || $[55] !== items || $[56] !== key || $[57] !== paneTitle || $[58] !== renderItem || $[59] !== searchInputElement ? (t72 = (0, import_jsx_runtime2.jsx)(CommandListBox, { children: (0, import_jsx_runtime2.jsx)(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: paneTitle, canReceiveFocus: true, inputElement: searchInputElement, itemHeight: 51, items, onEndReached: handleEndReached, onlyShowSelectionWhenActive: true, overscan: 10, paddingBottom: 1, paddingX: 3, renderItem, wrapAround: false }, key) }), $[54] = handleEndReached, $[55] = items, $[56] = key, $[57] = paneTitle, $[58] = renderItem, $[59] = searchInputElement, $[60] = t72) : t72 = $[60];
    let t8;
    $[61] !== t62 || $[62] !== t72 ? (t8 = (0, import_jsx_runtime2.jsx)(RootBox, { overflow: "hidden", height: "fill", $opacity: t62, children: t72 }), $[61] = t62, $[62] = t72, $[63] = t8) : t8 = $[63], t5 = t8;
  }
  const mainContent = t5, t6 = layoutCollapsed || loadingVariant === "initial" ? "hidden" : "auto";
  let t7;
  return $[64] !== mainContent || $[65] !== t6 ? (t7 = (0, import_jsx_runtime2.jsx)(PaneContent, { "data-testid": "document-list-pane", overflow: t6, children: mainContent }), $[64] = mainContent, $[65] = t6, $[66] = t7) : t7 = $[66], t7;
}
function _temp$a(t0) {
  const {
    children
  } = t0;
  return (0, import_jsx_runtime2.jsx)("code", { children });
}
function removePublishedWithDrafts(documents) {
  return collate(documents).map((entry) => {
    const doc = entry.draft || entry.published || entry.versions[0], hasDraft = !!entry.draft;
    return {
      ...doc,
      hasPublished: !!entry.published,
      hasDraft
    };
  });
}
function applyOrderingFunctions(order, schemaType) {
  const orderBy = order.by.map((by) => {
    if (by.mapWith)
      return by;
    const fieldType = tryResolveSchemaTypeForPath(schemaType, by.field);
    return fieldType ? fieldExtendsType(fieldType, "datetime") ? {
      ...by,
      mapWith: "dateTime"
    } : fieldType.jsonType === "string" ? {
      ...by,
      mapWith: "lower"
    } : by : by;
  });
  return orderBy.every((item, index) => item === order.by[index]) ? order : {
    ...order,
    by: orderBy
  };
}
function tryResolveSchemaTypeForPath(baseType, path) {
  const pathSegments = fromString(path);
  let current = baseType;
  for (const segment of pathSegments) {
    if (!current)
      return;
    if (typeof segment == "string") {
      current = getFieldTypeByName(current, segment);
      continue;
    }
    if (!(isKeySegment(segment) || isIndexSegment(segment)) || current.jsonType !== "array")
      return;
    const [memberType, otherType] = current.of || [];
    if (otherType || !memberType)
      return;
    if (!isReferenceSchemaType(memberType)) {
      current = memberType;
      continue;
    }
    const [refType, otherRefType] = memberType.to || [];
    if (otherRefType || !refType)
      return;
    current = refType;
  }
  return current;
}
function getFieldTypeByName(type, fieldName) {
  if (!("fields" in type))
    return;
  const fieldType = type.fields.find((field) => field.name === fieldName);
  return fieldType ? fieldType.type : void 0;
}
function fieldExtendsType(field, ofType) {
  let current = field.type;
  for (; current; ) {
    if (current.name === ofType || !current.type && current.jsonType === ofType)
      return true;
    current = current.type;
  }
  return false;
}
function findTypes(node) {
  switch (node.type) {
    case "OpCall": {
      const {
        left,
        right
      } = node;
      switch (node.op) {
        // e.g. `a == b`
        case "==":
          return left.type === "AccessAttribute" && left.name === "_type" && !left.base ? right.type !== "Value" || typeof right.value != "string" ? null : /* @__PURE__ */ new Set([right.value]) : right.type === "AccessAttribute" && right.name === "_type" && !right.base ? left.type !== "Value" || typeof left.value != "string" ? null : /* @__PURE__ */ new Set([left.value]) : null;
        // e.g. `a in b`
        case "in": {
          if (left.type !== "AccessAttribute" || left.name !== "_type" || left.base || right.type !== "Array") return null;
          const types = /* @__PURE__ */ new Set();
          for (const element of right.elements) {
            if (element.isSplat || element.value.type !== "Value" || typeof element.value.value != "string") return null;
            types.add(element.value.value);
          }
          return types.size ? types : null;
        }
        default:
          return null;
      }
    }
    // groups can just be unwrapped, the AST preserves the order
    case "Group":
      return findTypes(node.base);
    // e.g. `_type == 'a' || _type == 'b'`
    // with Or nodes, if we can't determine the types for either the left or
    // right hand side then we can't determine the types for any
    // e.g. `_type == 'a' || isActive`
    //  can't determine types because `isActive` could be true on another types
    case "Or": {
      const left = findTypes(node.left);
      if (!left) return null;
      const right = findTypes(node.right);
      return right ? /* @__PURE__ */ new Set([...left, ...right]) : null;
    }
    // e.g. `_type == 'a' && isActive`
    // with And nodes, we can determine the types as long as we can determine
    // the types for one side. We can't determine the types if both are `null`.
    case "And": {
      const left = findTypes(node.left), right = findTypes(node.right);
      return !left && !right ? null : /* @__PURE__ */ new Set([...left || [], ...right || []]);
    }
    default:
      return null;
  }
}
function findStaticTypesInFilter(filter2, params = {}) {
  try {
    const types = findTypes(parse(filter2, {
      params
    }));
    return types ? Array.from(types).sort() : null;
  } catch {
    return null;
  }
}
var swr = createSWR({
  maxSize: 100
});
function listenSearchQuery(options) {
  const {
    client,
    schema,
    sort,
    perspective,
    limit,
    params,
    filter: groqFilter,
    searchQuery,
    staticTypeNames,
    maxFieldDepth,
    searchStrategy
  } = options, sortBy = sort.by, extendedProjection = sort?.extendedProjection, events$ = defer(() => client.listen(`*[${groqFilter}]`, params, {
    events: ["welcome", "mutation", "reconnect"],
    includeAllVersions: true,
    includeResult: false,
    visibility: "query",
    tag: "listen-search-query"
  })).pipe(mergeMap((ev, i) => {
    const isFirst = i === 0;
    return isFirst && ev.type === "reconnect" ? throwError(() => new Error("Failed to establish EventSource connection")) : isFirst && ev.type !== "welcome" ? throwError(() => new Error(`Received unexpected type of first event "${ev.type}"`)) : of(ev);
  }), share()), [welcome$, mutationAndReconnect$] = partition(events$, (ev) => ev.type === "welcome"), swrKey = JSON.stringify({
    fiilter: groqFilter,
    limit,
    params,
    searchQuery,
    perspective,
    sort,
    staticTypeNames
  });
  return merge(welcome$, mutationAndReconnect$.pipe(throttleTime(1e3, asyncScheduler, {
    leading: true,
    trailing: true
  }))).pipe(exhaustMapWithTrailing((event) => (staticTypeNames ? of(staticTypeNames) : client.observable.fetch(`array::unique(*[${groqFilter}][]._type)`, params)).pipe(mergeMap((typeNames) => {
    const types = getSearchableTypes(schema, staticTypeNames || []).filter((type) => typeNames.includes(type.name) ? (getExtendedProjection(type, sort.by, true), true) : false), search = createSearch(types, client, {
      filter: groqFilter,
      params,
      strategy: searchStrategy,
      maxDepth: maxFieldDepth
    }), doFetch = () => search({
      query: searchQuery || "",
      types
    }, {
      __unstable_extendedProjection: extendedProjection,
      comments: [`findability-source: ${searchQuery ? "list-query" : "list"}`],
      limit,
      skipSortByScore: true,
      sort: sortBy,
      perspective
    }).pipe(map((result) => (
      // eslint-disable-next-line max-nested-callbacks
      result.hits.map(({
        hit
      }) => hit)
    )), map((hits) => ({
      type: "result",
      documents: hits
    })));
    return event.type === "mutation" && event.visibility !== "query" ? timer(1200).pipe(mergeMap(doFetch)) : event.type === "reconnect" ? of(event) : doFetch();
  }))), scan((acc, event) => ({
    connected: event.type !== "reconnect",
    documents: event.type === "result" ? event.documents : acc?.documents || []
  }), null), filter((v) => v !== null), swr(swrKey), map(({
    fromCache,
    value
  }) => ({
    fromCache,
    ...value
  })));
}
var INITIAL_QUERY_STATE = {
  error: null,
  isRetrying: false,
  retryCount: 0,
  autoRetry: false,
  canRetry: false,
  isLoading: true,
  isLoadingFullList: false,
  fromCache: false,
  items: []
};
function isRetriableError(error) {
  return error instanceof ChannelError ? false : error instanceof ServerError ? true : error instanceof ClientError ? error.statusCode === 403 : true;
}
function useDocumentList(opts) {
  const $ = (0, import_compiler_runtime2.c)(31), {
    client,
    filter: searchFilter,
    params: paramsProp,
    sortOrder,
    searchQuery,
    perspective
  } = opts, {
    strategy: searchStrategy
  } = useWorkspace().search, schema = useSchema(), maxFieldDepth = useSearchMaxFieldDepth();
  let t0;
  $[0] !== paramsProp || $[1] !== searchFilter ? (t0 = findStaticTypesInFilter(searchFilter, paramsProp), $[0] = paramsProp, $[1] = searchFilter, $[2] = t0) : t0 = $[2];
  const typeNameFromFilter = t0, [t1] = (0, import_react2.useState)(_temp$9), [onRetry$, onRetry] = t1, [t2] = (0, import_react2.useState)(_temp2$5), [onFetchFullList$, onLoadFullList] = t2, t3 = searchQuery || "", t4 = sortOrder || DEFAULT_ORDERING;
  let t5;
  if ($[3] !== client || $[4] !== maxFieldDepth || $[5] !== onFetchFullList$ || $[6] !== onRetry$ || $[7] !== paramsProp || $[8] !== perspective || $[9] !== schema || $[10] !== searchFilter || $[11] !== searchStrategy || $[12] !== t3 || $[13] !== t4 || $[14] !== typeNameFromFilter) {
    const listenSearchQueryArgs = {
      client,
      filter: searchFilter,
      limit: PARTIAL_PAGE_LIMIT,
      params: paramsProp,
      schema,
      perspective,
      searchQuery: t3,
      sort: t4,
      staticTypeNames: typeNameFromFilter,
      maxFieldDepth,
      searchStrategy
    }, partialList$ = listenSearchQuery(listenSearchQueryArgs).pipe(shareReplay({
      refCount: true,
      bufferSize: 1
    })), fullList$ = onFetchFullList$.pipe(withLatestFrom(partialList$), filter(_temp3$3), take(1), mergeMap(() => concat(of({
      type: "loadFullList"
    }), listenSearchQuery({
      ...listenSearchQueryArgs,
      limit: FULL_LIST_LIMIT
    }).pipe(map(_temp4$3)))), share());
    let t62;
    $[16] !== onRetry$ ? (t62 = (lastError, retryCount, caught$) => {
      const error = safeError(lastError), isOnline = window.navigator.onLine, canRetry = isOnline && isRetriableError(lastError), autoRetry = retryCount < 10, retries = merge(isOnline ? onRetry$ : fromEvent(window, "online"), isOnline && autoRetry ? timer(retryCount * 1e3) : NEVER).pipe(take(1), switchMap(() => merge(of({
        type: "error",
        error,
        retrying: true,
        autoRetry,
        canRetry,
        retryCount
      }), caught$)));
      return concat(of({
        type: "error",
        error,
        retrying: false,
        autoRetry,
        canRetry,
        retryCount
      }), retries);
    }, $[16] = onRetry$, $[17] = t62) : t62 = $[17], t5 = merge(partialList$.pipe(map(_temp5$2), takeUntil(fullList$)), fullList$).pipe(catchWithCount(t62), scan(_temp6$2, INITIAL_QUERY_STATE)), $[3] = client, $[4] = maxFieldDepth, $[5] = onFetchFullList$, $[6] = onRetry$, $[7] = paramsProp, $[8] = perspective, $[9] = schema, $[10] = searchFilter, $[11] = searchStrategy, $[12] = t3, $[13] = t4, $[14] = typeNameFromFilter, $[15] = t5;
  } else
    t5 = $[15];
  const queryResults$ = t5, {
    error: error_0,
    items,
    isLoading,
    fromCache,
    connected,
    canRetry: canRetry_0,
    isLoadingFullList,
    isRetrying,
    autoRetry: autoRetry_0,
    retryCount: retryCount_0
  } = useObservable(queryResults$, INITIAL_QUERY_STATE);
  let t6;
  return $[18] !== autoRetry_0 || $[19] !== canRetry_0 || $[20] !== connected || $[21] !== error_0 || $[22] !== fromCache || $[23] !== isLoading || $[24] !== isLoadingFullList || $[25] !== isRetrying || $[26] !== items || $[27] !== onLoadFullList || $[28] !== onRetry || $[29] !== retryCount_0 ? (t6 = {
    error: error_0,
    onRetry,
    isLoading,
    items,
    isRetrying,
    canRetry: canRetry_0,
    retryCount: retryCount_0,
    autoRetry: autoRetry_0,
    connected,
    fromCache,
    onLoadFullList,
    isLoadingFullList
  }, $[18] = autoRetry_0, $[19] = canRetry_0, $[20] = connected, $[21] = error_0, $[22] = fromCache, $[23] = isLoading, $[24] = isLoadingFullList, $[25] = isRetrying, $[26] = items, $[27] = onLoadFullList, $[28] = onRetry, $[29] = retryCount_0, $[30] = t6) : t6 = $[30], t6;
}
function _temp6$2(prev, event) {
  if (event.type === "error")
    return {
      ...prev,
      error: event.error,
      retryCount: event.retryCount,
      isRetrying: event.retrying,
      autoRetry: event.autoRetry,
      canRetry: event.canRetry
    };
  if (event.type === "result")
    return {
      ...prev,
      error: null,
      isRetrying: false,
      fromCache: event.result.fromCache,
      connected: event.result.connected,
      isLoading: false,
      items: removePublishedWithDrafts(event.result.documents),
      isLoadingFullList: false
    };
  if (event.type === "loadFullList")
    return {
      ...prev,
      error: null,
      isLoadingFullList: true
    };
  throw new Error(`Unexpected event type: ${event.type}`);
}
function _temp5$2(result_1) {
  return {
    type: "result",
    result: result_1
  };
}
function _temp4$3(result_0) {
  return {
    type: "result",
    result: result_0
  };
}
function _temp3$3(t0) {
  const [, result] = t0;
  return result?.documents.length === PARTIAL_PAGE_LIMIT;
}
function _temp2$5() {
  return observableCallback();
}
function _temp$9() {
  return observableCallback();
}
var nonErrorThrownWarning = "[WARNING: This was thrown as a non-error. Only Error instances should be thrown]";
function safeError(thrown) {
  return thrown instanceof Error ? thrown : typeof thrown == "object" && thrown !== null ? "message" in thrown && typeof thrown.message == "string" ? new Error(`${thrown.message} ${nonErrorThrownWarning}`) : new Error(`${String(thrown)} ${nonErrorThrownWarning}`) : new Error(`${String(thrown)} ${nonErrorThrownWarning}`);
}
var rotate = lt`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`;
var fadeIn = lt`
  0% {
    opacity: 0;
  }
  50% {
    opacity: 0.1;
  }
  100% {
    opacity: 0.4;
  }
`;
var AnimatedSpinnerIcon = at(SpinnerIcon).withConfig({
  displayName: "AnimatedSpinnerIcon",
  componentId: "sc-1nmsicq-0"
})`animation:${rotate} 500ms linear infinite;`;
var SubtleSpinnerIcon = at(SpinnerIcon).withConfig({
  displayName: "SubtleSpinnerIcon",
  componentId: "sc-1nmsicq-1"
})`animation:${rotate} 1500ms linear infinite;opacity:0.4;`;
var DelayedSubtleSpinnerIcon = at(SpinnerIcon).withConfig({
  displayName: "DelayedSubtleSpinnerIcon",
  componentId: "sc-1nmsicq-2"
})`animation:${rotate} 1500ms linear infinite,${fadeIn} 1000ms linear;opacity:0.4;`;
var DocumentListPane = (0, import_react2.memo)(function(props) {
  const $ = (0, import_compiler_runtime2.c)(70), {
    childItemId,
    isActive,
    pane: pane2,
    paneKey,
    sortOrder: sortOrderRaw,
    layout
  } = props, schema = useSchema(), releases = useActiveReleases(), {
    perspectiveStack
  } = usePerspective(), {
    displayOptions,
    options
  } = pane2, {
    apiVersion,
    filter: filter2
  } = options, params = useShallowUnique(options.params || EMPTY_RECORD);
  let t0;
  bb0: {
    let t110;
    $[0] !== filter2 || $[1] !== params ? (t110 = findStaticTypesInFilter(filter2, params), $[0] = filter2, $[1] = params, $[2] = t110) : t110 = $[2];
    const staticTypes = t110;
    if (staticTypes?.length === 1) {
      t0 = staticTypes[0];
      break bb0;
    }
    t0 = null;
  }
  const typeName = t0, showIcons = displayOptions?.showIcons !== false, {
    t: t2
  } = useTranslation(structureLocaleNamespace), {
    title
  } = useI18nText(pane2), [searchQuery, setSearchQuery] = (0, import_react2.useState)(""), [searchInputValue, setSearchInputValue] = (0, import_react2.useState)(""), [searchInputElement, setSearchInputElement] = (0, import_react2.useState)(null);
  let t1;
  $[3] !== schema || $[4] !== sortOrderRaw || $[5] !== typeName ? (t1 = typeName && sortOrderRaw ? applyOrderingFunctions(sortOrderRaw, schema.get(typeName)) : sortOrderRaw, $[3] = schema, $[4] = sortOrderRaw, $[5] = typeName, $[6] = t1) : t1 = $[6];
  const sortOrder = useUnique(t1), t22 = apiVersion || DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion;
  let t3;
  $[7] !== t22 ? (t3 = {
    ...DEFAULT_STUDIO_CLIENT_OPTIONS,
    apiVersion: t22
  }, $[7] = t22, $[8] = t3) : t3 = $[8];
  const client = useClient(t3);
  let t4;
  $[9] !== searchQuery ? (t4 = searchQuery?.trim(), $[9] = searchQuery, $[10] = t4) : t4 = $[10];
  let t5;
  $[11] !== client || $[12] !== filter2 || $[13] !== params || $[14] !== perspectiveStack || $[15] !== sortOrder || $[16] !== t4 ? (t5 = {
    client,
    filter: filter2,
    perspective: perspectiveStack,
    params,
    searchQuery: t4,
    sortOrder
  }, $[11] = client, $[12] = filter2, $[13] = params, $[14] = perspectiveStack, $[15] = sortOrder, $[16] = t4, $[17] = t5) : t5 = $[17];
  const {
    error,
    isLoadingFullList,
    isLoading: documentListIsLoading,
    items,
    fromCache,
    isRetrying,
    autoRetry,
    canRetry,
    retryCount,
    connected,
    onLoadFullList,
    onRetry
  } = useDocumentList(t5), isLoading = documentListIsLoading || releases.loading;
  let t6;
  $[18] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t6 = (event$) => event$.pipe(map(_temp$8), tap(setSearchInputValue), debounce(_temp2$4), tap(setSearchQuery)), $[18] = t6) : t6 = $[18];
  const handleQueryChange = useObservableEvent(t6);
  let t7;
  $[19] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t7 = () => {
    setSearchQuery(""), setSearchInputValue("");
  }, $[19] = t7) : t7 = $[19];
  const handleClearSearch = t7;
  let t8;
  $[20] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t8 = (event_0) => {
    event_0.key === "Escape" && handleClearSearch();
  }, $[20] = t8) : t8 = $[20];
  const handleSearchKeyDown = t8, [enableSearchSpinner, setEnableSearchSpinner] = (0, import_react2.useState)();
  let t10, t9;
  $[21] !== enableSearchSpinner || $[22] !== isLoading || $[23] !== paneKey ? (t9 = () => {
    !enableSearchSpinner && !isLoading && setEnableSearchSpinner(paneKey);
  }, t10 = [enableSearchSpinner, isLoading, paneKey], $[21] = enableSearchSpinner, $[22] = isLoading, $[23] = paneKey, $[24] = t10, $[25] = t9) : (t10 = $[24], t9 = $[25]), (0, import_react2.useEffect)(t9, t10);
  let t11;
  $[26] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t11 = () => {
    handleClearSearch(), setEnableSearchSpinner();
  }, $[26] = t11) : t11 = $[26];
  let t12;
  $[27] !== paneKey ? (t12 = [paneKey, handleClearSearch], $[27] = paneKey, $[28] = t12) : t12 = $[28], (0, import_react2.useEffect)(t11, t12);
  let t13;
  bb1: {
    if (connected && isLoading && enableSearchSpinner === paneKey) {
      t13 = "spinner";
      break bb1;
    }
    if (connected && fromCache) {
      t13 = "subtle";
      break bb1;
    }
    t13 = "initial";
  }
  const loadingVariant = t13;
  let t14;
  bb2: {
    if (loadingVariant === "spinner") {
      t14 = AnimatedSpinnerIcon;
      break bb2;
    }
    if (searchInputValue && loadingVariant === "subtle") {
      t14 = SubtleSpinnerIcon;
      break bb2;
    }
    t14 = SearchIcon;
  }
  const textInputIcon = t14;
  useReconnectingToast(!connected);
  let t15;
  $[29] !== t2 ? (t15 = t2("panes.document-list-pane.search-input.aria-label"), $[29] = t2, $[30] = t15) : t15 = $[30];
  const t16 = !!searchQuery;
  let t17;
  $[31] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t17 = [2, 2, 1], $[31] = t17) : t17 = $[31];
  const t18 = !connected || loadingVariant === "subtle" && !searchInputValue ? DelayedSubtleSpinnerIcon : null;
  let t19;
  $[32] !== t2 ? (t19 = t2("panes.document-list-pane.search-input.placeholder"), $[32] = t2, $[33] = t19) : t19 = $[33];
  let t20;
  $[34] !== handleQueryChange || $[35] !== searchInputValue || $[36] !== t15 || $[37] !== t16 || $[38] !== t18 || $[39] !== t19 || $[40] !== textInputIcon ? (t20 = (0, import_jsx_runtime2.jsx)(Box, { paddingX: 3, paddingBottom: 3, children: (0, import_jsx_runtime2.jsx)(TextInput, { "aria-label": t15, autoComplete: "off", border: false, clearButton: t16, fontSize: t17, icon: textInputIcon, iconRight: t18, onChange: handleQueryChange, onClear: handleClearSearch, onKeyDown: handleSearchKeyDown, padding: 2, placeholder: t19, radius: 2, ref: setSearchInputElement, spellCheck: false, value: searchInputValue }) }), $[34] = handleQueryChange, $[35] = searchInputValue, $[36] = t15, $[37] = t16, $[38] = t18, $[39] = t19, $[40] = textInputIcon, $[41] = t20) : t20 = $[41];
  const t21 = !!typeName, t222 = items.length === FULL_LIST_LIMIT, t23 = !!searchQuery, t24 = loadingVariant === "subtle";
  let t25;
  $[42] !== autoRetry || $[43] !== canRetry || $[44] !== childItemId || $[45] !== connected || $[46] !== error || $[47] !== isActive || $[48] !== isLoading || $[49] !== isLoadingFullList || $[50] !== isRetrying || $[51] !== items || $[52] !== layout || $[53] !== loadingVariant || $[54] !== onLoadFullList || $[55] !== onRetry || $[56] !== paneKey || $[57] !== retryCount || $[58] !== searchInputElement || $[59] !== showIcons || $[60] !== sortOrder || $[61] !== t21 || $[62] !== t222 || $[63] !== t23 || $[64] !== t24 || $[65] !== title ? (t25 = (0, import_jsx_runtime2.jsx)(DocumentListPaneContent, { childItemId, error, filterIsSimpleTypeConstraint: t21, hasMaxItems: t222, hasSearchQuery: t23, isActive, isLazyLoading: isLoadingFullList, isLoading, autoRetry, canRetry, retryCount, isRetrying, isConnected: connected, items, layout, muted: t24, loadingVariant, onEndReached: onLoadFullList, onRetry, paneTitle: title, searchInputElement, showIcons, sortOrder }, paneKey), $[42] = autoRetry, $[43] = canRetry, $[44] = childItemId, $[45] = connected, $[46] = error, $[47] = isActive, $[48] = isLoading, $[49] = isLoadingFullList, $[50] = isRetrying, $[51] = items, $[52] = layout, $[53] = loadingVariant, $[54] = onLoadFullList, $[55] = onRetry, $[56] = paneKey, $[57] = retryCount, $[58] = searchInputElement, $[59] = showIcons, $[60] = sortOrder, $[61] = t21, $[62] = t222, $[63] = t23, $[64] = t24, $[65] = title, $[66] = t25) : t25 = $[66];
  let t26;
  return $[67] !== t20 || $[68] !== t25 ? (t26 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    t20,
    t25
  ] }), $[67] = t20, $[68] = t25, $[69] = t26) : t26 = $[69], t26;
});
function _temp$8(event) {
  return event.target.value;
}
function _temp2$4(value) {
  return value === "" ? of("") : timer(300);
}
var PaneHeader = (0, import_react2.memo)((t0) => {
  const $ = (0, import_compiler_runtime2.c)(33), {
    contentAfter,
    customMenuItemState: t1,
    index,
    initialValueTemplates: t2,
    menuItemGroups: t3,
    menuItems: t4,
    setLayout,
    setSortOrder,
    setCustomMenuItemState,
    title
  } = t0;
  let t5;
  $[0] !== t1 ? (t5 = t1 === void 0 ? {} : t1, $[0] = t1, $[1] = t5) : t5 = $[1];
  const customMenuItemState = t5;
  let t6;
  $[2] !== t2 ? (t6 = t2 === void 0 ? [] : t2, $[2] = t2, $[3] = t6) : t6 = $[3];
  const initialValueTemplates = t6;
  let t7;
  $[4] !== t3 ? (t7 = t3 === void 0 ? [] : t3, $[4] = t3, $[5] = t7) : t7 = $[5];
  const menuItemGroups = t7;
  let t8;
  $[6] !== t4 ? (t8 = t4 === void 0 ? [] : t4, $[6] = t4, $[7] = t8) : t8 = $[7];
  const menuItems = t8, {
    features
  } = useStructureTool(), {
    collapsed,
    isLast
  } = usePane(), tabIndex = isLast && !collapsed ? -1 : 0;
  let t9;
  $[8] !== setLayout ? (t9 = (t102) => {
    const {
      layout: value
    } = t102;
    setLayout(value);
  }, $[8] = setLayout, $[9] = t9) : t9 = $[9];
  let t10;
  $[10] !== setSortOrder ? (t10 = (sort) => {
    setSortOrder(sort);
  }, $[10] = setSortOrder, $[11] = t10) : t10 = $[11];
  let t11;
  $[12] !== customMenuItemState || $[13] !== setCustomMenuItemState ? (t11 = (params) => {
    const id = params._menuItemId, value_0 = params.value ?? true;
    if (customMenuItemState[id] === value_0) {
      const newState = Object.fromEntries(Object.entries(customMenuItemState).filter((t122) => {
        const [key] = t122;
        return key !== id;
      }));
      setCustomMenuItemState(newState);
    } else
      setCustomMenuItemState({
        ...customMenuItemState,
        [id]: value_0
      });
  }, $[12] = customMenuItemState, $[13] = setCustomMenuItemState, $[14] = t11) : t11 = $[14];
  let t12;
  $[15] !== t10 || $[16] !== t11 || $[17] !== t9 ? (t12 = {
    setLayout: t9,
    setSortOrder: t10,
    setMenuItemState: t11
  }, $[15] = t10, $[16] = t11, $[17] = t9, $[18] = t12) : t12 = $[18];
  const actionHandlers = t12;
  let t13;
  $[19] !== actionHandlers || $[20] !== initialValueTemplates || $[21] !== menuItemGroups || $[22] !== menuItems ? (t13 = (0, import_jsx_runtime2.jsx)(PaneHeaderActions, { initialValueTemplateItems: initialValueTemplates, actionHandlers, menuItemGroups, menuItems }), $[19] = actionHandlers, $[20] = initialValueTemplates, $[21] = menuItemGroups, $[22] = menuItems, $[23] = t13) : t13 = $[23];
  let t14;
  $[24] !== features.backButton || $[25] !== index ? (t14 = features.backButton && index > 0 && (0, import_jsx_runtime2.jsx)(Button2, { as: BackLink, "data-as": "a", icon: ArrowLeftIcon, mode: "bleed", tooltipProps: {
    content: "Back"
  } }), $[24] = features.backButton, $[25] = index, $[26] = t14) : t14 = $[26];
  let t15;
  return $[27] !== contentAfter || $[28] !== t13 || $[29] !== t14 || $[30] !== tabIndex || $[31] !== title ? (t15 = (0, import_jsx_runtime2.jsx)(TooltipDelayGroupProvider, { children: (0, import_jsx_runtime2.jsx)(PaneHeader$1, { actions: t13, backButton: t14, contentAfter, tabIndex, title }) }), $[27] = contentAfter, $[28] = t13, $[29] = t14, $[30] = tabIndex, $[31] = title, $[32] = t15) : t15 = $[32], t15;
});
PaneHeader.displayName = "Memo(PaneHeader)";
function DocumentSheetListSelect(props) {
  const {
    row,
    table
  } = props, {
    selectedAnchor,
    setSelectedAnchor
  } = table.options.meta || {}, handleOnClick = (0, import_react2.useCallback)((e2) => {
    if (e2.shiftKey && selectedAnchor !== null && selectedAnchor !== void 0) {
      const shiftClickIndex = row.index, lowerIndex = shiftClickIndex < selectedAnchor ? shiftClickIndex : selectedAnchor, upperIndex = shiftClickIndex < selectedAnchor ? selectedAnchor : shiftClickIndex, additionalSelectedRows = table.getRowModel().flatRows.slice(lowerIndex, upperIndex + 1).map(({
        id
      }) => id), currentSelectedRows = table.getSelectedRowModel().rows.map(({
        id: id_0
      }) => id_0);
      table.setRowSelection(() => [...additionalSelectedRows, ...currentSelectedRows].reduce((nextSelectedRows, rowId) => ({
        ...nextSelectedRows,
        [rowId]: true
      }), {}));
    } else if (setSelectedAnchor) {
      const isRowCurrentlySelected = row.getIsSelected();
      setSelectedAnchor(isRowCurrentlySelected ? null : row.index), row.toggleSelected();
    }
  }, [selectedAnchor, row, setSelectedAnchor, table]);
  return (0, import_jsx_runtime2.jsx)(
    Checkbox,
    {
      style: {
        paddingLeft: 4
      },
      checked: props.row.getIsSelected(),
      disabled: !props.row.getCanSelect(),
      onChange: () => null,
      onClick: handleOnClick
    }
  );
}
var useDocumentSheetListContext = () => {
  const context = (0, import_react2.useContext)(DocumentSheetListContext);
  if (context === void 0)
    throw new Error("useDocumentSheetListContext must be used within an DocumentSheetListProvider");
  return context;
};
function DocumentSheetListProvider(t0) {
  const $ = (0, import_compiler_runtime2.c)(49), {
    children,
    table
  } = t0, [selectedAnchorCellDetails, setSelectedAnchorCellDetails] = (0, import_react2.useState)(null);
  let t1;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = [], $[0] = t1) : t1 = $[0];
  const [selectedRangeCellIndexes, setSelectedRangeCellIndexes] = (0, import_react2.useState)(t1);
  let t2;
  $[1] !== selectedAnchorCellDetails?.state ? (t2 = (t32) => {
    const nextAnchorDetails = t32 === void 0 ? null : t32;
    selectedAnchorCellDetails?.state === "focused" && document.activeElement instanceof HTMLElement && document.activeElement.blur(), setSelectedAnchorCellDetails(nextAnchorDetails), setSelectedRangeCellIndexes([]);
  }, $[1] = selectedAnchorCellDetails?.state, $[2] = t2) : t2 = $[2];
  const clearAndSetFocusSelection = t2;
  let t3;
  $[3] !== clearAndSetFocusSelection ? (t3 = () => clearAndSetFocusSelection(), $[3] = clearAndSetFocusSelection, $[4] = t3) : t3 = $[4];
  const resetFocusSelection = t3;
  let t4;
  $[5] !== clearAndSetFocusSelection || $[6] !== selectedAnchorCellDetails || $[7] !== table ? (t4 = (direction) => {
    if (!selectedAnchorCellDetails)
      return;
    const visibleColumns = table.getVisibleLeafColumns(), columnIndexAfterMove = visibleColumns.findIndex((col) => col.id === selectedAnchorCellDetails.colId) + (direction === "left" ? -1 : 1);
    columnIndexAfterMove < 0 || columnIndexAfterMove >= visibleColumns.length || clearAndSetFocusSelection({
      colId: visibleColumns[columnIndexAfterMove].id,
      rowIndex: selectedAnchorCellDetails.rowIndex,
      state: "selected"
    });
  }, $[5] = clearAndSetFocusSelection, $[6] = selectedAnchorCellDetails, $[7] = table, $[8] = t4) : t4 = $[8];
  const changeSelectionColumn = t4;
  let t5;
  $[9] !== selectedAnchorCellDetails ? (t5 = (direction_0) => {
    selectedAnchorCellDetails && setSelectedRangeCellIndexes((previousSelection) => {
      const {
        rowIndex: anchorIndex
      } = selectedAnchorCellDetails, getNextIndex = (startingIndex) => startingIndex + (direction_0 === "down" ? 1 : -1);
      if (!previousSelection.length) {
        const firstSelectedIndex = getNextIndex(anchorIndex);
        return firstSelectedIndex < 0 ? [] : [firstSelectedIndex];
      }
      const lastIndexSelected = previousSelection[previousSelection.length - 1], nextIndex = getNextIndex(lastIndexSelected);
      return nextIndex < 0 ? previousSelection : nextIndex === anchorIndex ? [] : previousSelection.includes(nextIndex) ? previousSelection.slice(0, -1) : [...previousSelection, nextIndex];
    });
  }, $[9] = selectedAnchorCellDetails, $[10] = t5) : t5 = $[10];
  const changeSelectionRange = t5;
  let t6;
  $[11] !== clearAndSetFocusSelection ? (t6 = (colId, rowIndex) => {
    clearAndSetFocusSelection({
      colId,
      rowIndex,
      state: "selected"
    });
  }, $[11] = clearAndSetFocusSelection, $[12] = t6) : t6 = $[12];
  const setSelectedAnchorCell = t6;
  let t7;
  $[13] !== clearAndSetFocusSelection || $[14] !== selectedAnchorCellDetails || $[15] !== selectedRangeCellIndexes.length ? (t7 = () => {
    if (selectedAnchorCellDetails)
      if (selectedRangeCellIndexes.length)
        setSelectedRangeCellIndexes([]);
      else {
        const nextAnchorCellDetails = selectedAnchorCellDetails.state === "selected" ? null : {
          ...selectedAnchorCellDetails,
          state: "selected"
        };
        clearAndSetFocusSelection(nextAnchorCellDetails);
      }
  }, $[13] = clearAndSetFocusSelection, $[14] = selectedAnchorCellDetails, $[15] = selectedRangeCellIndexes.length, $[16] = t7) : t7 = $[16];
  const handleEscapePress = t7;
  let t8;
  $[17] !== changeSelectionRange || $[18] !== selectedAnchorCellDetails || $[19] !== setSelectedAnchorCell ? (t8 = (isShiftKey, key) => {
    if (!selectedAnchorCellDetails)
      return;
    const direction_1 = key === "ArrowDown" ? "down" : "up", offset = direction_1 === "down" ? 1 : -1;
    if (isShiftKey)
      changeSelectionRange(direction_1);
    else {
      const newSelectedCellRowIndex = selectedAnchorCellDetails.rowIndex + offset;
      if (newSelectedCellRowIndex < 0)
        return;
      setSelectedAnchorCell(selectedAnchorCellDetails.colId, newSelectedCellRowIndex);
    }
  }, $[17] = changeSelectionRange, $[18] = selectedAnchorCellDetails, $[19] = setSelectedAnchorCell, $[20] = t8) : t8 = $[20];
  const handleUpDownKey = t8;
  let t9;
  $[21] !== changeSelectionColumn || $[22] !== handleEscapePress || $[23] !== handleUpDownKey || $[24] !== selectedAnchorCellDetails ? (t9 = (event) => {
    if (!selectedAnchorCellDetails)
      return;
    const {
      key: key_0,
      shiftKey
    } = event;
    bb96: switch (key_0) {
      case "Shift":
        break bb96;
      case "Escape": {
        handleEscapePress();
        break bb96;
      }
      case "ArrowDown":
      case "ArrowUp": {
        event.preventDefault(), handleUpDownKey(shiftKey, key_0);
        break bb96;
      }
      case "ArrowLeft":
      case "ArrowRight": {
        selectedAnchorCellDetails.state === "selected" && (event.preventDefault(), changeSelectionColumn(key_0 === "ArrowLeft" ? "left" : "right"));
        break bb96;
      }
    }
  }, $[21] = changeSelectionColumn, $[22] = handleEscapePress, $[23] = handleUpDownKey, $[24] = selectedAnchorCellDetails, $[25] = t9) : t9 = $[25];
  const handleAnchorKeydown = t9;
  let t10;
  $[26] !== resetFocusSelection || $[27] !== selectedAnchorCellDetails ? (t10 = (event_0) => {
    selectedAnchorCellDetails && (document.getElementById(`cell-${selectedAnchorCellDetails.colId}-${selectedAnchorCellDetails.rowIndex}`)?.contains(event_0.target) || resetFocusSelection());
  }, $[26] = resetFocusSelection, $[27] = selectedAnchorCellDetails, $[28] = t10) : t10 = $[28];
  const handleAnchorClick = t10;
  let t11, t12;
  $[29] !== handleAnchorClick || $[30] !== handleAnchorKeydown || $[31] !== selectedAnchorCellDetails ? (t11 = () => (selectedAnchorCellDetails && (document.addEventListener("keydown", handleAnchorKeydown), document.addEventListener("click", handleAnchorClick)), () => {
    selectedAnchorCellDetails && (document.removeEventListener("keydown", handleAnchorKeydown), document.removeEventListener("click", handleAnchorClick));
  }), t12 = [handleAnchorClick, handleAnchorKeydown, selectedAnchorCellDetails], $[29] = handleAnchorClick, $[30] = handleAnchorKeydown, $[31] = selectedAnchorCellDetails, $[32] = t11, $[33] = t12) : (t11 = $[32], t12 = $[33]), (0, import_react2.useEffect)(t11, t12);
  let t13;
  $[34] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t13 = () => setSelectedAnchorCellDetails(_temp$7), $[34] = t13) : t13 = $[34];
  const focusAnchorCell = t13;
  let t14;
  $[35] !== selectedAnchorCellDetails || $[36] !== selectedRangeCellIndexes ? (t14 = (colId_0, rowIndex_0) => selectedAnchorCellDetails?.colId !== colId_0 ? null : selectedAnchorCellDetails.rowIndex === rowIndex_0 ? selectedAnchorCellDetails.state === "focused" ? "focused" : "selectedAnchor" : selectedRangeCellIndexes.includes(rowIndex_0) ? "selectedRange" : null, $[35] = selectedAnchorCellDetails, $[36] = selectedRangeCellIndexes, $[37] = t14) : t14 = $[37];
  const getStateByCellId = t14;
  let t15;
  $[38] !== clearAndSetFocusSelection || $[39] !== selectedAnchorCellDetails ? (t15 = () => {
    selectedAnchorCellDetails && clearAndSetFocusSelection({
      colId: selectedAnchorCellDetails.colId,
      rowIndex: selectedAnchorCellDetails.rowIndex + 1,
      state: "selected"
    });
  }, $[38] = clearAndSetFocusSelection, $[39] = selectedAnchorCellDetails, $[40] = t15) : t15 = $[40];
  const submitFocusedCell = t15;
  let t16;
  $[41] !== getStateByCellId || $[42] !== resetFocusSelection || $[43] !== setSelectedAnchorCell || $[44] !== submitFocusedCell ? (t16 = {
    focusAnchorCell,
    resetFocusSelection,
    setSelectedAnchorCell,
    getStateByCellId,
    submitFocusedCell
  }, $[41] = getStateByCellId, $[42] = resetFocusSelection, $[43] = setSelectedAnchorCell, $[44] = submitFocusedCell, $[45] = t16) : t16 = $[45];
  const value = t16;
  let t17;
  return $[46] !== children || $[47] !== value ? (t17 = (0, import_jsx_runtime2.jsx)(DocumentSheetListContext.Provider, { value, children }), $[46] = children, $[47] = value, $[48] = t17) : t17 = $[48], t17;
}
function _temp$7(anchorCellDetails) {
  return anchorCellDetails ? {
    ...anchorCellDetails,
    state: "focused"
  } : null;
}
var DataCell = at.td.withConfig({
  displayName: "DataCell",
  componentId: "sc-1b0ndkq-0"
})`display:flex;overflow:hidden;box-sizing:border-box;width:${({
  width
}) => width}px;border-top:1px solid var(--card-border-color);background-color:var(--card-bg-color);`;
var PinnedDataCell = at(DataCell).withConfig({
  displayName: "PinnedDataCell",
  componentId: "sc-1b0ndkq-1"
})`position:sticky;z-index:2;`;
function SheetListCellInner(props) {
  const {
    getValue,
    column,
    row,
    fieldType
  } = props, cellId = `cell-${column.id}-${row.index}`, [renderValue, setRenderValue] = (0, import_react2.useState)(() => getValue()), [isDirty, setIsDirty] = (0, import_react2.useState)(false), inputRef = (0, import_react2.useRef)(null), {
    focusAnchorCell,
    resetFocusSelection,
    setSelectedAnchorCell,
    getStateByCellId,
    submitFocusedCell
  } = useDocumentSheetListContext(), cellState = getStateByCellId(column.id, row.index), handleOnFocus = (0, import_react2.useCallback)(() => {
    setSelectedAnchorCell(column.id, row.index), focusAnchorCell();
  }, [column.id, focusAnchorCell, row.index, setSelectedAnchorCell]), {
    patchDocument
  } = props.table.options.meta || {}, handleProgrammaticFocus = () => {
    inputRef.current?.focus(), inputRef.current instanceof HTMLInputElement && inputRef.current.select();
  }, handleOnMouseDown = (event) => {
    event.detail === 2 ? handleProgrammaticFocus() : (event.preventDefault(), setSelectedAnchorCell(column.id, row.index));
  }, handleOnEnterDown = (0, import_react2.useCallback)((event_0) => {
    const {
      key
    } = event_0;
    key === "Enter" && (cellState === "selectedAnchor" && handleProgrammaticFocus(), cellState === "focused" && submitFocusedCell());
  }, [cellState, submitFocusedCell]), handleOnChange = (event_1) => {
    setIsDirty(true), setRenderValue(event_1.target.value);
  }, handleOnBlur = () => {
    isDirty && (patchDocument?.(row.id, column.id, renderValue), setIsDirty(false)), resetFocusSelection();
  }, handlePaste = (0, import_react2.useCallback)((event_2) => {
    const clipboardData = event_2.clipboardData?.getData("Text");
    (typeof clipboardData == "string" || typeof clipboardData == "number") && (setRenderValue(clipboardData), patchDocument?.(row.id, column.id, clipboardData));
  }, [column.id, patchDocument, row.id]), handleCopy = (0, import_react2.useCallback)(() => navigator.clipboard.writeText(renderValue.toString()), [renderValue]);
  (0, import_react2.useEffect)(() => ((cellState === "selectedAnchor" || cellState === "focused") && document.addEventListener("keydown", handleOnEnterDown), (cellState === "selectedAnchor" || cellState === "selectedRange") && document.addEventListener("paste", handlePaste), cellState === "selectedAnchor" && document.addEventListener("copy", handleCopy), () => {
    (cellState === "selectedAnchor" || cellState === "focused") && document.removeEventListener("keydown", handleOnEnterDown), (cellState === "selectedAnchor" || cellState === "selectedRange") && document.removeEventListener("paste", handlePaste), cellState === "selectedAnchor" && document.removeEventListener("copy", handleCopy);
  }), [cellId, cellState, column.id, getStateByCellId, handleCopy, handleOnEnterDown, handlePaste, row.index]);
  const getBorderStyle = () => cellState === "focused" ? "2px solid blue" : cellState === "selectedRange" ? "1px solid green" : cellState === "selectedAnchor" ? "1px solid blue" : "1px solid transparent", inputProps = {
    onFocus: handleOnFocus,
    onBlur: handleOnBlur,
    onMouseDown: handleOnMouseDown,
    "aria-selected": !!cellState,
    "data-testid": cellId,
    id: cellId,
    ref: (ref) => {
      inputRef.current = ref;
    }
  };
  return fieldType.name === "boolean" ? (0, import_jsx_runtime2.jsxs)(Select, { ...inputProps, onChange: () => null, radius: 0, style: {
    boxShadow: "none",
    border: getBorderStyle(),
    padding: 0
  }, value: JSON.stringify(renderValue), children: [
    (0, import_jsx_runtime2.jsx)("option", { value: "True", children: "True" }),
    (0, import_jsx_runtime2.jsx)("option", { value: "False", children: "False" })
  ] }) : (0, import_jsx_runtime2.jsx)(TextInput, { ...inputProps, size: 0, radius: 0, border: false, style: {
    border: getBorderStyle(),
    padding: "22px 16px"
  }, value: typeof renderValue == "string" || typeof renderValue == "number" ? renderValue : JSON.stringify(renderValue), onChange: handleOnChange });
}
function SheetListCell(cell) {
  const isPinned = cell.column.getIsPinned(), Cell = isPinned ? PinnedDataCell : DataCell, borderWidth = isPinned && cell.column.getIsLastColumn("left") ? 2 : 1;
  return (0, import_jsx_runtime2.jsx)(Cell, { style: {
    left: cell.column.getStart("left") ?? void 0,
    borderRight: `${borderWidth}px solid var(--card-border-color)`
  }, width: cell.column.getSize(), children: flexRender(cell.column.columnDef.cell, cell.getContext?.()) }, cell.row.original._id + cell.id);
}
var VISIBLE_COLUMN_LIMIT = 5;
var PreviewCell = (props) => {
  const {
    documentPreviewStore,
    row,
    schemaType
  } = props, previewStateObservable = (0, import_react2.useMemo)(() => getPreviewStateObservable$1(documentPreviewStore, schemaType, row.original._id), [documentPreviewStore, row.original._id, schemaType]), versionsInfo = useDocumentVersionInfo(row.original._id), {
    snapshot,
    isLoading
  } = useObservable(previewStateObservable, {
    snapshot: null,
    isLoading: true
  });
  if (isLoading)
    return (0, import_jsx_runtime2.jsx)(Text, { size: 1, muted: true, children: "Loading..." });
  const displayValue = snapshot?.title ?? "Untitled";
  return (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", gap: 3, children: [
    (0, import_jsx_runtime2.jsx)(DocumentStatusIndicator, { draft: versionsInfo.draft, published: versionsInfo.published, versions: void 0 }),
    (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: displayValue })
  ] });
};
var columnHelper = createColumnHelper();
var SUPPORTED_FIELDS = ["string", "number", "boolean"];
var getColsFromSchemaType = (schemaType, parentalField) => schemaType.fields.reduce((tableColumns, field) => {
  const {
    type,
    name
  } = field;
  if (SUPPORTED_FIELDS.includes(type.name)) {
    const nextCol = columnHelper.accessor(
      // accessor must use dot notation for internal tanstack method of reading cell data
      parentalField ? `${parentalField}.${field.name}` : field.name,
      {
        id: parentalField ? `${parentalField}_${field.name}` : field.name,
        header: field.type.title,
        enableHiding: true,
        cell: (info) => (0, import_jsx_runtime2.jsx)(SheetListCellInner, { ...info, fieldType: type })
      }
    );
    return [...tableColumns, nextCol];
  }
  return type.name === "object" && isObjectSchemaType(type) && !parentalField ? [...tableColumns, columnHelper.group({
    header: name,
    columns: getColsFromSchemaType(type, field.name)
  })] : tableColumns;
}, []);
function isAccessorKeyColumnDef(column) {
  return "accessorKey" in column;
}
function isGroupColumnDef(column) {
  return "columns" in column;
}
var flatColumns = (cols) => cols.flatMap((col) => isAccessorKeyColumnDef(col) ? col : isGroupColumnDef(col) ? col.columns ? flatColumns(col.columns) : [] : []);
function useDocumentSheetColumns(documentSchemaType) {
  const documentPreviewStore = useDocumentPreviewStore(), columns = (0, import_react2.useMemo)(() => documentSchemaType ? [columnHelper.display({
    id: "selected",
    enableHiding: false,
    header: (info) => (0, import_jsx_runtime2.jsxs)(Box, { children: [
      (0, import_jsx_runtime2.jsx)(Checkbox, { style: {
        paddingLeft: 4
      }, indeterminate: info.table.getIsSomeRowsSelected(), onChange: info.table.getToggleAllPageRowsSelectedHandler() }),
      info.table.getSelectedRowModel().rows.length,
      " selected"
    ] }),
    cell: DocumentSheetListSelect
  }), columnHelper.accessor("Preview", {
    enableHiding: false,
    id: "Preview",
    cell: (info_0) => (0, import_jsx_runtime2.jsx)(PreviewCell, { ...info_0, documentPreviewStore, schemaType: documentSchemaType })
  }), ...getColsFromSchemaType(documentSchemaType)] : [], [documentPreviewStore, documentSchemaType]), [initialColumnsVisibility] = (0, import_react2.useMemo)(() => flatColumns(columns).reduce(([accCols, countAllowedVisible], column) => {
    if (!column.id) throw new Error("Column must have an id");
    const visibilityKey = column.id;
    return column.enableHiding ? countAllowedVisible === VISIBLE_COLUMN_LIMIT ? [{
      ...accCols,
      [visibilityKey]: false
    }, countAllowedVisible] : [{
      ...accCols,
      [visibilityKey]: true
    }, countAllowedVisible + 1] : [{
      ...accCols,
      [visibilityKey]: true
    }, countAllowedVisible];
  }, [{}, 0]), [columns]);
  return {
    columns,
    initialColumnsVisibility
  };
}
function ColumnsControl({
  table
}) {
  const {
    t: t2
  } = useTranslation(), isVisibleLimitReached = table.getVisibleLeafColumns().filter((col) => col.getCanHide()).length >= VISIBLE_COLUMN_LIMIT, setInitialColumns = (0, import_react2.useCallback)(() => {
    table.resetColumnVisibility();
  }, [table]), handleColumnOnChange = (column) => () => {
    column.toggleVisibility();
  }, getColumnVisibilityDisabled = (column_0) => {
    const isColumnVisible = column_0.getIsVisible(), isSingleColumnVisible = table.getVisibleLeafColumns().filter((col_0) => col_0.getCanHide()).length === 1;
    return isVisibleLimitReached && !isColumnVisible || isSingleColumnVisible && isColumnVisible;
  };
  return (0, import_jsx_runtime2.jsx)(MenuButton, { button: (0, import_jsx_runtime2.jsx)(Button2, { mode: "bleed", text: t2("sheet-list.edit-columns") }), id: "columns-control", menu: (0, import_jsx_runtime2.jsx)(Menu, { padding: 3, paddingTop: 4, style: {
    width: 240
  }, children: (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", height: "fill", gap: 3, children: [
    (0, import_jsx_runtime2.jsx)(Text, { weight: "semibold", size: 1, children: t2("sheet-list.select-fields") }),
    (0, import_jsx_runtime2.jsx)(Flex, { style: {
      flex: "1 1 auto",
      maxHeight: 320,
      overflowY: "scroll"
    }, children: (0, import_jsx_runtime2.jsx)(Stack, { children: table.getAllLeafColumns().filter((column_1) => column_1.getCanHide()).map((column_2) => {
      const columnId = column_2.id.replace(/ /g, "-");
      return (0, import_jsx_runtime2.jsxs)(Flex, { marginY: 2, align: "center", children: [
        (0, import_jsx_runtime2.jsx)(Checkbox, { readOnly: getColumnVisibilityDisabled(column_2), checked: column_2.getIsVisible(), onChange: handleColumnOnChange(column_2), id: `col-visibility-${columnId}`, style: {
          display: "block"
        } }),
        (0, import_jsx_runtime2.jsx)(Box, { flex: 1, paddingLeft: 3, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)("label", { htmlFor: `col-visibility-${columnId}`, children: column_2.columnDef.header?.toString() }) }) })
      ] }, column_2.id);
    }) }) }),
    (0, import_jsx_runtime2.jsx)(Button2, { width: "fill", mode: "ghost", text: t2("sheet-list.reset-columns"), onClick: setInitialColumns })
  ] }) }), placement: "bottom", popover: {
    portal: true
  } });
}
var SearchContainer = at(Flex).withConfig({
  displayName: "SearchContainer",
  componentId: "sc-rt1blp-0"
})`flex-shrink:0;`;
function DocumentSheetListFilter() {
  const $ = (0, import_compiler_runtime2.c)(5), {
    state: t0
  } = useSearchState(), {
    filtersVisible
  } = t0;
  let t1;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = (0, import_jsx_runtime2.jsx)(SearchHeader, {}), $[0] = t1) : t1 = $[0];
  let t2;
  $[1] !== filtersVisible ? (t2 = filtersVisible && (0, import_jsx_runtime2.jsx)(Filters, { showTypeFilter: false }), $[1] = filtersVisible, $[2] = t2) : t2 = $[2];
  let t3;
  return $[3] !== t2 ? (t3 = (0, import_jsx_runtime2.jsxs)(SearchContainer, { children: [
    t1,
    t2
  ] }), $[3] = t2, $[4] = t3) : t3 = $[4], t3;
}
var Header = at.th.withConfig({
  displayName: "Header",
  componentId: "sc-1l8g8jw-0"
})`margin:16px;z-index:1;padding:22px 0px;border-top:1px solid var(--card-border-color);background-color:var(--card-badge-default-bg-color);box-sizing:border-box;text-align:left;width:${({
  width
}) => width}px;max-width:${({
  width
}) => width}px;`;
var PinnedHeader = at(Header).withConfig({
  displayName: "PinnedHeader",
  componentId: "sc-1l8g8jw-1"
})`position:sticky;z-index:2;`;
var HoverMenu = at.div.withConfig({
  displayName: "HoverMenu",
  componentId: "sc-1l8g8jw-2"
})`visibility:hidden;${Header}:hover &{visibility:visible;}`;
function DocumentSheetListHeader(props) {
  const {
    header,
    headerGroup
  } = props, {
    t: t2
  } = useTranslation(), isPinned = header.column.getIsPinned(), headerTitle = headerGroup.depth > 0 && !header.column.parent ? null : (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "semibold", textOverflow: "ellipsis", children: flexRender(header.column.columnDef.header, header.getContext()) }), HeaderTag = isPinned ? PinnedHeader : Header, canShowHeaderMenu = header.column.getCanHide() && (headerGroup.depth === 0 ? !header.column.columns.length : header.column.parent), borderWidth = isPinned && header.column.getIsLastColumn("left") ? 2 : 1;
  return (0, import_jsx_runtime2.jsx)(HeaderTag, { style: {
    left: header.column.getStart("left") ?? void 0,
    borderRight: `${borderWidth}px solid var(--card-border-color)`
  }, "data-testid": `header-${header.id}`, width: header.getSize(), children: (0, import_jsx_runtime2.jsxs)(Flex, { justify: "space-between", marginX: 2, align: "baseline", children: [
    (0, import_jsx_runtime2.jsx)(Tooltip, { delay: 500, content: headerTitle, children: (0, import_jsx_runtime2.jsx)(Box, { style: {
      boxSizing: "border-box"
    }, marginLeft: 3, marginRight: 3, children: headerTitle }) }),
    canShowHeaderMenu && (0, import_jsx_runtime2.jsx)(HoverMenu, { children: (0, import_jsx_runtime2.jsx)(MenuButton, { button: (0, import_jsx_runtime2.jsx)(Button2, { tooltipProps: {
      content: "Open field menu"
    }, mode: "bleed", icon: EllipsisHorizontalIcon, "data-testid": "field-menu-button" }), id: "field menu", popover: {
      placement: "bottom-end"
    }, menu: (0, import_jsx_runtime2.jsx)(Menu, { children: (0, import_jsx_runtime2.jsx)(MenuItem2, { text: t2("sheet-list.hide-field"), icon: CloseIcon, onClick: () => header.column.toggleVisibility() }) }) }) })
  ] }) }, header.id);
}
function DocumentSheetListPaginator({
  table
}) {
  return (0, import_jsx_runtime2.jsx)(TooltipDelayGroupProvider, { children: (0, import_jsx_runtime2.jsxs)(Flex, { gap: 3, align: "center", children: [
    (0, import_jsx_runtime2.jsx)(Button2, { onClick: () => table.setPageIndex(0), disabled: !table.getCanPreviousPage(), icon: DoubleChevronLeftIcon, tooltipProps: {
      content: "Go to first page"
    } }),
    (0, import_jsx_runtime2.jsx)(Button2, { onClick: () => table.previousPage(), disabled: !table.getCanPreviousPage(), icon: ChevronLeftIcon, tooltipProps: {
      content: "Go to previous page"
    } }),
    (0, import_jsx_runtime2.jsxs)(Text, { style: {
      whiteSpace: "nowrap"
    }, children: [
      table.getState().pagination.pageIndex + 1,
      " of ",
      table.getPageCount()
    ] }),
    (0, import_jsx_runtime2.jsx)(Button2, { onClick: () => table.nextPage(), disabled: !table.getCanNextPage(), icon: ChevronRightIcon, tooltipProps: {
      content: "Go to next page"
    } }),
    (0, import_jsx_runtime2.jsx)(Button2, { onClick: () => table.setPageIndex(table.getPageCount() - 1), disabled: !table.getCanNextPage(), icon: DoubleChevronRightIcon, tooltipProps: {
      content: "Go to last page"
    } }),
    (0, import_jsx_runtime2.jsx)("select", { value: table.getState().pagination.pageSize, onChange: (e2) => {
      table.setPageSize(Number(e2.target.value));
    }, children: [25, 50, 100].map((pageSize) => (0, import_jsx_runtime2.jsx)("option", { value: pageSize, children: pageSize }, pageSize)) })
  ] }) });
}
function createDocumentsSet(documents) {
  return documents.reduce((acc, doc) => ({
    ...acc,
    [doc._id]: doc
  }), {});
}
function documentsReducer(state2, action) {
  switch (action.type) {
    case "DOCUMENTS_SET": {
      const documents = createDocumentsSet(action.documents);
      return {
        ...state2,
        documents
      };
    }
    case "DOCUMENT_RECEIVED": {
      const nextDocumentResult = action.payload;
      return {
        ...state2,
        documents: {
          ...state2.documents,
          [nextDocumentResult._id]: nextDocumentResult
        }
      };
    }
    case "DOCUMENT_DELETED": {
      const {
        [action.id]: _,
        ...restDocuments
      } = state2.documents;
      return {
        ...state2,
        documents: restDocuments
      };
    }
    case "DOCUMENT_UPDATED": {
      const updatedDocument = action.payload, id = updatedDocument._id, nextDocument = {
        // Add existing document data
        ...state2.documents[id],
        // Add incoming document data
        ...updatedDocument
      };
      return {
        ...state2,
        documents: {
          ...state2.documents,
          [id]: nextDocument
        }
      };
    }
    default:
      return state2;
  }
}
var LISTEN_OPTIONS = {
  events: ["welcome", "mutation", "reconnect"],
  includeResult: true,
  visibility: "query",
  includeAllVersions: true,
  tag: "document-sheet-list-store"
};
function useDocumentSheetListStore(t0) {
  const $ = (0, import_compiler_runtime2.c)(27), {
    filter: filter2,
    params,
    apiVersion
  } = t0, QUERY = `*[${filter2}][0...2000]`, t1 = apiVersion || DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion;
  let t2;
  $[0] !== t1 ? (t2 = {
    ...DEFAULT_STUDIO_CLIENT_OPTIONS,
    apiVersion: t1
  }, $[0] = t1, $[1] = t2) : t2 = $[1];
  const client = useClient(t2);
  let t3;
  $[2] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t3 = {
    documents: {}
  }, $[2] = t3) : t3 = $[2];
  const [state2, dispatch] = (0, import_react2.useReducer)(documentsReducer, t3), [isLoading, setIsLoading] = (0, import_react2.useState)(client !== null), [error, setError] = (0, import_react2.useState)(null);
  let t4;
  $[3] !== QUERY || $[4] !== client || $[5] !== params ? (t4 = async () => {
    if (!client) {
      setIsLoading(false);
      return;
    }
    try {
      const res = await client.fetch(QUERY, params);
      dispatch({
        type: "DOCUMENTS_SET",
        documents: res
      }), setIsLoading(false);
    } catch (t52) {
      setError(t52);
    }
  }, $[3] = QUERY, $[4] = client, $[5] = params, $[6] = t4) : t4 = $[6];
  const initialFetch = t4;
  let t5;
  $[7] !== initialFetch ? (t5 = async (event) => {
    if (event.type === "welcome" && (setIsLoading(true), await initialFetch(), setIsLoading(false)), event.type === "reconnect" && setIsLoading(true), event.type === "mutation") {
      if (event.transition === "appear") {
        const nextDocument = event.result;
        nextDocument && dispatch({
          type: "DOCUMENT_RECEIVED",
          payload: nextDocument
        });
      }
      if (event.transition === "disappear" && dispatch({
        type: "DOCUMENT_DELETED",
        id: event.documentId
      }), event.transition === "update") {
        const updatedDocument = event.result;
        updatedDocument && dispatch({
          type: "DOCUMENT_UPDATED",
          payload: updatedDocument
        });
      }
    }
  }, $[7] = initialFetch, $[8] = t5) : t5 = $[8];
  const handleListenerEvent = t5;
  let t6;
  bb0: {
    if (!client) {
      let t73;
      $[9] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t73 = of(), $[9] = t73) : t73 = $[9], t6 = t73;
      break bb0;
    }
    let t72;
    if ($[10] !== QUERY || $[11] !== client.observable || $[12] !== params) {
      let t82;
      $[14] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t82 = (err_0) => (setError(err_0), of(err_0)), $[14] = t82) : t82 = $[14], t72 = client.observable.listen(QUERY, params, LISTEN_OPTIONS).pipe(catchError(t82)), $[10] = QUERY, $[11] = client.observable, $[12] = params, $[13] = t72;
    } else
      t72 = $[13];
    t6 = t72;
  }
  const listener$ = t6;
  let t7, t8;
  $[15] !== handleListenerEvent || $[16] !== listener$ ? (t7 = () => {
    const sub = listener$.subscribe(handleListenerEvent);
    return () => {
      sub?.unsubscribe();
    };
  }, t8 = [handleListenerEvent, listener$], $[15] = handleListenerEvent, $[16] = listener$, $[17] = t7, $[18] = t8) : (t7 = $[17], t8 = $[18]), (0, import_react2.useEffect)(t7, t8);
  let t9;
  $[19] !== state2.documents ? (t9 = Object.keys(state2.documents).reduce((acc, key) => {
    const document2 = state2.documents[key], isDraft = document2._id === getDraftId(document2._id), id = isDraft ? document2._id : getDraftId(document2._id);
    return acc[id] && !isDraft || (acc[id] = document2), acc;
  }, {}), $[19] = state2.documents, $[20] = t9) : t9 = $[20];
  const uniques = t9;
  let t10;
  $[21] !== uniques ? (t10 = Object.values(uniques), $[21] = uniques, $[22] = t10) : t10 = $[22];
  const dataAsArray = t10;
  let t11;
  return $[23] !== dataAsArray || $[24] !== error || $[25] !== isLoading ? (t11 = {
    data: dataAsArray,
    isLoading,
    error
  }, $[23] = dataAsArray, $[24] = error, $[25] = isLoading, $[26] = t11) : t11 = $[26], t11;
}
function useDocumentSheetList(t0) {
  const $ = (0, import_compiler_runtime2.c)(12), {
    typeName
  } = t0, {
    state: state2
  } = useSearchState();
  let map2;
  $[0] !== state2.result.hits ? (map2 = /* @__PURE__ */ new Map(), state2.result.hits.forEach((h) => map2.set(getPublishedId(h.hit._id), h.hit)), $[0] = state2.result.hits, $[1] = map2) : map2 = $[1];
  const items = map2, t1 = `_type == "${typeName}"`;
  let t2;
  $[2] !== t1 ? (t2 = {
    filter: t1
  }, $[2] = t1, $[3] = t2) : t2 = $[3];
  const {
    data,
    isLoading
  } = useDocumentSheetListStore(t2);
  let t3;
  if ($[4] !== data || $[5] !== items) {
    let t42;
    $[7] !== items ? (t42 = (doc) => items.has(getPublishedId(doc._id)), $[7] = items, $[8] = t42) : t42 = $[8], t3 = data.filter(t42), $[4] = data, $[5] = items, $[6] = t3;
  } else
    t3 = $[6];
  const documents = t3;
  let t4;
  return $[9] !== documents || $[10] !== isLoading ? (t4 = {
    data: documents,
    isLoading
  }, $[9] = documents, $[10] = isLoading, $[11] = t4) : t4 = $[11], t4;
}
var PaneContainer$1 = at(Flex).withConfig({
  displayName: "PaneContainer",
  componentId: "sc-t7phoh-0"
})`height:100%;`;
var TableContainer = at.div.withConfig({
  displayName: "TableContainer",
  componentId: "sc-t7phoh-1"
})`overflow:auto;position:relative;`;
var Table = at.table.withConfig({
  displayName: "Table",
  componentId: "sc-t7phoh-2"
})`border-collapse:separate;border-spacing:0;font-family:arial,sans-serif;white-space:nowrap;width:100%;border:1px solid lightgray;thead{display:grid;position:sticky;top:0;z-index:10;}tr{padding:0;}tr:last-child{border-bottom:none;}`;
function DocumentSheetListPaneInner({
  documentSchemaType
}) {
  const {
    dispatch,
    state: state2
  } = useSearchState(), {
    columns,
    initialColumnsVisibility
  } = useDocumentSheetColumns(documentSchemaType), {
    data
  } = useDocumentSheetList({
    typeName: documentSchemaType.name
  }), [selectedAnchor, setSelectedAnchor] = (0, import_react2.useState)(null), totalRows = state2.result.hits.length, table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    // Avoids resetting the page index when the data changes, e.g. a mutation is received
    autoResetPageIndex: false,
    initialState: {
      columnPinning: {
        left: ["selected", "Preview"]
      },
      pagination: {
        pageSize: 25
      },
      columnVisibility: initialColumnsVisibility
    },
    getRowId: (row) => row._id,
    meta: {
      selectedAnchor,
      setSelectedAnchor,
      patchDocument: (documentId, fieldId, value) => null
    }
  }), {
    rows
  } = table.getRowModel();
  (0, import_react2.useEffect)(() => (dispatch({
    type: "TERMS_TYPE_ADD",
    schemaType: documentSchemaType
  }), () => {
    dispatch({
      type: "TERMS_TYPE_REMOVE",
      schemaType: documentSchemaType
    });
  }), [documentSchemaType, dispatch]);
  const renderRow = (0, import_react2.useCallback)((row_0) => (0, import_jsx_runtime2.jsx)(Box, { as: "tr", paddingY: 2, style: {
    display: "flex",
    width: "100%"
  }, children: row_0.getVisibleCells().map((cell) => (0, import_jsx_runtime2.jsx)(SheetListCell, { ...cell }, row_0.original._id + cell.id)) }, row_0.original._id + row_0.id), []), rowsCount = `Total: ${totalRows} rows, showing ${rows.length} rows`;
  return (0, import_jsx_runtime2.jsxs)(PaneContainer$1, { direction: "column", paddingX: 3, "data-testid": "document-sheet-list-pane", children: [
    (0, import_jsx_runtime2.jsxs)(Flex, { direction: "row", align: "center", paddingY: 3, paddingX: 1, justify: "space-between", children: [
      (0, import_jsx_runtime2.jsxs)(Flex, { direction: "row", align: "center", children: [
        (0, import_jsx_runtime2.jsx)(DocumentSheetListFilter, {}),
        (0, import_jsx_runtime2.jsx)(Text, { size: 0, muted: true, children: rowsCount })
      ] }),
      (0, import_jsx_runtime2.jsx)(ColumnsControl, { table })
    ] }),
    (0, import_jsx_runtime2.jsx)(TableContainer, { children: (0, import_jsx_runtime2.jsx)(DocumentSheetListProvider, { table, children: (0, import_jsx_runtime2.jsxs)(Table, { children: [
      (0, import_jsx_runtime2.jsx)("thead", { children: table.getHeaderGroups().map((headerGroup) => (0, import_jsx_runtime2.jsx)(Box, { as: "tr", children: headerGroup.headers.map((header) => (0, import_jsx_runtime2.jsx)(DocumentSheetListHeader, { header, headerGroup }, header.id)) }, headerGroup.id)) }),
      (0, import_jsx_runtime2.jsx)("tbody", { children: table.getRowModel().rows.map(renderRow) })
    ] }) }) }),
    (0, import_jsx_runtime2.jsx)(Flex, { justify: "flex-end", padding: 3, gap: 4, paddingY: 5, children: (0, import_jsx_runtime2.jsx)(DocumentSheetListPaginator, { table }) })
  ] });
}
function DocumentSheetListPane(props) {
  const $ = (0, import_compiler_runtime2.c)(7), schema = useSchema(), typeName = props.pane.schemaTypeName;
  let schemaType, t0;
  if ($[0] !== schema || $[1] !== typeName ? (schemaType = schema.get(typeName), t0 = !schemaType || !isDocumentSchemaType(schemaType), $[0] = schema, $[1] = typeName, $[2] = schemaType, $[3] = t0) : (schemaType = $[2], t0 = $[3]), t0)
    throw new Error(`Schema type "${typeName}" not found or not a document schema`);
  let t1;
  return $[4] !== props || $[5] !== schemaType ? (t1 = (0, import_jsx_runtime2.jsx)(SearchProvider, { children: (0, import_jsx_runtime2.jsx)(DocumentSheetListPaneInner, { ...props, documentSchemaType: schemaType }) }), $[4] = props, $[5] = schemaType, $[6] = t1) : t1 = $[6], t1;
}
var addIdsToMenuItems = (menuItems) => menuItems?.map((item) => item.id ? item : {
  ...item,
  id: assignId(item)
});
var addSelectedStateToMenuItems = (options) => {
  const {
    menuItems,
    sortOrderRaw,
    layout,
    customMenuItemState = {}
  } = options;
  return menuItems?.map((item) => {
    if (item.params?.layout)
      return {
        ...item,
        selected: layout === item.params?.layout
      };
    if (item?.params?.by)
      return {
        ...item,
        selected: isEqual_default(sortOrderRaw?.by, item?.params?.by || EMPTY_ARRAY$z)
      };
    if (item.id && item.id in customMenuItemState) {
      const storedValue = customMenuItemState[item.id], itemValue = item.params?.value ?? true;
      return {
        ...item,
        selected: isEqual_default(storedValue, itemValue)
      };
    }
    return {
      ...item,
      selected: item.selected ?? false
    };
  });
};
function useShallowUnique(value) {
  const [previous, setPrevious] = (0, import_react2.useState)(value);
  return (0, import_shallow_equals.default)(previous, value) ? previous : (setPrevious(value), value);
}
var PaneContainer = (0, import_react2.memo)(function(props) {
  const $ = (0, import_compiler_runtime2.c)(41), {
    index,
    isSelected,
    pane: pane2,
    paneKey
  } = props, {
    name: parentSourceName
  } = useSource(), {
    defaultLayout: t0,
    initialValueTemplates: t1,
    menuItemGroups,
    menuItems,
    options
  } = pane2, defaultLayout = t0 === void 0 ? "default" : t0, initialValueTemplates = t1 === void 0 ? EMPTY_ARRAY$z : t1, {
    defaultOrdering: t2,
    filter: filter2
  } = options, defaultOrdering = t2 === void 0 ? EMPTY_ARRAY$z : t2, params = useShallowUnique(options.params || EMPTY_RECORD), sourceName = pane2.source;
  let t3;
  bb0: {
    let t42;
    $[0] !== filter2 || $[1] !== params ? (t42 = findStaticTypesInFilter(filter2, params), $[0] = filter2, $[1] = params, $[2] = t42) : t42 = $[2];
    const staticTypes = t42;
    if (staticTypes?.length === 1) {
      t3 = staticTypes[0];
      break bb0;
    }
    t3 = null;
  }
  const typeName = t3, [layout, setLayout] = useStructureToolSetting("layout", typeName ?? pane2.id, defaultLayout), {
    title
  } = useI18nText(pane2);
  let t4;
  $[3] !== defaultOrdering ? (t4 = defaultOrdering?.length > 0 ? {
    by: defaultOrdering
  } : DEFAULT_ORDERING, $[3] = defaultOrdering, $[4] = t4) : t4 = $[4];
  const defaultSortOrder = t4, [sortOrderRaw, setSortOrder] = useStructureToolSetting("sort-order", typeName ?? pane2.id, defaultSortOrder);
  let t5;
  $[5] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t5 = {}, $[5] = t5) : t5 = $[5];
  const [customMenuItemState, setCustomMenuItemState] = (0, import_react2.useState)(t5);
  let t6;
  $[6] !== menuItems ? (t6 = addIdsToMenuItems(menuItems), $[6] = menuItems, $[7] = t6) : t6 = $[7];
  const menuItemsWithIds = t6;
  let t7;
  $[8] !== customMenuItemState || $[9] !== layout || $[10] !== menuItemsWithIds || $[11] !== sortOrderRaw ? (t7 = addSelectedStateToMenuItems({
    menuItems: menuItemsWithIds,
    sortOrderRaw,
    layout,
    customMenuItemState
  }), $[8] = customMenuItemState, $[9] = layout, $[10] = menuItemsWithIds, $[11] = sortOrderRaw, $[12] = t7) : t7 = $[12];
  const menuItemsWithSelectedState = t7, isSheetListLayout = layout === "sheetList";
  let t8;
  $[13] !== isSheetListLayout || $[14] !== layout || $[15] !== props || $[16] !== sortOrderRaw ? (t8 = isSheetListLayout ? (0, import_jsx_runtime2.jsx)(DocumentSheetListPane, { ...props }, props.pane.id) : (0, import_jsx_runtime2.jsx)(DocumentListPane, { ...props, sortOrder: sortOrderRaw, layout }), $[13] = isSheetListLayout, $[14] = layout, $[15] = props, $[16] = sortOrderRaw, $[17] = t8) : t8 = $[17];
  const paneLayout = t8, t9 = sourceName || parentSourceName;
  let t10;
  $[18] !== isSheetListLayout ? (t10 = isSheetListLayout ? {} : {
    currentMaxWidth: 350,
    maxWidth: 640
  }, $[18] = isSheetListLayout, $[19] = t10) : t10 = $[19];
  let t11;
  $[20] !== pane2.source ? (t11 = _DEBUG, $[20] = pane2.source, $[21] = t11) : t11 = $[21];
  let t12;
  $[22] !== customMenuItemState || $[23] !== index || $[24] !== initialValueTemplates || $[25] !== menuItemGroups || $[26] !== menuItemsWithSelectedState || $[27] !== setLayout || $[28] !== setSortOrder || $[29] !== title ? (t12 = (0, import_jsx_runtime2.jsx)(PaneHeader, { customMenuItemState, index, initialValueTemplates, menuItemGroups, menuItems: menuItemsWithSelectedState, setLayout, setSortOrder, setCustomMenuItemState, title }), $[22] = customMenuItemState, $[23] = index, $[24] = initialValueTemplates, $[25] = menuItemGroups, $[26] = menuItemsWithSelectedState, $[27] = setLayout, $[28] = setSortOrder, $[29] = title, $[30] = t12) : t12 = $[30];
  let t13;
  $[31] !== isSelected || $[32] !== paneKey || $[33] !== paneLayout || $[34] !== t10 || $[35] !== t11 || $[36] !== t12 ? (t13 = (0, import_jsx_runtime2.jsxs)(Pane, { "data-ui": "DocumentListPane", id: paneKey, minWidth: 320, ...t10, selected: isSelected, children: [
    t11,
    t12,
    paneLayout
  ] }), $[31] = isSelected, $[32] = paneKey, $[33] = paneLayout, $[34] = t10, $[35] = t11, $[36] = t12, $[37] = t13) : t13 = $[37];
  let t14;
  return $[38] !== t13 || $[39] !== t9 ? (t14 = (0, import_jsx_runtime2.jsx)(SourceProvider, { name: t9, children: t13 }), $[38] = t13, $[39] = t9, $[40] = t14) : t14 = $[40], t14;
});
PaneContainer.displayName = "Memo(PaneContainer)";
var useLiveEditBadge = (props) => {
  const {
    liveEditSchemaType,
    version
  } = props;
  return liveEditSchemaType && !version ? {
    label: "Live",
    color: "danger"
  } : null;
};
useLiveEditBadge.displayName = "LiveEditBadge";
var state = {
  activePanes: []
};
function setActivePanes(panes) {
  state.activePanes = panes;
}
function getIntentState(intent, params, routerState, payload) {
  const panes = routerState?.panes || [], activePanes = state.activePanes || [], editDocumentId = params.id || v4_default();
  for (let i = activePanes.length - 1; i >= 0; i--) {
    const pane2 = activePanes[i];
    if (typeof pane2 == "object" && (pane2.canHandleIntent?.(intent, params, {
      pane: pane2,
      index: i
    }) || // see `resolveIntent.ts` for more info
    pane2.type === "documentList" && pane2.schemaTypeName === params.type && pane2.options.filter === "_type == $type")) {
      const paneParams = getPaneParams(intent, params);
      return {
        panes: panes.slice(0, i).concat([[{
          id: editDocumentId,
          params: paneParams,
          payload
        }]])
      };
    }
  }
  return {
    intent,
    params,
    payload
  };
}
function getPaneParams(intent, {
  template,
  version,
  inspect,
  comment,
  task,
  scheduledDraft
}) {
  switch (intent) {
    case "create":
      return {
        template,
        version
      };
    case "edit":
      return {
        inspect,
        comment,
        task,
        scheduledDraft
      };
    default:
      return EMPTY_PARAMS$1;
  }
}
var Scroller$3 = at(ScrollContainer).withConfig({
  displayName: "Scroller",
  componentId: "sc-jiqgdv-0"
})`height:100%;overflow:auto;position:relative;scroll-behavior:smooth;`;
var Grid$1 = at(Box).withConfig({
  displayName: "Grid",
  componentId: "sc-jiqgdv-1"
})`&:not([hidden]){display:grid;}grid-template-columns:48px 1fr;align-items:center;gap:0.25em;`;
function ChangesInspector(t0) {
  const $ = (0, import_compiler_runtime2.c)(39), {
    showChanges
  } = t0, {
    documentId,
    schemaType,
    timelineError,
    timelineStore,
    value
  } = useDocumentPane(), {
    selectedReleaseId
  } = usePerspective(), [scrollRef, setScrollRef] = (0, import_react2.useState)(null), rev = useTimelineSelector(timelineStore, _temp$6), diff = useTimelineSelector(timelineStore, _temp2$3), onOlderRevision = useTimelineSelector(timelineStore, _temp3$2), selectionState = useTimelineSelector(timelineStore, _temp4$2), sinceTime = useTimelineSelector(timelineStore, _temp5$1), loading = selectionState === "loading", isComparingCurrent = !onOlderRevision, {
    t: structureT
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[0] !== diff || $[1] !== documentId || $[2] !== isComparingCurrent || $[3] !== schemaType || $[4] !== value ? (t1 = {
    documentId,
    schemaType,
    FieldWrapper: _temp6$1,
    rootDiff: diff,
    isComparingCurrent,
    value,
    showFromValue: true
  }, $[0] = diff, $[1] = documentId, $[2] = isComparingCurrent, $[3] = schemaType, $[4] = value, $[5] = t1) : t1 = $[5];
  const documentContext = t1;
  if (selectedReleaseId) {
    let t22;
    return $[6] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t22 = (0, import_jsx_runtime2.jsx)(Flex, { "data-testid": "review-changes-pane", direction: "column", height: "fill", children: (0, import_jsx_runtime2.jsx)(Card, { flex: 1, padding: 2, paddingTop: 0, children: (0, import_jsx_runtime2.jsx)(TimelineError, { versionError: true }) }) }), $[6] = t22) : t22 = $[6], t22;
  }
  let t2;
  $[7] !== structureT ? (t2 = structureT("changes.from.label"), $[7] = structureT, $[8] = t2) : t2 = $[8];
  let t3;
  $[9] !== t2 ? (t3 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, muted: true, children: t2 }), $[9] = t2, $[10] = t3) : t3 = $[10];
  let t4;
  $[11] !== sinceTime ? (t4 = (0, import_jsx_runtime2.jsx)(TimelineMenu, { mode: "since", chunk: sinceTime, placement: "bottom-start" }), $[11] = sinceTime, $[12] = t4) : t4 = $[12];
  let t5;
  $[13] !== structureT ? (t5 = structureT("changes.to.label"), $[13] = structureT, $[14] = t5) : t5 = $[14];
  let t6;
  $[15] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, muted: true, children: t5 }), $[15] = t5, $[16] = t6) : t6 = $[16];
  let t7;
  $[17] !== rev ? (t7 = (0, import_jsx_runtime2.jsx)(TimelineMenu, { chunk: rev, mode: "rev", placement: "bottom-end" }), $[17] = rev, $[18] = t7) : t7 = $[18];
  let t8;
  $[19] !== t3 || $[20] !== t4 || $[21] !== t6 || $[22] !== t7 ? (t8 = (0, import_jsx_runtime2.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime2.jsxs)(Grid$1, { paddingX: 2, paddingBottom: 2, children: [
    t3,
    t4,
    t6,
    t7
  ] }) }), $[19] = t3, $[20] = t4, $[21] = t6, $[22] = t7, $[23] = t8) : t8 = $[23];
  let t9;
  $[24] !== diff || $[25] !== documentContext || $[26] !== loading || $[27] !== schemaType || $[28] !== showChanges || $[29] !== timelineError ? (t9 = showChanges && (0, import_jsx_runtime2.jsx)(Content$1, { diff, documentContext, error: timelineError, loading, schemaType }), $[24] = diff, $[25] = documentContext, $[26] = loading, $[27] = schemaType, $[28] = showChanges, $[29] = timelineError, $[30] = t9) : t9 = $[30];
  let t10;
  $[31] !== t9 ? (t10 = (0, import_jsx_runtime2.jsx)(Scroller$3, { "data-ui": "Scroller", ref: setScrollRef, children: (0, import_jsx_runtime2.jsx)(Box, { flex: 1, paddingX: 3, height: "fill", children: t9 }) }), $[31] = t9, $[32] = t10) : t10 = $[32];
  let t11;
  $[33] !== scrollRef || $[34] !== t10 ? (t11 = (0, import_jsx_runtime2.jsx)(Card, { flex: 1, paddingX: 2, paddingY: 2, children: (0, import_jsx_runtime2.jsx)(BoundaryElementProvider, { element: scrollRef, children: t10 }) }), $[33] = scrollRef, $[34] = t10, $[35] = t11) : t11 = $[35];
  let t12;
  return $[36] !== t11 || $[37] !== t8 ? (t12 = (0, import_jsx_runtime2.jsxs)(Flex, { "data-testid": "review-changes-pane", direction: "column", height: "fill", overflow: "hidden", children: [
    t8,
    t11
  ] }), $[36] = t11, $[37] = t8, $[38] = t12) : t12 = $[38], t12;
}
function _temp6$1(props) {
  return (0, import_jsx_runtime2.jsx)(ChangeFieldWrapper, { ...props, hasRevertHover: false });
}
function _temp5$1(state_3) {
  return state_3.sinceTime;
}
function _temp4$2(state_2) {
  return state_2.selectionState;
}
function _temp3$2(state_1) {
  return state_1.onOlderRevision;
}
function _temp2$3(state_0) {
  return state_0.diff;
}
function _temp$6(state2) {
  return state2.revTime;
}
function Content$1(t0) {
  const $ = (0, import_compiler_runtime2.c)(9), {
    error,
    diff,
    documentContext,
    loading,
    schemaType
  } = t0;
  if (error) {
    let t12;
    return $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t12 = (0, import_jsx_runtime2.jsx)(NoChanges, {}), $[0] = t12) : t12 = $[0], t12;
  }
  if (loading) {
    let t12;
    return $[1] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t12 = (0, import_jsx_runtime2.jsx)(LoadingBlock, { showText: true }), $[1] = t12) : t12 = $[1], t12;
  }
  if (!diff) {
    let t12;
    return $[2] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t12 = (0, import_jsx_runtime2.jsx)(NoChanges, {}), $[2] = t12) : t12 = $[2], t12;
  }
  let t1;
  $[3] !== diff || $[4] !== schemaType ? (t1 = (0, import_jsx_runtime2.jsx)(ChangeList, { diff, schemaType }), $[3] = diff, $[4] = schemaType, $[5] = t1) : t1 = $[5];
  let t2;
  return $[6] !== documentContext || $[7] !== t1 ? (t2 = (0, import_jsx_runtime2.jsx)(DocumentChangeContext.Provider, { value: documentContext, children: t1 }), $[6] = documentContext, $[7] = t1, $[8] = t2) : t2 = $[8], t2;
}
var getIsSelectable = (event) => !isDeleteDocumentVersionEvent(event) && !isDeleteDocumentGroupEvent(event) && !isUnpublishDocumentEvent(event) && !isScheduleDocumentVersionEvent(event) && !isUnscheduleDocumentVersionEvent(event);
function EventTimelineItem(t0) {
  const $ = (0, import_compiler_runtime2.c)(27), {
    event,
    isSelected,
    onSelect,
    optionsMenu
  } = t0, {
    t: t2
  } = useTranslation("studio");
  let t1;
  $[0] !== event ? (t1 = getIsSelectable(event), $[0] = event, $[1] = t1) : t1 = $[1];
  const isSelectable = t1;
  let t22;
  $[2] !== event || $[3] !== isSelectable || $[4] !== onSelect ? (t22 = (evt) => {
    evt.preventDefault(), evt.stopPropagation(), isSelectable && onSelect(event);
  }, $[2] = event, $[3] = isSelectable, $[4] = onSelect, $[5] = t22) : t22 = $[5];
  const handleClick = t22;
  let t3;
  $[6] !== isSelectable || $[7] !== t2 ? (t3 = isSelectable ? "" : t2("changes.not-selectable"), $[6] = isSelectable, $[7] = t2, $[8] = t3) : t3 = $[8];
  const t4 = isSelectable ? "button" : "div", t5 = isSelectable ? "pointer" : "default";
  let t6;
  $[9] !== t5 ? (t6 = {
    cursor: t5,
    width: "100%"
  }, $[9] = t5, $[10] = t6) : t6 = $[10];
  let t7;
  $[11] !== event ? (t7 = (0, import_jsx_runtime2.jsx)(Event$1, { event, showChangesBy: "tooltip" }), $[11] = event, $[12] = t7) : t7 = $[12];
  let t8;
  $[13] !== event.timestamp || $[14] !== handleClick || $[15] !== isSelected || $[16] !== t4 || $[17] !== t6 || $[18] !== t7 ? (t8 = (0, import_jsx_runtime2.jsx)(Card, { as: t4, onClick: handleClick, padding: 2, pressed: isSelected, radius: 2, "data-ui": "timelineItem", "data-testid": "timeline-item-button", "data-chunk-timestamp": event.timestamp, style: t6, children: t7 }), $[13] = event.timestamp, $[14] = handleClick, $[15] = isSelected, $[16] = t4, $[17] = t6, $[18] = t7, $[19] = t8) : t8 = $[19];
  let t9;
  $[20] !== isSelectable || $[21] !== t3 || $[22] !== t8 ? (t9 = (0, import_jsx_runtime2.jsx)(Tooltip, { content: t3, disabled: isSelectable, children: t8 }), $[20] = isSelectable, $[21] = t3, $[22] = t8, $[23] = t9) : t9 = $[23];
  let t10;
  return $[24] !== optionsMenu || $[25] !== t9 ? (t10 = (0, import_jsx_runtime2.jsxs)(Flex, { gap: 1, children: [
    t9,
    optionsMenu
  ] }), $[24] = optionsMenu, $[25] = t9, $[26] = t10) : t10 = $[26], t10;
}
function PublishedEventMenu(t0) {
  const $ = (0, import_compiler_runtime2.c)(47), {
    event
  } = t0, {
    t: t2
  } = useTranslation(structureLocaleNamespace), {
    t: tCore
  } = useTranslation(), portalContext = usePortal(), {
    params,
    setParams
  } = usePaneRouter(), setPerspective = useSetPerspective(), {
    document: document2
  } = useWorkspace(), {
    drafts: t1
  } = document2, {
    enabled: isDraftModelEnabled
  } = t1;
  let t22;
  $[0] !== event.id || $[1] !== event.versionId || $[2] !== event.versionRevisionId || $[3] !== params || $[4] !== setParams ? (t22 = () => {
    setParams({
      ...params,
      rev: event.versionRevisionId || "@lastPublished",
      since: void 0,
      historyEvent: event.id,
      historyVersion: getVersionFromId(event.versionId)
    });
  }, $[0] = event.id, $[1] = event.versionId, $[2] = event.versionRevisionId, $[3] = params, $[4] = setParams, $[5] = t22) : t22 = $[5];
  const handleOpenReleaseDocument = t22;
  let t3;
  $[6] !== event.versionRevisionId || $[7] !== isDraftModelEnabled || $[8] !== params || $[9] !== setParams || $[10] !== setPerspective ? (t3 = () => {
    setParams({
      ...params,
      rev: event.versionRevisionId,
      preserveRev: "true",
      since: void 0
    }), setTimeout(() => {
      setPerspective(isDraftModelEnabled ? "drafts" : "published");
    }, 100);
  }, $[6] = event.versionRevisionId, $[7] = isDraftModelEnabled, $[8] = params, $[9] = setParams, $[10] = setPerspective, $[11] = t3) : t3 = $[11];
  const handleOpenDraftDocument = t3, releaseTitle = event.release?.metadata?.title;
  let t4;
  $[12] !== tCore ? (t4 = tCore("release.placeholder-untitled-release"), $[12] = tCore, $[13] = t4) : t4 = $[13];
  const releaseFallback = t4;
  let t5;
  $[14] !== event.release ? (t5 = (t62) => {
    const {
      children
    } = t62;
    return (0, import_jsx_runtime2.jsx)(VersionInlineBadge, { $tone: event.release ? isReleaseDocument(event.release) ? getReleaseTone(event.release) : "default" : void 0, children });
  }, $[14] = event.release, $[15] = t5) : t5 = $[15];
  const VersionBadge = t5;
  let t6;
  $[16] !== event.release ? (t6 = event.release && !isReleaseDocument(event.release), $[16] = event.release, $[17] = t6) : t6 = $[17];
  const isMenuDisabled = t6, t7 = `timeline-item-menu-button-${event.versionId}`;
  let t8;
  $[18] !== t2 ? (t8 = t2("timeline-item.menu-button.aria-label"), $[18] = t2, $[19] = t8) : t8 = $[19];
  let t9;
  $[20] !== event.release || $[21] !== isMenuDisabled || $[22] !== t2 ? (t9 = isMenuDisabled ? t2("timeline-item.not-found-release.tooltip", {
    releaseId: event.release?._id ? getReleaseIdFromReleaseDocumentId(event.release._id) : void 0
  }) : t2("timeline-item.menu-button.tooltip"), $[20] = event.release, $[21] = isMenuDisabled, $[22] = t2, $[23] = t9) : t9 = $[23];
  let t10;
  $[24] !== t9 ? (t10 = {
    content: t9
  }, $[24] = t9, $[25] = t10) : t10 = $[25];
  let t11;
  $[26] !== isMenuDisabled || $[27] !== t10 || $[28] !== t8 ? (t11 = (0, import_jsx_runtime2.jsx)(ContextMenuButton, { "aria-label": t8, tooltipProps: t10, disabled: isMenuDisabled }), $[26] = isMenuDisabled, $[27] = t10, $[28] = t8, $[29] = t11) : t11 = $[29];
  let t12;
  $[30] !== VersionBadge || $[31] !== event.release || $[32] !== event.versionRevisionId || $[33] !== handleOpenDraftDocument || $[34] !== handleOpenReleaseDocument || $[35] !== releaseFallback || $[36] !== releaseTitle || $[37] !== t2 ? (t12 = (0, import_jsx_runtime2.jsx)(Menu, { padding: 1, children: event.release ? (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    (0, import_jsx_runtime2.jsx)(IntentLink, { intent: RELEASES_INTENT, params: {
      id: getReleaseIdFromReleaseDocumentId(event.release._id)
    }, style: {
      textDecoration: "none"
    }, children: (0, import_jsx_runtime2.jsx)(MenuItem, { padding: 3, children: (0, import_jsx_runtime2.jsx)(Flex, { align: "center", justify: "flex-start", children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, style: {
      textDecoration: "none"
    }, children: (0, import_jsx_runtime2.jsx)(ReleaseTitle, { title: releaseTitle, fallback: releaseFallback, children: (t132) => {
      const {
        displayTitle
      } = t132;
      return (0, import_jsx_runtime2.jsx)(Translate, { components: {
        VersionBadge: (t142) => {
          const {
            children: children_0
          } = t142;
          return (0, import_jsx_runtime2.jsx)(VersionBadge, { children: children_0 });
        }
      }, i18nKey: "events.open.release", values: {
        releaseTitle: displayTitle
      }, t: t2 });
    } }) }) }) }) }),
    (0, import_jsx_runtime2.jsx)(MenuItem, { onClick: handleOpenReleaseDocument, children: (0, import_jsx_runtime2.jsx)(Flex, { align: "center", justify: "flex-start", children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(ReleaseTitle, { title: releaseTitle, fallback: releaseFallback, children: (t152) => {
      const {
        displayTitle: displayTitle_0
      } = t152;
      return (0, import_jsx_runtime2.jsx)(Translate, { components: {
        VersionBadge: (t162) => {
          const {
            children: children_1
          } = t162;
          return (0, import_jsx_runtime2.jsx)(VersionBadge, { children: children_1 });
        }
      }, i18nKey: "events.inspect.release", values: {
        releaseTitle: displayTitle_0
      }, t: t2 });
    } }) }) }) })
  ] }) : (0, import_jsx_runtime2.jsx)(MenuItem, { onClick: handleOpenDraftDocument, disabled: !event.versionRevisionId, children: (0, import_jsx_runtime2.jsx)(Flex, { align: "center", children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(Translate, { components: {
    VersionBadge: _temp$5
  }, i18nKey: "events.open.draft", t: t2 }) }) }) }) }), $[30] = VersionBadge, $[31] = event.release, $[32] = event.versionRevisionId, $[33] = handleOpenDraftDocument, $[34] = handleOpenReleaseDocument, $[35] = releaseFallback, $[36] = releaseTitle, $[37] = t2, $[38] = t12) : t12 = $[38];
  const t13 = portalContext.elements?.[TIMELINE_MENU_PORTAL$1] ? TIMELINE_MENU_PORTAL$1 : true;
  let t14;
  $[39] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t14 = ["bottom-end", "bottom-start"], $[39] = t14) : t14 = $[39];
  let t15;
  $[40] !== t13 ? (t15 = {
    portal: t13,
    placement: "bottom",
    fallbackPlacements: t14
  }, $[40] = t13, $[41] = t15) : t15 = $[41];
  let t16;
  return $[42] !== t11 || $[43] !== t12 || $[44] !== t15 || $[45] !== t7 ? (t16 = (0, import_jsx_runtime2.jsx)(MenuButton, { id: t7, button: t11, menu: t12, popover: t15 }), $[42] = t11, $[43] = t12, $[44] = t15, $[45] = t7, $[46] = t16) : t16 = $[46], t16;
}
function _temp$5(t0) {
  const {
    children: children_2
  } = t0;
  return (0, import_jsx_runtime2.jsx)(VersionInlineBadge, { $tone: "caution", children: children_2 });
}
var TimelineItemWrapper = motion.create(Box);
var CHILDREN_ITEMS_VARIANTS = {
  initial: {
    opacity: 0
  },
  animate: {
    opacity: 1
  },
  exit: {
    opacity: 0
  }
};
var ITEM_HEIGHT = 57;
var TIMELINE_LIST_WRAPPER_ID = "timeline-list-wrapper";
var EventsTimeline = (t0) => {
  const $ = (0, import_compiler_runtime2.c)(38), {
    events: allEvents,
    hasMoreEvents,
    selectedEventId,
    onLoadMore,
    onSelect,
    listMaxHeight: t1,
    fetchEventChildren
  } = t0, listMaxHeight = t1 === void 0 ? "calc(100vh - 280px)" : t1, [mounted, setMounted] = (0, import_react2.useState)(false), {
    t: t2
  } = useTranslation("studio");
  let t22;
  $[0] !== allEvents || $[1] !== selectedEventId ? (t22 = () => {
    if (selectedEventId) {
      const selectedEvent = allEvents.find((event) => event.id === selectedEventId);
      if (selectedEvent && "parentId" in selectedEvent && selectedEvent.parentId)
        return /* @__PURE__ */ new Set([selectedEvent.parentId]);
    }
    return /* @__PURE__ */ new Set();
  }, $[0] = allEvents, $[1] = selectedEventId, $[2] = t22) : t22 = $[2];
  const [expandedParents, setExpandedParents] = (0, import_react2.useState)(t22);
  let t3;
  $[3] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t3 = /* @__PURE__ */ new Set(), $[3] = t3) : t3 = $[3];
  const [expandingParents, setExpandingParents] = (0, import_react2.useState)(t3);
  let t4;
  $[4] !== allEvents || $[5] !== expandedParents ? (t4 = allEvents.filter((event_0) => isCreateDocumentVersionEvent(event_0) && event_0.parentId ? allEvents[allEvents.length - 1].id === event_0.id ? true : expandedParents.has(event_0.parentId) : isEditDocumentVersionEvent(event_0) && event_0.parentId ? expandedParents.has(event_0.parentId) : true), $[4] = allEvents, $[5] = expandedParents, $[6] = t4) : t4 = $[6];
  const events = t4;
  let t5;
  $[7] !== fetchEventChildren ? (t5 = (event_1) => async () => {
    const parentId = event_1.id;
    let isExpanding = false;
    setExpandedParents((prev) => {
      const next = new Set(prev);
      return prev.has(parentId) ? next.delete(parentId) : (isExpanding = true, next.add(parentId)), next;
    }), isExpanding && (setExpandingParents((prev_0) => {
      const next_0 = new Set(prev_0);
      return next_0.add(parentId), next_0;
    }), await fetchEventChildren(event_1), setExpandingParents((prev_1) => {
      const next_1 = new Set(prev_1);
      return next_1.delete(parentId), next_1;
    }));
  }, $[7] = fetchEventChildren, $[8] = t5) : t5 = $[8];
  const handleExpandParent = t5;
  let t6;
  $[9] !== onSelect ? (t6 = (event_2) => {
    onSelect(event_2);
  }, $[9] = onSelect, $[10] = t6) : t6 = $[10];
  const handleSelectChunk = t6;
  let t7;
  $[11] !== expandedParents || $[12] !== handleExpandParent ? (t7 = (event_3) => {
    const documentVariantType = getDocumentVariantType(event_3.documentId);
    return isPublishDocumentVersionEvent(event_3) && documentVariantType === "published" ? (0, import_jsx_runtime2.jsx)(PublishedEventMenu, { event: event_3 }) : isPublishDocumentVersionEvent(event_3) && documentVariantType === "draft" && event_3.creationEvent || isDeleteDocumentVersionEvent(event_3) && event_3.creationEvent ? (0, import_jsx_runtime2.jsx)(ExpandableTimelineItemButton, { isExpanded: expandedParents.has(event_3.id), onExpand: handleExpandParent(event_3) }) : null;
  }, $[11] = expandedParents, $[12] = handleExpandParent, $[13] = t7) : t7 = $[13];
  const renderOptionsMenu = t7;
  let t8;
  $[14] !== events.length || $[15] !== expandingParents || $[16] !== handleSelectChunk || $[17] !== hasMoreEvents || $[18] !== renderOptionsMenu || $[19] !== selectedEventId ? (t8 = (event_4, t92) => {
    const {
      activeIndex
    } = t92, showExpandingLoader = isCreateDocumentVersionEvent(event_4) && event_4.parentId && expandingParents.has(event_4.parentId), isLastEvent_0 = activeIndex === events.length - 1;
    return showExpandingLoader ? (0, import_jsx_runtime2.jsx)(TimelineItemWrapper, { animate: {
      opacity: 1
    }, initial: {
      opacity: 0
    }, transition: {
      duration: 0.2,
      delay: 0.2
    }, children: (0, import_jsx_runtime2.jsx)(Flex, { align: "center", justify: "center", style: {
      height: ITEM_HEIGHT
    }, children: (0, import_jsx_runtime2.jsx)(Spinner, {}) }) }) : (0, import_jsx_runtime2.jsxs)(TimelineItemWrapper, { paddingBottom: 1, paddingRight: 1, animate: "animate", exit: "exit", initial: "initial", variants: "parentId" in event_4 ? CHILDREN_ITEMS_VARIANTS : void 0, paddingLeft: (isEditDocumentVersionEvent(event_4) || isCreateDocumentVersionEvent(event_4)) && event_4.parentId && !isLastEvent_0 ? 4 : 1, children: [
      (0, import_jsx_runtime2.jsx)(EventTimelineItem, { event: event_4, isSelected: event_4.id === selectedEventId, onSelect: handleSelectChunk, optionsMenu: renderOptionsMenu(event_4) }),
      isLastEvent_0 && hasMoreEvents && (0, import_jsx_runtime2.jsx)(LoadingBlock, {})
    ] }, event_4.timestamp);
  }, $[14] = events.length, $[15] = expandingParents, $[16] = handleSelectChunk, $[17] = hasMoreEvents, $[18] = renderOptionsMenu, $[19] = selectedEventId, $[20] = t8) : t8 = $[20];
  const renderItem = t8;
  let t10, t9;
  $[21] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t9 = () => setMounted(true), t10 = [], $[21] = t10, $[22] = t9) : (t10 = $[21], t9 = $[22]), (0, import_react2.useEffect)(t9, t10);
  let t11;
  if ($[23] !== events || $[24] !== selectedEventId) {
    let t122;
    $[26] !== selectedEventId ? (t122 = (event_5) => event_5.id === selectedEventId, $[26] = selectedEventId, $[27] = t122) : t122 = $[27], t11 = events.findIndex(t122), $[23] = events, $[24] = selectedEventId, $[25] = t11;
  } else
    t11 = $[25];
  const selectedIndex = t11, t12 = !selectedIndex || mounted;
  let t13;
  $[28] !== events || $[29] !== listMaxHeight || $[30] !== onLoadMore || $[31] !== renderItem || $[32] !== selectedIndex || $[33] !== t2 ? (t13 = events.length > 0 ? (0, import_jsx_runtime2.jsx)(ListWrapper, { direction: "column", $maxHeight: listMaxHeight, id: TIMELINE_LIST_WRAPPER_ID, children: (0, import_jsx_runtime2.jsx)(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: t2("timeline.list.aria-label"), autoFocus: "list", initialIndex: selectedIndex, initialScrollAlign: "center", itemHeight: ITEM_HEIGHT, items: events, onEndReached: onLoadMore, onEndReachedIndexOffset: 20, overscan: 5, renderItem, wrapAround: false }) }) : (0, import_jsx_runtime2.jsxs)(Stack, { padding: 3, space: 3, children: [
    (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: t2("timeline.error.no-document-history-title") }),
    (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: t2("timeline.error.no-document-history-description") })
  ] }), $[28] = events, $[29] = listMaxHeight, $[30] = onLoadMore, $[31] = renderItem, $[32] = selectedIndex, $[33] = t2, $[34] = t13) : t13 = $[34];
  let t14;
  return $[35] !== t12 || $[36] !== t13 ? (t14 = (0, import_jsx_runtime2.jsx)(Root$3, { $visible: t12, "data-ui": "timeline", children: t13 }), $[35] = t12, $[36] = t13, $[37] = t14) : t14 = $[37], t14;
};
EventsTimeline.displayName = "EventsTimeline";
var Root = at(Popover2).withConfig({
  displayName: "Root",
  componentId: "sc-mrgvta-0"
})`overflow:hidden;overflow:clip;`;
var TIMELINE_MENU_PORTAL = "timeline-menu";
var formatParams = {
  timestamp: {
    dateStyle: "medium",
    timeStyle: "short"
  }
};
function EventsTimelineMenu(t0) {
  const $ = (0, import_compiler_runtime2.c)(58), {
    event,
    events,
    mode,
    placement
  } = t0, {
    setTimelineRange
  } = useDocumentPane(), [open, setOpen] = (0, import_react2.useState)(false), [button, setButton] = (0, import_react2.useState)(null), [popoverRef, setPopoverRef] = (0, import_react2.useState)(null), toast = useToast(), {
    nextCursor,
    loading,
    error: eventsError,
    findRangeForRevision,
    findRangeForSince,
    loadMoreEvents,
    expandEvent
  } = useEvents(), {
    t: t2
  } = useTranslation("studio");
  let t1;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = () => {
    setOpen(true);
  }, $[0] = t1) : t1 = $[0];
  const handleOpen = t1;
  let t22;
  $[1] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t22 = () => {
    setOpen(false);
  }, $[1] = t22) : t22 = $[1];
  const handleClose = t22;
  let t3;
  $[2] !== button || $[3] !== open ? (t3 = (e2) => {
    open && (e2.key === "Escape" || e2.key === "Tab") && (handleClose(), button?.focus());
  }, $[2] = button, $[3] = open, $[4] = t3) : t3 = $[4], useGlobalKeyDown(t3);
  let t4;
  $[5] !== button || $[6] !== popoverRef ? (t4 = () => [button, popoverRef], $[5] = button, $[6] = popoverRef, $[7] = t4) : t4 = $[7], useClickOutsideEvent(open && handleClose, t4);
  let t5;
  $[8] !== findRangeForRevision || $[9] !== setTimelineRange || $[10] !== t2 || $[11] !== toast ? (t5 = (revEvent) => {
    const run = () => {
      if (isDeleteDocumentVersionEvent(revEvent) || isDeleteDocumentGroupEvent(revEvent) || isUnpublishDocumentEvent(revEvent) || isScheduleDocumentVersionEvent(revEvent) || isUnscheduleDocumentVersionEvent(revEvent)) {
        console.error("Event is not selectable");
        return;
      }
      const [since, rev] = findRangeForRevision(revEvent?.id);
      setTimelineRange(since, rev), handleClose();
    };
    try {
      run();
    } catch (t62) {
      const err = t62;
      toast.push({
        closable: true,
        description: err.message,
        status: "error",
        title: t2("timeline.error.unable-to-load-revision")
      });
    }
  }, $[8] = findRangeForRevision, $[9] = setTimelineRange, $[10] = t2, $[11] = toast, $[12] = t5) : t5 = $[12];
  const selectRev = t5;
  let t6;
  $[13] !== findRangeForSince || $[14] !== setTimelineRange || $[15] !== t2 || $[16] !== toast ? (t6 = (sinceEvent) => {
    try {
      const [since_0, rev_0] = findRangeForSince(sinceEvent.id);
      setTimelineRange(since_0, rev_0), handleClose();
    } catch (t72) {
      const err_0 = t72;
      toast.push({
        closable: true,
        description: err_0.message,
        status: "error",
        title: t2("timeline.error.unable-to-load-revision")
      });
    }
  }, $[13] = findRangeForSince, $[14] = setTimelineRange, $[15] = t2, $[16] = toast, $[17] = t6) : t6 = $[17];
  const selectSince = t6;
  let t7;
  $[18] !== loadMoreEvents || $[19] !== loading || $[20] !== nextCursor ? (t7 = () => {
    !loading && nextCursor && loadMoreEvents();
  }, $[18] = loadMoreEvents, $[19] = loading, $[20] = nextCursor, $[21] = t7) : t7 = $[21];
  const handleLoadMore = t7;
  let t8;
  bb0: {
    if (eventsError) {
      let t93;
      $[22] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t93 = (0, import_jsx_runtime2.jsx)(TimelineError, {}), $[22] = t93) : t93 = $[22], t8 = t93;
      break bb0;
    }
    const t92 = !!nextCursor, t102 = event?.id, t112 = mode === "rev" ? selectRev : selectSince;
    let t122;
    $[23] !== events || $[24] !== expandEvent || $[25] !== handleLoadMore || $[26] !== t102 || $[27] !== t112 || $[28] !== t92 ? (t122 = (0, import_jsx_runtime2.jsx)(EventsTimeline, { events, fetchEventChildren: expandEvent, hasMoreEvents: t92, selectedEventId: t102, onLoadMore: handleLoadMore, onSelect: t112 }), $[23] = events, $[24] = expandEvent, $[25] = handleLoadMore, $[26] = t102, $[27] = t112, $[28] = t92, $[29] = t122) : t122 = $[29], t8 = t122;
  }
  const content = t8;
  let t9;
  $[30] !== event || $[31] !== t2 ? (t9 = event ? t2(TIMELINE_ITEM_I18N_KEY_MAPPING[event.documentVariantType][event.type], {
    context: "timestamp",
    timestamp: new Date(event.timestamp),
    formatParams
  }) : t2("timeline.latest-revision"), $[30] = event, $[31] = t2, $[32] = t9) : t9 = $[32];
  const revLabel = t9;
  let t10;
  $[33] !== event || $[34] !== events || $[35] !== t2 ? (t10 = event ? t2(TIMELINE_ITEM_I18N_KEY_MAPPING[event.documentVariantType][event.type], {
    context: "timestamp",
    timestamp: new Date(event.timestamp),
    formatParams
  }) : events.length > 0 ? t2("timeline.since-version-missing") : t2("timeline.no-previous-events"), $[33] = event, $[34] = events, $[35] = t2, $[36] = t10) : t10 = $[36];
  const buttonLabel = mode === "rev" ? revLabel : t10;
  let t11;
  $[37] !== popoverRef ? (t11 = {
    [TIMELINE_MENU_PORTAL]: popoverRef
  }, $[37] = popoverRef, $[38] = t11) : t11 = $[38];
  const portalElements = t11, t12 = open && content, t13 = open ? "timeline-menu-close-button" : "timeline-menu-open-button", t14 = loading || !events.length, t15 = open ? handleClose : handleOpen;
  let t16;
  $[39] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t16 = {
    maxWidth: "100%"
  }, $[39] = t16) : t16 = $[39];
  let t17;
  $[40] !== buttonLabel || $[41] !== loading || $[42] !== t2 ? (t17 = loading ? t2("timeline.loading-history") : buttonLabel, $[40] = buttonLabel, $[41] = loading, $[42] = t2, $[43] = t17) : t17 = $[43];
  let t18;
  $[44] !== open || $[45] !== t13 || $[46] !== t14 || $[47] !== t15 || $[48] !== t17 ? (t18 = (0, import_jsx_runtime2.jsx)(Flex, { width: "fill", children: (0, import_jsx_runtime2.jsx)(Button2, { "data-testid": t13, disabled: t14, mode: "ghost", onClick: t15, ref: setButton, selected: open, width: "fill", tooltipProps: null, justify: "space-between", style: t16, iconRight: ChevronDownIcon, text: t17 }) }), $[44] = open, $[45] = t13, $[46] = t14, $[47] = t15, $[48] = t17, $[49] = t18) : t18 = $[49];
  let t19;
  $[50] !== open || $[51] !== placement || $[52] !== t12 || $[53] !== t18 ? (t19 = (0, import_jsx_runtime2.jsx)(Root, { "data-testid": "timeline-menu", constrainSize: true, content: t12, "data-ui": "versionMenu", open, placement, matchReferenceWidth: true, portal: true, ref: setPopoverRef, children: t18 }), $[50] = open, $[51] = placement, $[52] = t12, $[53] = t18, $[54] = t19) : t19 = $[54];
  let t20;
  return $[55] !== portalElements || $[56] !== t19 ? (t20 = (0, import_jsx_runtime2.jsx)(PortalProvider, { __unstable_elements: portalElements, children: t19 }), $[55] = portalElements, $[56] = t19, $[57] = t20) : t20 = $[57], t20;
}
var Scroller$2 = at(ScrollContainer).withConfig({
  displayName: "Scroller",
  componentId: "sc-qjtu5v-0"
})`height:100%;overflow:auto;position:relative;scroll-behavior:smooth;`;
var Grid = at(Box).withConfig({
  displayName: "Grid",
  componentId: "sc-qjtu5v-1"
})`&:not([hidden]){display:grid;}grid-template-columns:48px 1fr;align-items:center;gap:0.25em;`;
var SpinnerContainer = at(Flex).withConfig({
  displayName: "SpinnerContainer",
  componentId: "sc-qjtu5v-2"
})`width:100%;position:absolute;bottom:-4px;`;
var DIFF_INITIAL_VALUE = {
  diff: null,
  loading: true,
  error: null
};
var CompareWithPublishedView = () => {
  const $ = (0, import_compiler_runtime2.c)(31), {
    documentId,
    schemaType,
    editState,
    displayed
  } = useDocumentPane(), {
    selectedPerspective,
    selectedPerspectiveName,
    selectedReleaseId
  } = usePerspective(), {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t0;
  $[0] !== displayed || $[1] !== editState?.published ? (t0 = diffInput(wrap(editState?.published ?? {}, {
    author: ""
  }), wrap(displayed ?? {}, {
    author: ""
  })), $[0] = displayed, $[1] = editState?.published, $[2] = t0) : t0 = $[2];
  const rootDiff = t0;
  if (selectedReleaseId && !editState?.version || selectedPerspective === "drafts" && !editState?.draft || selectedPerspectiveName === "published" || !displayed?._rev)
    return null;
  let t1;
  $[3] !== t2 ? (t1 = t2("events.compare-with-published.title"), $[3] = t2, $[4] = t1) : t1 = $[4];
  let t22;
  $[5] !== t1 ? (t22 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: t1 }), $[5] = t1, $[6] = t22) : t22 = $[6];
  let t3;
  $[7] !== selectedPerspective ? (t3 = isReleaseDocument(selectedPerspective) ? selectedPerspective.metadata?.title : "draft", $[7] = selectedPerspective, $[8] = t3) : t3 = $[8];
  let t4;
  $[9] !== t3 ? (t4 = {
    version: t3
  }, $[9] = t3, $[10] = t4) : t4 = $[10];
  let t5;
  $[11] !== t2 || $[12] !== t4 ? (t5 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, muted: true, children: (0, import_jsx_runtime2.jsx)(Translate, { i18nKey: "events.compare-with-published.description", t: t2, values: t4 }) }), $[11] = t2, $[12] = t4, $[13] = t5) : t5 = $[13];
  let t6;
  $[14] !== t22 || $[15] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(Card, { borderBottom: true, paddingBottom: 3, children: (0, import_jsx_runtime2.jsxs)(Stack, { space: 3, paddingTop: 1, children: [
    t22,
    t5
  ] }) }), $[14] = t22, $[15] = t5, $[16] = t6) : t6 = $[16];
  let t7;
  $[17] !== displayed || $[18] !== documentId || $[19] !== rootDiff || $[20] !== schemaType ? (t7 = {
    documentId,
    schemaType,
    rootDiff,
    isComparingCurrent: true,
    FieldWrapper: _temp$4,
    value: displayed,
    showFromValue: true
  }, $[17] = displayed, $[18] = documentId, $[19] = rootDiff, $[20] = schemaType, $[21] = t7) : t7 = $[21];
  let t8;
  $[22] !== rootDiff || $[23] !== schemaType ? (t8 = (0, import_jsx_runtime2.jsx)(Box, { paddingY: 1, children: (0, import_jsx_runtime2.jsx)(ChangeList, { diff: rootDiff, schemaType }) }), $[22] = rootDiff, $[23] = schemaType, $[24] = t8) : t8 = $[24];
  let t9;
  $[25] !== t7 || $[26] !== t8 ? (t9 = (0, import_jsx_runtime2.jsx)(DocumentChangeContext.Provider, { value: t7, children: t8 }), $[25] = t7, $[26] = t8, $[27] = t9) : t9 = $[27];
  let t10;
  return $[28] !== t6 || $[29] !== t9 ? (t10 = (0, import_jsx_runtime2.jsxs)(Stack, { space: 2, marginBottom: 3, children: [
    t6,
    t9
  ] }), $[28] = t6, $[29] = t9, $[30] = t10) : t10 = $[30], t10;
};
function EventsInspector(t0) {
  const $ = (0, import_compiler_runtime2.c)(83), {
    showChanges
  } = t0, {
    documentId,
    schemaType,
    timelineError,
    value,
    formState
  } = useDocumentPane(), [scrollRef, setScrollRef] = (0, import_react2.useState)(null), {
    events,
    revision,
    sinceRevision,
    getChangesList
  } = useEvents(), isComparingCurrent = !revision?.revisionId;
  let t1;
  $[0] !== getChangesList ? (t1 = getChangesList(), $[0] = getChangesList, $[1] = t1) : t1 = $[1];
  const changesList$ = t1, {
    diff,
    loading: diffLoading,
    error: diffError
  } = useObservable(changesList$, DIFF_INITIAL_VALUE), {
    t: t2
  } = useTranslation("studio");
  let t22;
  $[2] !== diff || $[3] !== documentId || $[4] !== formState?.readOnly || $[5] !== isComparingCurrent || $[6] !== schemaType || $[7] !== value ? (t22 = () => ({
    documentId,
    schemaType,
    FieldWrapper: _temp2$2,
    rootDiff: diff,
    isComparingCurrent: isComparingCurrent && !formState?.readOnly,
    value,
    showFromValue: true
  }), $[2] = diff, $[3] = documentId, $[4] = formState?.readOnly, $[5] = isComparingCurrent, $[6] = schemaType, $[7] = value, $[8] = t22) : t22 = $[8];
  let t3;
  $[9] !== t22 ? (t3 = t22(), $[9] = t22, $[10] = t3) : t3 = $[10];
  const documentContext = t3;
  let t4;
  bb0: {
    if (!events) {
      let t53;
      $[11] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t53 = [null, null], $[11] = t53) : t53 = $[11], t4 = t53;
      break bb0;
    }
    let t52;
    $[12] !== events || $[13] !== sinceRevision?.revisionId ? (t52 = events.find((e2) => e2.id === sinceRevision?.revisionId) || null, $[12] = events, $[13] = sinceRevision?.revisionId, $[14] = t52) : t52 = $[14];
    let t62;
    $[15] !== events || $[16] !== revision?.revisionId ? (t62 = events.find((e_0) => e_0.id === revision?.revisionId) || events[0], $[15] = events, $[16] = revision?.revisionId, $[17] = t62) : t62 = $[17];
    let t72;
    $[18] !== t52 || $[19] !== t62 ? (t72 = [t52, t62], $[18] = t52, $[19] = t62, $[20] = t72) : t72 = $[20], t4 = t72;
  }
  const [sinceEvent, toEvent] = t4;
  let t5;
  bb1: {
    if (!toEvent) {
      let t63;
      $[21] !== events ? (t63 = events.slice(1), $[21] = events, $[22] = t63) : t63 = $[22], t5 = t63;
      break bb1;
    }
    let t62;
    if ($[23] !== events || $[24] !== toEvent) {
      let t72;
      $[26] !== toEvent ? (t72 = (event) => "parentId" in toEvent && "parentId" in event && event.parentId === toEvent.parentId || "parentId" in event && toEvent.id === event.parentId ? {
        ...event,
        parentId: void 0
      } : event, $[26] = toEvent, $[27] = t72) : t72 = $[27], t62 = events.slice(events.indexOf(toEvent) + 1).map(t72), $[23] = events, $[24] = toEvent, $[25] = t62;
    } else
      t62 = $[25];
    t5 = t62;
  }
  const sinceEvents = t5;
  if (!events.length) {
    let t62;
    $[28] !== t2 ? (t62 = t2("timeline.error.no-document-history-title"), $[28] = t2, $[29] = t62) : t62 = $[29];
    let t72;
    $[30] !== t62 ? (t72 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: t62 }), $[30] = t62, $[31] = t72) : t72 = $[31];
    let t82;
    $[32] !== t2 ? (t82 = t2("timeline.error.no-document-history-description"), $[32] = t2, $[33] = t82) : t82 = $[33];
    let t92;
    $[34] !== t82 ? (t92 = (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: t82 }), $[34] = t82, $[35] = t92) : t92 = $[35];
    let t102;
    return $[36] !== t72 || $[37] !== t92 ? (t102 = (0, import_jsx_runtime2.jsx)(Box, { paddingX: 2, children: (0, import_jsx_runtime2.jsxs)(Stack, { padding: 3, space: 3, children: [
      t72,
      t92
    ] }) }), $[36] = t72, $[37] = t92, $[38] = t102) : t102 = $[38], t102;
  }
  let t6;
  $[39] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t6 = {
    position: "relative"
  }, $[39] = t6) : t6 = $[39];
  let t7;
  $[40] !== t2 ? (t7 = t2("changes.inspector.from-label"), $[40] = t2, $[41] = t7) : t7 = $[41];
  let t8;
  $[42] !== t7 ? (t8 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, muted: true, children: t7 }), $[42] = t7, $[43] = t8) : t8 = $[43];
  const t9 = sinceEvent || null;
  let t10;
  $[44] !== sinceEvents || $[45] !== t9 ? (t10 = (0, import_jsx_runtime2.jsx)(EventsTimelineMenu, { event: t9, events: sinceEvents, mode: "since", placement: "bottom-start" }), $[44] = sinceEvents, $[45] = t9, $[46] = t10) : t10 = $[46];
  let t11;
  $[47] !== t2 ? (t11 = t2("changes.inspector.to-label"), $[47] = t2, $[48] = t11) : t11 = $[48];
  let t12;
  $[49] !== t11 ? (t12 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, muted: true, children: t11 }), $[49] = t11, $[50] = t12) : t12 = $[50];
  const t13 = toEvent || null;
  let t14;
  $[51] !== events || $[52] !== t13 ? (t14 = (0, import_jsx_runtime2.jsx)(EventsTimelineMenu, { event: t13, events, mode: "rev", placement: "bottom-end" }), $[51] = events, $[52] = t13, $[53] = t14) : t14 = $[53];
  let t15;
  $[54] !== t10 || $[55] !== t12 || $[56] !== t14 || $[57] !== t8 ? (t15 = (0, import_jsx_runtime2.jsxs)(Grid, { paddingX: 2, paddingBottom: 2, children: [
    t8,
    t10,
    t12,
    t14
  ] }), $[54] = t10, $[55] = t12, $[56] = t14, $[57] = t8, $[58] = t15) : t15 = $[58];
  let t16;
  $[59] !== diffLoading || $[60] !== t2 ? (t16 = diffLoading && (0, import_jsx_runtime2.jsx)(motion.div, { animate: {
    opacity: 1
  }, initial: {
    opacity: 0
  }, transition: {
    delay: 0.2,
    duration: 0.2
  }, children: (0, import_jsx_runtime2.jsxs)(SpinnerContainer, { justify: "center", align: "center", gap: 2, children: [
    (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 0, children: t2("changes.loading-changes") }),
    (0, import_jsx_runtime2.jsx)(Spinner, { size: 0 })
  ] }) }), $[59] = diffLoading, $[60] = t2, $[61] = t16) : t16 = $[61];
  let t17;
  $[62] !== t15 || $[63] !== t16 ? (t17 = (0, import_jsx_runtime2.jsxs)(Box, { padding: 3, style: t6, children: [
    t15,
    t16
  ] }), $[62] = t15, $[63] = t16, $[64] = t17) : t17 = $[64];
  let t18;
  $[65] !== diffError || $[66] !== documentContext || $[67] !== revision?.loading || $[68] !== schemaType || $[69] !== showChanges || $[70] !== sinceEvent || $[71] !== sinceRevision?.loading || $[72] !== timelineError || $[73] !== toEvent?.id ? (t18 = showChanges && (0, import_jsx_runtime2.jsx)(Content, { documentContext, error: timelineError || diffError, loading: revision?.loading || sinceRevision?.loading || false, schemaType, sameRevisionSelected: sinceEvent?.id === toEvent?.id, sinceEvent }), $[65] = diffError, $[66] = documentContext, $[67] = revision?.loading, $[68] = schemaType, $[69] = showChanges, $[70] = sinceEvent, $[71] = sinceRevision?.loading, $[72] = timelineError, $[73] = toEvent?.id, $[74] = t18) : t18 = $[74];
  let t19;
  $[75] !== t18 ? (t19 = (0, import_jsx_runtime2.jsx)(Scroller$2, { "data-ui": "Scroller", ref: setScrollRef, children: (0, import_jsx_runtime2.jsx)(Box, { flex: 1, paddingX: 3, height: "fill", children: t18 }) }), $[75] = t18, $[76] = t19) : t19 = $[76];
  let t20;
  $[77] !== scrollRef || $[78] !== t19 ? (t20 = (0, import_jsx_runtime2.jsx)(Card, { flex: 1, paddingX: 2, paddingY: 2, children: (0, import_jsx_runtime2.jsx)(BoundaryElementProvider, { element: scrollRef, children: t19 }) }), $[77] = scrollRef, $[78] = t19, $[79] = t20) : t20 = $[79];
  let t21;
  return $[80] !== t17 || $[81] !== t20 ? (t21 = (0, import_jsx_runtime2.jsxs)(Flex, { "data-testid": "review-changes-pane", direction: "column", height: "fill", overflow: "hidden", children: [
    t17,
    t20
  ] }), $[80] = t17, $[81] = t20, $[82] = t21) : t21 = $[82], t21;
}
function _temp2$2(props) {
  return props.path.length > 0 ? (0, import_jsx_runtime2.jsx)(ChangeFieldWrapper, { ...props }) : props.children;
}
function Content(t0) {
  const $ = (0, import_compiler_runtime2.c)(15), {
    error,
    documentContext,
    loading,
    schemaType,
    sameRevisionSelected,
    sinceEvent
  } = t0;
  if (error) {
    let t12;
    $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t12 = (0, import_jsx_runtime2.jsx)(CompareWithPublishedView, {}), $[0] = t12) : t12 = $[0];
    let t22;
    $[1] !== error || $[2] !== sinceEvent?.type ? (t22 = sinceEvent?.type !== "historyCleared" && (0, import_jsx_runtime2.jsx)(ChangesError, { error }), $[1] = error, $[2] = sinceEvent?.type, $[3] = t22) : t22 = $[3];
    let t3;
    return $[4] !== t22 ? (t3 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      t12,
      t22
    ] }), $[4] = t22, $[5] = t3) : t3 = $[5], t3;
  }
  if (loading) {
    let t12;
    return $[6] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t12 = (0, import_jsx_runtime2.jsx)(LoadingBlock, { showText: true }), $[6] = t12) : t12 = $[6], t12;
  }
  if (sameRevisionSelected) {
    let t12;
    return $[7] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t12 = (0, import_jsx_runtime2.jsx)(SameRevisionSelected, {}), $[7] = t12) : t12 = $[7], t12;
  }
  if (!documentContext.rootDiff) {
    let t12;
    return $[8] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t12 = (0, import_jsx_runtime2.jsx)(motion.div, { animate: {
      opacity: 1
    }, initial: {
      opacity: 0
    }, transition: {
      delay: 0.2,
      duration: 0.2
    }, children: (0, import_jsx_runtime2.jsx)(NoChanges, {}) }), $[8] = t12) : t12 = $[8], t12;
  }
  let t1;
  $[9] !== documentContext.rootDiff || $[10] !== schemaType ? (t1 = (0, import_jsx_runtime2.jsx)(Box, { paddingY: 1, children: (0, import_jsx_runtime2.jsx)(ChangeList, { diff: documentContext.rootDiff, schemaType }) }), $[9] = documentContext.rootDiff, $[10] = schemaType, $[11] = t1) : t1 = $[11];
  let t2;
  return $[12] !== documentContext || $[13] !== t1 ? (t2 = (0, import_jsx_runtime2.jsx)(DocumentChangeContext.Provider, { value: documentContext, children: t1 }), $[12] = documentContext, $[13] = t1, $[14] = t2) : t2 = $[14], t2;
}
function SameRevisionSelected() {
  const $ = (0, import_compiler_runtime2.c)(12), {
    t: t2
  } = useTranslation("");
  let t0, t1, t22;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    opacity: 1
  }, t1 = {
    opacity: 0
  }, t22 = {
    delay: 0.2,
    duration: 0.2
  }, $[0] = t0, $[1] = t1, $[2] = t22) : (t0 = $[0], t1 = $[1], t22 = $[2]);
  let t3;
  $[3] !== t2 ? (t3 = t2("changes.same-revision-selected-title"), $[3] = t2, $[4] = t3) : t3 = $[4];
  let t4;
  $[5] !== t3 ? (t4 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", as: "h3", children: t3 }), $[5] = t3, $[6] = t4) : t4 = $[6];
  let t5;
  $[7] !== t2 ? (t5 = (0, import_jsx_runtime2.jsx)(Text, { as: "p", size: 1, muted: true, children: (0, import_jsx_runtime2.jsx)(Translate, { i18nKey: "changes.same-revision-selected-description", t: t2 }) }), $[7] = t2, $[8] = t5) : t5 = $[8];
  let t6;
  return $[9] !== t4 || $[10] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(motion.div, { animate: t0, initial: t1, transition: t22, children: (0, import_jsx_runtime2.jsxs)(Stack, { space: 3, paddingTop: 2, children: [
    t4,
    t5
  ] }) }), $[9] = t4, $[10] = t5, $[11] = t6) : t6 = $[11], t6;
}
function _temp$4(props) {
  return props.children;
}
var Scroller$1 = at(ScrollContainer).withConfig({
  displayName: "Scroller",
  componentId: "sc-1f5fnfo-0"
})`height:100%;overflow:auto;position:relative;scroll-behavior:smooth;`;
function EventsSelector(t0) {
  const $ = (0, import_compiler_runtime2.c)(21), {
    showList
  } = t0, [scrollRef, setScrollRef] = (0, import_react2.useState)(null), [listHeight, setListHeight] = (0, import_react2.useState)(0), {
    setTimelineRange
  } = useDocumentPane();
  let t1;
  $[0] !== listHeight ? (t1 = (el) => {
    !listHeight && el && (setListHeight(el.clientHeight ? el.clientHeight - 1 : 0), setScrollRef(el));
  }, $[0] = listHeight, $[1] = t1) : t1 = $[1];
  const getScrollerRef = t1, {
    events,
    nextCursor,
    loading,
    error,
    revision,
    loadMoreEvents,
    findRangeForRevision,
    expandEvent
  } = useEvents(), {
    t: t2
  } = useTranslation("studio"), toast = useToast();
  let t22;
  $[2] !== findRangeForRevision || $[3] !== setTimelineRange || $[4] !== t2 || $[5] !== toast ? (t22 = (event) => {
    const run = () => {
      if (isDeleteDocumentVersionEvent(event) || isDeleteDocumentGroupEvent(event) || isUnpublishDocumentEvent(event) || isScheduleDocumentVersionEvent(event) || isUnscheduleDocumentVersionEvent(event)) {
        console.error("Event is not selectable");
        return;
      }
      const [since, rev] = findRangeForRevision(event.id);
      setTimelineRange(since, rev);
    };
    try {
      run();
    } catch (t32) {
      const err = t32;
      toast.push({
        closable: true,
        description: err.message,
        status: "error",
        title: t2("timeline.error.unable-to-load-revision")
      });
    }
  }, $[2] = findRangeForRevision, $[3] = setTimelineRange, $[4] = t2, $[5] = toast, $[6] = t22) : t22 = $[6];
  const selectRev = t22, initialLoad = loading && !events.length;
  let t3;
  return $[7] !== error || $[8] !== events || $[9] !== expandEvent || $[10] !== getScrollerRef || $[11] !== initialLoad || $[12] !== listHeight || $[13] !== loadMoreEvents || $[14] !== loading || $[15] !== nextCursor || $[16] !== revision?.revisionId || $[17] !== scrollRef || $[18] !== selectRev || $[19] !== showList ? (t3 = (0, import_jsx_runtime2.jsx)(Flex, { "data-testid": "review-changes-pane", direction: "column", height: "fill", children: (0, import_jsx_runtime2.jsx)(Card, { flex: 1, padding: 2, paddingTop: 0, children: error ? (0, import_jsx_runtime2.jsx)(TimelineError, {}) : (0, import_jsx_runtime2.jsx)(BoundaryElementProvider, { element: scrollRef, children: (0, import_jsx_runtime2.jsxs)(Scroller$1, { "data-ui": "Scroller", ref: getScrollerRef, children: [
    listHeight && showList && !initialLoad ? (0, import_jsx_runtime2.jsx)(EventsTimeline, { events, fetchEventChildren: expandEvent, hasMoreEvents: !!nextCursor, selectedEventId: revision?.revisionId || events[0]?.id, onLoadMore: loadMoreEvents, onSelect: selectRev, listMaxHeight: `${listHeight}px` }) : null,
    loading && (0, import_jsx_runtime2.jsx)(LoadingBlock, {})
  ] }) }) }) }), $[7] = error, $[8] = events, $[9] = expandEvent, $[10] = getScrollerRef, $[11] = initialLoad, $[12] = listHeight, $[13] = loadMoreEvents, $[14] = loading, $[15] = nextCursor, $[16] = revision?.revisionId, $[17] = scrollRef, $[18] = selectRev, $[19] = showList, $[20] = t3) : t3 = $[20], t3;
}
var Scroller = at(ScrollContainer).withConfig({
  displayName: "Scroller",
  componentId: "sc-1ey5vbx-0"
})`height:100%;overflow:auto;position:relative;scroll-behavior:smooth;`;
function HistorySelector(t0) {
  const $ = (0, import_compiler_runtime2.c)(20), {
    showList
  } = t0, {
    timelineError,
    setTimelineRange,
    timelineStore
  } = useDocumentPane(), {
    selectedReleaseId
  } = usePerspective(), [scrollRef, setScrollRef] = (0, import_react2.useState)(null), [listHeight, setListHeight] = (0, import_react2.useState)(0);
  let t1;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t1 = (el) => {
    el?.clientHeight && (setListHeight(el.clientHeight - 1), setScrollRef(el));
  }, $[0] = t1) : t1 = $[0];
  const getScrollerRef = t1, chunks = useTimelineSelector(timelineStore, _temp$3), realRevChunk = useTimelineSelector(timelineStore, _temp2$1), hasMoreChunks = useTimelineSelector(timelineStore, _temp3$1), loading = useTimelineSelector(timelineStore, _temp4$1), {
    t: t2
  } = useTranslation("studio"), toast = useToast();
  let t22;
  $[1] !== setTimelineRange || $[2] !== t2 || $[3] !== timelineStore || $[4] !== toast ? (t22 = (revChunk) => {
    const run = () => {
      const [sinceId, revId] = timelineStore?.findRangeForRev(revChunk) || [null, null];
      setTimelineRange(sinceId, revId);
    };
    try {
      run();
    } catch (t32) {
      const err = t32;
      toast.push({
        closable: true,
        description: err.message,
        status: "error",
        title: t2("timeline.error.unable-to-load-revision")
      });
    }
  }, $[1] = setTimelineRange, $[2] = t2, $[3] = timelineStore, $[4] = toast, $[5] = t22) : t22 = $[5];
  const selectRev = t22;
  let t3;
  $[6] !== loading || $[7] !== timelineStore ? (t3 = () => {
    loading || timelineStore?.loadMore();
  }, $[6] = loading, $[7] = timelineStore, $[8] = t3) : t3 = $[8];
  const handleLoadMore = t3;
  let t4;
  return $[9] !== chunks || $[10] !== handleLoadMore || $[11] !== hasMoreChunks || $[12] !== listHeight || $[13] !== realRevChunk || $[14] !== scrollRef || $[15] !== selectRev || $[16] !== selectedReleaseId || $[17] !== showList || $[18] !== timelineError ? (t4 = (0, import_jsx_runtime2.jsx)(Flex, { "data-testid": "review-changes-pane", direction: "column", height: "fill", children: (0, import_jsx_runtime2.jsx)(Card, { flex: 1, padding: 2, paddingTop: 0, children: timelineError || selectedReleaseId ? (0, import_jsx_runtime2.jsx)(TimelineError, { versionError: !!selectedReleaseId }) : (0, import_jsx_runtime2.jsx)(BoundaryElementProvider, { element: scrollRef, children: (0, import_jsx_runtime2.jsx)(Scroller, { "data-ui": "Scroller", ref: getScrollerRef, children: listHeight && showList ? (0, import_jsx_runtime2.jsx)(Timeline, { chunks, hasMoreChunks, lastChunk: realRevChunk, onLoadMore: handleLoadMore, onSelect: selectRev, listMaxHeight: `${listHeight}px` }) : null }) }) }) }), $[9] = chunks, $[10] = handleLoadMore, $[11] = hasMoreChunks, $[12] = listHeight, $[13] = realRevChunk, $[14] = scrollRef, $[15] = selectRev, $[16] = selectedReleaseId, $[17] = showList, $[18] = timelineError, $[19] = t4) : t4 = $[19], t4;
}
function _temp4$1(state_2) {
  return state_2.isLoading;
}
function _temp3$1(state_1) {
  return state_1.hasMoreChunks;
}
function _temp2$1(state_0) {
  return state_0.realRevChunk;
}
function _temp$3(state2) {
  return state2.chunks;
}
var FadeInFlex$1 = at(Flex).withConfig({
  displayName: "FadeInFlex",
  componentId: "sc-a5131c-0"
})`opacity:0;transition:opacity 200ms;&[data-ready]{opacity:1;}`;
var TABS = ["history", "review"];
var isValidTab = (tab) => (
  // @ts-expect-error TS doesn't understand the type guard
  tab && TABS.includes(tab)
);
function ChangesTabs(props) {
  const $ = (0, import_compiler_runtime2.c)(73), {
    params,
    setParams
  } = usePaneRouter(), source = useSource(), [parentRef, setParentRef] = (0, import_react2.useState)(null), {
    t: t2
  } = useTranslation(structureLocaleNamespace), {
    t: tCore
  } = useTranslation(), isReady = params?.inspect === HISTORY_INSPECTOR_NAME, {
    selectedPerspective
  } = usePerspective();
  let t0;
  $[0] !== params ? (t0 = isValidTab(params?.changesInspectorTab) ? params.changesInspectorTab : TABS[0], $[0] = params, $[1] = t0) : t0 = $[1];
  const paneRouterTab = t0;
  let t1;
  $[2] !== params || $[3] !== setParams ? (t1 = (tab) => setParams({
    ...params,
    changesInspectorTab: tab,
    since: tab === "history" ? void 0 : params?.since
  }), $[2] = params, $[3] = setParams, $[4] = t1) : t1 = $[4];
  const setPaneRouterTab = t1, t22 = isReady ? "" : void 0;
  let t3;
  $[5] !== t2 ? (t3 = t2("changes.tab.history"), $[5] = t2, $[6] = t3) : t3 = $[6];
  let t4;
  $[7] !== setPaneRouterTab ? (t4 = () => setPaneRouterTab("history"), $[7] = setPaneRouterTab, $[8] = t4) : t4 = $[8];
  const t5 = paneRouterTab === "history";
  let t6;
  $[9] !== t3 || $[10] !== t4 || $[11] !== t5 ? (t6 = (0, import_jsx_runtime2.jsx)(Tab, { "aria-controls": "history-panel", id: "history-tab", label: t3, onClick: t4, selected: t5 }), $[9] = t3, $[10] = t4, $[11] = t5, $[12] = t6) : t6 = $[12];
  let t7;
  $[13] !== t2 ? (t7 = t2("changes.tab.review-changes"), $[13] = t2, $[14] = t7) : t7 = $[14];
  let t8;
  $[15] !== setPaneRouterTab ? (t8 = () => setPaneRouterTab("review"), $[15] = setPaneRouterTab, $[16] = t8) : t8 = $[16];
  const t9 = paneRouterTab === "review";
  let t10;
  $[17] !== t7 || $[18] !== t8 || $[19] !== t9 ? (t10 = (0, import_jsx_runtime2.jsx)(Tab, { "aria-controls": "review-changes-panel", id: "changes-tab", label: t7, onClick: t8, selected: t9 }), $[17] = t7, $[18] = t8, $[19] = t9, $[20] = t10) : t10 = $[20];
  let t11;
  $[21] !== t10 || $[22] !== t6 ? (t11 = (0, import_jsx_runtime2.jsxs)(TabList, { space: 1, flex: 1, children: [
    t6,
    t10
  ] }), $[21] = t10, $[22] = t6, $[23] = t11) : t11 = $[23];
  let t12;
  $[24] !== t2 ? (t12 = t2("changes.action.close-label"), $[24] = t2, $[25] = t12) : t12 = $[25];
  const t13 = props.onClose;
  let t14;
  $[26] !== t2 ? (t14 = t2("document-inspector.close-button.tooltip"), $[26] = t2, $[27] = t14) : t14 = $[27];
  let t15;
  $[28] !== t14 ? (t15 = {
    content: t14
  }, $[28] = t14, $[29] = t15) : t15 = $[29];
  let t16;
  $[30] !== props.onClose || $[31] !== t12 || $[32] !== t15 ? (t16 = (0, import_jsx_runtime2.jsx)(Button2, { "aria-label": t12, icon: CloseIcon, mode: "bleed", onClick: t13, tooltipProps: t15 }), $[30] = props.onClose, $[31] = t12, $[32] = t15, $[33] = t16) : t16 = $[33];
  let t17;
  $[34] !== t11 || $[35] !== t16 ? (t17 = (0, import_jsx_runtime2.jsx)(Card, { paddingBottom: 1, children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", padding: 3, gap: 2, children: [
    t11,
    t16
  ] }) }), $[34] = t11, $[35] = t16, $[36] = t17) : t17 = $[36];
  let t18;
  $[37] !== t2 ? (t18 = (0, import_jsx_runtime2.jsx)(Box, { flex: 1, padding: 1, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(Translate, { t: t2, i18nKey: "changes.banner.tooltip" }) }) }), $[37] = t2, $[38] = t18) : t18 = $[38];
  let t19;
  $[39] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t19 = (0, import_jsx_runtime2.jsx)(Text, { size: 0, muted: true, children: (0, import_jsx_runtime2.jsx)(InfoOutlineIcon, { fontSize: 1 }) }), $[39] = t19) : t19 = $[39];
  let t20;
  $[40] !== parentRef || $[41] !== t18 ? (t20 = (0, import_jsx_runtime2.jsx)(Tooltip, { portal: true, placement: "bottom-end", boundaryElement: parentRef, content: t18, children: t19 }), $[40] = parentRef, $[41] = t18, $[42] = t20) : t20 = $[42];
  let t21;
  $[43] !== selectedPerspective || $[44] !== t2 || $[45] !== tCore ? (t21 = perspectiveLabel(selectedPerspective, {
    t: t2,
    tCore
  }), $[43] = selectedPerspective, $[44] = t2, $[45] = tCore, $[46] = t21) : t21 = $[46];
  let t222;
  $[47] !== t21 ? (t222 = {
    perspective: t21
  }, $[47] = t21, $[48] = t222) : t222 = $[48];
  let t23;
  $[49] !== t2 || $[50] !== t222 ? (t23 = (0, import_jsx_runtime2.jsx)(Text, { size: 0, muted: true, children: (0, import_jsx_runtime2.jsx)(Translate, { t: t2, values: t222, i18nKey: "changes.banner.description" }) }), $[49] = t2, $[50] = t222, $[51] = t23) : t23 = $[51];
  let t24;
  $[52] !== t20 || $[53] !== t23 ? (t24 = (0, import_jsx_runtime2.jsx)(Card, { padding: 2, marginBottom: 3, marginX: 3, tone: "neutral", border: true, radius: 3, children: (0, import_jsx_runtime2.jsxs)(Flex, { gap: 2, align: "flex-start", children: [
    t20,
    t23
  ] }) }), $[52] = t20, $[53] = t23, $[54] = t24) : t24 = $[54];
  const t25 = paneRouterTab !== "history";
  let t26;
  $[55] !== paneRouterTab || $[56] !== source.beta?.eventsAPI?.documents ? (t26 = source.beta?.eventsAPI?.documents ? (0, import_jsx_runtime2.jsx)(EventsSelector, { showList: paneRouterTab === "history" }) : (0, import_jsx_runtime2.jsx)(HistorySelector, { showList: paneRouterTab === "history" }), $[55] = paneRouterTab, $[56] = source.beta?.eventsAPI?.documents, $[57] = t26) : t26 = $[57];
  let t27;
  $[58] !== t25 || $[59] !== t26 ? (t27 = (0, import_jsx_runtime2.jsx)(TabPanel, { "aria-labelledby": "history-tab", height: "fill", hidden: t25, id: "history-panel", children: t26 }), $[58] = t25, $[59] = t26, $[60] = t27) : t27 = $[60];
  const t28 = paneRouterTab !== "review";
  let t29;
  $[61] !== paneRouterTab || $[62] !== source.beta?.eventsAPI?.documents ? (t29 = source.beta?.eventsAPI?.documents ? (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: paneRouterTab === "review" ? (0, import_jsx_runtime2.jsx)(EventsInspector, { showChanges: paneRouterTab === "review" }) : null }) : (0, import_jsx_runtime2.jsx)(ChangesInspector, { showChanges: paneRouterTab === "review" }), $[61] = paneRouterTab, $[62] = source.beta?.eventsAPI?.documents, $[63] = t29) : t29 = $[63];
  let t30;
  $[64] !== t28 || $[65] !== t29 ? (t30 = (0, import_jsx_runtime2.jsx)(TabPanel, { "aria-labelledby": "review-tab", hidden: t28, id: "review-panel", height: "fill", children: t29 }), $[64] = t28, $[65] = t29, $[66] = t30) : t30 = $[66];
  let t31;
  return $[67] !== t17 || $[68] !== t22 || $[69] !== t24 || $[70] !== t27 || $[71] !== t30 ? (t31 = (0, import_jsx_runtime2.jsxs)(FadeInFlex$1, { direction: "column", padding: 0, height: "fill", "data-ready": t22, ref: setParentRef, children: [
    t17,
    t24,
    t27,
    t30
  ] }), $[67] = t17, $[68] = t22, $[69] = t24, $[70] = t27, $[71] = t30, $[72] = t31) : t31 = $[72], t31;
}
function perspectiveLabel(perspective, {
  t: t2,
  tCore
}) {
  return isReleaseDocument(perspective) ? perspective.metadata.title || tCore("release.placeholder-untitled-release") : perspective === "drafts" ? t2("compare-versions.status.draft") : perspective === "published" ? t2("compare-versions.status.published") : perspective;
}
var changesInspector = {
  name: HISTORY_INSPECTOR_NAME,
  useMenuItem: () => {
    const {
      features
    } = useStructureTool(), {
      t: t2
    } = useTranslation();
    return {
      hidden: !features.reviewChanges,
      icon: RestoreIcon,
      title: t2("changes.title")
    };
  },
  component: ChangesTabs,
  onClose: ({
    params
  }) => ({
    params: {
      ...params,
      since: void 0,
      rev: void 0,
      changesInspectorTab: void 0,
      historyVersion: void 0
    }
  }),
  onOpen: ({
    params
  }) => ({
    params: {
      ...params,
      since: "@lastPublished"
    }
  })
};
var FadeInFlex = motion.create(Flex);
var IncomingReferenceDocument = (props) => {
  const $ = (0, import_compiler_runtime2.c)(25), {
    t: t2
  } = useTranslation(structureLocaleNamespace), {
    document: document2,
    referenceToId
  } = props;
  let t0;
  $[0] !== document2 || $[1] !== referenceToId ? (t0 = getReferencePaths(document2, referenceToId), $[0] = document2, $[1] = referenceToId, $[2] = t0) : t0 = $[2];
  const referencePaths = t0, id = document2._id, schema = useSchema(), {
    navigate
  } = useRouter(), {
    routerPanesState,
    groupIndex
  } = usePaneRouter(), type = document2?._type;
  let t1;
  $[3] !== groupIndex || $[4] !== id || $[5] !== navigate || $[6] !== referencePaths || $[7] !== routerPanesState || $[8] !== type ? (t1 = () => {
    type && navigate({
      panes: [...routerPanesState.slice(0, groupIndex + 1), [{
        id: getPublishedId(id),
        params: {
          type,
          path: pathToString$1(referencePaths[0])
        }
      }]]
    });
  }, $[3] = groupIndex, $[4] = id, $[5] = navigate, $[6] = referencePaths, $[7] = routerPanesState, $[8] = type, $[9] = t1) : t1 = $[9];
  const handleClick = t1;
  let t22;
  $[10] !== document2._type || $[11] !== schema ? (t22 = schema.get(document2._type), $[10] = document2._type, $[11] = schema, $[12] = t22) : t22 = $[12];
  const schemaType = t22;
  if (!schemaType) {
    let t32;
    $[13] !== document2._type || $[14] !== t2 ? (t32 = t2("incoming-references-pane.schema-type-not-found", {
      type: document2._type
    }), $[13] = document2._type, $[14] = t2, $[15] = t32) : t32 = $[15];
    let t42;
    return $[16] !== t32 ? (t42 = (0, import_jsx_runtime2.jsx)(Card, { radius: 2, tone: "critical", children: (0, import_jsx_runtime2.jsx)(Box, { paddingY: 4, paddingX: 3, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: t32 }) }) }), $[16] = t32, $[17] = t42) : t42 = $[17], t42;
  }
  let t3, t4;
  $[18] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t3 = {
    opacity: 0
  }, t4 = {
    opacity: 1
  }, $[18] = t3, $[19] = t4) : (t3 = $[18], t4 = $[19]);
  let t5;
  return $[20] !== document2 || $[21] !== handleClick || $[22] !== referencePaths[0] || $[23] !== schemaType ? (t5 = (0, import_jsx_runtime2.jsx)(Card, { radius: 2, tone: "default", children: (0, import_jsx_runtime2.jsx)(FadeInFlex, { initial: t3, animate: t4, gap: 1, align: "center", children: (0, import_jsx_runtime2.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime2.jsx)(IncomingReferencePreview, { type: schemaType, value: document2, onClick: handleClick, path: referencePaths[0] }) }) }) }), $[20] = document2, $[21] = handleClick, $[22] = referencePaths[0], $[23] = schemaType, $[24] = t5) : t5 = $[24], t5;
};
function TypeSection(t0) {
  const $ = (0, import_compiler_runtime2.c)(16), {
    type,
    documents,
    renderItem,
    getItemKey,
    emptyMessage
  } = t0, schema = useSchema(), {
    t: t2
  } = useTranslation(structureLocaleNamespace);
  let t1;
  $[0] !== schema || $[1] !== type ? (t1 = schema.get(type), $[0] = schema, $[1] = type, $[2] = t1) : t1 = $[2];
  const title = t1?.title || type;
  let t22;
  $[3] !== title ? (t22 = (0, import_jsx_runtime2.jsx)(Flex, { align: "center", justify: "space-between", paddingBottom: 2, gap: 2, children: (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: title }) }) }), $[3] = title, $[4] = t22) : t22 = $[4];
  let t3;
  $[5] !== documents || $[6] !== emptyMessage || $[7] !== getItemKey || $[8] !== renderItem || $[9] !== t2 || $[10] !== title ? (t3 = documents.length > 0 ? (0, import_jsx_runtime2.jsx)(Card, { radius: 2, padding: 1, border: true, tone: "default", children: (0, import_jsx_runtime2.jsx)(IncomingReferencesListContainer, { $itemCount: documents.length, children: (0, import_jsx_runtime2.jsx)(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: t2("incoming-references-input.list-label", {
    type: title
  }), canReceiveFocus: true, fixedHeight: true, getItemKey, itemHeight: INCOMING_REFERENCES_ITEM_HEIGHT, items: documents, onlyShowSelectionWhenActive: true, overscan: 5, renderItem, wrapAround: false }) }) }) : (0, import_jsx_runtime2.jsx)(Box, { padding: 0, children: (0, import_jsx_runtime2.jsx)(Card, { border: true, radius: 3, padding: 1, tone: "default", children: (0, import_jsx_runtime2.jsx)(Box, { paddingY: 3, paddingX: 2, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, muted: true, children: emptyMessage }) }) }) }), $[5] = documents, $[6] = emptyMessage, $[7] = getItemKey, $[8] = renderItem, $[9] = t2, $[10] = title, $[11] = t3) : t3 = $[11];
  let t4;
  return $[12] !== t22 || $[13] !== t3 || $[14] !== type ? (t4 = (0, import_jsx_runtime2.jsxs)(Stack, { padding: 2, space: 1, marginBottom: 2, children: [
    t22,
    t3
  ] }, type), $[12] = t22, $[13] = t3, $[14] = type, $[15] = t4) : t4 = $[15], t4;
}
function IncomingReferencesList() {
  const $ = (0, import_compiler_runtime2.c)(26), {
    documentId
  } = useDocumentPane(), {
    t: t2
  } = useTranslation(structureLocaleNamespace), {
    getClient
  } = useSource(), documentPreviewStore = useDocumentPreviewStore(), client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  let t0;
  $[0] !== documentId || $[1] !== documentPreviewStore || $[2] !== getClient ? (t0 = getIncomingReferences({
    documentId,
    documentPreviewStore,
    getClient
  }).pipe(map(_temp3), map(_temp4)), $[0] = documentId, $[1] = documentPreviewStore, $[2] = getClient, $[3] = t0) : t0 = $[3];
  const references = useObservable(t0, null);
  let t1;
  $[4] !== client || $[5] !== documentId || $[6] !== documentPreviewStore ? (t1 = getCrossDatasetIncomingReferences({
    documentId,
    client,
    documentPreviewStore
  }).pipe(map(_temp7), map(_temp8)), $[4] = client, $[5] = documentId, $[6] = documentPreviewStore, $[7] = t1) : t1 = $[7];
  const crossDatasetRefs = useObservable(t1, null);
  let t22;
  $[8] !== documentId ? (t22 = (document2) => (0, import_jsx_runtime2.jsx)(IncomingReferenceDocument, { document: document2, referenceToId: documentId }), $[8] = documentId, $[9] = t22) : t22 = $[9];
  const renderSameDatasetItem = t22, renderCrossDatasetItem = _temp9;
  let t3;
  $[10] !== t2 ? (t3 = t2("incoming-references-pane.no-references-found"), $[10] = t2, $[11] = t3) : t3 = $[11];
  const emptyMessage = t3;
  let t4;
  $[12] !== emptyMessage || $[13] !== references?.list || $[14] !== references?.loading || $[15] !== renderSameDatasetItem || $[16] !== t2 ? (t4 = references?.loading ? (0, import_jsx_runtime2.jsx)(LoadingBlock, { showText: true, title: t2("incoming-references-input.types-loading") }) : references?.list.map((t52) => {
    const {
      type: type_3,
      documents: documents_1
    } = t52;
    return (0, import_jsx_runtime2.jsx)(TypeSection, { type: type_3, documents: documents_1, renderItem: renderSameDatasetItem, getItemKey: (index) => documents_1[index]._id, emptyMessage }, type_3);
  }), $[12] = emptyMessage, $[13] = references?.list, $[14] = references?.loading, $[15] = renderSameDatasetItem, $[16] = t2, $[17] = t4) : t4 = $[17];
  let t5;
  $[18] !== crossDatasetRefs?.list || $[19] !== crossDatasetRefs?.loading || $[20] !== emptyMessage || $[21] !== t2 ? (t5 = crossDatasetRefs?.loading ? (0, import_jsx_runtime2.jsx)(LoadingBlock, { showText: true, title: t2("incoming-references-input.types-loading-cross-dataset") }) : crossDatasetRefs?.list.map((t62) => {
    const {
      type: type_4,
      documents: documents_2
    } = t62;
    return (0, import_jsx_runtime2.jsx)(TypeSection, { type: type_4, documents: documents_2, renderItem: renderCrossDatasetItem, getItemKey: (index_0) => documents_2[index_0].id, emptyMessage }, type_4);
  }), $[18] = crossDatasetRefs?.list, $[19] = crossDatasetRefs?.loading, $[20] = emptyMessage, $[21] = t2, $[22] = t5) : t5 = $[22];
  let t6;
  return $[23] !== t4 || $[24] !== t5 ? (t6 = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    t4,
    t5
  ] }), $[23] = t4, $[24] = t5, $[25] = t6) : t6 = $[25], t6;
}
function _temp9(document_0) {
  return (0, import_jsx_runtime2.jsx)(CrossDatasetIncomingReferenceDocumentPreview, { document: document_0 });
}
function _temp8(list_0) {
  return {
    list: list_0,
    loading: false
  };
}
function _temp7(t0) {
  const {
    documents: documents_0
  } = t0, documentsByType_0 = documents_0.reduce(_temp5, {});
  return Object.entries(documentsByType_0).map(_temp6);
}
function _temp6(t0) {
  const [type_2, docs_0] = t0;
  return {
    type: type_2,
    documents: docs_0
  };
}
function _temp5(acc_0, doc_0) {
  const type_1 = doc_0.type;
  return acc_0[type_1] ? acc_0[type_1].push(doc_0) : acc_0[type_1] = [doc_0], acc_0;
}
function _temp4(list) {
  return {
    list,
    loading: false
  };
}
function _temp3(t0) {
  const {
    documents
  } = t0, documentsByType = documents.reduce(_temp$2, {});
  return Object.entries(documentsByType).map(_temp2);
}
function _temp2(t0) {
  const [type_0, docs] = t0;
  return {
    type: type_0,
    documents: docs
  };
}
function _temp$2(acc, doc) {
  const type = doc._type;
  return acc[type] ? acc[type].push(doc) : acc[type] = [doc], acc;
}
var IncomingReferencesInspector = (props) => {
  const $ = (0, import_compiler_runtime2.c)(11), {
    t: t2
  } = useTranslation();
  let t0;
  $[0] !== t2 ? (t0 = t2("panel.close-button-aria-label"), $[0] = t2, $[1] = t0) : t0 = $[1];
  const t1 = props.onClose;
  let t22;
  $[2] !== t2 ? (t22 = t2("incoming-references.title"), $[2] = t2, $[3] = t22) : t22 = $[3];
  let t3;
  $[4] !== props.onClose || $[5] !== t0 || $[6] !== t22 ? (t3 = (0, import_jsx_runtime2.jsx)(DocumentInspectorHeader, { as: "header", closeButtonLabel: t0, flex: "none", onClose: t1, title: t22 }), $[4] = props.onClose, $[5] = t0, $[6] = t22, $[7] = t3) : t3 = $[7];
  let t4;
  $[8] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t4 = (0, import_jsx_runtime2.jsx)(Card, { flex: 1, overflow: "auto", padding: 3, children: (0, import_jsx_runtime2.jsx)(IncomingReferencesList, {}) }), $[8] = t4) : t4 = $[8];
  let t5;
  return $[9] !== t3 ? (t5 = (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", height: "fill", overflow: "hidden", children: [
    t3,
    t4
  ] }), $[9] = t3, $[10] = t5) : t5 = $[10], t5;
};
var incomingReferencesInspector = {
  name: INCOMING_REFERENCES_INSPECTOR_NAME,
  useMenuItem: () => {
    const {
      t: t2
    } = useTranslation();
    return {
      icon: SyncIcon,
      title: t2("incoming-references.title")
    };
  },
  component: IncomingReferencesInspector
};
function getPathTitles(options) {
  const {
    path,
    schemaType,
    value
  } = options, result = [];
  let s2 = schemaType, v = value;
  for (const segment of path) {
    if (typeof segment == "string") {
      if (!isRecord$4(v) && v !== void 0)
        throw new Error(`Parent value is not an object, cannot get path segment: .${segment}`);
      if (s2.jsonType !== "object")
        throw new Error(`Parent type is not an object schema type, cannot get path segment: .${segment}`);
      v = v?.[segment];
      const field = s2.fields.find((f) => f.name === segment);
      if (!field)
        return result.push({
          name: segment
        }), result;
      s2 = field.type, result.push(s2);
      continue;
    }
    if (typeof segment == "number") {
      if (!isArray(v) && v !== void 0)
        throw new Error(`Parent value is not an array, cannot get path segment: [${segment}]`);
      if (s2.jsonType !== "array")
        throw new Error(`Parent type is not an array schema type, cannot get path segment: [${segment}]`);
      v = v?.[segment];
      const itemType = s2.of.find((ofType) => typeof v == "string" ? ofType.jsonType === "string" : typeof v == "number" ? ofType.jsonType === "number" : typeof v == "boolean" ? ofType.jsonType === "boolean" : isRecord$4(v) ? ofType.name === v?._type : false);
      if (!itemType)
        throw new Error(`Item type not found: [${segment}]`);
      s2 = itemType, result.push(s2);
      continue;
    }
    if (isRecord$4(segment) && segment._key) {
      if (typeof v > "u")
        return result;
      if (!isArray(v))
        throw new Error(`Parent value is not an array, cannot get path segment: [_key == ${segment}]`);
      if (s2.jsonType !== "array")
        throw new Error(`Parent type is not an array schema type, cannot get path segment: .${segment}`);
      if (v = (v ?? []).find((i) => isRecord$4(i) && i._key === segment._key), typeof v > "u")
        return result;
      if (!isRecord$4(v))
        throw new Error(`Array item not found: [_key == ${segment._key}]`);
      let ofType = s2.of.find((i) => isRecord$4(v) && i.name === v?._type);
      if (!ofType && !v?._type) {
        const objectTypes = s2.of.filter((i) => i.jsonType === "object");
        objectTypes.length === 1 && (ofType = objectTypes[0]);
      }
      if (!ofType)
        throw new Error(`Array item type not found: .${v?._type}`);
      s2 = ofType, result.push(s2);
      continue;
    }
    throw new Error(`Invalid path segment: ${JSON.stringify(segment)}`);
  }
  return result;
}
var MARKER_ICON = {
  error: ErrorOutlineIcon,
  warning: WarningOutlineIcon,
  info: InfoOutlineIcon
};
var MARKER_TONE = {
  error: "critical",
  warning: "caution",
  info: "primary"
};
function ValidationInspector(props) {
  const $ = (0, import_compiler_runtime2.c)(23), {
    onClose
  } = props, {
    onFocus,
    onPathOpen,
    schemaType,
    validation,
    value,
    editState
  } = useDocumentPane(), {
    t: t2
  } = useTranslation("validation");
  let t0;
  $[0] !== onFocus || $[1] !== onPathOpen ? (t0 = (path) => {
    onPathOpen(path), onFocus(path);
  }, $[0] = onFocus, $[1] = onPathOpen, $[2] = t0) : t0 = $[2];
  const handleOpen = t0;
  let t1;
  $[3] !== editState ? (t1 = editState && editState.version && isGoingToUnpublish(editState.version), $[3] = editState, $[4] = t1) : t1 = $[4];
  const isVersionGoingToUnpublish = t1;
  let t22;
  $[5] !== t2 ? (t22 = t2("panel.close-button-aria-label"), $[5] = t2, $[6] = t22) : t22 = $[6];
  let t3;
  $[7] !== t2 ? (t3 = t2("panel.title"), $[7] = t2, $[8] = t3) : t3 = $[8];
  let t4;
  $[9] !== onClose || $[10] !== t22 || $[11] !== t3 ? (t4 = (0, import_jsx_runtime2.jsx)(DocumentInspectorHeader, { as: "header", closeButtonLabel: t22, flex: "none", onClose, title: t3 }), $[9] = onClose, $[10] = t22, $[11] = t3, $[12] = t4) : t4 = $[12];
  let t5;
  $[13] !== handleOpen || $[14] !== isVersionGoingToUnpublish || $[15] !== schemaType || $[16] !== t2 || $[17] !== validation || $[18] !== value ? (t5 = (0, import_jsx_runtime2.jsx)(Card, { flex: 1, overflow: "auto", padding: 3, children: isVersionGoingToUnpublish ? (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: t2("panel.unpublish-message") }) }) : (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    validation.length === 0 && (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: t2("panel.no-errors-message") }) }),
    validation.length > 0 && (0, import_jsx_runtime2.jsx)(Stack, { space: 2, children: validation.map((marker, i) => (0, import_jsx_runtime2.jsx)(ValidationCard, { marker, onOpen: handleOpen, schemaType, value }, i)) })
  ] }) }), $[13] = handleOpen, $[14] = isVersionGoingToUnpublish, $[15] = schemaType, $[16] = t2, $[17] = validation, $[18] = value, $[19] = t5) : t5 = $[19];
  let t6;
  return $[20] !== t4 || $[21] !== t5 ? (t6 = (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", height: "fill", overflow: "hidden", children: [
    t4,
    t5
  ] }), $[20] = t4, $[21] = t5, $[22] = t6) : t6 = $[22], t6;
}
function ValidationCard(props) {
  const $ = (0, import_compiler_runtime2.c)(17), {
    marker,
    onOpen,
    schemaType,
    value
  } = props;
  let t0;
  $[0] !== marker.path || $[1] !== onOpen ? (t0 = () => onOpen(marker.path), $[0] = marker.path, $[1] = onOpen, $[2] = t0) : t0 = $[2];
  const handleOpen = t0, [errorInfo, setErrorInfo] = (0, import_react2.useState)(null), Icon = MARKER_ICON[marker.level];
  let t1;
  $[3] !== errorInfo ? (t1 = errorInfo && (0, import_jsx_runtime2.jsx)(Card, { padding: 3, radius: 2, tone: "critical", children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: errorInfo.error.message }) }), $[3] = errorInfo, $[4] = t1) : t1 = $[4];
  let t2;
  $[5] !== Icon || $[6] !== errorInfo || $[7] !== handleOpen || $[8] !== marker.level || $[9] !== marker.message || $[10] !== marker.path || $[11] !== schemaType || $[12] !== value ? (t2 = !errorInfo && (0, import_jsx_runtime2.jsx)(Card, { __unstable_focusRing: true, as: "button", onClick: handleOpen, padding: 3, radius: 2, tone: MARKER_TONE[marker.level], children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "flex-start", gap: 3, children: [
    (0, import_jsx_runtime2.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(Icon, {}) }) }),
    (0, import_jsx_runtime2.jsxs)(Stack, { flex: 1, space: 2, children: [
      (0, import_jsx_runtime2.jsx)(DocumentNodePathBreadcrumbs, { path: marker.path, schemaType, value }),
      (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: marker.message })
    ] })
  ] }) }), $[5] = Icon, $[6] = errorInfo, $[7] = handleOpen, $[8] = marker.level, $[9] = marker.message, $[10] = marker.path, $[11] = schemaType, $[12] = value, $[13] = t2) : t2 = $[13];
  let t3;
  return $[14] !== t1 || $[15] !== t2 ? (t3 = (0, import_jsx_runtime2.jsxs)(ErrorBoundary, { onCatch: setErrorInfo, children: [
    t1,
    t2
  ] }), $[14] = t1, $[15] = t2, $[16] = t3) : t3 = $[16], t3;
}
function DocumentNodePathBreadcrumbs(props) {
  const $ = (0, import_compiler_runtime2.c)(8), {
    path,
    schemaType,
    value
  } = props;
  let t0;
  bb0: {
    try {
      let t22;
      $[0] !== path || $[1] !== schemaType || $[2] !== value ? (t22 = getPathTitles({
        path,
        schemaType,
        value
      }), $[0] = path, $[1] = schemaType, $[2] = value, $[3] = t22) : t22 = $[3], t0 = t22;
      break bb0;
    } catch (t12) {
      console.error(t12);
    }
    t0 = null;
  }
  const pathTitles = t0;
  if (!pathTitles?.length)
    return null;
  let t1;
  $[4] !== pathTitles ? (t1 = pathTitles.map(_temp$1), $[4] = pathTitles, $[5] = t1) : t1 = $[5];
  let t2;
  return $[6] !== t1 ? (t2 = (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: t1 }), $[6] = t1, $[7] = t2) : t2 = $[7], t2;
}
function _temp$1(t2, i) {
  return (0, import_jsx_runtime2.jsxs)(import_react2.Fragment, { children: [
    i > 0 && (0, import_jsx_runtime2.jsx)("span", { style: {
      color: "var(--card-muted-fg-color)",
      opacity: 0.5
    }, children: " / " }),
    (0, import_jsx_runtime2.jsx)("span", { style: {
      fontWeight: 500
    }, children: t2.title || t2.name })
  ] }, i);
}
function useMenuItem(props) {
  const $ = (0, import_compiler_runtime2.c)(11), {
    documentType
  } = props, {
    t: t2
  } = useTranslation("validation"), {
    selectedReleaseId
  } = usePerspective(), {
    value
  } = useDocumentPane(), {
    validation: validationMarkers
  } = useValidationStatus(value._id, documentType, !selectedReleaseId);
  let t0;
  $[0] !== validationMarkers ? (t0 = validationMarkers.map(_temp), $[0] = validationMarkers, $[1] = t0) : t0 = $[1];
  const validation = t0, hasErrors = validation.some(isValidationError), hasWarnings = validation.some(isValidationWarning);
  let t1;
  $[2] !== value ? (t1 = isGoingToUnpublish(value), $[2] = value, $[3] = t1) : t1 = $[3];
  const isDocumentGoingToUnpublish = t1;
  let t22;
  bb0: {
    if (hasErrors) {
      t22 = ErrorOutlineIcon;
      break bb0;
    }
    if (hasWarnings) {
      t22 = WarningOutlineIcon;
      break bb0;
    }
    t22 = CheckmarkCircleIcon;
  }
  const icon = t22;
  let t3;
  bb1: {
    if (hasErrors) {
      t3 = "critical";
      break bb1;
    }
    if (hasWarnings) {
      t3 = "caution";
      break bb1;
    }
    t3 = "positive";
  }
  const tone = t3, t4 = validation.length === 0 || isDocumentGoingToUnpublish;
  let t5;
  $[4] !== t2 ? (t5 = t2("panel.title"), $[4] = t2, $[5] = t5) : t5 = $[5];
  let t6;
  return $[6] !== icon || $[7] !== t4 || $[8] !== t5 || $[9] !== tone ? (t6 = {
    hidden: t4,
    icon,
    title: t5,
    tone,
    showAsAction: true
  }, $[6] = icon, $[7] = t4, $[8] = t5, $[9] = tone, $[10] = t6) : t6 = $[10], t6;
}
function _temp(item) {
  return {
    level: item.level,
    message: item.message,
    path: item.path
  };
}
var validationInspector = {
  name: VALIDATION_INSPECTOR_NAME,
  component: ValidationInspector,
  useMenuItem
};
var EMPTY_PARAMS = {};
function legacyEditParamsToState(params) {
  try {
    return JSON.parse(decodeURIComponent(params));
  } catch {
    return console.warn("Failed to parse JSON parameters"), {};
  }
}
function encodePanesSegment(panes) {
  return (panes || []).map((group) => group.map(encodeChunks).join("|")).map(encodeURIComponent).join(";");
}
function legacyEditParamsToPath(params) {
  return JSON.stringify(params);
}
function toState(pathSegment) {
  return parsePanesSegment(decodeURIComponent(pathSegment));
}
function toPath(panes) {
  return encodePanesSegment(panes);
}
var router = route.create("/", [
  // "Asynchronous intent resolving" route
  route.intents("/intent"),
  // Legacy fallback route, will be redirected to new format
  route.create("/edit/:type/:editDocumentId", [route.create({
    path: "/:params",
    transform: {
      params: {
        toState: legacyEditParamsToState,
        toPath: legacyEditParamsToPath
      }
    }
  })]),
  // The regular path - when the intent can be resolved to a specific pane
  route.create({
    path: "/:panes",
    // Legacy URLs, used to handle redirects
    children: [route.create("/:action", route.create("/:legacyEditDocumentId"))],
    transform: {
      panes: {
        toState,
        toPath
      }
    }
  })
]);
var panePattern = /^([.a-z0-9_-]+),?({.*?})?(?:(;|$))/i;
var isParam = (str) => /^[a-z0-9]+=[^=]+/i.test(str);
var isPayloadLike = (str) => /^[A-Za-z0-9\-_]+(?:={0,2})$/.test(str);
var exclusiveParams = ["view", "since", "rev", "inspect", "comment"];
var isTruthy = Boolean;
function parseChunks(chunks, initial) {
  const sibling = {
    ...initial,
    params: EMPTY_PARAMS,
    payload: void 0
  };
  return chunks.reduce((pane2, chunk) => {
    if (isParam(chunk)) {
      const key = chunk.slice(0, chunk.indexOf("=")), value = chunk.slice(key.length + 1);
      pane2.params = {
        ...pane2.params,
        [decodeURIComponent(key)]: decodeURIComponent(value)
      };
    } else isPayloadLike(chunk) ? pane2.payload = tryParseBase64Payload(chunk) : console.warn("Unknown pane segment: %s - skipping", chunk);
    return pane2;
  }, sibling);
}
function encodeChunks(pane2, index, group) {
  const {
    payload,
    params = {},
    id
  } = pane2, [firstSibling] = group, paneIsFirstSibling = pane2 === firstSibling, sameAsFirst = index !== 0 && id === firstSibling.id, encodedPayload = typeof payload > "u" ? void 0 : encodeJsonParams(payload), encodedParams = Object.entries(params).filter((entry) => {
    const [key, value] = entry;
    if (!value) return false;
    if (paneIsFirstSibling) return true;
    const valueFromFirstSibling = firstSibling.params?.[key];
    return !(value === valueFromFirstSibling && !exclusiveParams.includes(key));
  }).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
  return [sameAsFirst ? "" : id].concat([encodedParams.length > 0 && encodedParams, encodedPayload].filter(isTruthy).flat()).join(",") || ",";
}
function parsePanesSegment(str) {
  return str.indexOf(",{") !== -1 ? parseOldPanesSegment(str) : str.split(";").map((group) => {
    const [firstSibling, ...restOfSiblings] = group.split("|").map((segment) => {
      const [id, ...chunks] = segment.split(",");
      return parseChunks(chunks, {
        id
      });
    });
    return [firstSibling, ...restOfSiblings.map((sibling) => ({
      ...firstSibling,
      ...sibling,
      id: sibling.id || firstSibling.id,
      params: {
        ...omit_default(firstSibling.params, exclusiveParams),
        ...sibling.params
      },
      payload: sibling.payload || firstSibling.payload
    }))];
  }).filter((group) => group.length > 0);
}
function parseOldPanesSegment(str) {
  const chunks = [];
  let buffer = str;
  for (; buffer.length; ) {
    const [match, id, payloadChunk] = buffer.match(panePattern) || [];
    if (!match) {
      buffer = buffer.slice(1);
      continue;
    }
    const payload = payloadChunk && tryParsePayload(payloadChunk);
    chunks.push({
      id,
      payload
    }), buffer = buffer.slice(match.length);
  }
  return [chunks];
}
function tryParsePayload(json) {
  try {
    return JSON.parse(json);
  } catch (err) {
    console.warn(`Failed to parse parameters: ${err.message}`);
    return;
  }
}
function tryParseBase64Payload(data) {
  try {
    return data ? decodeJsonParams(data) : void 0;
  } catch (err) {
    console.warn(`Failed to parse parameters: ${err.message}`);
    return;
  }
}
var documentActions = [usePublishAction, useUnpublishAction, useDiscardChangesAction, useDuplicateAction, useDeleteAction, useHistoryRestoreAction];
var destructiveActionNames = ["delete", "discardChanges"];
var documentBadges = [useLiveEditBadge];
var inspectors = [validationInspector, changesInspector, incomingReferencesInspector];
var structureTool = definePlugin((options) => {
  const icon = options?.icon || MasterDetailIcon;
  return {
    name: "sanity/structure",
    document: {
      actions: (prevActions, context) => {
        const combinedActions = Array.from(/* @__PURE__ */ new Set([...prevActions, ...documentActions])), destructiveActions = combinedActions.filter((action) => destructiveActionNames.includes(action.action)), otherActions = combinedActions.filter((action) => !destructiveActionNames.includes(action.action));
        return context.versionType === "published" ? [...[...otherActions].sort((a, b) => a.action === "unpublish" ? -1 : b.action === "unpublish" ? 1 : 0), ...destructiveActions] : [...otherActions, ...destructiveActions];
      },
      badges: (prevBadges) => Array.from(/* @__PURE__ */ new Set([...prevBadges, ...documentBadges])),
      inspectors: (prevInspectors) => Array.from(/* @__PURE__ */ new Set([...prevInspectors, ...inspectors]))
    },
    tools: [{
      name: options?.name || "structure",
      title: options?.title || "Structure",
      icon,
      component: (0, import_react2.lazy)(() => import("./index4-R2IIJCNT.js")),
      canHandleIntent: (intent, params) => intent === "create" ? canHandleCreateIntent(params) : intent === "edit" ? canHandleEditIntent(params) : false,
      getIntentState,
      // Controlled by sanity/src/structure/components/structureTool/StructureTitle.tsx
      controlsDocumentTitle: true,
      options,
      router,
      __internalApplicationType: "sanity/structure"
    }],
    i18n: {
      bundles: [structureUsEnglishLocaleBundle]
    }
  };
});
function canHandleCreateIntent(params) {
  if (!("type" in params))
    return false;
  const handle = {};
  return "mode" in params && (handle.mode = params.mode === "structure"), "template" in params && (handle.template = true), Object.keys(handle).length ? handle : true;
}
function canHandleEditIntent(params) {
  return "id" in params ? "mode" in params ? {
    mode: params.mode === "structure"
  } : true : false;
}
var pane$1 = Object.freeze({
  __proto__: null,
  default: DocumentPane
});
var pane = Object.freeze({
  __proto__: null,
  default: PaneContainer
});

export {
  structureLocaleNamespace,
  SerializeError,
  HELP_URL,
  maybeSerializeMenuItem,
  MenuItemBuilder,
  getOrderingMenuItem,
  getOrderingMenuItemsForSchemaType,
  maybeSerializeMenuItemGroup,
  MenuItemGroupBuilder,
  ComponentBuilder,
  GenericViewBuilder,
  maybeSerializeView,
  ComponentViewBuilder,
  FormViewBuilder,
  form,
  component,
  DocumentBuilder,
  documentFromEditor,
  documentFromEditorWithInitialValue,
  InitialValueTemplateItemBuilder,
  defaultInitialValueTemplateItems,
  maybeSerializeInitialValueTemplateItem,
  menuItemsFromInitialValueTemplateItems,
  DEFAULT_INTENT_HANDLER,
  defaultIntentChecker,
  shallowIntentChecker,
  GenericListBuilder,
  DocumentListBuilder,
  getTypeNamesFromFilter,
  ListBuilder,
  ListItemBuilder,
  DocumentListItemBuilder,
  isDocumentListItem,
  DocumentTypeListBuilder,
  createStructureBuilder,
  StructureToolProvider,
  usePaneLayout,
  Pane,
  usePane,
  PaneContent,
  PaneHeader$1,
  PaneLayout,
  LoadingPane,
  useDocumentPane,
  useStructureTool,
  useDocumentTitle,
  DocumentInspectorHeader,
  usePaneRouter,
  _DEBUG,
  LOADING_PANE,
  useDocumentLastRev,
  DocumentPaneProviderWrapper,
  DocumentPane,
  usePaneOptions,
  BackLink,
  StructureToolPane,
  ConfirmDeleteDialogContainer,
  PaneHeaderActions,
  PaneItem,
  INITIAL_STATE$1,
  getIncomingReferences,
  INCOMING_REFERENCES_ITEM_HEIGHT,
  IncomingReferencesListContainer,
  CrossDatasetIncomingReferenceDocumentPreview,
  getCrossDatasetIncomingReferences,
  IncomingReferenceDocument$1,
  assignId,
  PaneContainer,
  setActivePanes,
  structureTool
};
//# sourceMappingURL=chunk-I6XFQ6I4.js.map
